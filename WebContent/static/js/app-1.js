var Ext = Ext || {};
Ext._startTime = (new Date).getTime(); (function() {
    var e = this,
    t = Object.prototype,
    n = t.toString,
    r = true,
    i = {
        toString: 1
    },
    s = function() {},
    o = function() {
        var e = o.caller.caller;
        return e.$owner.prototype[e.$name].apply(this, arguments)
    },
    u,
    a = /\S/,
    f,
    l = /\[object\s*(?:Array|Arguments|\w*Collection|\w*List|HTML\s+document\.all\s+class)\]/;
    Ext.global = e;
    for (u in i) {
        r = null
    }
    if (r) {
        r = ["hasOwnProperty", "valueOf", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "constructor"]
    }
    Ext.enumerables = r;
    Ext.apply = function(e, t, n) {
        if (n) {
            Ext.apply(e, n)
        }
        if (e && t && typeof t === "object") {
            var i, s, o;
            for (i in t) {
                e[i] = t[i]
            }
            if (r) {
                for (s = r.length; s--;) {
                    o = r[s];
                    if (t.hasOwnProperty(o)) {
                        e[o] = t[o]
                    }
                }
            }
        }
        return e
    };
    Ext.buildSettings = Ext.apply({
        baseCSSPrefix: "x-"
    },
    Ext.buildSettings || {});
    Ext.apply(Ext, {
        name: Ext.sandboxName || "Ext",
        emptyFn: s,
        identityFn: function(e) {
            return e
        },
        emptyString: new String,
        baseCSSPrefix: Ext.buildSettings.baseCSSPrefix,
        applyIf: function(e, t) {
            var n;
            if (e) {
                for (n in t) {
                    if (e[n] === undefined) {
                        e[n] = t[n]
                    }
                }
            }
            return e
        },
        iterate: function(e, t, n) {
            if (Ext.isEmpty(e)) {
                return
            }
            if (n === undefined) {
                n = e
            }
            if (Ext.isIterable(e)) {
                Ext.Array.each.call(Ext.Array, e, t, n)
            } else {
                Ext.Object.each.call(Ext.Object, e, t, n)
            }
        }
    });
    Ext.apply(Ext, {
        extend: function() {
            var e = t.constructor,
            n = function(e) {
                for (var t in e) {
                    if (!e.hasOwnProperty(t)) {
                        continue
                    }
                    this[t] = e[t]
                }
            };
            return function(t, r, i) {
                if (Ext.isObject(r)) {
                    i = r;
                    r = t;
                    t = i.constructor !== e ? i.constructor: function() {
                        r.apply(this, arguments)
                    }
                }
                var s = function() {},
                o,
                u = r.prototype;
                s.prototype = u;
                o = t.prototype = new s;
                o.constructor = t;
                t.superclass = u;
                if (u.constructor === e) {
                    u.constructor = r
                }
                t.override = function(e) {
                    Ext.override(t, e)
                };
                o.override = n;
                o.proto = o;
                t.override(i);
                t.extend = function(e) {
                    return Ext.extend(t, e)
                };
                return t
            }
        } (),
        override: function(e, t) {
            if (e.$isClass) {
                e.override(t)
            } else {
                if (typeof e == "function") {
                    Ext.apply(e.prototype, t)
                } else {
                    var n = e.self,
                    r, i;
                    if (n && n.$isClass) {
                        for (r in t) {
                            if (t.hasOwnProperty(r)) {
                                i = t[r];
                                if (typeof i == "function") {
                                    i.$name = r;
                                    i.$owner = n;
                                    i.$previous = e.hasOwnProperty(r) ? e[r] : o
                                }
                                e[r] = i
                            }
                        }
                    } else {
                        Ext.apply(e, t)
                    }
                }
            }
            return e
        }
    });
    Ext.apply(Ext, {
        valueFrom: function(e, t, n) {
            return Ext.isEmpty(e, n) ? t: e
        },
        typeOf: function(e) {
            var t, r;
            if (e === null) {
                return "null"
            }
            t = typeof e;
            if (t === "undefined" || t === "string" || t === "number" || t === "boolean") {
                return t
            }
            r = n.call(e);
            switch (r) {
            case "[object Array]":
                return "array";
            case "[object Date]":
                return "date";
            case "[object Boolean]":
                return "boolean";
            case "[object Number]":
                return "number";
            case "[object RegExp]":
                return "regexp"
            }
            if (t === "function") {
                return "function"
            }
            if (t === "object") {
                if (e.nodeType !== undefined) {
                    if (e.nodeType === 3) {
                        return a.test(e.nodeValue) ? "textnode": "whitespace"
                    } else {
                        return "element"
                    }
                }
                return "object"
            }
        },
        coerce: function(e, t) {
            var n = Ext.typeOf(e),
            r = Ext.typeOf(t),
            i = typeof e === "string";
            if (n !== r) {
                switch (r) {
                case "string":
                    return String(e);
                case "number":
                    return Number(e);
                case "boolean":
                    return i && (!e || e === "false") ? false: Boolean(e);
                case "null":
                    return i && (!e || e === "null") ? null: e;
                case "undefined":
                    return i && (!e || e === "undefined") ? undefined: e;
                case "date":
                    return i && isNaN(e) ? Ext.Date.parse(e, Ext.Date.defaultFormat) : Date(Number(e))
                }
            }
            return e
        },
        isEmpty: function(e, t) {
            return e === null || e === undefined || (!t ? e === "": false) || Ext.isArray(e) && e.length === 0
        },
        isArray: "isArray" in Array ? Array.isArray: function(e) {
            return n.call(e) === "[object Array]"
        },
        isDate: function(e) {
            return n.call(e) === "[object Date]"
        },
        isObject: n.call(null) === "[object Object]" ?
        function(e) {
            return e !== null && e !== undefined && n.call(e) === "[object Object]" && e.ownerDocument === undefined
        }: function(e) {
            return n.call(e) === "[object Object]"
        },
        isSimpleObject: function(e) {
            return e instanceof Object && e.constructor === Object
        },
        isPrimitive: function(e) {
            var t = typeof e;
            return t === "string" || t === "number" || t === "boolean"
        },
        isFunction: typeof document !== "undefined" && typeof document.getElementsByTagName("body") === "function" ?
        function(e) {
            return !! e && n.call(e) === "[object Function]"
        }: function(e) {
            return !! e && typeof e === "function"
        },
        isNumber: function(e) {
            return typeof e === "number" && isFinite(e)
        },
        isNumeric: function(e) {
            return ! isNaN(parseFloat(e)) && isFinite(e)
        },
        isString: function(e) {
            return typeof e === "string"
        },
        isBoolean: function(e) {
            return typeof e === "boolean"
        },
        isElement: function(e) {
            return e ? e.nodeType === 1 : false
        },
        isTextNode: function(e) {
            return e ? e.nodeName === "#text": false
        },
        isDefined: function(e) {
            return typeof e !== "undefined"
        },
        isIterable: function(e) {
            if (!e || typeof e.length !== "number" || typeof e === "string" || Ext.isFunction(e)) {
                return false
            }
            if (!e.propertyIsEnumerable) {
                return !! e.item
            }
            if (e.hasOwnProperty("length") && !e.propertyIsEnumerable("length")) {
                return true
            }
            return l.test(n.call(e))
        }
    });
    Ext.apply(Ext, {
        clone: function(e) {
            var t, i, s, o, u, a;
            if (e === null || e === undefined) {
                return e
            }
            if (e.nodeType && e.cloneNode) {
                return e.cloneNode(true)
            }
            t = n.call(e);
            if (t === "[object Date]") {
                return new Date(e.getTime())
            }
            if (t === "[object Array]") {
                i = e.length;
                u = [];
                while (i--) {
                    u[i] = Ext.clone(e[i])
                }
            } else {
                if (t === "[object Object]" && e.constructor === Object) {
                    u = {};
                    for (a in e) {
                        u[a] = Ext.clone(e[a])
                    }
                    if (r) {
                        for (s = r.length; s--;) {
                            o = r[s];
                            if (e.hasOwnProperty(o)) {
                                u[o] = e[o]
                            }
                        }
                    }
                }
            }
            return u || e
        },
        getUniqueGlobalNamespace: function() {
            var e = this.uniqueGlobalNamespace,
            t;
            if (e === undefined) {
                t = 0;
                do {
                    e = "ExtBox" + ++t
                } while ( Ext . global [ e ] !== undefined);
                Ext.global[e] = Ext;
                this.uniqueGlobalNamespace = e
            }
            return e
        },
        functionFactoryCache: {},
        cacheableFunctionFactory: function() {
            var e = this,
            t = Array.prototype.slice.call(arguments),
            n = e.functionFactoryCache,
            r,
            i,
            s;
            if (Ext.isSandboxed) {
                s = t.length;
                if (s > 0) {
                    s--;
                    t[s] = "var Ext=window." + Ext.name + ";" + t[s]
                }
            }
            r = t.join("");
            i = n[r];
            if (!i) {
                i = Function.prototype.constructor.apply(Function.prototype, t);
                n[r] = i
            }
            return i
        },
        functionFactory: function() {
            var e = this,
            t = Array.prototype.slice.call(arguments),
            n;
            if (Ext.isSandboxed) {
                n = t.length;
                if (n > 0) {
                    n--;
                    t[n] = "var Ext=window." + Ext.name + ";" + t[n]
                }
            }
            return Function.prototype.constructor.apply(Function.prototype, t)
        },
        Logger: {
            verbose: s,
            log: s,
            info: s,
            warn: s,
            error: function(e) {
                throw new Error(e)
            },
            deprecate: s
        }
    });
    Ext.type = Ext.typeOf;
    f = Ext.app;
    if (!f) {
        f = Ext.app = {}
    }
    Ext.apply(f, {
        namespaces: {},
        collectNamespaces: function(e) {
            var t = Ext.app.namespaces,
            n;
            for (n in e) {
                if (e.hasOwnProperty(n)) {
                    t[n] = true
                }
            }
        },
        addNamespaces: function(e) {
            var t = Ext.app.namespaces,
            n, r;
            if (!Ext.isArray(e)) {
                e = [e]
            }
            for (n = 0, r = e.length; n < r; n++) {
                t[e[n]] = true
            }
        },
        clearNamespaces: function() {
            Ext.app.namespaces = {}
        },
        getNamespace: function(e) {
            var t = Ext.app.namespaces,
            n = "",
            r;
            for (r in t) {
                if (t.hasOwnProperty(r) && r.length > n.length && r + "." === e.substring(0, r.length + 1)) {
                    n = r
                }
            }
            return n === "" ? undefined: n
        }
    })
})();
Ext.globalEval = Ext.global.execScript ?
function(e) {
    execScript(e)
}: function($$code) { (function() {
        var Ext = this.Ext;
        eval($$code)
    })()
}; (function() {
    var e = "4.2.3.1477",
    t = [""],
    n = /([^\d\.])/,
    r = /[^\d]/g,
    i = /[\-+]/g,
    s = /\s/g,
    o = /_/g,
    u;
    Ext.Version = u = Ext.extend(Object, {
        isVersion: true,
        padModes: {
            "~": NaN,
            "^": Infinity
        },
        release: "",
        constructor: function(e, t) {
            var s = this,
            f = s.padModes,
            l, h, p, v, m, y, b;
            if (e.isVersion) {
                return e
            }
            s.version = b = String(e).toLowerCase().replace(o, ".").replace(i, "");
            l = b.charAt(0);
            if (l in f) {
                b = b.substring(1);
                p = f[l]
            } else {
                p = t ? f[t] : 0
            }
            s.pad = p;
            y = b.search(n);
            s.shortVersion = b;
            if (y !== -1) {
                s.release = m = b.substr(y, e.length);
                s.shortVersion = b.substr(0, y);
                m = u.releaseValueMap[m] || m
            }
            s.releaseValue = m || p;
            s.shortVersion = s.shortVersion.replace(r, "");
            s.parts = v = b.split(".");
            for (h = v.length; h--;) {
                v[h] = parseInt(v[h], 10)
            }
            if (p === Infinity) {
                v.push(p)
            }
            s.major = v[0] || p;
            s.minor = v[1] || p;
            s.patch = v[2] || p;
            s.build = v[3] || p;
            return s
        },
        compareTo: function(e) {
            var t = this,
            n = t.pad,
            r = t.parts,
            i = r.length,
            s = e.isVersion ? e: new u(e),
            o = s.pad,
            a = s.parts,
            f = a.length,
            l = Math.max(i, f),
            c,
            h,
            p;
            for (c = 0; c < l; c++) {
                h = c < i ? r[c] : n;
                p = c < f ? a[c] : o;
                if (h < p) {
                    return - 1
                }
                if (h > p) {
                    return 1
                }
            }
            h = t.releaseValue;
            p = s.releaseValue;
            if (h < p) {
                return - 1
            }
            if (h > p) {
                return 1
            }
            return 0
        },
        toString: function() {
            return this.version
        },
        valueOf: function() {
            return this.version
        },
        getMajor: function() {
            return this.major
        },
        getMinor: function() {
            return this.minor
        },
        getPatch: function() {
            return this.patch
        },
        getBuild: function() {
            return this.build
        },
        getRelease: function() {
            return this.release
        },
        getReleaseValue: function() {
            return this.releaseValue
        },
        isGreaterThan: function(e) {
            return this.compareTo(e) > 0
        },
        isGreaterThanOrEqual: function(e) {
            return this.compareTo(e) >= 0
        },
        isLessThan: function(e) {
            return this.compareTo(e) < 0
        },
        isLessThanOrEqual: function(e) {
            return this.compareTo(e) <= 0
        },
        equals: function(e) {
            return this.compareTo(e) === 0
        },
        match: function(e) {
            e = String(e);
            return this.version.substr(0, e.length) === e
        },
        toArray: function() {
            var e = this;
            return [e.getMajor(), e.getMinor(), e.getPatch(), e.getBuild(), e.getRelease()]
        },
        getShortVersion: function() {
            return this.shortVersion
        },
        gt: function(e) {
            return this.compareTo(e) > 0
        },
        lt: function(e) {
            return this.compareTo(e) < 0
        },
        gtEq: function(e) {
            return this.compareTo(e) >= 0
        },
        ltEq: function(e) {
            return this.compareTo(e) <= 0
        }
    });
    Ext.apply(u, {
        releaseValueMap: {
            dev: -6,
            alpha: -5,
            a: -5,
            beta: -4,
            b: -4,
            rc: -3,
            "#": -2,
            p: -1,
            pl: -1
        },
        getComponentValue: function(e) {
            return ! e ? 0 : isNaN(e) ? this.releaseValueMap[e] || e: parseInt(e, 10)
        },
        compare: function(e, t) {
            var n = e.isVersion ? e: new u(e);
            return n.compareTo(t)
        }
    });
    Ext.apply(Ext, {
        versions: {},
        lastRegisteredVersion: null,
        setVersion: function(e, t) {
            Ext.lastRegisteredVersion = Ext.versions[e] = new u(t);
            return this
        },
        getVersion: function(e) {
            if (e === undefined) {
                return Ext.lastRegisteredVersion
            }
            return Ext.versions[e]
        },
        checkVersion: function(e, n) {
            var r = Ext.isArray(e),
            i = r ? e: t,
            o = i.length,
            a = Ext.versions,
            f = a.ext || a.touch,
            l,
            c,
            p,
            d,
            v,
            m,
            y,
            b;
            if (!r) {
                t[0] = e
            }
            for (l = 0; l < o; ++l) {
                if (!Ext.isString(m = i[l])) {
                    p = Ext.checkVersion(m.and || m.or, !m.or);
                    if (m.not) {
                        p = !p
                    }
                } else {
                    if (m.indexOf(" ") >= 0) {
                        m = m.replace(s, "")
                    }
                    c = m.indexOf("@");
                    if (c < 0) {
                        y = m;
                        b = f
                    } else {
                        if (! (b = a[m.substring(0, c)])) {
                            if (n) {
                                return false
                            }
                            continue
                        }
                        y = m.substring(c + 1)
                    }
                    c = y.indexOf("-");
                    if (c < 0) {
                        if (y.charAt(c = y.length - 1) === "+") {
                            d = y.substring(0, c);
                            v = null
                        } else {
                            d = v = y
                        }
                    } else {
                        if (c > 0) {
                            d = y.substring(0, c);
                            v = y.substring(c + 1)
                        } else {
                            d = null;
                            v = y.substring(c + 1)
                        }
                    }
                    p = true;
                    if (d) {
                        d = new u(d, "~");
                        p = d.ltEq(b)
                    }
                    if (p && v) {
                        v = new u(v, "~");
                        p = v.gtEq(b)
                    }
                }
                if (p) {
                    if (!n) {
                        return true
                    }
                } else {
                    if (n) {
                        return false
                    }
                }
            }
            return !! n
        },
        deprecate: function(e, t, n, r) {
            if (u.compare(Ext.getVersion(e), t) < 1) {
                n.call(r)
            }
        }
    });
    Ext.setVersion("core", e)
})();
Ext.String = function() {
    var e = /^[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000]+|[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000]+$/g,
    t = /('|\\)/g,
    n = /\{\d+\}/,
    r = /([-.*+?\^${}()|\[\]\/\\])/g,
    i = /^\s+|\s+$/g,
    s = /\s+/,
    o = /(^[^a-z]*|[^\w])/gi,
    u, a, f, l, c = function(e, t) {
        return u[t]
    },
    h = function(e, t) {
        return t in a ? a[t] : String.fromCharCode(parseInt(t.substr(2), 10))
    },
    p = function(e, t) {
        if (e === null || e === undefined || t === null || t === undefined) {
            return false
        }
        return t.length <= e.length
    },
    d = {
        useFormat: false,
        compiled: true,
        stringFormat: true
    },
    v = {},
    m = function(e) {
        if (n.test(e)) {
            e = new Ext.Template(e, d);
            return function() {
                return e.apply(arguments)
            }
        } else {
            return function() {
                return e
            }
        }
    };
    return {
        insert: function(e, t, n) {
            if (!e) {
                return t
            }
            if (!t) {
                return e
            }
            var r = e.length;
            if (!n && n !== 0) {
                n = r
            }
            if (n < 0) {
                n *= -1;
                if (n >= r) {
                    n = 0
                } else {
                    n = r - n
                }
            }
            if (n === 0) {
                e = t + e
            } else {
                if (n >= e.length) {
                    e += t
                } else {
                    e = e.substr(0, n) + t + e.substr(n)
                }
            }
            return e
        },
        startsWith: function(e, t, n) {
            var r = p(e, t);
            if (r) {
                if (n) {
                    e = e.toLowerCase();
                    t = t.toLowerCase()
                }
                r = e.lastIndexOf(t, 0) === 0
            }
            return r
        },
        endsWith: function(e, t, n) {
            var r = p(e, t);
            if (r) {
                if (n) {
                    e = e.toLowerCase();
                    t = t.toLowerCase()
                }
                r = e.indexOf(t, e.length - t.length) !== -1
            }
            return r
        },
        createVarName: function(e) {
            return e.replace(o, "")
        },
        htmlEncode: function(e) {
            return ! e ? e: String(e).replace(f, c)
        },
        htmlDecode: function(e) {
            return ! e ? e: String(e).replace(l, h)
        },
        hasHtmlCharacters: function(e) {
            return f.test(e)
        },
        addCharacterEntities: function(e) {
            var t = [],
            n = [],
            r,
            i;
            for (r in e) {
                i = e[r];
                a[r] = i;
                u[i] = r;
                t.push(i);
                n.push(r)
            }
            f = new RegExp("(" + t.join("|") + ")", "g");
            l = new RegExp("(" + n.join("|") + "|&#[0-9]{1,5};)", "g")
        },
        resetCharacterEntities: function() {
            u = {};
            a = {};
            this.addCharacterEntities({
                "&amp;": "&",
                "&gt;": ">",
                "&lt;": "<",
                "&quot;": '"',
                "&#39;": "'"
            })
        },
        urlAppend: function(e, t) {
            if (!Ext.isEmpty(t)) {
                return e + (e.indexOf("?") === -1 ? "?": "&") + t
            }
            return e
        },
        trim: function(t) {
            return t.replace(e, "")
        },
        capitalize: function(e) {
            return e.charAt(0).toUpperCase() + e.substr(1)
        },
        uncapitalize: function(e) {
            return e.charAt(0).toLowerCase() + e.substr(1)
        },
        ellipsis: function(e, t, n) {
            if (e && e.length > t) {
                if (n) {
                    var r = e.substr(0, t - 2),
                    i = Math.max(r.lastIndexOf(" "), r.lastIndexOf("."), r.lastIndexOf("!"), r.lastIndexOf("?"));
                    if (i !== -1 && i >= t - 15) {
                        return r.substr(0, i) + "..."
                    }
                }
                return e.substr(0, t - 3) + "..."
            }
            return e
        },
        escapeRegex: function(e) {
            return e.replace(r, "\\$1")
        },
        escape: function(e) {
            return e.replace(t, "\\$1")
        },
        toggle: function(e, t, n) {
            return e === t ? n: t
        },
        leftPad: function(e, t, n) {
            var r = String(e);
            n = n || " ";
            while (r.length < t) {
                r = n + r
            }
            return r
        },
        format: function(e) {
            var t = v[e] || (v[e] = m(e));
            return t.apply(this, arguments)
        },
        repeat: function(e, t, n) {
            if (t < 1) {
                t = 0
            }
            for (var r = [], i = t; i--;) {
                r.push(e)
            }
            return r.join(n || "")
        },
        splitWords: function(e) {
            if (e && typeof e == "string") {
                return e.replace(i, "").split(s)
            }
            return e || []
        }
    }
} ();
Ext.String.resetCharacterEntities();
Ext.htmlEncode = Ext.String.htmlEncode;
Ext.htmlDecode = Ext.String.htmlDecode;
Ext.urlAppend = Ext.String.urlAppend;
Ext.Number = new
function() {
    var e = this,
    t = .9.toFixed() !== "1",
    n = Math;
    Ext.apply(this, {
        constrain: function(e, t, n) {
            var r = parseFloat(e);
            return r < t ? t: r > n ? n: r
        },
        snap: function(t, n, r, i) {
            var s;
            if (t === undefined || t < r) {
                return r || 0
            }
            if (n) {
                s = t % n;
                if (s !== 0) {
                    t -= s;
                    if (s * 2 >= n) {
                        t += n
                    } else {
                        if (s * 2 < -n) {
                            t -= n
                        }
                    }
                }
            }
            return e.constrain(t, r, i)
        },
        snapInRange: function(t, n, r, i) {
            var s;
            r = r || 0;
            if (t === undefined || t < r) {
                return r
            }
            if (n && (s = (t - r) % n)) {
                t -= s;
                s *= 2;
                if (s >= n) {
                    t += n
                }
            }
            if (i !== undefined) {
                if (t > (i = e.snapInRange(i, n, r))) {
                    t = i
                }
            }
            return t
        },
        toFixed: t ?
        function(e, t) {
            t = t || 0;
            var r = n.pow(10, t);
            return (n.round(e * r) / r).toFixed(t)
        }: function(e, t) {
            return e.toFixed(t)
        },
        from: function(e, t) {
            if (isFinite(e)) {
                e = parseFloat(e)
            }
            return ! isNaN(e) ? e: t
        },
        randomInt: function(e, t) {
            return n.floor(n.random() * (t - e + 1) + e)
        },
        correctFloat: function(e) {
            return parseFloat(e.toPrecision(14))
        }
    });
    Ext.num = function() {
        return e.from.apply(this, arguments)
    }
}; (function() {
    function m(e, t) {
        return t < 0 ? Math.max(0, e.length + t) : Math.min(e.length, t)
    }
    function g(e, t, n, r) {
        var i = r ? r.length: 0,
        s = e.length,
        o = m(e, t),
        u,
        a,
        f,
        l,
        c,
        h;
        if (o === s) {
            if (i) {
                e.push.apply(e, r)
            }
        } else {
            u = Math.min(n, s - o);
            a = o + u;
            f = a + i - u;
            l = s - a;
            c = s - u;
            if (f < a) {
                for (h = 0; h < l; ++h) {
                    e[f + h] = e[a + h]
                }
            } else {
                if (f > a) {
                    for (h = l; h--;) {
                        e[f + h] = e[a + h]
                    }
                }
            }
            if (i && o === c) {
                e.length = c;
                e.push.apply(e, r)
            } else {
                e.length = c + i;
                for (h = 0; h < i; ++h) {
                    e[o + h] = r[h]
                }
            }
        }
        return e
    }
    function y(e, t, n, r) {
        if (r && r.length) {
            if (t === 0 && !n) {
                e.unshift.apply(e, r)
            } else {
                if (t < e.length) {
                    e.splice.apply(e, [t, n].concat(r))
                } else {
                    e.push.apply(e, r)
                }
            }
        } else {
            e.splice(t, n)
        }
        return e
    }
    function b(e, t, n) {
        return g(e, t, n)
    }
    function w(e, t, n) {
        e.splice(t, n);
        return e
    }
    function E(e, n, r) {
        var i = m(e, n),
        s = e.slice(n, m(e, i + r));
        if (arguments.length < 4) {
            g(e, i, r)
        } else {
            g(e, i, r, t.call(arguments, 3))
        }
        return s
    }
    function S(e) {
        return e.splice.apply(e, t.call(arguments, 1))
    }
    var e = Array.prototype,
    t = e.slice,
    n = function() {
        var e = [],
        t,
        n = 20;
        if (!e.splice) {
            return false
        }
        while (n--) {
            e.push("A")
        }
        e.splice(15, 0, "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F");
        t = e.length;
        e.splice(13, 0, "XXX");
        if (t + 1 != e.length) {
            return false
        }
        return true
    } (),
    r = "forEach" in e,
    i = "map" in e,
    s = "indexOf" in e,
    o = "every" in e,
    u = "some" in e,
    a = "filter" in e,
    f = function() {
        var e = [1, 2, 3, 4, 5].sort(function() {
            return 0
        });
        return e[0] === 1 && e[1] === 2 && e[2] === 3 && e[3] === 4 && e[4] === 5
    } (),
    l = true,
    c,
    h,
    p,
    d;
    try {
        if (typeof document !== "undefined") {
            t.call(document.getElementsByTagName("body"))
        }
    } catch(v) {
        l = false
    }
    h = n ? w: b;
    p = n ? y: g;
    d = n ? S: E;
    c = Ext.Array = {
        each: function(e, t, n, r) {
            e = c.from(e);
            var i, s = e.length;
            if (r !== true) {
                for (i = 0; i < s; i++) {
                    if (t.call(n || e[i], e[i], i, e) === false) {
                        return i
                    }
                }
            } else {
                for (i = s - 1; i > -1; i--) {
                    if (t.call(n || e[i], e[i], i, e) === false) {
                        return i
                    }
                }
            }
            return true
        },
        forEach: r ?
        function(e, t, n) {
            e.forEach(t, n)
        }: function(e, t, n) {
            var r = 0,
            i = e.length;
            for (; r < i; r++) {
                t.call(n, e[r], r, e)
            }
        },
        indexOf: s ?
        function(t, n, r) {
            return e.indexOf.call(t, n, r)
        }: function(e, t, n) {
            var r, i = e.length;
            for (r = n < 0 ? Math.max(0, i + n) : n || 0; r < i; r++) {
                if (e[r] === t) {
                    return r
                }
            }
            return - 1
        },
        contains: s ?
        function(t, n) {
            return e.indexOf.call(t, n) !== -1
        }: function(e, t) {
            var n, r;
            for (n = 0, r = e.length; n < r; n++) {
                if (e[n] === t) {
                    return true
                }
            }
            return false
        },
        toArray: function(e, n, r) {
            if (!e || !e.length) {
                return []
            }
            if (typeof e === "string") {
                e = e.split("")
            }
            if (l) {
                return t.call(e, n || 0, r || e.length)
            }
            var i = [],
            s;
            n = n || 0;
            r = r ? r < 0 ? e.length + r: r: e.length;
            for (s = n; s < r; s++) {
                i.push(e[s])
            }
            return i
        },
        pluck: function(e, t) {
            var n = [],
            r,
            i,
            s;
            for (r = 0, i = e.length; r < i; r++) {
                s = e[r];
                n.push(s[t])
            }
            return n
        },
        map: i ?
        function(e, t, n) {
            return e.map(t, n)
        }: function(e, t, n) {
            var r = [],
            i = 0,
            s = e.length;
            for (; i < s; i++) {
                r[i] = t.call(n, e[i], i, e)
            }
            return r
        },
        every: o ?
        function(e, t, n) {
            return e.every(t, n)
        }: function(e, t, n) {
            var r = 0,
            i = e.length;
            for (; r < i; ++r) {
                if (!t.call(n, e[r], r, e)) {
                    return false
                }
            }
            return true
        },
        some: u ?
        function(e, t, n) {
            return e.some(t, n)
        }: function(e, t, n) {
            var r = 0,
            i = e.length;
            for (; r < i; ++r) {
                if (t.call(n, e[r], r, e)) {
                    return true
                }
            }
            return false
        },
        equals: function(e, t) {
            var n = e.length,
            r = t.length,
            i;
            if (e === t) {
                return true
            }
            if (n !== r) {
                return false
            }
            for (i = 0; i < n; ++i) {
                if (e[i] !== t[i]) {
                    return false
                }
            }
            return true
        },
        clean: function(e) {
            var t = [],
            n = 0,
            r = e.length,
            i;
            for (; n < r; n++) {
                i = e[n];
                if (!Ext.isEmpty(i)) {
                    t.push(i)
                }
            }
            return t
        },
        unique: function(e) {
            var t = [],
            n = 0,
            r = e.length,
            i;
            for (; n < r; n++) {
                i = e[n];
                if (c.indexOf(t, i) === -1) {
                    t.push(i)
                }
            }
            return t
        },
        filter: a ?
        function(e, t, n) {
            return e.filter(t, n)
        }: function(e, t, n) {
            var r = [],
            i = 0,
            s = e.length;
            for (; i < s; i++) {
                if (t.call(n, e[i], i, e)) {
                    r.push(e[i])
                }
            }
            return r
        },
        findBy: function(e, t, n) {
            var r = 0,
            i = e.length;
            for (; r < i; r++) {
                if (t.call(n || e, e[r], r)) {
                    return e[r]
                }
            }
            return null
        },
        from: function(e, n) {
            if (e === undefined || e === null) {
                return []
            }
            if (Ext.isArray(e)) {
                return n ? t.call(e) : e
            }
            var r = typeof e;
            if (e && e.length !== undefined && r !== "string" && (r !== "function" || !e.apply)) {
                return c.toArray(e)
            }
            return [e]
        },
        remove: function(e, t) {
            var n = c.indexOf(e, t);
            if (n !== -1) {
                h(e, n, 1)
            }
            return e
        },
        include: function(e, t) {
            if (!c.contains(e, t)) {
                e.push(t)
            }
        },
        clone: function(e) {
            return t.call(e)
        },
        merge: function() {
            var e = t.call(arguments),
            n = [],
            r,
            i;
            for (r = 0, i = e.length; r < i; r++) {
                n = n.concat(e[r])
            }
            return c.unique(n)
        },
        intersect: function() {
            var e = [],
            n = t.call(arguments),
            r,
            i,
            s,
            o,
            u,
            a,
            f,
            l,
            p,
            d,
            v,
            m,
            g;
            if (!n.length) {
                return e
            }
            r = n.length;
            for (v = u = 0; v < r; v++) {
                a = n[v];
                if (!o || a.length < o.length) {
                    o = a;
                    u = v
                }
            }
            o = c.unique(o);
            h(n, u, 1);
            f = o.length;
            r = n.length;
            for (v = 0; v < f; v++) {
                l = o[v];
                d = 0;
                for (m = 0; m < r; m++) {
                    i = n[m];
                    s = i.length;
                    for (g = 0; g < s; g++) {
                        p = i[g];
                        if (l === p) {
                            d++;
                            break
                        }
                    }
                }
                if (d === r) {
                    e.push(l)
                }
            }
            return e
        },
        difference: function(e, n) {
            var r = t.call(e),
            i = r.length,
            s,
            o,
            u;
            for (s = 0, u = n.length; s < u; s++) {
                for (o = 0; o < i; o++) {
                    if (r[o] === n[s]) {
                        h(r, o, 1);
                        o--;
                        i--
                    }
                }
            }
            return r
        },
        slice: [1, 2].slice(1, undefined).length ?
        function(e, n, r) {
            return t.call(e, n, r)
        }: function(e, n, r) {
            if (typeof n === "undefined") {
                return t.call(e)
            }
            if (typeof r === "undefined") {
                return t.call(e, n)
            }
            return t.call(e, n, r)
        },
        sort: f ?
        function(e, t) {
            if (t) {
                return e.sort(t)
            } else {
                return e.sort()
            }
        }: function(e, t) {
            var n = e.length,
            r = 0,
            i, s, o, u;
            for (; r < n; r++) {
                o = r;
                for (s = r + 1; s < n; s++) {
                    if (t) {
                        i = t(e[s], e[o]);
                        if (i < 0) {
                            o = s
                        }
                    } else {
                        if (e[s] < e[o]) {
                            o = s
                        }
                    }
                }
                if (o !== r) {
                    u = e[r];
                    e[r] = e[o];
                    e[o] = u
                }
            }
            return e
        },
        flatten: function(e) {
            function n(e) {
                var r, i, s;
                for (r = 0, i = e.length; r < i; r++) {
                    s = e[r];
                    if (Ext.isArray(s)) {
                        n(s)
                    } else {
                        t.push(s)
                    }
                }
                return t
            }
            var t = [];
            return n(e)
        },
        min: function(e, t) {
            var n = e[0],
            r,
            i,
            s;
            for (r = 0, i = e.length; r < i; r++) {
                s = e[r];
                if (t) {
                    if (t(n, s) === 1) {
                        n = s
                    }
                } else {
                    if (s < n) {
                        n = s
                    }
                }
            }
            return n
        },
        max: function(e, t) {
            var n = e[0],
            r,
            i,
            s;
            for (r = 0, i = e.length; r < i; r++) {
                s = e[r];
                if (t) {
                    if (t(n, s) === -1) {
                        n = s
                    }
                } else {
                    if (s > n) {
                        n = s
                    }
                }
            }
            return n
        },
        mean: function(e) {
            return e.length > 0 ? c.sum(e) / e.length: undefined
        },
        sum: function(e) {
            var t = 0,
            n, r, i;
            for (n = 0, r = e.length; n < r; n++) {
                i = e[n];
                t += i
            }
            return t
        },
        toMap: function(e, t, n) {
            var r = {},
            i = e.length;
            if (!t) {
                while (i--) {
                    r[e[i]] = i + 1
                }
            } else {
                if (typeof t == "string") {
                    while (i--) {
                        r[e[i][t]] = i + 1
                    }
                } else {
                    while (i--) {
                        r[t.call(n, e[i])] = i + 1
                    }
                }
            }
            return r
        },
        toValueMap: function(e, t, n) {
            var r = {},
            i = e.length;
            if (!t) {
                while (i--) {
                    r[e[i]] = e[i]
                }
            } else {
                if (typeof t == "string") {
                    while (i--) {
                        r[e[i][t]] = e[i]
                    }
                } else {
                    while (i--) {
                        r[t.call(n, e[i])] = e[i]
                    }
                }
            }
            return r
        },
        erase: h,
        insert: function(e, t, n) {
            return p(e, t, 0, n)
        },
        replace: p,
        splice: d,
        push: function(e) {
            var t = arguments.length,
            n = 1,
            r;
            if (e === undefined) {
                e = []
            } else {
                if (!Ext.isArray(e)) {
                    e = [e]
                }
            }
            for (; n < t; n++) {
                r = arguments[n];
                Array.prototype.push[Ext.isIterable(r) ? "apply": "call"](e, r)
            }
            return e
        }
    };
    Ext.each = c.each;
    c.union = c.merge;
    Ext.min = c.min;
    Ext.max = c.max;
    Ext.sum = c.sum;
    Ext.mean = c.mean;
    Ext.flatten = c.flatten;
    Ext.clean = c.clean;
    Ext.unique = c.unique;
    Ext.pluck = c.pluck;
    Ext.toArray = function() {
        return c.toArray.apply(c, arguments)
    }
})();
Ext.Function = {
    flexSetter: function(e) {
        return function(t, n) {
            var r, i;
            if (t === null) {
                return this
            }
            if (typeof t !== "string") {
                for (r in t) {
                    if (t.hasOwnProperty(r)) {
                        e.call(this, r, t[r])
                    }
                }
                if (Ext.enumerables) {
                    for (i = Ext.enumerables.length; i--;) {
                        r = Ext.enumerables[i];
                        if (t.hasOwnProperty(r)) {
                            e.call(this, r, t[r])
                        }
                    }
                }
            } else {
                e.call(this, t, n)
            }
            return this
        }
    },
    bind: function(e, t, n, r) {
        if (arguments.length === 2) {
            return function() {
                return e.apply(t, arguments)
            }
        }
        var i = e,
        s = Array.prototype.slice;
        return function() {
            var e = n || arguments;
            if (r === true) {
                e = s.call(arguments, 0);
                e = e.concat(n)
            } else {
                if (typeof r == "number") {
                    e = s.call(arguments, 0);
                    Ext.Array.insert(e, r, n)
                }
            }
            return i.apply(t || Ext.global, e)
        }
    },
    pass: function(e, t, n) {
        if (!Ext.isArray(t)) {
            if (Ext.isIterable(t)) {
                t = Ext.Array.clone(t)
            } else {
                t = t !== undefined ? [t] : []
            }
        }
        return function() {
            var r = [].concat(t);
            r.push.apply(r, arguments);
            return e.apply(n || this, r)
        }
    },
    alias: function(e, t) {
        return function() {
            return e[t].apply(e, arguments)
        }
    },
    clone: function(e) {
        return function() {
            return e.apply(this, arguments)
        }
    },
    createInterceptor: function(e, t, n, r) {
        var i = e;
        if (!Ext.isFunction(t)) {
            return e
        } else {
            r = Ext.isDefined(r) ? r: null;
            return function() {
                var i = this,
                s = arguments;
                t.target = i;
                t.method = e;
                return t.apply(n || i || Ext.global, s) !== false ? e.apply(i || Ext.global, s) : r
            }
        }
    },
    createDelayed: function(e, t, n, r, i) {
        if (n || r) {
            e = Ext.Function.bind(e, n, r, i)
        }
        return function() {
            var n = this,
            r = Array.prototype.slice.call(arguments);
            setTimeout(function() {
                e.apply(n, r)
            },
            t)
        }
    },
    defer: function(e, t, n, r, i) {
        e = Ext.Function.bind(e, n, r, i);
        if (t > 0) {
            return setTimeout(Ext.supports.TimeoutActualLateness ?
            function() {
                e()
            }: e, t)
        }
        e();
        return 0
    },
    createSequence: function(e, t, n) {
        if (!t) {
            return e
        } else {
            return function() {
                var r = e.apply(this, arguments);
                t.apply(n || this, arguments);
                return r
            }
        }
    },
    createBuffered: function(e, t, n, r) {
        var i;
        return function() {
            var s = r || Array.prototype.slice.call(arguments, 0),
            o = n || this;
            if (i) {
                clearTimeout(i)
            }
            i = setTimeout(function() {
                e.apply(o, s)
            },
            t)
        }
    },
    createThrottled: function(e, t, n) {
        var r, i, s, o, u = function() {
            e.apply(n || this, s);
            r = Ext.Date.now()
        };
        return function() {
            i = Ext.Date.now() - r;
            s = arguments;
            clearTimeout(o);
            if (!r || i >= t) {
                u()
            } else {
                o = setTimeout(u, t - i)
            }
        }
    },
    interceptBefore: function(e, t, n, r) {
        var i = e[t] || Ext.emptyFn;
        return e[t] = function() {
            var e = n.apply(r || this, arguments);
            i.apply(this, arguments);
            return e
        }
    },
    interceptAfter: function(e, t, n, r) {
        var i = e[t] || Ext.emptyFn;
        return e[t] = function() {
            i.apply(this, arguments);
            return n.apply(r || this, arguments)
        }
    }
};
Ext.defer = Ext.Function.alias(Ext.Function, "defer");
Ext.pass = Ext.Function.alias(Ext.Function, "pass");
Ext.bind = Ext.Function.alias(Ext.Function, "bind"); (function() {
    var e = function() {},
    t = Ext.Object = {
        chain: Object.create ||
        function(t) {
            e.prototype = t;
            var n = new e;
            e.prototype = null;
            return n
        },
        clear: function(e) {
            var n = t.getKeys(e),
            r = n.length;
            while (r--) {
                delete e[n[r]]
            }
            return e
        },
        toQueryObjects: function(e, n, r) {
            var i = t.toQueryObjects,
            s = [],
            o,
            u;
            if (Ext.isArray(n)) {
                for (o = 0, u = n.length; o < u; o++) {
                    if (r) {
                        s = s.concat(i(e + "[" + o + "]", n[o], true))
                    } else {
                        s.push({
                            name: e,
                            value: n[o]
                        })
                    }
                }
            } else {
                if (Ext.isObject(n)) {
                    for (o in n) {
                        if (n.hasOwnProperty(o)) {
                            if (r) {
                                s = s.concat(i(e + "[" + o + "]", n[o], true))
                            } else {
                                s.push({
                                    name: e,
                                    value: n[o]
                                })
                            }
                        }
                    }
                } else {
                    s.push({
                        name: e,
                        value: n
                    })
                }
            }
            return s
        },
        toQueryString: function(e, n) {
            var r = [],
            i = [],
            s,
            o,
            u,
            a,
            f;
            for (s in e) {
                if (e.hasOwnProperty(s)) {
                    r = r.concat(t.toQueryObjects(s, e[s], n))
                }
            }
            for (o = 0, u = r.length; o < u; o++) {
                a = r[o];
                f = a.value;
                if (Ext.isEmpty(f)) {
                    f = ""
                } else {
                    if (Ext.isDate(f)) {
                        f = Ext.Date.toString(f)
                    }
                }
                i.push(encodeURIComponent(a.name) + "=" + encodeURIComponent(String(f)))
            }
            return i.join("&")
        },
        fromQueryString: function(e, t) {
            var n = e.replace(/^\?/, "").split("&"),
            r = {},
            i,
            s,
            o,
            u,
            a,
            f,
            l,
            c,
            h,
            p,
            d,
            v,
            m,
            g;
            for (a = 0, f = n.length; a < f; a++) {
                l = n[a];
                if (l.length > 0) {
                    s = l.split("=");
                    o = decodeURIComponent(s[0]);
                    u = s[1] !== undefined ? decodeURIComponent(s[1]) : "";
                    if (!t) {
                        if (r.hasOwnProperty(o)) {
                            if (!Ext.isArray(r[o])) {
                                r[o] = [r[o]]
                            }
                            r[o].push(u)
                        } else {
                            r[o] = u
                        }
                    } else {
                        p = o.match(/(\[):?([^\]]*)\]/g);
                        d = o.match(/^([^\[]+)/);
                        o = d[0];
                        v = [];
                        if (p === null) {
                            r[o] = u;
                            continue
                        }
                        for (c = 0, h = p.length; c < h; c++) {
                            m = p[c];
                            m = m.length === 2 ? "": m.substring(1, m.length - 1);
                            v.push(m)
                        }
                        v.unshift(o);
                        i = r;
                        for (c = 0, h = v.length; c < h; c++) {
                            m = v[c];
                            if (c === h - 1) {
                                if (Ext.isArray(i) && m === "") {
                                    i.push(u)
                                } else {
                                    i[m] = u
                                }
                            } else {
                                if (i[m] === undefined || typeof i[m] === "string") {
                                    g = v[c + 1];
                                    i[m] = Ext.isNumeric(g) || g === "" ? [] : {}
                                }
                                i = i[m]
                            }
                        }
                    }
                }
            }
            return r
        },
        each: function(e, t, n) {
            for (var r in e) {
                if (e.hasOwnProperty(r)) {
                    if (t.call(n || e, r, e[r], e) === false) {
                        return
                    }
                }
            }
        },
        merge: function(e) {
            var n = 1,
            r = arguments.length,
            i = t.merge,
            s = Ext.clone,
            o, u, a, f;
            for (; n < r; n++) {
                o = arguments[n];
                for (u in o) {
                    a = o[u];
                    if (a && a.constructor === Object) {
                        f = e[u];
                        if (f && f.constructor === Object) {
                            i(f, a)
                        } else {
                            e[u] = s(a)
                        }
                    } else {
                        e[u] = a
                    }
                }
            }
            return e
        },
        mergeIf: function(e) {
            var t = 1,
            n = arguments.length,
            r = Ext.clone,
            i, s, o;
            for (; t < n; t++) {
                i = arguments[t];
                for (s in i) {
                    if (! (s in e)) {
                        o = i[s];
                        if (o && o.constructor === Object) {
                            e[s] = r(o)
                        } else {
                            e[s] = o
                        }
                    }
                }
            }
            return e
        },
        getKey: function(e, t) {
            for (var n in e) {
                if (e.hasOwnProperty(n) && e[n] === t) {
                    return n
                }
            }
            return null
        },
        getValues: function(e) {
            var t = [],
            n;
            for (n in e) {
                if (e.hasOwnProperty(n)) {
                    t.push(e[n])
                }
            }
            return t
        },
        getKeys: typeof Object.keys == "function" ?
        function(e) {
            if (!e) {
                return []
            }
            return Object.keys(e)
        }: function(e) {
            var t = [],
            n;
            for (n in e) {
                if (e.hasOwnProperty(n)) {
                    t.push(n)
                }
            }
            return t
        },
        getSize: function(e) {
            var t = 0,
            n;
            for (n in e) {
                if (e.hasOwnProperty(n)) {
                    t++
                }
            }
            return t
        },
        isEmpty: function(e) {
            for (var t in e) {
                if (e.hasOwnProperty(t)) {
                    return false
                }
            }
            return true
        },
        equals: function() {
            var e = function(e, t) {
                var n;
                for (n in e) {
                    if (e.hasOwnProperty(n)) {
                        if (e[n] !== t[n]) {
                            return false
                        }
                    }
                }
                return true
            };
            return function(t, n) {
                if (t === n) {
                    return true
                }
                if (t && n) {
                    return e(t, n) && e(n, t)
                } else {
                    if (!t && !n) {
                        return t === n
                    } else {
                        return false
                    }
                }
            }
        } (),
        classify: function(e) {
            var n = e,
            r = [],
            i = {},
            s = function() {
                var e = 0,
                t = r.length,
                n;
                for (; e < t; e++) {
                    n = r[e];
                    this[n] = new i[n]
                }
            },
            o,
            u;
            for (o in e) {
                if (e.hasOwnProperty(o)) {
                    u = e[o];
                    if (u && u.constructor === Object) {
                        r.push(o);
                        i[o] = t.classify(u)
                    }
                }
            }
            s.prototype = n;
            return s
        }
    };
    Ext.merge = Ext.Object.merge;
    Ext.mergeIf = Ext.Object.mergeIf;
    Ext.urlEncode = function() {
        var e = Ext.Array.from(arguments),
        n = "";
        if (typeof e[1] === "string") {
            n = e[1] + "&";
            e[1] = false
        }
        return n + t.toQueryString.apply(t, e)
    };
    Ext.urlDecode = function() {
        return t.fromQueryString.apply(t, arguments)
    }
})();
Ext.Date = new
function() {
    function a(e) {
        var t = Array.prototype.slice.call(arguments, 1);
        return e.replace(s,
        function(e, n) {
            return t[n]
        })
    }
    var e = this,
    t = /(\\.)/g,
    n = /([gGhHisucUOPZ]|MS)/,
    r = /([djzmnYycU]|MS)/,
    i = /\\/gi,
    s = /\{(\d+)\}/g,
    o = new RegExp("\\/Date\\(([-+])?(\\d+)(?:[+-]\\d{4})?\\)\\/"),
    u = ["var me = this, dt, y, m, d, h, i, s, ms, o, O, z, zz, u, v, W, year, jan4, week1monday, daysInMonth, dayMatched,", "def = me.defaults,", "from = Ext.Number.from,", "results = String(input).match(me.parseRegexes[{0}]);", "if(results){", "{1}", "if(u != null){", "v = new Date(u * 1000);", "}else{", "dt = me.clearTime(new Date);", "y = from(y, from(def.y, dt.getFullYear()));", "m = from(m, from(def.m - 1, dt.getMonth()));", "dayMatched = d !== undefined;", "d = from(d, from(def.d, dt.getDate()));", "if (!dayMatched) {", "dt.setDate(1);", "dt.setMonth(m);", "dt.setFullYear(y);", "daysInMonth = me.getDaysInMonth(dt);", "if (d > daysInMonth) {", "d = daysInMonth;", "}", "}", "h  = from(h, from(def.h, dt.getHours()));", "i  = from(i, from(def.i, dt.getMinutes()));", "s  = from(s, from(def.s, dt.getSeconds()));", "ms = from(ms, from(def.ms, dt.getMilliseconds()));", "if(z >= 0 && y >= 0){", "v = me.add(new Date(y < 100 ? 100 : y, 0, 1, h, i, s, ms), me.YEAR, y < 100 ? y - 100 : 0);", "v = !strict? v : (strict === true && (z <= 364 || (me.isLeapYear(v) && z <= 365))? me.add(v, me.DAY, z) : null);", "}else if(strict === true && !me.isValid(y, m + 1, d, h, i, s, ms)){", "v = null;", "}else{", "if (W) {", "year = y || (new Date()).getFullYear();", "jan4 = new Date(year, 0, 4, 0, 0, 0);", "d = jan4.getDay();", "week1monday = new Date(jan4.getTime() - ((d === 0 ? 6 : d - 1) * 86400000));", "v = Ext.Date.clearTime(new Date(week1monday.getTime() + ((W - 1) * 604800000 + 43200000)));", "} else {", "v = me.add(new Date(y < 100 ? 100 : y, m, d, h, i, s, ms), me.YEAR, y < 100 ? y - 100 : 0);", "}", "}", "}", "}", "if(v){", "if(zz != null){", "v = me.add(v, me.SECOND, -v.getTimezoneOffset() * 60 - zz);", "}else if(o){", "v = me.add(v, me.MINUTE, -v.getTimezoneOffset() + (sn == '+'? -1 : 1) * (hr * 60 + mn));", "}", "}", "return v;"].join("\n");
    Ext.apply(e, {
        now: Date.now ||
        function() {
            return + (new Date)
        },
        toString: function(e) {
            return Ext.Date.format(e, "Y-m-d H:i:s.u")
        },
        getElapsed: function(t, n) {
            return Math.abs(t - (n || e.now()))
        },
        useStrict: false,
        formatCodeToRegex: function(t, n) {
            var r = e.parseCodes[t];
            if (r) {
                r = typeof r == "function" ? r() : r;
                e.parseCodes[t] = r
            }
            return r ? Ext.applyIf({
                c: r.c ? a(r.c, n || "{0}") : r.c
            },
            r) : {
                g: 0,
                c: null,
                s: Ext.String.escapeRegex(t)
            }
        },
        parseFunctions: {
            MS: function(e, t) {
                var n = (e || "").match(o);
                return n ? new Date(((n[1] || "") + n[2]) * 1) : null
            },
            time: function(e, t) {
                var n = parseInt(e, 10);
                if (n || n === 0) {
                    return new Date(n)
                }
                return null
            },
            timestamp: function(e, t) {
                var n = parseInt(e, 10);
                if (n || n === 0) {
                    return new Date(n * 1e3)
                }
                return null
            }
        },
        parseRegexes: [],
        formatFunctions: {
            MS: function() {
                return "\\/Date(" + this.getTime() + ")\\/"
            },
            time: function() {
                return this.getTime().toString()
            },
            timestamp: function() {
                return e.format(this, "U")
            }
        },
        y2kYear: 50,
        MILLI: "ms",
        SECOND: "s",
        MINUTE: "mi",
        HOUR: "h",
        DAY: "d",
        MONTH: "mo",
        YEAR: "y",
        defaults: {},
        dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
        monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        monthNumbers: {
            January: 0,
            Jan: 0,
            February: 1,
            Feb: 1,
            March: 2,
            Mar: 2,
            April: 3,
            Apr: 3,
            May: 4,
            June: 5,
            Jun: 5,
            July: 6,
            Jul: 6,
            August: 7,
            Aug: 7,
            September: 8,
            Sep: 8,
            October: 9,
            Oct: 9,
            November: 10,
            Nov: 10,
            December: 11,
            Dec: 11
        },
        defaultFormat: "m/d/Y",
        getShortMonthName: function(e) {
            return Ext.Date.monthNames[e].substring(0, 3)
        },
        getShortDayName: function(e) {
            return Ext.Date.dayNames[e].substring(0, 3)
        },
        getMonthNumber: function(e) {
            return Ext.Date.monthNumbers[e.substring(0, 1).toUpperCase() + e.substring(1, 3).toLowerCase()]
        },
        formatContainsHourInfo: function(e) {
            return n.test(e.replace(t, ""))
        },
        formatContainsDateInfo: function(e) {
            return r.test(e.replace(t, ""))
        },
        unescapeFormat: function(e) {
            return e.replace(i, "")
        },
        formatCodes: {
            d: "Ext.String.leftPad(this.getDate(), 2, '0')",
            D: "Ext.Date.getShortDayName(this.getDay())",
            j: "this.getDate()",
            l: "Ext.Date.dayNames[this.getDay()]",
            N: "(this.getDay() ? this.getDay() : 7)",
            S: "Ext.Date.getSuffix(this)",
            w: "this.getDay()",
            z: "Ext.Date.getDayOfYear(this)",
            W: "Ext.String.leftPad(Ext.Date.getWeekOfYear(this), 2, '0')",
            F: "Ext.Date.monthNames[this.getMonth()]",
            m: "Ext.String.leftPad(this.getMonth() + 1, 2, '0')",
            M: "Ext.Date.getShortMonthName(this.getMonth())",
            n: "(this.getMonth() + 1)",
            t: "Ext.Date.getDaysInMonth(this)",
            L: "(Ext.Date.isLeapYear(this) ? 1 : 0)",
            o: "(this.getFullYear() + (Ext.Date.getWeekOfYear(this) == 1 && this.getMonth() > 0 ? +1 : (Ext.Date.getWeekOfYear(this) >= 52 && this.getMonth() < 11 ? -1 : 0)))",
            Y: "Ext.String.leftPad(this.getFullYear(), 4, '0')",
            y: "('' + this.getFullYear()).substring(2, 4)",
            a: "(this.getHours() < 12 ? 'am' : 'pm')",
            A: "(this.getHours() < 12 ? 'AM' : 'PM')",
            g: "((this.getHours() % 12) ? this.getHours() % 12 : 12)",
            G: "this.getHours()",
            h: "Ext.String.leftPad((this.getHours() % 12) ? this.getHours() % 12 : 12, 2, '0')",
            H: "Ext.String.leftPad(this.getHours(), 2, '0')",
            i: "Ext.String.leftPad(this.getMinutes(), 2, '0')",
            s: "Ext.String.leftPad(this.getSeconds(), 2, '0')",
            u: "Ext.String.leftPad(this.getMilliseconds(), 3, '0')",
            O: "Ext.Date.getGMTOffset(this)",
            P: "Ext.Date.getGMTOffset(this, true)",
            T: "Ext.Date.getTimezone(this)",
            Z: "(this.getTimezoneOffset() * -60)",
            c: function() {
                var t, n, r, i, s;
                for (t = "Y-m-dTH:i:sP", n = [], r = 0, i = t.length; r < i; ++r) {
                    s = t.charAt(r);
                    n.push(s == "T" ? "'T'": e.getFormatCode(s))
                }
                return n.join(" + ")
            },
            U: "Math.round(this.getTime() / 1000)"
        },
        isValid: function(t, n, r, i, s, o, u) {
            i = i || 0;
            s = s || 0;
            o = o || 0;
            u = u || 0;
            var a = e.add(new Date(t < 100 ? 100 : t, n - 1, r, i, s, o, u), e.YEAR, t < 100 ? t - 100 : 0);
            return t == a.getFullYear() && n == a.getMonth() + 1 && r == a.getDate() && i == a.getHours() && s == a.getMinutes() && o == a.getSeconds() && u == a.getMilliseconds()
        },
        parse: function(t, n, r) {
            var i = e.parseFunctions;
            if (i[n] == null) {
                e.createParser(n)
            }
            return i[n].call(e, t, Ext.isDefined(r) ? r: e.useStrict)
        },
        parseDate: function(t, n, r) {
            return e.parse(t, n, r)
        },
        getFormatCode: function(t) {
            var n = e.formatCodes[t];
            if (n) {
                n = typeof n == "function" ? n() : n;
                e.formatCodes[t] = n
            }
            return n || "'" + Ext.String.escape(t) + "'"
        },
        createFormat: function(t) {
            var n = [],
            r = false,
            i = "",
            s;
            for (s = 0; s < t.length; ++s) {
                i = t.charAt(s);
                if (!r && i == "\\") {
                    r = true
                } else {
                    if (r) {
                        r = false;
                        n.push("'" + Ext.String.escape(i) + "'")
                    } else {
                        n.push(e.getFormatCode(i))
                    }
                }
            }
            e.formatFunctions[t] = Ext.functionFactory("return " + n.join("+"))
        },
        createParser: function(t) {
            var n = e.parseRegexes.length,
            r = 1,
            i = [],
            s = [],
            o = false,
            f = "",
            l = 0,
            c = t.length,
            p = [],
            v;
            for (; l < c; ++l) {
                f = t.charAt(l);
                if (!o && f == "\\") {
                    o = true
                } else {
                    if (o) {
                        o = false;
                        s.push(Ext.String.escape(f))
                    } else {
                        v = e.formatCodeToRegex(f, r);
                        r += v.g;
                        s.push(v.s);
                        if (v.g && v.c) {
                            if (v.calcAtEnd) {
                                p.push(v.c)
                            } else {
                                i.push(v.c)
                            }
                        }
                    }
                }
            }
            i = i.concat(p);
            e.parseRegexes[n] = new RegExp("^" + s.join("") + "$", "i");
            e.parseFunctions[t] = Ext.functionFactory("input", "strict", a(u, n, i.join("")))
        },
        parseCodes: {
            d: {
                g: 1,
                c: "d = parseInt(results[{0}], 10);\n",
                s: "(3[0-1]|[1-2][0-9]|0[1-9])"
            },
            j: {
                g: 1,
                c: "d = parseInt(results[{0}], 10);\n",
                s: "(3[0-1]|[1-2][0-9]|[1-9])"
            },
            D: function() {
                for (var t = [], n = 0; n < 7; t.push(e.getShortDayName(n)), ++n) {}
                return {
                    g: 0,
                    c: null,
                    s: "(?:" + t.join("|") + ")"
                }
            },
            l: function() {
                return {
                    g: 0,
                    c: null,
                    s: "(?:" + e.dayNames.join("|") + ")"
                }
            },
            N: {
                g: 0,
                c: null,
                s: "[1-7]"
            },
            S: {
                g: 0,
                c: null,
                s: "(?:st|nd|rd|th)"
            },
            w: {
                g: 0,
                c: null,
                s: "[0-6]"
            },
            z: {
                g: 1,
                c: "z = parseInt(results[{0}], 10);\n",
                s: "(\\d{1,3})"
            },
            W: {
                g: 1,
                c: "W = parseInt(results[{0}], 10);\n",
                s: "(\\d{2})"
            },
            F: function() {
                return {
                    g: 1,
                    c: "m = parseInt(me.getMonthNumber(results[{0}]), 10);\n",
                    s: "(" + e.monthNames.join("|") + ")"
                }
            },
            M: function() {
                for (var t = [], n = 0; n < 12; t.push(e.getShortMonthName(n)), ++n) {}
                return Ext.applyIf({
                    s: "(" + t.join("|") + ")"
                },
                e.formatCodeToRegex("F"))
            },
            m: {
                g: 1,
                c: "m = parseInt(results[{0}], 10) - 1;\n",
                s: "(1[0-2]|0[1-9])"
            },
            n: {
                g: 1,
                c: "m = parseInt(results[{0}], 10) - 1;\n",
                s: "(1[0-2]|[1-9])"
            },
            t: {
                g: 0,
                c: null,
                s: "(?:\\d{2})"
            },
            L: {
                g: 0,
                c: null,
                s: "(?:1|0)"
            },
            o: {
                g: 1,
                c: "y = parseInt(results[{0}], 10);\n",
                s: "(\\d{4})"
            },
            Y: {
                g: 1,
                c: "y = parseInt(results[{0}], 10);\n",
                s: "(\\d{4})"
            },
            y: {
                g: 1,
                c: "var ty = parseInt(results[{0}], 10);\ny = ty > me.y2kYear ? 1900 + ty : 2000 + ty;\n",
                s: "(\\d{1,2})"
            },
            a: {
                g: 1,
                c: "if (/(am)/i.test(results[{0}])) {\nif (!h || h == 12) { h = 0; }\n} else { if (!h || h < 12) { h = (h || 0) + 12; }}",
                s: "(am|pm|AM|PM)",
                calcAtEnd: true
            },
            A: {
                g: 1,
                c: "if (/(am)/i.test(results[{0}])) {\nif (!h || h == 12) { h = 0; }\n} else { if (!h || h < 12) { h = (h || 0) + 12; }}",
                s: "(AM|PM|am|pm)",
                calcAtEnd: true
            },
            g: {
                g: 1,
                c: "h = parseInt(results[{0}], 10);\n",
                s: "(1[0-2]|[0-9])"
            },
            G: {
                g: 1,
                c: "h = parseInt(results[{0}], 10);\n",
                s: "(2[0-3]|1[0-9]|[0-9])"
            },
            h: {
                g: 1,
                c: "h = parseInt(results[{0}], 10);\n",
                s: "(1[0-2]|0[1-9])"
            },
            H: {
                g: 1,
                c: "h = parseInt(results[{0}], 10);\n",
                s: "(2[0-3]|[0-1][0-9])"
            },
            i: {
                g: 1,
                c: "i = parseInt(results[{0}], 10);\n",
                s: "([0-5][0-9])"
            },
            s: {
                g: 1,
                c: "s = parseInt(results[{0}], 10);\n",
                s: "([0-5][0-9])"
            },
            u: {
                g: 1,
                c: "ms = results[{0}]; ms = parseInt(ms, 10)/Math.pow(10, ms.length - 3);\n",
                s: "(\\d+)"
            },
            O: {
                g: 1,
                c: ["o = results[{0}];", "var sn = o.substring(0,1),", "hr = o.substring(1,3)*1 + Math.floor(o.substring(3,5) / 60),", "mn = o.substring(3,5) % 60;", "o = ((-12 <= (hr*60 + mn)/60) && ((hr*60 + mn)/60 <= 14))? (sn + Ext.String.leftPad(hr, 2, '0') + Ext.String.leftPad(mn, 2, '0')) : null;\n"].join("\n"),
                s: "([+-]\\d{4})"
            },
            P: {
                g: 1,
                c: ["o = results[{0}];", "var sn = o.substring(0,1),", "hr = o.substring(1,3)*1 + Math.floor(o.substring(4,6) / 60),", "mn = o.substring(4,6) % 60;", "o = ((-12 <= (hr*60 + mn)/60) && ((hr*60 + mn)/60 <= 14))? (sn + Ext.String.leftPad(hr, 2, '0') + Ext.String.leftPad(mn, 2, '0')) : null;\n"].join("\n"),
                s: "([+-]\\d{2}:\\d{2})"
            },
            T: {
                g: 0,
                c: null,
                s: "[A-Z]{1,5}"
            },
            Z: {
                g: 1,
                c: "zz = results[{0}] * 1;\nzz = (-43200 <= zz && zz <= 50400)? zz : null;\n",
                s: "([+-]?\\d{1,5})"
            },
            c: function() {
                var t = [],
                n = [e.formatCodeToRegex("Y", 1), e.formatCodeToRegex("m", 2), e.formatCodeToRegex("d", 3), e.formatCodeToRegex("H", 4), e.formatCodeToRegex("i", 5), e.formatCodeToRegex("s", 6), {
                    c: "ms = results[7] || '0'; ms = parseInt(ms, 10)/Math.pow(10, ms.length - 3);\n"
                },
                {
                    c: ["if(results[8]) {", "if(results[8] == 'Z'){", "zz = 0;", "}else if (results[8].indexOf(':') > -1){", e.formatCodeToRegex("P", 8).c, "}else{", e.formatCodeToRegex("O", 8).c, "}", "}"].join("\n")
                }],
                r,
                i;
                for (r = 0, i = n.length; r < i; ++r) {
                    t.push(n[r].c)
                }
                return {
                    g: 1,
                    c: t.join(""),
                    s: [n[0].s, "(?:", "-", n[1].s, "(?:", "-", n[2].s, "(?:", "(?:T| )?", n[3].s, ":", n[4].s, "(?::", n[5].s, ")?", "(?:(?:\\.|,)(\\d+))?", "(Z|(?:[-+]\\d{2}(?::)?\\d{2}))?", ")?", ")?", ")?"].join("")
                }
            },
            U: {
                g: 1,
                c: "u = parseInt(results[{0}], 10);\n",
                s: "(-?\\d+)"
            }
        },
        dateFormat: function(t, n) {
            return e.format(t, n)
        },
        isEqual: function(e, t) {
            if (e && t) {
                return e.getTime() === t.getTime()
            }
            return ! (e || t)
        },
        format: function(t, n) {
            var r = e.formatFunctions;
            if (!Ext.isDate(t)) {
                return ""
            }
            if (r[n] == null) {
                e.createFormat(n)
            }
            return r[n].call(t) + ""
        },
        getTimezone: function(e) {
            return e.toString().replace(/^.* (?:\((.*)\)|([A-Z]{1,5})(?:[\-+][0-9]{4})?(?: -?\d+)?)$/, "$1$2").replace(/[^A-Z]/g, "")
        },
        getGMTOffset: function(e, t) {
            var n = e.getTimezoneOffset();
            return (n > 0 ? "-": "+") + Ext.String.leftPad(Math.floor(Math.abs(n) / 60), 2, "0") + (t ? ":": "") + Ext.String.leftPad(Math.abs(n % 60), 2, "0")
        },
        getDayOfYear: function(t) {
            var n = 0,
            r = Ext.Date.clone(t),
            i = t.getMonth(),
            s;
            for (s = 0, r.setDate(1), r.setMonth(0); s < i; r.setMonth(++s)) {
                n += e.getDaysInMonth(r)
            }
            return n + t.getDate() - 1
        },
        getWeekOfYear: function() {
            var e = 864e5,
            t = 7 * e;
            return function(n) {
                var r = Date.UTC(n.getFullYear(), n.getMonth(), n.getDate() + 3) / e,
                i = Math.floor(r / 7),
                s = (new Date(i * t)).getUTCFullYear();
                return i - Math.floor(Date.UTC(s, 0, 7) / t) + 1
            }
        } (),
        isLeapYear: function(e) {
            var t = e.getFullYear();
            return !! ((t & 3) == 0 && (t % 100 || t % 400 == 0 && t))
        },
        getFirstDayOfMonth: function(e) {
            var t = (e.getDay() - (e.getDate() - 1)) % 7;
            return t < 0 ? t + 7 : t
        },
        getLastDayOfMonth: function(t) {
            return e.getLastDateOfMonth(t).getDay()
        },
        getFirstDateOfMonth: function(e) {
            return new Date(e.getFullYear(), e.getMonth(), 1)
        },
        getLastDateOfMonth: function(t) {
            return new Date(t.getFullYear(), t.getMonth(), e.getDaysInMonth(t))
        },
        getDaysInMonth: function() {
            var t = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
            return function(n) {
                var r = n.getMonth();
                return r == 1 && e.isLeapYear(n) ? 29 : t[r]
            }
        } (),
        getSuffix: function(e) {
            switch (e.getDate()) {
            case 1:
            case 21:
            case 31:
                return "st";
            case 2:
            case 22:
                return "nd";
            case 3:
            case 23:
                return "rd";
            default:
                return "th"
            }
        },
        clone: function(e) {
            return new Date(e.getTime())
        },
        isDST: function(e) {
            return (new Date(e.getFullYear(), 0, 1)).getTimezoneOffset() != e.getTimezoneOffset()
        },
        clearTime: function(t, n) {
            if (n) {
                return Ext.Date.clearTime(Ext.Date.clone(t))
            }
            var r = t.getDate(),
            i,
            s;
            t.setHours(0);
            t.setMinutes(0);
            t.setSeconds(0);
            t.setMilliseconds(0);
            if (t.getDate() != r) {
                for (i = 1, s = e.add(t, Ext.Date.HOUR, i); s.getDate() != r; i++, s = e.add(t, Ext.Date.HOUR, i)) {}
                t.setDate(r);
                t.setHours(s.getHours())
            }
            return t
        },
        add: function(t, n, r) {
            var i = Ext.Date.clone(t),
            s = Ext.Date,
            o,
            u,
            a = 0;
            if (!n || r === 0) {
                return i
            }
            u = r - parseInt(r, 10);
            r = parseInt(r, 10);
            if (r) {
                switch (n.toLowerCase()) {
                case Ext.Date.MILLI:
                    i.setTime(i.getTime() + r);
                    break;
                case Ext.Date.SECOND:
                    i.setTime(i.getTime() + r * 1e3);
                    break;
                case Ext.Date.MINUTE:
                    i.setTime(i.getTime() + r * 60 * 1e3);
                    break;
                case Ext.Date.HOUR:
                    i.setTime(i.getTime() + r * 60 * 60 * 1e3);
                    break;
                case Ext.Date.DAY:
                    i.setDate(i.getDate() + r);
                    break;
                case Ext.Date.MONTH:
                    o = t.getDate();
                    if (o > 28) {
                        o = Math.min(o, Ext.Date.getLastDateOfMonth(Ext.Date.add(Ext.Date.getFirstDateOfMonth(t), Ext.Date.MONTH, r)).getDate())
                    }
                    i.setDate(o);
                    i.setMonth(t.getMonth() + r);
                    break;
                case Ext.Date.YEAR:
                    o = t.getDate();
                    if (o > 28) {
                        o = Math.min(o, Ext.Date.getLastDateOfMonth(Ext.Date.add(Ext.Date.getFirstDateOfMonth(t), Ext.Date.YEAR, r)).getDate())
                    }
                    i.setDate(o);
                    i.setFullYear(t.getFullYear() + r);
                    break
                }
            }
            if (u) {
                switch (n.toLowerCase()) {
                case Ext.Date.MILLI:
                    a = 1;
                    break;
                case Ext.Date.SECOND:
                    a = 1e3;
                    break;
                case Ext.Date.MINUTE:
                    a = 1e3 * 60;
                    break;
                case Ext.Date.HOUR:
                    a = 1e3 * 60 * 60;
                    break;
                case Ext.Date.DAY:
                    a = 1e3 * 60 * 60 * 24;
                    break;
                case Ext.Date.MONTH:
                    o = e.getDaysInMonth(i);
                    a = 1e3 * 60 * 60 * 24 * o;
                    break;
                case Ext.Date.YEAR:
                    o = e.isLeapYear(i) ? 366 : 365;
                    a = 1e3 * 60 * 60 * 24 * o;
                    break
                }
                if (a) {
                    i.setTime(i.getTime() + a * u)
                }
            }
            return i
        },
        subtract: function(t, n, r) {
            return e.add(t, n, -r)
        },
        between: function(e, t, n) {
            var r = e.getTime();
            return t.getTime() <= r && r <= n.getTime()
        },
        compat: function() {
            var t = window.Date,
            n, r = ["useStrict", "formatCodeToRegex", "parseFunctions", "parseRegexes", "formatFunctions", "y2kYear", "MILLI", "SECOND", "MINUTE", "HOUR", "DAY", "MONTH", "YEAR", "defaults", "dayNames", "monthNames", "monthNumbers", "getShortMonthName", "getShortDayName", "getMonthNumber", "formatCodes", "isValid", "parseDate", "getFormatCode", "createFormat", "createParser", "parseCodes"],
            i = ["dateFormat", "format", "getTimezone", "getGMTOffset", "getDayOfYear", "getWeekOfYear", "isLeapYear", "getFirstDayOfMonth", "getLastDayOfMonth", "getDaysInMonth", "getSuffix", "clone", "isDST", "clearTime", "add", "between"],
            s = r.length,
            o = i.length,
            u,
            a,
            f;
            for (f = 0; f < s; f++) {
                u = r[f];
                t[u] = e[u]
            }
            for (n = 0; n < o; n++) {
                a = i[n];
                t.prototype[a] = function() {
                    var t = Array.prototype.slice.call(arguments);
                    t.unshift(this);
                    return e[a].apply(e, t)
                }
            }
        }
    })
}; (function(e) {
    var t = [],
    n = function() {},
    r = function(e, t, n, r) {
        var i = function() {
            var t = this.callParent(arguments);
            e.apply(this, arguments);
            return t
        };
        i.$name = n;
        i.$owner = r;
        if (t) {
            i.$previous = t.$previous;
            t.$previous = i
        }
        return i
    };
    Ext.apply(n, {
        $className: "Ext.Base",
        $isClass: true,
        create: function() {
            return Ext.create.apply(Ext, [this].concat(Array.prototype.slice.call(arguments, 0)))
        },
        extend: function(e) {
            var t = e.prototype,
            n, r, i, s, o, u;
            r = this.prototype = Ext.Object.chain(t);
            r.self = this;
            this.superclass = r.superclass = t;
            if (!e.$isClass) {
                n = Ext.Base.prototype;
                for (i in n) {
                    if (i in r) {
                        r[i] = n[i]
                    }
                }
            }
            u = t.$inheritableStatics;
            if (u) {
                for (i = 0, s = u.length; i < s; i++) {
                    o = u[i];
                    if (!this.hasOwnProperty(o)) {
                        this[o] = e[o]
                    }
                }
            }
            if (e.$onExtended) {
                this.$onExtended = e.$onExtended.slice()
            }
            r.config = new r.configClass;
            r.initConfigList = r.initConfigList.slice();
            r.initConfigMap = Ext.clone(r.initConfigMap);
            r.configMap = Ext.Object.chain(r.configMap)
        },
        $onExtended: [],
        triggerExtended: function() {
            var e = this.$onExtended,
            t = e.length,
            n, r;
            if (t > 0) {
                for (n = 0; n < t; n++) {
                    r = e[n];
                    r.fn.apply(r.scope || this, arguments)
                }
            }
        },
        onExtended: function(e, t) {
            this.$onExtended.push({
                fn: e,
                scope: t
            });
            return this
        },
        addConfig: function(e, t) {
            var n = this.prototype,
            r = Ext.Class.configNameCache,
            i = n.configMap,
            s = n.initConfigList,
            o = n.initConfigMap,
            u = n.config,
            a, f, l;
            for (f in e) {
                if (e.hasOwnProperty(f)) {
                    if (!i[f]) {
                        i[f] = true
                    }
                    l = e[f];
                    a = r[f].initialized;
                    if (!o[f] && l !== null && !n[a]) {
                        o[f] = true;
                        s.push(f)
                    }
                }
            }
            if (t) {
                Ext.merge(u, e)
            } else {
                Ext.mergeIf(u, e)
            }
            n.configClass = Ext.Object.classify(u)
        },
        addStatics: function(e) {
            var t, n;
            for (n in e) {
                if (e.hasOwnProperty(n)) {
                    t = e[n];
                    if (typeof t == "function" && !t.$isClass && t !== Ext.emptyFn && t !== Ext.identityFn) {
                        t.$owner = this;
                        t.$name = n
                    }
                    this[n] = t
                }
            }
            return this
        },
        addInheritableStatics: function(e) {
            var t, n, r = this.prototype,
            i, s;
            t = r.$inheritableStatics;
            n = r.$hasInheritableStatics;
            if (!t) {
                t = r.$inheritableStatics = [];
                n = r.$hasInheritableStatics = {}
            }
            for (i in e) {
                if (e.hasOwnProperty(i)) {
                    s = e[i];
                    this[i] = s;
                    if (!n[i]) {
                        n[i] = true;
                        t.push(i)
                    }
                }
            }
            return this
        },
        addMembers: function(e) {
            var t = this.prototype,
            n = Ext.enumerables,
            r = [],
            i,
            s,
            o,
            u;
            for (o in e) {
                r.push(o)
            }
            if (n) {
                r.push.apply(r, n)
            }
            for (i = 0, s = r.length; i < s; i++) {
                o = r[i];
                if (e.hasOwnProperty(o)) {
                    u = e[o];
                    if (typeof u == "function" && !u.$isClass && u !== Ext.emptyFn && u !== Ext.identityFn) {
                        u.$owner = this;
                        u.$name = o
                    }
                    t[o] = u
                }
            }
            return this
        },
        addMember: function(e, t) {
            if (typeof t == "function" && !t.$isClass && t !== Ext.emptyFn && t !== Ext.identityFn) {
                t.$owner = this;
                t.$name = e
            }
            this.prototype[e] = t;
            return this
        },
        implement: function() {
            this.addMembers.apply(this, arguments)
        },
        borrow: function(e, t) {
            var n = this.prototype,
            r = e.prototype,
            i, s, o, u, a;
            t = Ext.Array.from(t);
            for (i = 0, s = t.length; i < s; i++) {
                o = t[i];
                a = r[o];
                if (typeof a == "function") {
                    u = Ext.Function.clone(a);
                    u.$owner = this;
                    u.$name = o;
                    n[o] = u
                } else {
                    n[o] = a
                }
            }
            return this
        },
        override: function(e) {
            var t = this,
            n = Ext.enumerables,
            r = t.prototype,
            i = Ext.Function.clone,
            s, o, u, a, f, l;
            if (arguments.length === 2) {
                s = e;
                e = {};
                e[s] = arguments[1];
                n = null
            }
            do {
                f = [];
                a = null;
                for (s in e) {
                    if (s == "statics") {
                        a = e[s]
                    } else {
                        if (s == "inheritableStatics") {
                            t.addInheritableStatics(e[s])
                        } else {
                            if (s == "config") {
                                t.addConfig(e[s], true)
                            } else {
                                f.push(s)
                            }
                        }
                    }
                }
                if (n) {
                    f.push.apply(f, n)
                }
                for (o = f.length; o--;) {
                    s = f[o];
                    if (e.hasOwnProperty(s)) {
                        u = e[s];
                        if (typeof u == "function" && !u.$className && u !== Ext.emptyFn && u !== Ext.identityFn) {
                            if (typeof u.$owner != "undefined") {
                                u = i(u)
                            }
                            u.$owner = t;
                            u.$name = s;
                            l = r.hasOwnProperty(s) && r[s];
                            if (l) {
                                u.$previous = l
                            }
                        }
                        r[s] = u
                    }
                }
                r = t;
                e = a
            } while ( e );
            return this
        },
        callParent: function(e) {
            var n;
            return (n = this.callParent.caller) && (n.$previous || (n = n.$owner ? n: n.caller) && n.$owner.superclass.self[n.$name]).apply(this, e || t)
        },
        callSuper: function(e) {
            var n;
            return (n = this.callSuper.caller) && ((n = n.$owner ? n: n.caller) && n.$owner.superclass.self[n.$name]).apply(this, e || t)
        },
        mixin: function(e, t) {
            var n = this,
            i = t.prototype,
            s = n.prototype,
            o, u, a, f, l, h, p, d;
            if (typeof i.onClassMixedIn != "undefined") {
                i.onClassMixedIn.call(t, n)
            }
            if (!s.hasOwnProperty("mixins")) {
                if ("mixins" in s) {
                    s.mixins = Ext.Object.chain(s.mixins)
                } else {
                    s.mixins = {}
                }
            }
            for (o in i) {
                h = i[o];
                if (o === "mixins") {
                    Ext.merge(s.mixins, h)
                } else {
                    if (o === "xhooks") {
                        for (p in h) {
                            d = h[p];
                            d.$previous = Ext.emptyFn;
                            if (s.hasOwnProperty(p)) {
                                r(d, s[p], p, n)
                            } else {
                                s[p] = r(d, null, p, n)
                            }
                        }
                    } else {
                        if (! (o === "mixinId" || o === "config") && s[o] === undefined) {
                            s[o] = h
                        }
                    }
                }
            }
            u = i.$inheritableStatics;
            if (u) {
                for (a = 0, f = u.length; a < f; a++) {
                    l = u[a];
                    if (!n.hasOwnProperty(l)) {
                        n[l] = t[l]
                    }
                }
            }
            if ("config" in i) {
                n.addConfig(i.config, false)
            }
            s.mixins[e] = i;
            return n
        },
        getName: function() {
            return Ext.getClassName(this)
        },
        createAlias: e(function(e, t) {
            this.override(e,
            function() {
                return this[t].apply(this, arguments)
            })
        }),
        addXtype: function(e) {
            var t = this.prototype,
            n = t.xtypesMap,
            r = t.xtypes,
            i = t.xtypesChain;
            if (!t.hasOwnProperty("xtypesMap")) {
                n = t.xtypesMap = Ext.merge({},
                t.xtypesMap || {});
                r = t.xtypes = t.xtypes ? [].concat(t.xtypes) : [];
                i = t.xtypesChain = t.xtypesChain ? [].concat(t.xtypesChain) : [];
                t.xtype = e
            }
            if (!n[e]) {
                n[e] = true;
                r.push(e);
                i.push(e);
                Ext.ClassManager.setAlias(this, "widget." + e)
            }
            return this
        }
    });
    n.implement({
        isInstance: true,
        $className: "Ext.Base",
        configClass: Ext.emptyFn,
        initConfigList: [],
        configMap: {},
        initConfigMap: {},
        statics: function() {
            var e = this.statics.caller,
            t = this.self;
            if (!e) {
                return t
            }
            return e.$owner
        },
        callParent: function(e) {
            var n, r = (n = this.callParent.caller) && (n.$previous || (n = n.$owner ? n: n.caller) && n.$owner.superclass[n.$name]);
            return r.apply(this, e || t)
        },
        callSuper: function(e) {
            var n, r = (n = this.callSuper.caller) && (n = n.$owner ? n: n.caller) && n.$owner.superclass[n.$name];
            return r.apply(this, e || t)
        },
        self: n,
        constructor: function() {
            return this
        },
        initConfig: function(e) {
            var t = e,
            n = Ext.Class.configNameCache,
            r = new this.configClass,
            i = this.initConfigList,
            s = this.configMap,
            o, u, a, f, l;
            this.initConfig = Ext.emptyFn;
            this.initialConfig = t || {};
            this.config = e = t ? Ext.merge(r, e) : r;
            if (t) {
                i = i.slice();
                for (f in t) {
                    if (s[f]) {
                        if (t[f] !== null) {
                            i.push(f);
                            this[n[f].initialized] = false
                        }
                    }
                }
            }
            for (u = 0, a = i.length; u < a; u++) {
                f = i[u];
                o = n[f];
                l = o.initialized;
                if (!this[l]) {
                    this[l] = true;
                    this[o.set].call(this, e[f])
                }
            }
            return this
        },
        hasConfig: function(e) {
            return Boolean(this.configMap[e])
        },
        setConfig: function(e, t) {
            if (!e) {
                return this
            }
            var n = Ext.Class.configNameCache,
            r = this.config,
            i = this.configMap,
            s = this.initialConfig,
            o, u;
            t = Boolean(t);
            for (o in e) {
                if (t && s.hasOwnProperty(o)) {
                    continue
                }
                u = e[o];
                r[o] = u;
                if (i[o]) {
                    this[n[o].set](u)
                }
            }
            return this
        },
        getConfig: function(e) {
            var t = Ext.Class.configNameCache;
            return this[t[e].get]()
        },
        getInitialConfig: function(e) {
            var t = this.config;
            if (!e) {
                return t
            } else {
                return t[e]
            }
        },
        onConfigUpdate: function(e, t, n) {
            var r = this.self,
            i, s, o, u, a, f;
            e = Ext.Array.from(e);
            n = n || this;
            for (i = 0, s = e.length; i < s; i++) {
                o = e[i];
                u = "update" + Ext.String.capitalize(o);
                a = this[u] || Ext.emptyFn;
                f = function() {
                    a.apply(this, arguments);
                    n[t].apply(n, arguments)
                };
                f.$name = u;
                f.$owner = r;
                this[u] = f
            }
        },
        destroy: function() {
            this.destroy = Ext.emptyFn
        }
    });
    n.prototype.callOverridden = n.prototype.callParent;
    Ext.Base = n
})(Ext.Function.flexSetter); (function() {
    function s(e) {
        function t() {
            return this.constructor.apply(this, arguments) || null
        }
        return t
    }
    var e, t = Ext.Base,
    n = [],
    r,
    i;
    for (r in t) {
        if (t.hasOwnProperty(r)) {
            n.push(r)
        }
    }
    i = n.length;
    Ext.Class = e = function(t, n, r) {
        if (typeof t != "function") {
            r = n;
            n = t;
            t = null
        }
        if (!n) {
            n = {}
        }
        t = e.create(t, n);
        e.process(t, n, r);
        return t
    };
    Ext.apply(e, {
        onBeforeCreated: function(e, t, n) {
            e.addMembers(t);
            n.onCreated.call(e, e)
        },
        create: function(e, r) {
            var o, u;
            if (!e) {
                e = s()
            }
            for (u = 0; u < i; u++) {
                o = n[u];
                e[o] = t[o]
            }
            return e
        },
        process: function(t, n, r) {
            var i = n.preprocessors || e.defaultPreprocessors,
            s = this.preprocessors,
            o = {
                onBeforeCreated: this.onBeforeCreated
            },
            u = [],
            a,
            f,
            l,
            h,
            p,
            d,
            v;
            delete n.preprocessors;
            for (l = 0, h = i.length; l < h; l++) {
                a = i[l];
                if (typeof a == "string") {
                    a = s[a];
                    f = a.properties;
                    if (f === true) {
                        u.push(a.fn)
                    } else {
                        if (f) {
                            for (p = 0, d = f.length; p < d; p++) {
                                v = f[p];
                                if (n.hasOwnProperty(v)) {
                                    u.push(a.fn);
                                    break
                                }
                            }
                        }
                    }
                } else {
                    u.push(a)
                }
            }
            o.onCreated = r ? r: Ext.emptyFn;
            o.preprocessors = u;
            this.doProcess(t, n, o)
        },
        doProcess: function(e, t, n) {
            var r = this,
            i = n.preprocessors,
            s = i.shift(),
            o = r.doProcess;
            for (; s; s = i.shift()) {
                if (s.call(r, e, t, n, o) === false) {
                    return
                }
            }
            n.onBeforeCreated.apply(r, arguments)
        },
        preprocessors: {},
        registerPreprocessor: function(e, t, n, r, i) {
            if (!r) {
                r = "last"
            }
            if (!n) {
                n = [e]
            }
            this.preprocessors[e] = {
                name: e,
                properties: n || false,
                fn: t
            };
            this.setDefaultPreprocessorPosition(e, r, i);
            return this
        },
        getPreprocessor: function(e) {
            return this.preprocessors[e]
        },
        getPreprocessors: function() {
            return this.preprocessors
        },
        defaultPreprocessors: [],
        getDefaultPreprocessors: function() {
            return this.defaultPreprocessors
        },
        setDefaultPreprocessors: function(e) {
            this.defaultPreprocessors = Ext.Array.from(e);
            return this
        },
        setDefaultPreprocessorPosition: function(e, t, n) {
            var r = this.defaultPreprocessors,
            i;
            if (typeof t == "string") {
                if (t === "first") {
                    r.unshift(e);
                    return this
                } else {
                    if (t === "last") {
                        r.push(e);
                        return this
                    }
                }
                t = t === "after" ? 1 : -1
            }
            i = Ext.Array.indexOf(r, n);
            if (i !== -1) {
                Ext.Array.splice(r, Math.max(0, i + t), 0, e)
            }
            return this
        },
        configNameCache: {},
        getConfigNameMap: function(e) {
            var t = this.configNameCache,
            n = t[e],
            r;
            if (!n) {
                r = e.charAt(0).toUpperCase() + e.substr(1);
                n = t[e] = {
                    internal: e,
                    initialized: "_is" + r + "Initialized",
                    apply: "apply" + r,
                    update: "update" + r,
                    set: "set" + r,
                    get: "get" + r,
                    doSet: "doSet" + r,
                    changeEvent: e.toLowerCase() + "change"
                }
            }
            return n
        }
    });
    e.registerPreprocessor("extend",
    function(e, t, n) {
        var r = Ext.Base,
        i = r.prototype,
        s = t.extend,
        o, u, a;
        delete t.extend;
        if (s && s !== Object) {
            o = s
        } else {
            o = r
        }
        u = o.prototype;
        if (!o.$isClass) {
            for (a in i) {
                if (!u[a]) {
                    u[a] = i[a]
                }
            }
        }
        e.extend(o);
        e.triggerExtended.apply(e, arguments);
        if (t.onClassExtended) {
            e.onExtended(t.onClassExtended, e);
            delete t.onClassExtended
        }
    },
    true);
    e.registerPreprocessor("statics",
    function(e, t) {
        e.addStatics(t.statics);
        delete t.statics
    });
    e.registerPreprocessor("inheritableStatics",
    function(e, t) {
        e.addInheritableStatics(t.inheritableStatics);
        delete t.inheritableStatics
    });
    e.registerPreprocessor("config",
    function(t, n) {
        var r = n.config,
        i = t.prototype;
        delete n.config;
        Ext.Object.each(r,
        function(t, r) {
            var s = e.getConfigNameMap(t),
            o = s.internal,
            u = s.initialized,
            a = s.apply,
            f = s.update,
            h = s.set,
            p = s.get,
            d = h in i || n.hasOwnProperty(h),
            v = a in i || n.hasOwnProperty(a),
            m = f in i || n.hasOwnProperty(f),
            g,
            y;
            if (r === null || !d && !v && !m) {
                i[o] = r;
                i[u] = true
            } else {
                i[u] = false
            }
            if (!d) {
                n[h] = function(e) {
                    var t = this[o],
                    n = this[a],
                    r = this[f];
                    if (!this[u]) {
                        this[u] = true
                    }
                    if (n) {
                        e = n.call(this, e, t)
                    }
                    if (typeof e != "undefined") {
                        this[o] = e;
                        if (r && e !== t) {
                            r.call(this, e, t)
                        }
                    }
                    return this
                }
            }
            if (! (p in i) || n.hasOwnProperty(p)) {
                y = n[p] || false;
                if (y) {
                    g = function() {
                        return y.apply(this, arguments)
                    }
                } else {
                    g = function() {
                        return this[o]
                    }
                }
                n[p] = function() {
                    var e;
                    if (!this[u]) {
                        this[u] = true;
                        this[h](this.config[t])
                    }
                    e = this[p];
                    if ("$previous" in e) {
                        e.$previous = g
                    } else {
                        this[p] = g
                    }
                    return g.apply(this, arguments)
                }
            }
        });
        t.addConfig(r, true)
    });
    e.registerPreprocessor("mixins",
    function(e, t, n) {
        var r = t.mixins,
        i, s, o, u;
        delete t.mixins;
        Ext.Function.interceptBefore(n, "onCreated",
        function() {
            if (r instanceof Array) {
                for (o = 0, u = r.length; o < u; o++) {
                    s = r[o];
                    i = s.prototype.mixinId || s.$className;
                    e.mixin(i, s)
                }
            } else {
                for (var t in r) {
                    if (r.hasOwnProperty(t)) {
                        e.mixin(t, r[t])
                    }
                }
            }
        })
    });
    Ext.extend = function(t, n, r) {
        if (arguments.length === 2 && Ext.isObject(n)) {
            r = n;
            n = t;
            t = null
        }
        var i;
        if (!n) {
            throw new Error("[Ext.extend] Attempting to extend from a class which has not been loaded on the page.")
        }
        r.extend = n;
        r.preprocessors = ["extend", "statics", "inheritableStatics", "mixins", "config"];
        if (t) {
            i = new e(t, r);
            i.prototype.constructor = t
        } else {
            i = new e(r)
        }
        i.prototype.override = function(e) {
            for (var t in e) {
                if (e.hasOwnProperty(t)) {
                    this[t] = e[t]
                }
            }
        };
        return i
    }
})(); (function(e, t, n, r, i) {
    function s() {
        function e() {
            return this.constructor.apply(this, arguments) || null
        }
        return e
    }
    var o = Ext.ClassManager = {
        classes: {},
        existCache: {},
        namespaceRewrites: [{
            from: "Ext.",
            to: Ext
        }],
        maps: {
            alternateToName: {},
            aliasToName: {},
            nameToAliases: {},
            nameToAlternates: {}
        },
        enableNamespaceParseCache: true,
        namespaceParseCache: {},
        instantiators: [],
        isCreated: function(e) {
            var t = this.existCache,
            n, r, s, o, u;
            if (this.classes[e] || t[e]) {
                return true
            }
            o = i;
            u = this.parseNamespace(e);
            for (n = 0, r = u.length; n < r; n++) {
                s = u[n];
                if (typeof s != "string") {
                    o = s
                } else {
                    if (!o || !o[s]) {
                        return false
                    }
                    o = o[s]
                }
            }
            t[e] = true;
            this.triggerCreated(e);
            return true
        },
        createdListeners: [],
        nameCreatedListeners: {},
        triggerCreated: function(e) {
            var t = this.createdListeners,
            n = this.nameCreatedListeners,
            r = this.maps.nameToAlternates[e],
            i = [e],
            s,
            o,
            u,
            a,
            f,
            l;
            for (s = 0, o = t.length; s < o; s++) {
                f = t[s];
                f.fn.call(f.scope, e)
            }
            if (r) {
                i.push.apply(i, r)
            }
            for (s = 0, o = i.length; s < o; s++) {
                l = i[s];
                t = n[l];
                if (t) {
                    for (u = 0, a = t.length; u < a; u++) {
                        f = t[u];
                        f.fn.call(f.scope, l)
                    }
                    delete n[l]
                }
            }
        },
        onCreated: function(e, t, n) {
            var r = this.createdListeners,
            i = this.nameCreatedListeners,
            s = {
                fn: e,
                scope: t
            };
            if (n) {
                if (this.isCreated(n)) {
                    e.call(t, n);
                    return
                }
                if (!i[n]) {
                    i[n] = []
                }
                i[n].push(s)
            } else {
                r.push(s)
            }
        },
        parseNamespace: function(e) {
            var t = this.namespaceParseCache,
            n, r, s, o, u, a, f, l, c;
            if (this.enableNamespaceParseCache) {
                if (t.hasOwnProperty(e)) {
                    return t[e]
                }
            }
            n = [];
            r = this.namespaceRewrites;
            s = i;
            o = e;
            for (l = 0, c = r.length; l < c; l++) {
                u = r[l];
                a = u.from;
                f = u.to;
                if (o === a || o.substring(0, a.length) === a) {
                    o = o.substring(a.length);
                    if (typeof f != "string") {
                        s = f
                    } else {
                        n = n.concat(f.split("."))
                    }
                    break
                }
            }
            n.push(s);
            n = n.concat(o.split("."));
            if (this.enableNamespaceParseCache) {
                t[e] = n
            }
            return n
        },
        setNamespace: function(e, t) {
            var n = i,
            r = this.parseNamespace(e),
            s = r.length - 1,
            o = r[s],
            u,
            a;
            for (u = 0; u < s; u++) {
                a = r[u];
                if (typeof a != "string") {
                    n = a
                } else {
                    if (!n[a]) {
                        n[a] = {}
                    }
                    n = n[a]
                }
            }
            n[o] = t;
            return n[o]
        },
        createNamespaces: function() {
            var e = i,
            t, n, r, s, o, u;
            for (r = 0, o = arguments.length; r < o; r++) {
                t = this.parseNamespace(arguments[r]);
                for (s = 0, u = t.length; s < u; s++) {
                    n = t[s];
                    if (typeof n != "string") {
                        e = n
                    } else {
                        if (!e[n]) {
                            e[n] = {}
                        }
                        e = e[n]
                    }
                }
            }
            return e
        },
        set: function(e, t) {
            var n = this,
            r = n.maps,
            i = r.nameToAlternates,
            s = n.getName(t),
            o;
            n.classes[e] = n.setNamespace(e, t);
            if (s && s !== e) {
                r.alternateToName[e] = s;
                o = i[s] || (i[s] = []);
                o.push(e)
            }
            return this
        },
        get: function(e) {
            var t = this.classes,
            n, r, s, o, u;
            if (t[e]) {
                return t[e]
            }
            n = i;
            r = this.parseNamespace(e);
            for (o = 0, u = r.length; o < u; o++) {
                s = r[o];
                if (typeof s != "string") {
                    n = s
                } else {
                    if (!n || !n[s]) {
                        return null
                    }
                    n = n[s]
                }
            }
            return n
        },
        setAlias: function(e, t) {
            var n = this.maps.aliasToName,
            r = this.maps.nameToAliases,
            i;
            if (typeof e == "string") {
                i = e
            } else {
                i = this.getName(e)
            }
            if (t && n[t] !== i) {
                n[t] = i
            }
            if (!r[i]) {
                r[i] = []
            }
            if (t) {
                Ext.Array.include(r[i], t)
            }
            return this
        },
        addNameAliasMappings: function(e) {
            var t = this.maps.aliasToName,
            n = this.maps.nameToAliases,
            r, i, s, o;
            for (r in e) {
                i = n[r] || (n[r] = []);
                for (o = 0; o < e[r].length; o++) {
                    s = e[r][o];
                    if (!t[s]) {
                        t[s] = r;
                        i.push(s)
                    }
                }
            }
            return this
        },
        addNameAlternateMappings: function(e) {
            var t = this.maps.alternateToName,
            n = this.maps.nameToAlternates,
            r, i, s, o;
            for (r in e) {
                i = n[r] || (n[r] = []);
                for (o = 0; o < e[r].length; o++) {
                    s = e[r][o];
                    if (!t[s]) {
                        t[s] = r;
                        i.push(s)
                    }
                }
            }
            return this
        },
        getByAlias: function(e) {
            return this.get(this.getNameByAlias(e))
        },
        getNameByAlias: function(e) {
            return this.maps.aliasToName[e] || ""
        },
        getNameByAlternate: function(e) {
            return this.maps.alternateToName[e] || ""
        },
        getAliasesByName: function(e) {
            return this.maps.nameToAliases[e] || []
        },
        getName: function(e) {
            return e && e.$className || ""
        },
        getClass: function(e) {
            return e && e.self || null
        },
        create: function(t, n, r) {
            var i = s();
            if (typeof n == "function") {
                n = n(i)
            }
            n.$className = t;
            return new e(i, n,
            function() {
                var e = n.postprocessors || o.defaultPostprocessors,
                i = o.postprocessors,
                s = [],
                u,
                a,
                f,
                l,
                c,
                h,
                p;
                delete n.postprocessors;
                for (a = 0, f = e.length; a < f; a++) {
                    u = e[a];
                    if (typeof u == "string") {
                        u = i[u];
                        h = u.properties;
                        if (h === true) {
                            s.push(u.fn)
                        } else {
                            if (h) {
                                for (l = 0, c = h.length; l < c; l++) {
                                    p = h[l];
                                    if (n.hasOwnProperty(p)) {
                                        s.push(u.fn);
                                        break
                                    }
                                }
                            }
                        }
                    } else {
                        s.push(u)
                    }
                }
                n.postprocessors = s;
                n.createdFn = r;
                o.processCreate(t, this, n)
            })
        },
        processCreate: function(e, t, n) {
            var r = this,
            i = n.postprocessors.shift(),
            s = n.createdFn;
            if (!i) {
                if (e) {
                    r.set(e, t)
                }
                if (s) {
                    s.call(t, t)
                }
                if (e) {
                    r.triggerCreated(e)
                }
                return
            }
            if (i.call(r, e, t, n, r.processCreate) !== false) {
                r.processCreate(e, t, n)
            }
        },
        createOverride: function(e, t, n) {
            var r = this,
            i = t.override,
            s = t.requires,
            o = t.uses,
            u = t.compatibility,
            a = function() {
                var u, f;
                if (s) {
                    f = s;
                    s = null;
                    Ext.Loader.require(f, a)
                } else {
                    u = r.get(i);
                    delete t.override;
                    delete t.compatibility;
                    delete t.requires;
                    delete t.uses;
                    Ext.override(u, t);
                    r.triggerCreated(e);
                    if (o) {
                        Ext.Loader.addUsedClasses(o)
                    }
                    if (n) {
                        n.call(u)
                    }
                }
            };
            r.existCache[e] = true;
            if (!u || Ext.checkVersion(u)) {
                r.onCreated(a, r, i)
            }
            return r
        },
        instantiateByAlias: function() {
            var e = arguments[0],
            t = n.call(arguments),
            r = this.getNameByAlias(e);
            if (!r) {
                r = this.maps.aliasToName[e];
                Ext.syncRequire(r)
            }
            t[0] = r;
            return this.instantiate.apply(this, t)
        },
        instantiate: function() {
            var e = arguments[0],
            t = typeof e,
            r = n.call(arguments, 1),
            i = e,
            s,
            o;
            if (t != "function") {
                if (t != "string" && r.length === 0) {
                    r = [e];
                    e = e.xclass
                }
                o = this.get(e)
            } else {
                o = e
            }
            if (!o) {
                s = this.getNameByAlias(e);
                if (s) {
                    e = s;
                    o = this.get(e)
                }
            }
            if (!o) {
                s = this.getNameByAlternate(e);
                if (s) {
                    e = s;
                    o = this.get(e)
                }
            }
            if (!o) {
                Ext.syncRequire(e);
                o = this.get(e)
            }
            return this.getInstantiator(r.length)(o, r)
        },
        dynInstantiate: function(e, t) {
            t = r(t, true);
            t.unshift(e);
            return this.instantiate.apply(this, t)
        },
        getInstantiator: function(e) {
            var t = this.instantiators,
            n, r, i;
            n = t[e];
            if (!n) {
                r = e;
                i = [];
                for (r = 0; r < e; r++) {
                    i.push("a[" + r + "]")
                }
                n = t[e] = new Function("c", "a", "return new c(" + i.join(",") + ")")
            }
            return n
        },
        postprocessors: {},
        defaultPostprocessors: [],
        registerPostprocessor: function(e, t, n, r, i) {
            if (!r) {
                r = "last"
            }
            if (!n) {
                n = [e]
            }
            this.postprocessors[e] = {
                name: e,
                properties: n || false,
                fn: t
            };
            this.setDefaultPostprocessorPosition(e, r, i);
            return this
        },
        setDefaultPostprocessors: function(e) {
            this.defaultPostprocessors = r(e);
            return this
        },
        setDefaultPostprocessorPosition: function(e, t, n) {
            var r = this.defaultPostprocessors,
            i;
            if (typeof t == "string") {
                if (t === "first") {
                    r.unshift(e);
                    return this
                } else {
                    if (t === "last") {
                        r.push(e);
                        return this
                    }
                }
                t = t === "after" ? 1 : -1
            }
            i = Ext.Array.indexOf(r, n);
            if (i !== -1) {
                Ext.Array.splice(r, Math.max(0, i + t), 0, e)
            }
            return this
        },
        getNamesByExpression: function(e) {
            var t = this.maps.nameToAliases,
            n = [],
            r,
            i,
            s,
            o,
            u,
            a,
            f;
            if (e.indexOf("*") !== -1) {
                e = e.replace(/\*/g, "(.*?)");
                u = new RegExp("^" + e + "$");
                for (r in t) {
                    if (t.hasOwnProperty(r)) {
                        s = t[r];
                        if (r.search(u) !== -1) {
                            n.push(r)
                        } else {
                            for (a = 0, f = s.length; a < f; a++) {
                                i = s[a];
                                if (i.search(u) !== -1) {
                                    n.push(r);
                                    break
                                }
                            }
                        }
                    }
                }
            } else {
                o = this.getNameByAlias(e);
                if (o) {
                    n.push(o)
                } else {
                    o = this.getNameByAlternate(e);
                    if (o) {
                        n.push(o)
                    } else {
                        n.push(e)
                    }
                }
            }
            return n
        }
    };
    o.registerPostprocessor("alias",
    function(e, n, r) {
        var i = r.alias,
        s, o;
        for (s = 0, o = i.length; s < o; s++) {
            t = i[s];
            this.setAlias(n, t)
        }
    },
    ["xtype", "alias"]);
    o.registerPostprocessor("singleton",
    function(e, t, n, r) {
        if (n.singleton) {
            r.call(this, e, new t, n)
        } else {
            return true
        }
        return false
    });
    o.registerPostprocessor("alternateClassName",
    function(e, t, n) {
        var r = n.alternateClassName,
        i, s, o;
        if (! (r instanceof Array)) {
            r = [r]
        }
        for (i = 0, s = r.length; i < s; i++) {
            o = r[i];
            this.set(o, t)
        }
    });
    Ext.apply(Ext, {
        create: t(o, "instantiate"),
        widget: function(e, t) {
            var n = e,
            r, i, s, u;
            if (typeof n != "string") {
                t = e;
                n = t.xtype
            } else {
                t = t || {}
            }
            if (t.isComponent) {
                return t
            }
            r = "widget." + n;
            i = o.getNameByAlias(r);
            if (!i) {
                u = true
            }
            s = o.get(i);
            if (u || !s) {
                return o.instantiateByAlias(r, t)
            }
            return new s(t)
        },
        createByAlias: t(o, "instantiateByAlias"),
        define: function(e, t, n) {
            if (t.override) {
                return o.createOverride.apply(o, arguments)
            }
            return o.create.apply(o, arguments)
        },
        undefine: function(e) {
            var t = o.classes,
            n = o.maps,
            r = n.aliasToName,
            i = n.nameToAliases,
            s = n.alternateToName,
            u = n.nameToAlternates,
            a = i[e],
            f = u[e],
            l,
            c,
            h,
            p;
            delete o.namespaceParseCache[e];
            delete i[e];
            delete u[e];
            delete t[e];
            if (a) {
                for (p = a.length; p--;) {
                    delete r[a[p]]
                }
            }
            if (f) {
                for (p = f.length; p--;) {
                    delete s[f[p]]
                }
            }
            l = o.parseNamespace(e);
            c = l.length - 1;
            h = l[0];
            for (p = 1; p < c; p++) {
                h = h[l[p]];
                if (!h) {
                    return
                }
            }
            try {
                delete h[l[c]]
            } catch(d) {
                h[l[c]] = undefined
            }
        },
        getClassName: t(o, "getName"),
        getDisplayName: function(e) {
            if (e) {
                if (e.displayName) {
                    return e.displayName
                }
                if (e.$name && e.$class) {
                    return Ext.getClassName(e.$class) + "#" + e.$name
                }
                if (e.$className) {
                    return e.$className
                }
            }
            return "Anonymous"
        },
        getClass: t(o, "getClass"),
        namespace: t(o, "createNamespaces")
    });
    Ext.createWidget = Ext.widget;
    Ext.ns = Ext.namespace;
    e.registerPreprocessor("className",
    function(e, t) {
        if ("$className" in t) {
            e.$className = t.$className
        }
    },
    true, "first");
    e.registerPreprocessor("alias",
    function(e, t) {
        var n = e.prototype,
        i = r(t.xtype),
        s = r(t.alias),
        o = "widget.",
        u = o.length,
        a = Array.prototype.slice.call(n.xtypesChain || []),
        f = Ext.merge({},
        n.xtypesMap || {}),
        l,
        c,
        h,
        p;
        for (l = 0, c = s.length; l < c; l++) {
            h = s[l];
            if (h.substring(0, u) === o) {
                p = h.substring(u);
                Ext.Array.include(i, p)
            }
        }
        e.xtype = t.xtype = i[0];
        t.xtypes = i;
        for (l = 0, c = i.length; l < c; l++) {
            p = i[l];
            if (!f[p]) {
                f[p] = true;
                a.push(p)
            }
        }
        t.xtypesChain = a;
        t.xtypesMap = f;
        Ext.Function.interceptAfter(t, "onClassCreated",
        function() {
            var e = n.mixins,
            t, r;
            for (t in e) {
                if (e.hasOwnProperty(t)) {
                    r = e[t];
                    i = r.xtypes;
                    if (i) {
                        for (l = 0, c = i.length; l < c; l++) {
                            p = i[l];
                            if (!f[p]) {
                                f[p] = true;
                                a.push(p)
                            }
                        }
                    }
                }
            }
        });
        for (l = 0, c = i.length; l < c; l++) {
            p = i[l];
            Ext.Array.include(s, o + p)
        }
        t.alias = s
    },
    ["xtype", "alias"])
})(Ext.Class, Ext.Function.alias, Array.prototype.slice, Ext.Array.from, Ext.global);
if (Ext._alternatesMetadata) {
    Ext.ClassManager.addNameAlternateMappings(Ext._alternatesMetadata);
    Ext._alternatesMetadata = null
}
if (Ext._aliasMetadata) {
    Ext.ClassManager.addNameAliasMappings(Ext._aliasMetadata);
    Ext._aliasMetadata = null
}
Ext.Loader = new
function() {
    var e = this,
    t = Ext.ClassManager,
    n = Ext.Class,
    r = Ext.Function.flexSetter,
    i = Ext.Function.alias,
    s = Ext.Function.pass,
    o = Ext.Function.defer,
    u = Ext.Array.erase,
    a = ["extend", "mixins", "requires"],
    f = {},
    l = [],
    c = /\/\.\//g,
    h = /\./g,
    p = 0;
    Ext.apply(e, {
        isInHistory: f,
        history: l,
        config: {
            enabled: false,
            scriptChainDelay: false,
            disableCaching: false,
            disableCachingParam: "_dc",
            garbageCollect: false,
            paths: {
                Ext: ".",
                "Ext.ux": "wb/libs/ext/ux",
                Wb: "wb/script"
            },
            preserveScripts: true,
            scriptCharset: undefined
        },
        setConfig: function(t, n) {
            if (Ext.isObject(t) && arguments.length === 1) {
                Ext.merge(e.config, t);
                if ("paths" in t) {
                    Ext.app.collectNamespaces(t.paths)
                }
            } else {
                e.config[t] = Ext.isObject(n) ? Ext.merge(e.config[t], n) : n;
                if (t === "paths") {
                    Ext.app.collectNamespaces(n)
                }
            }
            return e
        },
        getConfig: function(t) {
            if (t) {
                return e.config[t]
            }
            return e.config
        },
        setPath: r(function(t, n) {
            e.config.paths[t] = n;
            Ext.app.namespaces[t] = true;
            p++;
            return e
        }),
        addClassPathMappings: function(t) {
            var n;
            if (p == 0) {
                e.config.paths = t
            } else {
                for (n in t) {
                    e.config.paths[n] = t[n]
                }
            }
            p++;
            return e
        },
        getPath: function(t) {
            var n = "",
            r = e.config.paths,
            i = e.getPrefix(t);
            if (i.length > 0) {
                if (i === t) {
                    return r[i]
                }
                n = r[i];
                t = t.substring(i.length + 1)
            }
            if (n.length > 0) {
                n += "/"
            }
            return n.replace(c, "/") + t.replace(h, "/") + ".js"
        },
        getPrefix: function(t) {
            var n = e.config.paths,
            r, i = "";
            if (n.hasOwnProperty(t)) {
                return t
            }
            for (r in n) {
                if (n.hasOwnProperty(r) && r + "." === t.substring(0, r.length + 1)) {
                    if (r.length > i.length) {
                        i = r
                    }
                }
            }
            return i
        },
        isAClassNameWithAKnownPrefix: function(t) {
            var n = e.getPrefix(t);
            return n !== "" && n !== t
        },
        require: function(e, t, n, r) {
            if (t) {
                t.call(n)
            }
        },
        syncRequire: function() {},
        exclude: function(t) {
            return {
                require: function(n, r, i) {
                    return e.require(n, r, i, t)
                },
                syncRequire: function(n, r, i) {
                    return e.syncRequire(n, r, i, t)
                }
            }
        },
        onReady: function(e, t, n, r) {
            var i;
            if (n !== false && Ext.onDocumentReady) {
                i = e;
                e = function() {
                    Ext.onDocumentReady(i, t, r)
                }
            }
            e.call(t)
        }
    });
    var d = [],
    v = {},
    m = {},
    g = {},
    y = {},
    b = {},
    w = [],
    E = [],
    S = {},
    x = function(e, t) {
        return t.priority - e.priority
    };
    Ext.apply(e, {
        documentHead: typeof document != "undefined" && (document.head || document.getElementsByTagName("head")[0]),
        isLoading: false,
        queue: d,
        isClassFileLoaded: v,
        isFileLoaded: m,
        readyListeners: w,
        optionalRequires: E,
        requiresMap: S,
        numPendingFiles: 0,
        numLoadedFiles: 0,
        hasFileLoadError: false,
        classNameToFilePathMap: y,
        scriptsLoading: 0,
        syncModeEnabled: false,
        scriptElements: b,
        refreshQueue: function() {
            var n = d.length,
            r, i, s, o;
            if (!n && !e.scriptsLoading) {
                return e.triggerReady()
            }
            for (r = 0; r < n; r++) {
                i = d[r];
                if (i) {
                    o = i.requires;
                    for (s = 0; s < o.length;) {
                        if (t.isCreated(o[s])) {
                            u(o, s, 1)
                        } else {
                            s++
                        }
                    }
                    if (i.requires.length === 0) {
                        u(d, r, 1);
                        i.callback.call(i.scope);
                        e.refreshQueue();
                        break
                    }
                }
            }
            return e
        },
        injectScriptElement: function(t, n, r, i, s) {
            var u = document.createElement("script"),
            a = false,
            f = e.config,
            l = function() {
                if (!a) {
                    a = true;
                    u.onload = u.onreadystatechange = u.onerror = null;
                    if (typeof f.scriptChainDelay == "number") {
                        o(n, f.scriptChainDelay, i)
                    } else {
                        n.call(i)
                    }
                    e.cleanupScriptElement(u, f.preserveScripts === false, f.garbageCollect)
                }
            },
            c = function(t) {
                o(r, 1, i);
                e.cleanupScriptElement(u, f.preserveScripts === false, f.garbageCollect)
            };
            u.type = "text/javascript";
            u.onerror = c;
            s = s || f.scriptCharset;
            if (s) {
                u.charset = s
            }
            if ("addEventListener" in u) {
                u.onload = l
            } else {
                if ("readyState" in u) {
                    u.onreadystatechange = function() {
                        if (this.readyState == "loaded" || this.readyState == "complete") {
                            l()
                        }
                    }
                } else {
                    u.onload = l
                }
            }
            u.src = t; (e.documentHead || document.getElementsByTagName("head")[0]).appendChild(u);
            return u
        },
        removeScriptElement: function(t) {
            if (b[t]) {
                e.cleanupScriptElement(b[t], true, !!e.getConfig("garbageCollect"));
                delete b[t]
            }
            return e
        },
        cleanupScriptElement: function(t, n, r) {
            var i;
            t.onload = t.onreadystatechange = t.onerror = null;
            if (n) {
                Ext.removeNode(t);
                if (r) {
                    for (i in t) {
                        try {
                            if (i != "src") {
                                t[i] = null
                            }
                            delete t[i]
                        } catch(s) {}
                    }
                }
            }
            return e
        },
        loadScript: function(t) {
            var n = e.getConfig(),
            r = typeof t == "string",
            i = r ? t: t.url,
            s = !r && t.onError,
            o = !r && t.onLoad,
            u = !r && t.scope,
            a = function() {
                e.numPendingFiles--;
                e.scriptsLoading--;
                if (s) {
                    s.call(u, "Failed loading '" + i + "', please verify that the file exists")
                }
                if (e.numPendingFiles + e.scriptsLoading === 0) {
                    e.refreshQueue()
                }
            },
            f = function() {
                e.numPendingFiles--;
                e.scriptsLoading--;
                if (o) {
                    o.call(u)
                }
                if (e.numPendingFiles + e.scriptsLoading === 0) {
                    e.refreshQueue()
                }
            },
            l;
            e.isLoading = true;
            e.numPendingFiles++;
            e.scriptsLoading++;
            l = n.disableCaching ? i + (i.indexOf("?") === -1 ? "?": "&") + n.disableCachingParam + "=" + Ext.Date.now() : i;
            b[i] = e.injectScriptElement(l, f, a)
        },
        loadScriptFile: function(t, n, r, i, s) {
            var o = e.getConfig(),
            u = t + (o.disableCaching ? "?" + o.disableCachingParam + "=" + Ext.Date.now() : ""),
            a = false,
            f,
            l,
            c,
            h = "";
            i = i || e;
            e.isLoading = true;
            if (!s) {
                c = function() {};
                b[t] = e.injectScriptElement(u, n, c, i)
            } else {
                if (typeof XMLHttpRequest != "undefined") {
                    f = new XMLHttpRequest
                } else {
                    f = new ActiveXObject("Microsoft.XMLHTTP")
                }
                try {
                    f.open("GET", u, false);
                    f.send(null)
                } catch(p) {
                    a = true
                }
                l = f.status === 1223 ? 204 : f.status === 0 && ((self.location || {}).protocol == "file:" || (self.location || {}).protocol == "ionp:") ? 200 : f.status;
                a = a || l === 0;
                if (a) {} else {
                    if (l >= 200 && l < 300 || l === 304) {
                        if (!Ext.isIE) {
                            h = "\n//@ sourceURL=" + t
                        }
                        Ext.globalEval(f.responseText + h);
                        n.call(i)
                    } else {}
                }
                f = null
            }
        },
        syncRequire: function() {
            var t = e.syncModeEnabled;
            if (!t) {
                e.syncModeEnabled = true
            }
            e.require.apply(e, arguments);
            if (!t) {
                e.syncModeEnabled = false
            }
            e.refreshQueue()
        },
        require: function(n, r, i, o) {
            var u = {},
            a = {},
            f = [],
            l = [],
            c = [],
            h = [],
            p,
            m,
            b,
            w,
            E,
            S,
            x,
            T,
            N,
            C,
            k;
            if (o) {
                o = typeof o === "string" ? [o] : o;
                for (T = 0, C = o.length; T < C; T++) {
                    E = o[T];
                    if (typeof E == "string" && E.length > 0) {
                        f = t.getNamesByExpression(E);
                        for (N = 0, k = f.length; N < k; N++) {
                            u[f[N]] = true
                        }
                    }
                }
            }
            n = typeof n === "string" ? [n] : n ? n: [];
            if (r) {
                if (r.length > 0) {
                    p = function() {
                        var e = [],
                        n,
                        i;
                        for (n = 0, i = h.length; n < i; n++) {
                            e.push(t.get(h[n]))
                        }
                        return r.apply(this, e)
                    }
                } else {
                    p = r
                }
            } else {
                p = Ext.emptyFn
            }
            i = i || Ext.global;
            for (T = 0, C = n.length; T < C; T++) {
                w = n[T];
                if (typeof w == "string" && w.length > 0) {
                    l = t.getNamesByExpression(w);
                    k = l.length;
                    for (N = 0; N < k; N++) {
                        x = l[N];
                        if (u[x] !== true) {
                            h.push(x);
                            if (!t.isCreated(x) && !a[x]) {
                                a[x] = true;
                                c.push(x)
                            }
                        }
                    }
                }
            }
            if (c.length > 0) {
                if (!e.config.enabled) {
                    throw new Error("Ext.Loader is not enabled, so dependencies cannot be resolved dynamically. Missing required class" + (c.length > 1 ? "es": "") + ": " + c.join(", "))
                }
            } else {
                p.call(i);
                return e
            }
            m = e.syncModeEnabled;
            if (!m) {
                d.push({
                    requires: c.slice(),
                    callback: p,
                    scope: i
                })
            }
            C = c.length;
            for (T = 0; T < C; T++) {
                S = c[T];
                b = e.getPath(S);
                if (m && v.hasOwnProperty(S)) {
                    if (!v[S]) {
                        e.numPendingFiles--;
                        e.removeScriptElement(b);
                        delete v[S]
                    }
                }
                if (!v.hasOwnProperty(S)) {
                    if (e.isFileLoaded[b] || g[b]) {
                        v[S] = true
                    } else {
                        g[b] = true;
                        v[S] = false;
                        e.numPendingFiles++;
                        e.loadScriptFile(b, s(e.onFileLoaded, [S, b], e), s(e.onFileLoadError, [S, b], e), e, m)
                    }
                    y[S] = b
                }
            }
            if (m) {
                p.call(i);
                if (C === 1) {
                    return t.get(S)
                }
            }
            return e
        },
        onFileLoaded: function(t, n) {
            var r = v[t];
            e.numLoadedFiles++;
            v[t] = true;
            m[n] = true;
            delete g[n];
            if (!r) {
                e.numPendingFiles--
            }
            if (e.numPendingFiles === 0) {
                e.refreshQueue()
            }
        },
        onFileLoadError: function(t, n, r, i) {
            e.numPendingFiles--;
            e.hasFileLoadError = true
        },
        addUsedClasses: function(t) {
            var n, r, i;
            if (t) {
                t = typeof t == "string" ? [t] : t;
                for (r = 0, i = t.length; r < i; r++) {
                    n = t[r];
                    if (typeof n == "string" && !Ext.Array.contains(E, n)) {
                        E.push(n)
                    }
                }
            }
            return e
        },
        triggerReady: function() {
            var t, n = E;
            if (e.isLoading) {
                e.isLoading = false;
                if (n.length !== 0) {
                    n = n.slice();
                    E.length = 0;
                    e.require(n, e.triggerReady, e);
                    return e
                }
            }
            Ext.Array.sort(w, x);
            while (w.length && !e.isLoading) {
                t = w.shift();
                t.fn.call(t.scope)
            }
            return e
        },
        onReady: function(t, n, r, i) {
            var s;
            if (r !== false && Ext.onDocumentReady) {
                s = t;
                t = function() {
                    Ext.onDocumentReady(s, n, i)
                }
            }
            if (!e.isLoading) {
                t.call(n)
            } else {
                w.push({
                    fn: t,
                    scope: n,
                    priority: i && i.priority || 0
                })
            }
        },
        historyPush: function(t) {
            if (t && v.hasOwnProperty(t) && !f[t]) {
                f[t] = true;
                l.push(t)
            }
            return e
        }
    });
    Ext.disableCacheBuster = function(e, t) {
        var n = new Date;
        n.setTime(n.getTime() + (e ? 10 * 365 : -1) * 24 * 60 * 60 * 1e3);
        n = n.toGMTString();
        document.cookie = "ext-cache=1; expires=" + n + "; path=" + (t || "/")
    };
    Ext.require = i(e, "require");
    Ext.syncRequire = i(e, "syncRequire");
    Ext.exclude = i(e, "exclude");
    Ext.onReady = function(t, n, r) {
        e.onReady(t, n, true, r)
    };
    n.registerPreprocessor("loader",
    function(n, r, i, s) {
        var o = this,
        u = [],
        f,
        l = t.getName(n),
        c,
        h,
        p,
        d,
        v,
        m,
        g,
        y,
        b;
        for (c = 0, p = a.length; c < p; c++) {
            m = a[c];
            if (r.hasOwnProperty(m)) {
                g = r[m];
                if (typeof g == "string") {
                    u.push(g)
                } else {
                    if (g instanceof Array) {
                        for (h = 0, d = g.length; h < d; h++) {
                            v = g[h];
                            if (typeof v == "string") {
                                u.push(v)
                            }
                        }
                    } else {
                        if (typeof g != "function") {
                            for (h in g) {
                                if (g.hasOwnProperty(h)) {
                                    v = g[h];
                                    if (typeof v == "string") {
                                        u.push(v)
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if (u.length === 0) {
            return
        }
        e.require(u,
        function() {
            for (c = 0, p = a.length; c < p; c++) {
                m = a[c];
                if (r.hasOwnProperty(m)) {
                    g = r[m];
                    if (typeof g == "string") {
                        r[m] = t.get(g)
                    } else {
                        if (g instanceof Array) {
                            for (h = 0, d = g.length; h < d; h++) {
                                v = g[h];
                                if (typeof v == "string") {
                                    r[m][h] = t.get(v)
                                }
                            }
                        } else {
                            if (typeof g != "function") {
                                for (var e in g) {
                                    if (g.hasOwnProperty(e)) {
                                        v = g[e];
                                        if (typeof v == "string") {
                                            r[m][e] = t.get(v)
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            s.call(o, n, r, i)
        });
        return false
    },
    true, "after", "className");
    t.registerPostprocessor("uses",
    function(t, n, r) {
        var i = r.uses;
        if (i) {
            e.addUsedClasses(i)
        }
    });
    t.onCreated(e.historyPush)
};
if (Ext._classPathMetadata) {
    Ext.Loader.addClassPathMappings(Ext._classPathMetadata);
    Ext._classPathMetadata = null
} (function() {
    var e = document.getElementsByTagName("script"),
    t = e[e.length - 1],
    n = t.src,
    r = n.substring(0, n.lastIndexOf("/") + 1),
    i = Ext.Loader;
    i.setConfig({
        enabled: true,
        disableCaching: true,
        paths: {
            Ext: r + "src"
        }
    })
})();
Ext._endTime = (new Date).getTime();
if (Ext._beforereadyhandler) {
    Ext._beforereadyhandler()
}
Ext.Error = Ext.extend(Error, {
    statics: {
        ignore: false,
        raise: function(e) {
            e = e || {};
            if (Ext.isString(e)) {
                e = {
                    msg: e
                }
            }
            var t = this.raise.caller,
            n;
            if (t) {
                if (t.$name) {
                    e.sourceMethod = t.$name
                }
                if (t.$owner) {
                    e.sourceClass = t.$owner.$className
                }
            }
            if (Ext.Error.handle(e) !== true) {
                n = Ext.Error.prototype.toString.call(e);
                Ext.log({
                    msg: n,
                    level: "error",
                    dump: e,
                    stack: true
                });
                throw new Ext.Error(e)
            }
        },
        handle: function() {
            return Ext.Error.ignore
        }
    },
    name: "Ext.Error",
    constructor: function(e) {
        if (Ext.isString(e)) {
            e = {
                msg: e
            }
        }
        var t = this;
        Ext.apply(t, e);
        t.message = t.message || t.msg
    },
    toString: function() {
        var e = this,
        t = e.sourceClass ? e.sourceClass: "",
        n = e.sourceMethod ? "." + e.sourceMethod + "(): ": "",
        r = e.msg || "(No description provided)";
        return t + n + r
    }
});
Ext.deprecated = function(e) {
    return Ext.emptyFn
};
Ext.JSON = new
function() {
    var me = this,
    encodingFunction, decodingFunction, useNative = null,
    useHasOwn = !!{}.hasOwnProperty,
    isNative = function() {
        if (useNative === null) {
            useNative = Ext.USE_NATIVE_JSON && window.JSON && JSON.toString() == "[object JSON]"
        }
        return useNative
    },
    doDecode = function(json) {
        return eval("(" + json + ")")
    },
    doEncode = function(e, t) {
        if (e === null || e === undefined) {
            return "null"
        } else {
            if (Ext.isDate(e)) {
                return Ext.JSON.encodeDate(e)
            } else {
                if (Ext.isString(e)) {
                    return Ext.JSON.encodeString(e)
                } else {
                    if (typeof e == "number") {
                        return isFinite(e) ? String(e) : "null"
                    } else {
                        if (Ext.isBoolean(e)) {
                            return String(e)
                        } else {
                            if (e.toJSON) {
                                return e.toJSON()
                            } else {
                                if (Ext.isArray(e)) {
                                    return encodeArray(e, t)
                                } else {
                                    if (Ext.isObject(e)) {
                                        return encodeObject(e, t)
                                    } else {
                                        if (typeof e === "function") {
                                            return "null"
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return "undefined"
    },
    encodeString = function(e) {
        var t, n, r, i, s = 0,
        o = e.length;
        if (o === 0) {
            return '""'
        }
        i = '"';
        for (n = 0; n < o; n++) {
            t = s;
            s = e.charAt(n);
            switch (s) {
            case "\\":
            case '"':
                i += "\\";
                i += s;
                break;
            case "/":
                if (t == "<") {
                    i += "\\"
                }
                i += s;
                break;
            case "\b":
                i += "\\b";
                break;
            case "	":
                i += "\\t";
                break;
            case "\n":
                i += "\\n";
                break;
            case "\f":
                i += "\\f";
                break;
            case "\r":
                i += "\\r";
                break;
            case "":
                i += "\\u000b";
                break;
            default:
                if (s < " " || s >= "" && s < "" || s >= "" && s < "") {
                    i += "\\u" + ("0000" + e.charCodeAt(n).toString(16)).slice( - 4)
                } else {
                    i += s
                }
            }
        }
        i += '"';
        return i
    },
    encodeArray = function(e, t) {
        var n = ["[", ""],
        r = e.length,
        i;
        for (i = 0; i < r; i += 1) {
            n.push(Ext.JSON.encodeValue(e[i]), ",")
        }
        n[n.length - 1] = "]";
        return n.join("")
    },
    encodeObject = function(e, t) {
        var n = ["{", ""],
        r,
        i;
        for (r in e) {
            i = e[r];
            if (!useHasOwn || e.hasOwnProperty(r)) {
                if (typeof i === "function" || i === undefined) {
                    continue
                }
                n.push(Ext.JSON.encodeValue(r), ":", Ext.JSON.encodeValue(i), ",")
            }
        }
        n[n.length - 1] = "}";
        return n.join("")
    };
    me.encodeString = encodeString;
    me.encodeValue = doEncode;
    me.encodeDate = function(e) {
        return Ext.Date.format(e, '"Y-m-d H:i:s.u"')
    };
    me.encode = function(e) {
        if (!encodingFunction) {
            encodingFunction = isNative() ? JSON.stringify: me.encodeValue
        }
        return encodingFunction(e)
    };
    me.decode = function(e, t) {
        if (!decodingFunction) {
            decodingFunction = isNative() ? JSON.parse: doDecode
        }
        try {
            return decodingFunction(e)
        } catch(n) {
            if (t === true) {
                return null
            }
            Ext.Error.raise({
                sourceClass: "Ext.JSON",
                sourceMethod: "decode",
                msg: "You're trying to decode an invalid JSON String: " + e
            })
        }
    }
};
Ext.encode = Ext.JSON.encode;
Ext.decode = Ext.JSON.decode;
Ext.apply(Ext, {
    userAgent: navigator.userAgent.toLowerCase(),
    cache: {},
    idSeed: 1e3,
    windowId: "ext-window",
    documentId: "ext-document",
    isReady: false,
    enableGarbageCollector: true,
    enableListenerCollection: true,
    rootHierarchyState: {},
    addCacheEntry: function(e, t, n) {
        n = n || t.dom;
        var r = Ext.cache,
        i = e || t && t.id || n.id,
        s = r[i] || (r[i] = {
            data: {},
            events: {},
            dom: n,
            skipGarbageCollection: !!(n.getElementById || n.navigator)
        });
        if (t) {
            t.$cache = s;
            s.el = t
        }
        return s
    },
    updateCacheEntry: function(e, t) {
        var n = e.dom;
        if (t !== n) {
            Ext.EventManager.removeAll(n)
        }
        e.dom = t;
        if (e.el) {
            e.el.dom = t
        }
        return e
    },
    id: function(e, t) {
        var n = this,
        r = "";
        e = Ext.getDom(e, true) || {};
        if (e === document) {
            e.id = n.documentId
        } else {
            if (e === window) {
                e.id = n.windowId
            }
        }
        if (!e.id) {
            if (n.isSandboxed) {
                r = Ext.sandboxName.toLowerCase() + "-"
            }
            e.id = r + (t || "ext-gen") + ++Ext.idSeed
        }
        return e.id
    },
    escapeId: function() {
        var e = /^[a-zA-Z_][a-zA-Z0-9_\-]*$/i,
        t = /([\W]{1})/g,
        n = /^(\d)/g,
        r = function(e, t) {
            return "\\" + t
        },
        i = function(e, t) {
            return "\\00" + t.charCodeAt(0).toString(16) + " "
        };
        return function(s) {
            return e.test(s) ? s: s.replace(t, r).replace(n, i)
        }
    } (),
    getBody: function() {
        var e;
        return function() {
            return e || (e = Ext.get(document.body))
        }
    } (),
    getHead: function() {
        var e;
        return function() {
            return e || (e = Ext.get(document.getElementsByTagName("head")[0]))
        }
    } (),
    getDoc: function() {
        var e;
        return function() {
            return e || (e = Ext.get(document))
        }
    } (),
    getOrientation: function() {
        return window.innerHeight > window.innerWidth ? "portrait": "landscape"
    },
    destroy: function() {
        var e = arguments.length,
        t, n;
        for (t = 0; t < e; t++) {
            n = arguments[t];
            if (n) {
                if (Ext.isArray(n)) {
                    this.destroy.apply(this, n)
                } else {
                    if (n.isStore) {
                        n.destroyStore()
                    } else {
                        if (Ext.isFunction(n.destroy)) {
                            n.destroy()
                        } else {
                            if (n.dom) {
                                n.remove()
                            }
                        }
                    }
                }
            }
        }
    },
    callback: function(e, t, n, r) {
        var i, s;
        if (Ext.isFunction(e)) {
            i = e
        } else {
            if (t && Ext.isString(e)) {
                i = t[e]
            }
        }
        if (i) {
            n = n || [];
            t = t || window;
            if (r) {
                Ext.defer(i, r, t, n)
            } else {
                s = i.apply(t, n)
            }
        }
        return s
    },
    resolveMethod: function(e, t) {
        if (Ext.isFunction(e)) {
            return e
        }
        return t[e]
    },
    htmlEncode: function(e) {
        return Ext.String.htmlEncode(e)
    },
    htmlDecode: function(e) {
        return Ext.String.htmlDecode(e)
    },
    urlAppend: function(e, t) {
        return Ext.String.urlAppend(e, t)
    },
    splitAndUnescape: function() {
        var e = {};
        return function(t, n) {
            if (!t) {
                return []
            } else {
                if (!n) {
                    return [t]
                }
            }
            var r = e[n] || (e[n] = new RegExp("\\\\" + n, "g")),
            i = [],
            s,
            o;
            s = t.split(n);
            while ((o = s.shift()) !== undefined) {
                while (o.charAt(o.length - 1) === "\\" && s.length > 0) {
                    o = o + n + s.shift()
                }
                o = o.replace(r, n);
                i.push(o)
            }
            return i
        }
    } ()
});
Ext.ns = Ext.namespace;
window.undefined = window.undefined; (function() {
    var e = function(e) {
        return e.test(Ext.userAgent)
    },
    t = document.compatMode == "CSS1Compat",
    n = function(e, t) {
        var n;
        return e && (n = t.exec(Ext.userAgent)) ? parseFloat(n[1]) : 0
    },
    r = document.documentMode,
    i = e(/opera/),
    s = i && e(/version\/10\.5/),
    o = e(/\bchrome\b/),
    u = e(/webkit/),
    a = !o && e(/safari/),
    f = a && e(/applewebkit\/4/),
    l = a && e(/version\/3/),
    c = a && e(/version\/4/),
    h = a && e(/version\/5\.0/),
    p = a && e(/version\/5/),
    d = !i && (e(/msie/) || e(/trident/)),
    v = d && (e(/msie 7/) && r != 8 && r != 9 && r != 10 || r == 7),
    m = d && (e(/msie 8/) && r != 7 && r != 9 && r != 10 || r == 8),
    g = d && (e(/msie 9/) && r != 7 && r != 8 && r != 10 || r == 9),
    y = d && (e(/msie 10/) && r != 7 && r != 8 && r != 9 || r == 10),
    b = d && (e(/trident\/7\.0/) && r != 7 && r != 8 && r != 9 && r != 10 || r == 11),
    w = d && e(/msie 6/),
    E = !u && !d && e(/gecko/),
    S = E && e(/rv:1\.9/),
    x = E && e(/rv:2\.0/),
    T = E && e(/rv:5\./),
    N = E && e(/rv:10\./),
    C = S && e(/rv:1\.9\.0/),
    k = S && e(/rv:1\.9\.1/),
    L = S && e(/rv:1\.9\.2/),
    A = e(/windows|win32/),
    O = e(/macintosh|mac os x/),
    M = e(/linux/),
    _ = null,
    D = n(true, /\bchrome\/(\d+\.\d+)/),
    P = n(true, /\bfirefox\/(\d+\.\d+)/),
    H = n(d, /msie (\d+\.\d+)/),
    B = n(i, /version\/(\d+\.\d+)/),
    j = n(a, /version\/(\d+\.\d+)/),
    F = n(u, /webkit\/(\d+\.\d+)/),
    I = /^https/i.test(window.location.protocol),
    q;
    try {
        document.execCommand("BackgroundImageCache", false, true)
    } catch(R) {}
    q = function() {};
    q.info = q.warn = q.error = Ext.emptyFn;
    Ext.setVersion("ext", "4.2.3.1477");
    Ext.setVersion("extjs", "4.2.3.1477");
    Ext.apply(Ext, {
        SSL_SECURE_URL: I && d ? "javascript:''": "about:blank",
        plainTableCls: Ext.buildSettings.baseCSSPrefix + "table-plain",
        plainListCls: Ext.buildSettings.baseCSSPrefix + "list-plain",
        enableNestedListenerRemoval: false,
        USE_NATIVE_JSON: false,
        getDom: function(e, t) {
            if (!e || !document) {
                return null
            }
            if (e.dom) {
                return e.dom
            } else {
                if (typeof e == "string") {
                    var n = Ext.getElementById(e);
                    if (n && d && t) {
                        if (e == n.getAttribute("id")) {
                            return n
                        } else {
                            return null
                        }
                    }
                    return n
                } else {
                    return e
                }
            }
        },
        removeNode: w || v || m ?
        function() {
            var e;
            return function(t) {
                if (t && t.tagName.toUpperCase() != "BODY") {
                    Ext.enableNestedListenerRemoval ? Ext.EventManager.purgeElement(t) : Ext.EventManager.removeAll(t);
                    var n = Ext.cache,
                    r = t.id;
                    if (n[r]) {
                        delete n[r].dom;
                        delete n[r]
                    }
                    if (m && t.parentNode) {
                        t.parentNode.removeChild(t)
                    }
                    e = e || document.createElement("div");
                    e.appendChild(t);
                    e.innerHTML = ""
                }
            }
        } () : function(e) {
            if (e && e.parentNode && e.tagName.toUpperCase() != "BODY") {
                Ext.enableNestedListenerRemoval ? Ext.EventManager.purgeElement(e) : Ext.EventManager.removeAll(e);
                var t = Ext.cache,
                n = e.id;
                if (t[n]) {
                    delete t[n].dom;
                    delete t[n]
                }
                e.parentNode.removeChild(e)
            }
        },
        isStrict: t,
        isIEQuirks: d && !t && (w || v || m || g),
        isOpera: i,
        isOpera10_5: s,
        isWebKit: u,
        isChrome: o,
        isSafari: a,
        isSafari3: l,
        isSafari4: c,
        isSafari5: p,
        isSafari5_0: h,
        isSafari2: f,
        isIE: d,
        isIE6: w,
        isIE7: v,
        isIE7m: w || v,
        isIE7p: d && !w,
        isIE8: m,
        isIE8m: w || v || m,
        isIE8p: d && !(w || v),
        isIE9: g,
        isIE9m: w || v || m || g,
        isIE9p: d && !(w || v || m),
        isIE10: y,
        isIE10m: w || v || m || g || y,
        isIE10p: d && !(w || v || m || g),
        isIE11: b,
        isIE11m: w || v || m || g || y || b,
        isIE11p: d && !(w || v || m || g || y),
        isGecko: E,
        isGecko3: S,
        isGecko4: x,
        isGecko5: T,
        isGecko10: N,
        isFF3_0: C,
        isFF3_5: k,
        isFF3_6: L,
        isFF4: 4 <= P && P < 5,
        isFF5: 5 <= P && P < 6,
        isFF10: 10 <= P && P < 11,
        isLinux: M,
        isWindows: A,
        isMac: O,
        chromeVersion: D,
        firefoxVersion: P,
        ieVersion: H,
        operaVersion: B,
        safariVersion: j,
        webKitVersion: F,
        isSecure: I,
        BLANK_IMAGE_URL: w || v ? "wb/images/app/s.gif": "data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==",
        value: function(e, t, n) {
            return Ext.isEmpty(e, n) ? t: e
        },
        escapeRe: function(e) {
            return e.replace(/([-.*+?\^${}()|\[\]\/\\])/g, "\\$1")
        },
        addBehaviors: function(e) {
            if (!Ext.isReady) {
                Ext.onReady(function() {
                    Ext.addBehaviors(e)
                })
            } else {
                var t = {},
                n, r, i;
                for (r in e) {
                    if ((n = r.split("@"))[1]) {
                        i = n[0];
                        if (!t[i]) {
                            t[i] = Ext.select(i)
                        }
                        t[i].on(n[1], e[r])
                    }
                }
                t = null
            }
        },
        getScrollbarSize: function(e) {
            if (!Ext.isReady) {
                return {}
            }
            if (e || !_) {
                var t = document.body,
                n = document.createElement("div");
                n.style.width = n.style.height = "100px";
                n.style.overflow = "scroll";
                n.style.position = "absolute";
                t.appendChild(n);
                _ = {
                    width: n.offsetWidth - n.clientWidth,
                    height: n.offsetHeight - n.clientHeight
                };
                t.removeChild(n)
            }
            return _
        },
        getScrollBarWidth: function(e) {
            var t = Ext.getScrollbarSize(e);
            return t.width + 2
        },
        copyTo: function(e, t, n, r) {
            if (typeof n == "string") {
                n = n.split(/[,;\s]/)
            }
            var i, s = n ? n.length: 0,
            o;
            for (i = 0; i < s; i++) {
                o = n[i];
                if (r || t.hasOwnProperty(o)) {
                    e[o] = t[o]
                }
            }
            return e
        },
        destroyMembers: function(e) {
            for (var t = 1,
            n = arguments,
            r = n.length; t < r; t++) {
                Ext.destroy(e[n[t]]);
                delete e[n[t]]
            }
        },
        log: q,
        partition: function(e, t) {
            var n = [[], []],
            r,
            i,
            s = e.length;
            for (r = 0; r < s; r++) {
                i = e[r];
                n[t && t(i, r, e) || !t && i ? 0 : 1].push(i)
            }
            return n
        },
        invoke: function(e, t) {
            var n = [],
            r = Array.prototype.slice.call(arguments, 2),
            i,
            s,
            o = e.length;
            for (i = 0; i < o; i++) {
                s = e[i];
                if (s && typeof s[t] == "function") {
                    n.push(s[t].apply(s, r))
                } else {
                    n.push(undefined)
                }
            }
            return n
        },
        zip: function() {
            var e = Ext.partition(arguments,
            function(e) {
                return typeof e != "function"
            }),
            t = e[0],
            n = e[1][0],
            r = Ext.max(Ext.pluck(t, "length")),
            i = [],
            s,
            o,
            u;
            for (s = 0; s < r; s++) {
                i[s] = [];
                if (n) {
                    i[s] = n.apply(n, Ext.pluck(t, s))
                } else {
                    for (o = 0, u = t.length; o < u; o++) {
                        i[s].push(t[o][s])
                    }
                }
            }
            return i
        },
        toSentence: function(e, t) {
            var n = e.length,
            r, i;
            if (n <= 1) {
                return e[0]
            } else {
                r = e.slice(0, n - 1);
                i = e[n - 1];
                return Ext.util.Format.format("{0} {1} {2}", r.join(", "), t || "and", i)
            }
        },
        setGlyphFontFamily: function(e) {
            Ext._glyphFontFamily = e
        },
        useShims: w
    })
})();
Ext.application = function(e) {
    var t, n, r, i = function() {
        Ext.onReady(function() {
            Ext.app.Application.instance = new t
        })
    };
    if (typeof e === "string") {
        Ext.require(e,
        function() {
            t = Ext.ClassManager.get(e);
            i()
        })
    } else {
        Ext.Loader.setPath(e.name, e.appFolder || "app");
        if (n = e.paths) {
            for (r in n) {
                if (n.hasOwnProperty(r)) {
                    Ext.Loader.setPath(r, n[r])
                }
            }
        }
        e["paths processed"] = true;
        Ext.define(e.name + ".$application", Ext.apply({
            extend: "Ext.app.Application"
        },
        e),
        function() {
            t = this;
            i()
        })
    }
}; (function() {
    Ext.ns("Ext.util");
    var e = Ext.util.Format = {},
    t = /<\/?[^>]+>/gi,
    n = /(?:<script.*?>)((\n|\r|.)*?)(?:<\/script>)/ig,
    r = /\r?\n/g,
    i = /#+$/,
    s = /[\d,\.#]+/,
    o = /[^\d\.#]/g,
    u, a, f = {};
    Ext.apply(e, {
        thousandSeparator: ",",
        decimalSeparator: ".",
        currencyPrecision: 2,
        currencySign: "$",
        currencyAtEnd: false,
        undef: function(e) {
            return e !== undefined ? e: ""
        },
        defaultValue: function(e, t) {
            return e !== undefined && e !== "" ? e: t
        },
        substr: "ab".substr( - 1) != "b" ?
        function(e, t, n) {
            var r = String(e);
            return t < 0 ? r.substr(Math.max(r.length + t, 0), n) : r.substr(t, n)
        }: function(e, t, n) {
            return String(e).substr(t, n)
        },
        lowercase: function(e) {
            return String(e).toLowerCase()
        },
        uppercase: function(e) {
            return String(e).toUpperCase()
        },
        usMoney: function(t) {
            return e.currency(t, "$", 2)
        },
        currency: function(t, n, r, i) {
            var s = "",
            o = ",0",
            u = 0;
            t = t - 0;
            if (t < 0) {
                t = -t;
                s = "-"
            }
            r = Ext.isDefined(r) ? r: e.currencyPrecision;
            o += r > 0 ? ".": "";
            for (; u < r; u++) {
                o += "0"
            }
            t = e.number(t, o);
            if ((i || e.currencyAtEnd) === true) {
                return Ext.String.format("{0}{1}{2}", s, t, n || e.currencySign)
            } else {
                return Ext.String.format("{0}{1}{2}", s, n || e.currencySign, t)
            }
        },
        date: function(e, t) {
            if (!e) {
                return ""
            }
            if (!Ext.isDate(e)) {
                e = new Date(Date.parse(e))
            }
            return Ext.Date.dateFormat(e, t || Ext.Date.defaultFormat)
        },
        dateRenderer: function(t) {
            return function(n) {
                return e.date(n, t)
            }
        },
        stripTags: function(e) {
            return ! e ? e: String(e).replace(t, "")
        },
        stripScripts: function(e) {
            return ! e ? e: String(e).replace(n, "")
        },
        fileSize: function() {
            var e = 1024,
            t = 1048576,
            n = 1073741824;
            return function(r) {
                var i;
                if (r < e) {
                    if (r === 1) {
                        i = "1 byte"
                    } else {
                        i = r + " bytes"
                    }
                } else {
                    if (r < t) {
                        i = Math.round(r * 10 / e) / 10 + " KB"
                    } else {
                        if (r < n) {
                            i = Math.round(r * 10 / t) / 10 + " MB"
                        } else {
                            i = Math.round(r * 10 / n) / 10 + " GB"
                        }
                    }
                }
                return i
            }
        } (),
        math: function() {
            var e = {};
            return function(t, n) {
                if (!e[n]) {
                    e[n] = Ext.functionFactory("v", "return v " + n + ";")
                }
                return e[n](t)
            }
        } (),
        round: function(e, t) {
            var n = Number(e);
            if (typeof t == "number") {
                t = Math.pow(10, t);
                n = Math.round(e * t) / t
            }
            return n
        },
        number: function(t, n) {
            if (!n) {
                return t
            }
            var r = f[n];
            if (!r) {
                var c = n,
                p = e.thousandSeparator,
                v = e.decimalSeparator,
                m = 0,
                y = "",
                w, E, S, x, T, N, C;
                if (n.substr(n.length - 2) == "/i") {
                    if (!u || a !== v) {
                        u = new RegExp("[^\\d\\" + v + "]", "g");
                        a = v
                    }
                    n = n.substr(0, n.length - 2);
                    w = n.indexOf(p) !== -1;
                    E = n.replace(u, "").split(v)
                } else {
                    w = n.indexOf(",") != -1;
                    E = n.replace(o, "").split(".")
                }
                S = n.replace(s, "");
                if (E.length > 2) {} else {
                    if (E.length === 2) {
                        m = E[1].length;
                        T = E[1].match(i);
                        if (T) {
                            C = T[0].length;
                            y = 'trailingZeroes=new RegExp(Ext.String.escapeRegex(utilFormat.decimalSeparator) + "*0{0,' + C + '}$")'
                        }
                    }
                }
                N = ["var utilFormat=Ext.util.Format,extNumber=Ext.Number,neg,absVal,fnum,parts" + (w ? ",thousandSeparator,thousands=[],j,n,i": "") + (S ? ',formatString="' + n + '",formatPattern=/[\\d,\\.#]+/': "") + ',trailingZeroes;return function(v){if(typeof v!=="number"&&isNaN(v=extNumber.from(v,NaN)))return"";neg=v<0;', "absVal=Math.abs(v);", "fnum=Ext.Number.toFixed(absVal, " + m + ");", y, ";"];
                if (w) {
                    if (m) {
                        N[N.length] = 'parts=fnum.split(".");';
                        N[N.length] = "fnum=parts[0];"
                    }
                    N[N.length] = "if(absVal>=1000) {";
                    N[N.length] = "thousandSeparator=utilFormat.thousandSeparator;thousands.length=0;j=fnum.length;n=fnum.length%3||3;for(i=0;i<j;i+=n){if(i!==0){n=3;}thousands[thousands.length]=fnum.substr(i,n);}fnum=thousands.join(thousandSeparator);}";
                    if (m) {
                        N[N.length] = "fnum += utilFormat.decimalSeparator+parts[1];"
                    }
                } else {
                    if (m) {
                        N[N.length] = 'if(utilFormat.decimalSeparator!=="."){parts=fnum.split(".");fnum=parts[0]+utilFormat.decimalSeparator+parts[1];}'
                    }
                }
                N[N.length] = 'if(neg&&fnum!=="' + (m ? "0." + Ext.String.repeat("0", m) : "0") + '")fnum="-"+fnum;';
                if (T) {
                    N[N.length] = 'fnum=fnum.replace(trailingZeroes,"");'
                }
                N[N.length] = "return ";
                if (S) {
                    N[N.length] = "formatString.replace(formatPattern, fnum);"
                } else {
                    N[N.length] = "fnum;"
                }
                N[N.length] = "};";
                r = f[c] = Ext.functionFactory("Ext", N.join(""))(Ext)
            }
            return r(t)
        },
        numberRenderer: function(t) {
            return function(n) {
                return e.number(n, t)
            }
        },
        attributes: function(e) {
            if (typeof e === "object") {
                var t = [],
                n;
                for (n in e) {
                    if (e.hasOwnProperty(n)) {
                        t.push(n, '="', n === "style" ? Ext.DomHelper.generateStyles(e[n], null, true) : Ext.htmlEncode(e[n]), '"')
                    }
                }
                e = t.join("")
            }
            return e || ""
        },
        plural: function(e, t, n) {
            return e + " " + (e == 1 ? t: n ? n: t + "s")
        },
        nl2br: function(e) {
            return Ext.isEmpty(e) ? "": e.replace(r, "<br/>")
        },
        capitalize: Ext.String.capitalize,
        ellipsis: Ext.String.ellipsis,
        format: Ext.String.format,
        htmlDecode: Ext.String.htmlDecode,
        htmlEncode: Ext.String.htmlEncode,
        leftPad: Ext.String.leftPad,
        trim: Ext.String.trim,
        parseBox: function(e) {
            e = e || 0;
            if (typeof e === "number") {
                return {
                    top: e,
                    right: e,
                    bottom: e,
                    left: e
                }
            }
            var t = e.split(" "),
            n = t.length;
            if (n == 1) {
                t[1] = t[2] = t[3] = t[0]
            } else {
                if (n == 2) {
                    t[2] = t[0];
                    t[3] = t[1]
                } else {
                    if (n == 3) {
                        t[3] = t[1]
                    }
                }
            }
            return {
                top: parseInt(t[0], 10) || 0,
                right: parseInt(t[1], 10) || 0,
                bottom: parseInt(t[2], 10) || 0,
                left: parseInt(t[3], 10) || 0
            }
        },
        escapeRegex: function(e) {
            return e.replace(/([\-.*+?\^${}()|\[\]\/\\])/g, "\\$1")
        }
    })
})();
Ext.define("Ext.util.TaskRunner", {
    interval: 10,
    timerId: null,
    constructor: function(e) {
        var t = this;
        if (typeof e == "number") {
            t.interval = e
        } else {
            if (e) {
                Ext.apply(t, e)
            }
        }
        t.tasks = [];
        t.timerFn = Ext.Function.bind(t.onTick, t)
    },
    newTask: function(e) {
        var t = new Ext.util.TaskRunner.Task(e);
        t.manager = this;
        return t
    },
    start: function(e) {
        var t = this,
        n = Ext.Date.now();
        if (!e.pending) {
            t.tasks.push(e);
            e.pending = true
        }
        e.stopped = false;
        e.taskStartTime = n;
        e.taskRunTime = e.fireOnStart !== false ? 0 : e.taskStartTime;
        e.taskRunCount = 0;
        if (!t.firing) {
            if (e.fireOnStart !== false) {
                t.startTimer(0, n)
            } else {
                t.startTimer(e.interval, n)
            }
        }
        return e
    },
    stop: function(e) {
        if (!e.stopped) {
            e.stopped = true;
            if (e.onStop) {
                e.onStop.call(e.scope || e, e)
            }
        }
        return e
    },
    stopAll: function() {
        Ext.each(this.tasks, this.stop, this)
    },
    firing: false,
    nextExpires: 1e99,
    onTick: function() {
        var e = this,
        t = e.tasks,
        n = Ext.Date.now(),
        r = 1e99,
        i = t.length,
        s,
        o,
        u,
        a,
        f,
        l;
        e.timerId = null;
        e.firing = true;
        for (u = 0; u < i || u < (i = t.length); ++u) {
            a = t[u];
            if (! (l = a.stopped)) {
                s = a.taskRunTime + a.interval;
                if (s <= n) {
                    f = 1;
                    try {
                        f = a.run.apply(a.scope || a, a.args || [++a.taskRunCount])
                    } catch(c) {
                        try {
                            if (a.onError) {
                                f = a.onError.call(a.scope || a, a, c)
                            }
                        } catch(h) {}
                    }
                    a.taskRunTime = n;
                    if (f === false || a.taskRunCount === a.repeat) {
                        e.stop(a);
                        l = true
                    } else {
                        l = a.stopped;
                        s = n + a.interval
                    }
                }
                if (!l && a.duration && a.duration <= n - a.taskStartTime) {
                    e.stop(a);
                    l = true
                }
            }
            if (l) {
                a.pending = false;
                if (!o) {
                    o = t.slice(0, u)
                }
            } else {
                if (o) {
                    o.push(a)
                }
                if (r > s) {
                    r = s
                }
            }
        }
        if (o) {
            e.tasks = o
        }
        e.firing = false;
        if (e.tasks.length) {
            e.startTimer(r - n, Ext.Date.now())
        }
        if (e.fireIdleEvent !== false) {
            Ext.EventManager.idleEvent.fire()
        }
    },
    startTimer: function(e, t) {
        var n = this,
        r = t + e,
        i = n.timerId;
        if (i && n.nextExpires - r > n.interval) {
            clearTimeout(i);
            i = null
        }
        if (!i) {
            if (e < n.interval) {
                e = n.interval
            }
            n.timerId = setTimeout(n.timerFn, e);
            n.nextExpires = r
        }
    }
},
function() {
    var e = this,
    t = e.prototype;
    t.destroy = t.stopAll;
    Ext.util.TaskManager = Ext.TaskManager = new e;
    e.Task = new Ext.Class({
        isTask: true,
        stopped: true,
        fireOnStart: false,
        constructor: function(e) {
            Ext.apply(this, e)
        },
        restart: function(e) {
            if (e !== undefined) {
                this.interval = e
            }
            this.manager.start(this)
        },
        start: function(e) {
            if (this.stopped) {
                this.restart(e)
            }
        },
        stop: function() {
            this.manager.stop(this)
        }
    });
    t = e.Task.prototype;
    t.destroy = t.stop
});
Ext.define("Ext.util.TaskManager", {
    extend: Ext.util.TaskRunner,
    alternateClassName: ["Ext.TaskManager"],
    singleton: true
});
Ext.define("Ext.perf.Accumulator",
function() {
    function i(e, t) {
        e.sum += t;
        e.min = Math.min(e.min, t);
        e.max = Math.max(e.max, t)
    }
    function s(t) {
        var n = t ? t: r() - this.time,
        s = this,
        o = s.accum; ++o.count;
        if (!--o.depth) {
            i(o.total, n)
        }
        i(o.pure, n - s.childTime);
        e = s.parent;
        if (e) {++e.accum.childCount;
            e.childTime += n
        }
    }
    function o() {
        return {
            min: Number.MAX_VALUE,
            max: 0,
            sum: 0
        }
    }
    function u(e, t) {
        return function() {
            var n = e.enter(),
            r = t.apply(this, arguments);
            n.leave();
            return r
        }
    }
    function a(e) {
        return Math.round(e * 100) / 100
    }
    function f(e, t, n, r) {
        var i = {
            avg: 0,
            min: r.min,
            max: r.max,
            sum: 0
        };
        if (e) {
            n = n || 0;
            i.sum = r.sum - t * n;
            i.avg = i.sum / e
        }
        return i
    }
    var e = null,
    t = Ext.global.chrome,
    n, r = function() {
        r = function() {
            return (new Date).getTime()
        };
        var e, n;
        if (Ext.isChrome && t && t.Interval) {
            e = new t.Interval;
            e.start();
            r = function() {
                return e.microseconds() / 1e3
            }
        } else {
            if (window.ActiveXObject) {
                try {
                    n = new ActiveXObject("SenchaToolbox.Toolbox");
                    Ext.senchaToolbox = n;
                    r = function() {
                        return n.milliseconds
                    }
                } catch(i) {}
            } else {
                if (Date.now) {
                    r = Date.now
                }
            }
        }
        Ext.perf.getTimestamp = Ext.perf.Accumulator.getTimestamp = r;
        return r()
    };
    return {
        constructor: function(e) {
            var t = this;
            t.count = t.childCount = t.depth = t.maxDepth = 0;
            t.pure = o();
            t.total = o();
            t.name = e
        },
        statics: {
            getTimestamp: r
        },
        format: function(e) {
            if (!n) {
                n = new Ext.XTemplate(["{name} - {count} call(s)", '<tpl if="count">', '<tpl if="childCount">', " ({childCount} children)", "</tpl>", '<tpl if="depth - 1">', " ({depth} deep)", "</tpl>", '<tpl for="times">', ", {type}: {[this.time(values.sum)]} msec (", "avg={[this.time(values.sum / parent.count)]}", ")", "</tpl>", "</tpl>"].join(""), {
                    time: function(e) {
                        return Math.round(e * 100) / 100
                    }
                })
            }
            var t = this.getData(e);
            t.name = this.name;
            t.pure.type = "Pure";
            t.total.type = "Total";
            t.times = [t.pure, t.total];
            return n.apply(t)
        },
        getData: function(e) {
            var t = this;
            return {
                count: t.count,
                childCount: t.childCount,
                depth: t.maxDepth,
                pure: f(t.count, t.childCount, e, t.pure),
                total: f(t.count, t.childCount, e, t.total)
            }
        },
        enter: function() {
            var t = this,
            n = {
                accum: t,
                leave: s,
                childTime: 0,
                parent: e
            }; ++t.depth;
            if (t.maxDepth < t.depth) {
                t.maxDepth = t.depth
            }
            e = n;
            n.time = r();
            return n
        },
        monitor: function(e, t, n) {
            var r = this.enter();
            if (n) {
                e.apply(t, n)
            } else {
                e.call(t)
            }
            r.leave()
        },
        report: function() {
            Ext.log(this.format())
        },
        tap: function(e, t) {
            var n = this,
            r = typeof t == "string" ? [t] : t,
            i,
            s,
            o,
            a,
            f,
            l,
            c,
            h;
            h = function() {
                if (typeof e == "string") {
                    i = Ext.global;
                    a = e.split(".");
                    for (o = 0, f = a.length; o < f; ++o) {
                        i = i[a[o]]
                    }
                } else {
                    i = e
                }
                for (o = 0, f = r.length; o < f; ++o) {
                    l = r[o];
                    s = l.charAt(0) == "!";
                    if (s) {
                        l = l.substring(1)
                    } else {
                        s = !(l in i.prototype)
                    }
                    c = s ? i: i.prototype;
                    c[l] = u(n, c[l])
                }
            };
            Ext.ClassManager.onCreated(h, n, e);
            return n
        }
    }
} (),
function() {
    Ext.perf.getTimestamp = this.getTimestamp
});
Ext.define("Ext.perf.Monitor", {
    singleton: true,
    alternateClassName: "Ext.Perf",
    constructor: function() {
        this.accumulators = [];
        this.accumulatorsByName = {}
    },
    calibrate: function() {
        var e = new Ext.perf.Accumulator("$"),
        t = e.total,
        n = Ext.perf.Accumulator.getTimestamp,
        r = 0,
        i,
        s,
        o;
        o = n();
        do {
            i = e.enter();
            i.leave(); ++r
        } while ( t . sum < 100 );
        s = n();
        return (s - o) / r
    },
    get: function(e) {
        var t = this,
        n = t.accumulatorsByName[e];
        if (!n) {
            t.accumulatorsByName[e] = n = new Ext.perf.Accumulator(e);
            t.accumulators.push(n)
        }
        return n
    },
    enter: function(e) {
        return this.get(e).enter()
    },
    monitor: function(e, t, n) {
        this.get(e).monitor(t, n)
    },
    report: function() {
        var e = this,
        t = e.accumulators,
        n = e.calibrate();
        t.sort(function(e, t) {
            return e.name < t.name ? -1 : t.name < e.name ? 1 : 0
        });
        e.updateGC();
        Ext.log("Calibration: " + Math.round(n * 100) / 100 + " msec/sample");
        Ext.each(t,
        function(e) {
            Ext.log(e.format(n))
        })
    },
    getData: function(e) {
        var t = {},
        n = this.accumulators;
        Ext.each(n,
        function(n) {
            if (e || n.count) {
                t[n.name] = n.getData()
            }
        });
        return t
    },
    reset: function() {
        Ext.each(this.accumulators,
        function(e) {
            var t = e;
            t.count = t.childCount = t.depth = t.maxDepth = 0;
            t.pure = {
                min: Number.MAX_VALUE,
                max: 0,
                sum: 0
            };
            t.total = {
                min: Number.MAX_VALUE,
                max: 0,
                sum: 0
            }
        })
    },
    updateGC: function() {
        var e = this.accumulatorsByName.GC,
        t = Ext.senchaToolbox,
        n;
        if (e) {
            e.count = t.garbageCollectionCounter || 0;
            if (e.count) {
                n = e.pure;
                e.total.sum = n.sum = t.garbageCollectionMilliseconds;
                n.min = n.max = n.sum / e.count;
                n = e.total;
                n.min = n.max = n.sum / e.count
            }
        }
    },
    watchGC: function() {
        Ext.perf.getTimestamp();
        var e = Ext.senchaToolbox;
        if (e) {
            this.get("GC");
            e.watchGarbageCollector(false)
        }
    },
    setup: function(e) {
        if (!e) {
            e = {
                render: {
                    "Ext.AbstractComponent": "render"
                },
                layout: {
                    "Ext.layout.Context": "run"
                }
            }
        }
        this.currentConfig = e;
        var t, n, r, i, s;
        for (t in e) {
            if (e.hasOwnProperty(t)) {
                n = e[t];
                r = Ext.Perf.get(t);
                for (i in n) {
                    if (n.hasOwnProperty(i)) {
                        s = n[i];
                        r.tap(i, s)
                    }
                }
            }
        }
        this.watchGC()
    }
});
Ext.is = {
    init: function(e) {
        var t = this.platforms,
        n = t.length,
        r, i;
        e = e || window.navigator;
        for (r = 0; r < n; r++) {
            i = t[r];
            this[i.identity] = i.regex.test(e[i.property])
        }
        this.Desktop = this.Mac || this.Windows || this.Linux && !this.Android;
        this.Tablet = this.iPad;
        this.Phone = !this.Desktop && !this.Tablet;
        this.iOS = this.iPhone || this.iPad || this.iPod;
        this.Standalone = !!window.navigator.standalone
    },
    platforms: [{
        property: "platform",
        regex: /iPhone/i,
        identity: "iPhone"
    },
    {
        property: "platform",
        regex: /iPod/i,
        identity: "iPod"
    },
    {
        property: "userAgent",
        regex: /iPad/i,
        identity: "iPad"
    },
    {
        property: "userAgent",
        regex: /Blackberry/i,
        identity: "Blackberry"
    },
    {
        property: "userAgent",
        regex: /Android/i,
        identity: "Android"
    },
    {
        property: "platform",
        regex: /Mac/i,
        identity: "Mac"
    },
    {
        property: "platform",
        regex: /Win/i,
        identity: "Windows"
    },
    {
        property: "platform",
        regex: /Linux/i,
        identity: "Linux"
    }]
};
Ext.is.init(); (function() {
    function i() {
        var e = Ext.isIE6 ? "IE6": Ext.isIE7 ? "IE7": Ext.isIE8 ? "IE8": Ext.isIE9 ? "IE9": Ext.isIE10 ? "IE10": "";
        return e ? e + (Ext.isStrict ? "-strict": "-quirks") : ""
    }
    var e = function(e, t) {
        var n = e.ownerDocument.defaultView,
        r = (n ? n.getComputedStyle(e, null) : e.currentStyle) || e.style;
        return r[t]
    },
    t = {
        "IE6-quirks": [0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0],
        "IE6-strict": [0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0],
        "IE7-quirks": [0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0],
        "IE7-strict": [0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0],
        "IE8-quirks": [0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0],
        "IE8-strict": [0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0],
        "IE9-quirks": [0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0],
        "IE9-strict": [0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0],
        "IE10-quirks": [1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0],
        "IE10-strict": [1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0]
    },
    n = document,
    r = n.createElement("div");
    Ext.supports = {
        init: function() {
            var e = this,
            s = e.toRun || e.tests,
            o = s.length,
            u = [],
            a = i(),
            f,
            l,
            h,
            p = Ext.isReady;
            if (p) {
                r.innerHTML = ['<div style="height:30px;width:50px;">', '<div style="height:20px;width:20px;"></div>', "</div>", '<div style="width: 200px; height: 200px; position: relative; padding: 5px;">', '<div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></div>', "</div>", '<div style="position: absolute; left: 10%; top: 10%;"></div>', '<div style="float:left; background-color:transparent;"></div>'].join("");
                n.body.appendChild(r)
            }
            l = t[a];
            while (o--) {
                f = s[o];
                h = l && l[o];
                if (h !== undefined) {
                    e[f.identity] = h
                } else {
                    if (p || f.early) {
                        e[f.identity] = f.fn.call(e, n, r)
                    } else {
                        u.push(f)
                    }
                }
            }
            if (p) {
                n.body.removeChild(r)
            }
            e.toRun = u
        },
        PointerEvents: "pointerEvents" in document.documentElement.style,
        LocalStorage: function() {
            try {
                return "localStorage" in window && window.localStorage !== null
            } catch(e) {
                return false
            }
        } (),
        CSS3BoxShadow: "boxShadow" in document.documentElement.style || "WebkitBoxShadow" in document.documentElement.style || "MozBoxShadow" in document.documentElement.style,
        ClassList: !!document.documentElement.classList,
        OrientationChange: typeof window.orientation != "undefined" && "onorientationchange" in window,
        DeviceMotion: "ondevicemotion" in window,
        Touch: "ontouchstart" in window && !Ext.is.Desktop,
        TimeoutActualLateness: function() {
            setTimeout(function() {
                Ext.supports.TimeoutActualLateness = arguments.length !== 0
            },
            0)
        } (),
        tests: [{
            identity: "Transitions",
            fn: function(t, n) {
                var r = ["webkit", "Moz", "o", "ms", "khtml"],
                i = "TransitionEnd",
                s = [r[0] + i, "transitionend", r[2] + i, r[3] + i, r[4] + i],
                o = r.length,
                u = 0,
                f = false;
                for (; u < o; u++) {
                    if (e(n, r[u] + "TransitionProperty")) {
                        Ext.supports.CSS3Prefix = r[u];
                        Ext.supports.CSS3TransitionEnd = s[u];
                        f = true;
                        break
                    }
                }
                return f
            }
        },
        {
            identity: "RightMargin",
            fn: function(e, t) {
                var n = e.defaultView;
                return ! (n && n.getComputedStyle(t.firstChild.firstChild, null).marginRight != "0px")
            }
        },
        {
            identity: "DisplayChangeInputSelectionBug",
            early: true,
            fn: function() {
                var e = Ext.webKitVersion;
                return 0 < e && e < 533
            }
        },
        {
            identity: "DisplayChangeTextAreaSelectionBug",
            early: true,
            fn: function() {
                var e = Ext.webKitVersion;
                return 0 < e && e < 534.24
            }
        },
        {
            identity: "TransparentColor",
            fn: function(e, t, n) {
                n = e.defaultView;
                return ! (n && n.getComputedStyle(t.lastChild, null).backgroundColor != "transparent")
            }
        },
        {
            identity: "ComputedStyle",
            fn: function(e, t, n) {
                n = e.defaultView;
                return n && n.getComputedStyle
            }
        },
        {
            identity: "Svg",
            fn: function(e) {
                return !! e.createElementNS && !!e.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGRect
            }
        },
        {
            identity: "Canvas",
            fn: function(e) {
                return !! e.createElement("canvas").getContext
            },
            early: true
        },
        {
            identity: "Vml",
            fn: function(e) {
                var t = e.createElement("div");
                t.innerHTML = "<!--[if vml]><br/><br/><![endif]-->";
                return t.childNodes.length == 2
            },
            early: true
        },
        {
            identity: "Float",
            fn: function(e) {
                return "cssFloat" in e.documentElement.style
            },
            early: true
        },
        {
            identity: "AudioTag",
            fn: function(e) {
                return !! e.createElement("audio").canPlayType
            },
            early: true
        },
        {
            identity: "History",
            fn: function() {
                var e = window.history;
                return !! (e && e.pushState)
            },
            early: true
        },
        {
            identity: "Hashchange",
            fn: function() {
                var e = document.documentMode;
                return "onhashchange" in window && (e === undefined || e > 7)
            },
            early: true
        },
        {
            identity: "CSS3DTransform",
            fn: function() {
                return typeof WebKitCSSMatrix != "undefined" && (new WebKitCSSMatrix).hasOwnProperty("m41")
            },
            early: true
        },
        {
            identity: "CSS3LinearGradient",
            fn: function(e, t) {
                var n = "background-image:",
                r = "-webkit-gradient(linear, left top, right bottom, from(black), to(white))",
                i = "linear-gradient(left top, black, white)",
                s = "-moz-" + i,
                o = "-ms-" + i,
                u = "-o-" + i,
                a = [n + r, n + i, n + s, n + o, n + u];
                t.style.cssText = a.join(";");
                return ("" + t.style.backgroundImage).indexOf("gradient") !== -1 && !Ext.isIE9
            },
            early: true
        },
        {
            identity: "CSS3BorderRadius",
            fn: function(e) {
                var t = ["borderRadius", "BorderRadius", "MozBorderRadius", "WebkitBorderRadius", "OBorderRadius", "KhtmlBorderRadius"],
                n;
                for (n = 0; n < t.length; n++) {
                    if (t[n] in e.documentElement.style) {
                        return true
                    }
                }
                return false
            },
            early: true
        },
        {
            identity: "GeoLocation",
            fn: function() {
                return typeof navigator != "undefined" && "geolocation" in navigator || typeof google != "undefined" && typeof google.gears != "undefined"
            },
            early: true
        },
        {
            identity: "MouseEnterLeave",
            fn: function(e) {
                return "onmouseenter" in e.documentElement && "onmouseleave" in e.documentElement
            },
            early: true
        },
        {
            identity: "MouseWheel",
            fn: function(e) {
                return "onmousewheel" in e.documentElement
            },
            early: true
        },
        {
            identity: "Opacity",
            fn: function(e, t) {
                if (Ext.isIE6 || Ext.isIE7 || Ext.isIE8) {
                    return false
                }
                t.style.cssText = "opacity:0.73";
                return t.style.opacity == "0.73"
            },
            early: true
        },
        {
            identity: "Placeholder",
            fn: function(e) {
                return "placeholder" in e.createElement("input")
            },
            early: true
        },
        {
            identity: "Direct2DBug",
            fn: function(e) {
                return Ext.isString(e.documentElement.style.msTransformOrigin) && Ext.isIE10m
            },
            early: true
        },
        {
            identity: "BoundingClientRect",
            fn: function(e) {
                return ! Ext.isIEQuirks && "getBoundingClientRect" in e.documentElement
            },
            early: true
        },
        {
            identity: "RotatedBoundingClientRect",
            fn: function(e) {
                var t = e.body,
                n = false,
                r = e.createElement("div"),
                i = r.style;
                if (r.getBoundingClientRect) {
                    i.WebkitTransform = i.MozTransform = i.OTransform = i.transform = "rotate(90deg)";
                    i.width = "100px";
                    i.height = "30px";
                    t.appendChild(r);
                    n = r.getBoundingClientRect().height !== 100;
                    t.removeChild(r)
                }
                return n
            }
        },
        {
            identity: "IncludePaddingInWidthCalculation",
            fn: function(e, t) {
                return t.childNodes[1].firstChild.offsetWidth == 210
            }
        },
        {
            identity: "IncludePaddingInHeightCalculation",
            fn: function(e, t) {
                return t.childNodes[1].firstChild.offsetHeight == 210
            }
        },
        {
            identity: "ArraySort",
            fn: function() {
                var e = [1, 2, 3, 4, 5].sort(function() {
                    return 0
                });
                return e[0] === 1 && e[1] === 2 && e[2] === 3 && e[3] === 4 && e[4] === 5
            },
            early: true
        },
        {
            identity: "Range",
            fn: function(e) {
                return !! e.createRange
            },
            early: true
        },
        {
            identity: "CreateContextualFragment",
            fn: function(e) {
                var t = e.createRange ? e.createRange() : false;
                return t && !!t.createContextualFragment
            },
            early: true
        },
        {
            identity: "WindowOnError",
            fn: function() {
                return Ext.isIE || Ext.isGecko || Ext.webKitVersion >= 534.16
            },
            early: true
        },
        {
            identity: "TextAreaMaxLength",
            fn: function(e) {
                var t = e.createElement("textarea");
                return "maxlength" in t
            },
            early: true
        },
        {
            identity: "GetPositionPercentage",
            fn: function(t, n) {
                return e(n.childNodes[2], "left") == "10%"
            }
        },
        {
            identity: "PercentageHeightOverflowBug",
            fn: function(e) {
                var t = false,
                n, r;
                if (Ext.getScrollbarSize().height) {
                    r = e.createElement("div");
                    n = r.style;
                    n.height = "50px";
                    n.width = "50px";
                    n.overflow = "auto";
                    n.position = "absolute";
                    r.innerHTML = ['<div style="display:table;height:100%;">', '<div style="width:51px;"></div>', "</div>"].join("");
                    e.body.appendChild(r);
                    if (r.firstChild.offsetHeight === 50) {
                        t = true
                    }
                    e.body.removeChild(r)
                }
                return t
            }
        },
        {
            identity: "xOriginBug",
            fn: function(e, t) {
                t.innerHTML = '<div id="b1" style="height:100px;width:100px;direction:rtl;position:relative;overflow:scroll"><div id="b2" style="position:relative;width:100%;height:20px;"></div><div id="b3" style="position:absolute;width:20px;height:20px;top:0px;right:0px"></div></div>';
                var n = document.getElementById("b1").getBoundingClientRect(),
                r = document.getElementById("b2").getBoundingClientRect(),
                i = document.getElementById("b3").getBoundingClientRect();
                return r.left !== n.left && i.right !== n.right
            }
        },
        {
            identity: "ScrollWidthInlinePaddingBug",
            fn: function(e) {
                var t = false,
                n, r;
                r = e.createElement("div");
                n = r.style;
                n.height = "50px";
                n.width = "50px";
                n.padding = "10px";
                n.overflow = "hidden";
                n.position = "absolute";
                r.innerHTML = '<span style="display:inline-block;zoom:1;height:60px;width:60px;"></span>';
                e.body.appendChild(r);
                if (r.scrollWidth === 70) {
                    t = true
                }
                e.body.removeChild(r);
                return t
            }
        },
        {
            identity: "rtlVertScrollbarOnRight",
            fn: function(e, t) {
                t.innerHTML = '<div style="height:100px;width:100px;direction:rtl;overflow:scroll"><div style="width:20px;height:200px;"></div></div>';
                var n = t.firstChild,
                r = n.firstChild;
                return r.offsetLeft + r.offsetWidth !== n.offsetLeft + n.offsetWidth
            }
        },
        {
            identity: "rtlVertScrollbarOverflowBug",
            fn: function(e, t) {
                t.innerHTML = '<div style="height:100px;width:100px;direction:rtl;overflow:auto"><div style="width:95px;height:200px;"></div></div>';
                var n = t.firstChild;
                return n.clientHeight === n.offsetHeight
            }
        }]
    }
})();
Ext.supports.init();
Ext.util.DelayedTask = function(e, t, n, r) {
    var i = this,
    s, o = function() {
        clearInterval(i.id);
        i.id = null;
        e.apply(t, n || []);
        Ext.EventManager.idleEvent.fire()
    };
    r = typeof r === "boolean" ? r: true;
    i.id = null;
    i.delay = function(u, f, l, p) {
        if (r) {
            i.cancel()
        }
        if (typeof u === "number") {
            s = u
        }
        e = f || e;
        t = l || t;
        n = p || n;
        if (!i.id) {
            i.id = setInterval(o, s)
        }
    };
    i.cancel = function() {
        if (i.id) {
            clearInterval(i.id);
            i.id = null
        }
    }
};
Ext.define("Ext.util.Event",
function() {
    var e = Array.prototype.slice,
    t = Ext.Array.insert,
    n = Ext.Array.toArray,
    r = Ext.util.DelayedTask;
    return {
        isEvent: true,
        suspended: 0,
        noOptions: {},
        constructor: function(e, t) {
            this.name = t;
            this.observable = e;
            this.listeners = []
        },
        addListener: function(e, n, r) {
            var i = this,
            s, o, u, f, l, c, h, p, d, v;
            n = n || i.observable;
            if (!i.isListening(e, n)) {
                o = i.createListener(e, n, r);
                if (i.firing) {
                    i.listeners = i.listeners.slice(0)
                }
                s = i.listeners;
                p = h = s.length;
                u = r && r.priority;
                l = i._highestNegativePriorityIndex;
                c = l !== undefined;
                if (u) {
                    f = u < 0;
                    if (!f || c) {
                        for (d = f ? l: 0; d < h; d++) {
                            v = s[d].o ? s[d].o.priority || 0 : 0;
                            if (v < u) {
                                p = d;
                                break
                            }
                        }
                    } else {
                        i._highestNegativePriorityIndex = p
                    }
                } else {
                    if (c) {
                        p = l
                    }
                }
                if (!f && p <= l) {
                    i._highestNegativePriorityIndex++
                }
                if (p === h) {
                    i.listeners[h] = o
                } else {
                    t(i.listeners, p, [o])
                }
            }
        },
        createListener: function(e, t, n) {
            t = t || this.observable;
            var r = this,
            i = {
                fn: e,
                scope: t,
                ev: r
            },
            s = e;
            if (n) {
                i.o = n;
                if (n.single) {
                    s = r.createSingle(s, i, n, t)
                }
                if (n.target) {
                    s = r.createTargeted(s, i, n, t)
                }
                if (n.delay) {
                    s = r.createDelayed(s, i, n, t)
                }
                if (n.buffer) {
                    s = r.createBuffered(s, i, n, t)
                }
            }
            i.fireFn = s;
            return i
        },
        findListener: function(e, t) {
            var n = this.listeners,
            r = n.length,
            i, s;
            while (r--) {
                i = n[r];
                if (i) {
                    s = i.scope;
                    if (i.fn == e && s == (t || this.observable)) {
                        return r
                    }
                }
            }
            return - 1
        },
        isListening: function(e, t) {
            return this.findListener(e, t) !== -1
        },
        removeListener: function(e, t) {
            var n = this,
            r, i, s, o;
            r = n.findListener(e, t);
            if (r != -1) {
                i = n.listeners[r];
                s = n._highestNegativePriorityIndex;
                if (n.firing) {
                    n.listeners = n.listeners.slice(0)
                }
                if (i.task) {
                    i.task.cancel();
                    delete i.task
                }
                o = i.tasks && i.tasks.length;
                if (o) {
                    while (o--) {
                        i.tasks[o].cancel()
                    }
                    delete i.tasks
                }
                n.listeners.splice(r, 1);
                if (s) {
                    if (r < s) {
                        n._highestNegativePriorityIndex--
                    } else {
                        if (r === s && r === n.listeners.length) {
                            delete n._highestNegativePriorityIndex
                        }
                    }
                }
                return true
            }
            return false
        },
        clearListeners: function() {
            var e = this.listeners,
            t = e.length;
            while (t--) {
                this.removeListener(e[t].fn, e[t].scope)
            }
        },
        suspend: function() {++this.suspended
        },
        resume: function() {
            if (this.suspended) {--this.suspended
            }
        },
        isSuspended: function() {
            return this.suspended > 0
        },
        fire: function() {
            var t = this,
            n = t.listeners,
            r = n.length,
            i, s, o, u;
            if (!t.suspended && r > 0) {
                t.firing = true;
                s = arguments.length ? e.call(arguments, 0) : [];
                u = s.length;
                for (i = 0; i < r; i++) {
                    o = n[i];
                    if (o.o) {
                        s[u] = o.o
                    }
                    if (window.Ide) {
                        try {
                            if (o && o.fireFn.apply(o.scope || t.observable, s) === false) {
                                return t.firing = false
                            }
                        } catch(a) {
                            Wb.error(a.message);
                            console.error(a.stack || a);
                            return t.firing = false
                        }
                    } else {
                        if (o && o.fireFn.apply(o.scope || t.observable, s) === false) {
                            return t.firing = false
                        }
                    }
                }
            }
            t.firing = false;
            return true
        },
        createTargeted: function(e, t, n, r) {
            return function() {
                if (n.target === arguments[0]) {
                    e.apply(r, arguments)
                }
            }
        },
        createBuffered: function(e, t, i, s) {
            t.task = new r;
            return function() {
                t.task.delay(i.buffer, e, s, n(arguments))
            }
        },
        createDelayed: function(e, t, i, s) {
            return function() {
                var o = new r;
                if (!t.tasks) {
                    t.tasks = []
                }
                t.tasks.push(o);
                o.delay(i.delay || 10, e, s, n(arguments))
            }
        },
        createSingle: function(e, t, n, r) {
            return function() {
                var n = t.ev;
                if (n.removeListener(t.fn, r) && n.observable) {
                    n.observable.hasListeners[n.name]--
                }
                return e.apply(r, arguments)
            }
        }
    }
});
Ext.EventManager = new
function() {
    var e = this,
    t = document,
    n = window,
    r = Ext.supports,
    i = /\\/g,
    s = Ext.baseCSSPrefix,
    o = !Ext.isIE9 && "addEventListener" in t,
    u, a = function() {
        function f(e) {
            n.push(s + e)
        }
        var e = t.body || t.getElementsByTagName("body")[0],
        n = [],
        i = [],
        o = r.CSS3LinearGradient,
        u = r.CSS3BorderRadius,
        a;
        if (!Ext.scopeCss) {
            n.push(s + "body")
        }
        if (!e) {
            return false
        }
        a = e.parentNode;
        if (Ext.isIE && Ext.isIE9m) {
            f("ie");
            if (Ext.isIE6) {
                f("ie6")
            } else {
                f("ie7p");
                if (Ext.isIE7) {
                    f("ie7")
                } else {
                    f("ie8p");
                    if (Ext.isIE8) {
                        f("ie8")
                    } else {
                        f("ie9p");
                        if (Ext.isIE9) {
                            f("ie9")
                        }
                    }
                }
            }
            if (Ext.isIE7m) {
                f("ie7m")
            }
            if (Ext.isIE8m) {
                f("ie8m")
            }
            if (Ext.isIE9m) {
                f("ie9m")
            }
            if (Ext.isIE7 || Ext.isIE8) {
                f("ie78")
            }
        }
        if (Ext.isIE10) {
            f("ie10")
        }
        if (Ext.isGecko) {
            f("gecko");
            if (Ext.isGecko3) {
                f("gecko3")
            }
            if (Ext.isGecko4) {
                f("gecko4")
            }
            if (Ext.isGecko5) {
                f("gecko5")
            }
        }
        if (Ext.isOpera) {
            f("opera")
        }
        if (Ext.isWebKit) {
            f("webkit")
        }
        if (Ext.isSafari) {
            f("safari");
            if (Ext.isSafari2) {
                f("safari2")
            }
            if (Ext.isSafari3) {
                f("safari3")
            }
            if (Ext.isSafari4) {
                f("safari4")
            }
            if (Ext.isSafari5) {
                f("safari5")
            }
            if (Ext.isSafari5_0) {
                f("safari5_0")
            }
        }
        if (Ext.isChrome) {
            f("chrome")
        }
        if (Ext.isMac) {
            f("mac")
        }
        if (Ext.isLinux) {
            f("linux")
        }
        if (!u) {
            f("nbr")
        }
        if (!o) {
            f("nlg")
        }
        if (a) {
            if (Ext.isStrict && (Ext.isIE6 || Ext.isIE7)) {
                Ext.isBorderBox = false
            } else {
                Ext.isBorderBox = true
            }
            if (!Ext.isBorderBox) {
                i.push(s + "content-box")
            }
            if (Ext.isStrict) {
                i.push(s + "strict")
            } else {
                i.push(s + "quirks")
            }
            Ext.fly(a, "_internal").addCls(i)
        }
        Ext.fly(e, "_internal").addCls(n);
        return true
    };
    Ext.apply(e, {
        hasBoundOnReady: false,
        hasFiredReady: false,
        deferReadyEvent: 1,
        onReadyChain: [],
        readyEvent: function() {
            u = new Ext.util.Event;
            u.fire = function() {
                Ext._beforeReadyTime = Ext._beforeReadyTime || (new Date).getTime();
                u.self.prototype.fire.apply(u, arguments);
                Ext._afterReadytime = (new Date).getTime()
            };
            return u
        } (),
        idleEvent: new Ext.util.Event,
        isReadyPaused: function() {
            return /[?&]ext-pauseReadyFire\b/i.test(location.search) && !Ext._continueFireReady
        },
        bindReadyEvent: function() {
            if (e.hasBoundOnReady) {
                return
            }
            if (t.readyState == "complete") {
                e.onReadyEvent({
                    type: t.readyState || "body"
                })
            } else {
                t.addEventListener("DOMContentLoaded", e.onReadyEvent, false);
                n.addEventListener("load", e.onReadyEvent, false);
                e.hasBoundOnReady = true
            }
        },
        onReadyEvent: function(r) {
            if (r && r.type) {
                e.onReadyChain.push(r.type)
            }
            if (e.hasBoundOnReady) {
                t.removeEventListener("DOMContentLoaded", e.onReadyEvent, false);
                n.removeEventListener("load", e.onReadyEvent, false)
            }
            if (!Ext.isReady) {
                e.fireDocReady()
            }
        },
        fireDocReady: function() {
            if (!Ext.isReady) {
                Ext._readyTime = (new Date).getTime();
                Ext.isReady = true;
                r.init();
                e.onWindowUnload();
                u.onReadyChain = e.onReadyChain;
                if (Ext.isNumber(e.deferReadyEvent)) {
                    Ext.Function.defer(e.fireReadyEvent, e.deferReadyEvent);
                    e.hasDocReadyTimer = true
                } else {
                    e.fireReadyEvent()
                }
            }
        },
        fireReadyEvent: function() {
            e.hasDocReadyTimer = false;
            e.isFiring = true;
            while (u.listeners.length && !e.isReadyPaused()) {
                u.fire()
            }
            e.isFiring = false;
            e.hasFiredReady = true;
            e.idleEvent.fire()
        },
        onDocumentReady: function(t, n, r) {
            r = r || {};
            r.single = true;
            u.addListener(t, n, r);
            if (! (e.isFiring || e.hasDocReadyTimer)) {
                if (Ext.isReady) {
                    e.fireReadyEvent()
                } else {
                    e.bindReadyEvent()
                }
            }
        },
        stoppedMouseDownEvent: new Ext.util.Event,
        propRe: /^(?:scope|delay|buffer|single|stopEvent|preventDefault|stopPropagation|normalized|args|delegate|freezeEvent)$/,
        getId: function(e) {
            var r;
            e = Ext.getDom(e);
            if (e === t) {
                r = Ext.documentId
            } else {
                if (e == n) {
                    r = Ext.windowId
                } else {
                    r = Ext.id(e)
                }
            }
            if (!Ext.cache[r]) {
                Ext.addCacheEntry(r, null, e)
            }
            return r
        },
        prepareListenerConfig: function(t, n, r) {
            var i = e.propRe,
            s, o, u;
            for (s in n) {
                if (n.hasOwnProperty(s)) {
                    if (!i.test(s)) {
                        o = n[s];
                        if (typeof o == "function") {
                            u = [t, s, o, n.scope, n]
                        } else {
                            u = [t, s, o.fn, o.scope, o]
                        }
                        if (r) {
                            e.removeListener.apply(e, u)
                        } else {
                            e.addListener.apply(e, u)
                        }
                    }
                }
            }
        },
        mouseEnterLeaveRe: /mouseenter|mouseleave/,
        normalizeEvent: function(t, n) {
            if (e.mouseEnterLeaveRe.test(t) && !r.MouseEnterLeave) {
                if (n) {
                    n = Ext.Function.createInterceptor(n, e.contains)
                }
                t = t == "mouseenter" ? "mouseover": "mouseout"
            } else {
                if (t == "mousewheel" && !r.MouseWheel && !Ext.isOpera) {
                    t = "DOMMouseScroll"
                }
            }
            return {
                eventName: t,
                fn: n
            }
        },
        contains: function(t) {
            t = t.browserEvent || t;
            var n = t.currentTarget,
            r = e.getRelatedTarget(t);
            if (n && n.firstChild) {
                while (r) {
                    if (r === n) {
                        return false
                    }
                    r = r.parentNode;
                    if (r && r.nodeType != 1) {
                        r = null
                    }
                }
            }
            return true
        },
        addListener: function(n, r, i, s, u) {
            if (typeof r !== "string") {
                e.prepareListenerConfig(n, r);
                return
            }
            var a = n.dom || Ext.getDom(n),
            f,
            l,
            c,
            p,
            d,
            v,
            m;
            if (typeof i === "string") {
                i = Ext.resolveMethod(i, s || n)
            }
            u = u || {};
            l = e.normalizeEvent(r, i);
            c = e.createListenerWrap(a, r, l.fn, s, u);
            p = e.getEventListenerCache(n.dom ? n: a, r);
            r = l.eventName;
            f = o || Ext.isIE9 && !a.attachEvent;
            if (!f) {
                d = e.normalizeId(a);
                if (d) {
                    v = Ext.cache[d][r];
                    if (v && v.firing) {
                        p = e.cloneEventListenerCache(a, r)
                    }
                }
            }
            m = !!u.capture;
            p.push({
                fn: i,
                wrap: c,
                scope: s,
                capture: m
            });
            if (!f) {
                if (p.length === 1) {
                    d = e.normalizeId(a, true);
                    i = Ext.Function.bind(e.handleSingleEvent, e, [d, r], true);
                    Ext.cache[d][r] = {
                        firing: false,
                        fn: i
                    };
                    a.attachEvent("on" + r, i)
                }
            } else {
                a.addEventListener(r, c, m)
            }
            if (a == t && r == "mousedown") {
                e.stoppedMouseDownEvent.addListener(c)
            }
        },
        normalizeId: function(r, i) {
            var s;
            if (r === t) {
                s = Ext.documentId
            } else {
                if (r == n) {
                    s = Ext.windowId
                } else {
                    s = r.id
                }
            }
            if (!s && i) {
                s = e.getId(r)
            }
            return s
        },
        handleSingleEvent: function(t, n, r) {
            var i = e.getEventListenerCache(n, r),
            s = Ext.cache[n][r],
            o,
            u;
            if (s.firing) {
                return
            }
            s.firing = true;
            for (u = 0, o = i.length; u < o; ++u) {
                i[u].wrap(t)
            }
            s.firing = false
        },
        removeListener: function(n, r, i, s) {
            if (typeof r !== "string") {
                e.prepareListenerConfig(n, r, true);
                return
            }
            var u = Ext.getDom(n),
            a,
            f = n.dom ? n: Ext.get(u),
            l = e.getEventListenerCache(f, r),
            c = e.normalizeEvent(r).eventName,
            p = l.length,
            d,
            v,
            m,
            g,
            y;
            if (!u) {
                return
            }
            m = o || Ext.isIE9 && !u.detachEvent;
            if (typeof i === "string") {
                i = Ext.resolveMethod(i, s || n)
            }
            while (p--) {
                g = l[p];
                if (g && (!i || g.fn == i) && (!s || g.scope === s)) {
                    y = g.wrap;
                    if (y.task) {
                        clearTimeout(y.task);
                        delete y.task
                    }
                    d = y.tasks && y.tasks.length;
                    if (d) {
                        while (d--) {
                            clearTimeout(y.tasks[d])
                        }
                        delete y.tasks
                    }
                    if (!m) {
                        a = e.normalizeId(u, true);
                        v = Ext.cache[a][c];
                        if (v && v.firing) {
                            l = e.cloneEventListenerCache(u, c)
                        }
                        if (l.length === 1) {
                            i = v.fn;
                            delete Ext.cache[a][c];
                            u.detachEvent("on" + c, i)
                        }
                    } else {
                        u.removeEventListener(c, y, g.capture)
                    }
                    if (y && u == t && r == "mousedown") {
                        e.stoppedMouseDownEvent.removeListener(y)
                    }
                    Ext.Array.erase(l, p, 1)
                }
            }
        },
        removeAll: function(t) {
            var n = typeof t === "string" ? t: t.id,
            r,
            i,
            s;
            if (n && (r = Ext.cache[n])) {
                i = r.events;
                for (s in i) {
                    if (i.hasOwnProperty(s)) {
                        e.removeListener(t, s)
                    }
                }
                r.events = {}
            }
        },
        purgeElement: function(t, n) {
            var r = Ext.getDom(t),
            i = 0,
            s,
            o;
            if (n) {
                e.removeListener(t, n)
            } else {
                e.removeAll(t)
            }
            if (r && r.childNodes) {
                o = r.childNodes;
                for (s = o.length; i < s; i++) {
                    e.purgeElement(o[i], n)
                }
            }
        },
        createListenerWrap: function(t, n, r, s, o) {
            o = o || {};
            var u, a = function(f, c) {
                var h;
                if (!u) {
                    h = ["if(!" + Ext.name + ") {return;}"];
                    if (o.buffer || o.delay || o.freezeEvent) {
                        if (o.freezeEvent) {
                            h.push("e = X.EventObject.setEvent(e);")
                        }
                        h.push("e = new X.EventObjectImpl(e, " + (o.freezeEvent ? "true": "false") + ");")
                    } else {
                        h.push("e = X.EventObject.setEvent(e);")
                    }
                    if (o.delegate) {
                        h.push('var result, t = e.getTarget("' + (o.delegate + "").replace(i, "\\\\") + '", this);');
                        h.push("if(!t) {return;}")
                    } else {
                        h.push("var t = e.target, result;")
                    }
                    if (o.target) {
                        h.push("if(e.target !== options.target) {return;}")
                    }
                    if (o.stopEvent) {
                        h.push("e.stopEvent();")
                    } else {
                        if (o.preventDefault) {
                            h.push("e.preventDefault();")
                        }
                        if (o.stopPropagation) {
                            h.push("e.stopPropagation();")
                        }
                    }
                    if (o.normalized === false) {
                        h.push("e = e.browserEvent;")
                    }
                    if (o.buffer) {
                        h.push("(wrap.task && clearTimeout(wrap.task));");
                        h.push("wrap.task = setTimeout(function() {")
                    }
                    if (o.delay) {
                        h.push("wrap.tasks = wrap.tasks || [];");
                        h.push("wrap.tasks.push(setTimeout(function() {")
                    }
                    h.push("result = fn.call(scope || dom, e, t, options);");
                    if (o.single) {
                        h.push("evtMgr.removeListener(dom, ename, fn, scope);")
                    }
                    if (n !== "mousemove" && n !== "unload") {
                        h.push("if (evtMgr.idleEvent.listeners.length) {");
                        h.push("evtMgr.idleEvent.fire();");
                        h.push("}")
                    }
                    if (o.delay) {
                        h.push("}, " + o.delay + "));")
                    }
                    if (o.buffer) {
                        h.push("}, " + o.buffer + ");")
                    }
                    h.push("return result;");
                    u = Ext.cacheableFunctionFactory("e", "options", "fn", "scope", "ename", "dom", "wrap", "args", "X", "evtMgr", h.join("\n"))
                }
                return u.call(t, f, o, r, s, n, t, a, c, Ext, e)
            };
            return a
        },
        getEventCache: function(t) {
            var n, r, i;
            if (!t) {
                return []
            }
            if (t.$cache) {
                n = t.$cache
            } else {
                if (typeof t === "string") {
                    i = t
                } else {
                    i = e.getId(t)
                }
                n = Ext.cache[i]
            }
            r = n.events || (n.events = {});
            return r
        },
        getEventListenerCache: function(t, n) {
            var r = e.getEventCache(t);
            return r[n] || (r[n] = [])
        },
        cloneEventListenerCache: function(t, n) {
            var r = e.getEventCache(t),
            i;
            if (r[n]) {
                i = r[n].slice(0)
            } else {
                i = []
            }
            r[n] = i;
            return i
        },
        mouseLeaveRe: /(mouseout|mouseleave)/,
        mouseEnterRe: /(mouseover|mouseenter)/,
        stopEvent: function(t) {
            e.stopPropagation(t);
            e.preventDefault(t)
        },
        stopPropagation: function(e) {
            e = e.browserEvent || e;
            if (e.stopPropagation) {
                e.stopPropagation()
            } else {
                e.cancelBubble = true
            }
        },
        preventDefault: function(e) {
            e = e.browserEvent || e;
            if (e.preventDefault) {
                e.preventDefault()
            } else {
                e.returnValue = false;
                try {
                    if (e.ctrlKey || e.keyCode > 111 && e.keyCode < 124) {
                        e.keyCode = -1
                    }
                } catch(t) {}
            }
        },
        getRelatedTarget: function(t) {
            t = t.browserEvent || t;
            var n = t.relatedTarget;
            if (!n) {
                if (e.mouseLeaveRe.test(t.type)) {
                    n = t.toElement
                } else {
                    if (e.mouseEnterRe.test(t.type)) {
                        n = t.fromElement
                    }
                }
            }
            return e.resolveTextNode(n)
        },
        getPageX: function(t) {
            return e.getPageXY(t)[0]
        },
        getPageY: function(t) {
            return e.getPageXY(t)[1]
        },
        getPageXY: function(e) {
            e = e.browserEvent || e;
            var n = e.pageX,
            r = e.pageY,
            i = t.documentElement,
            s = t.body;
            if (!n && n !== 0) {
                n = e.clientX + (i && i.scrollLeft || s && s.scrollLeft || 0) - (i && i.clientLeft || s && s.clientLeft || 0);
                r = e.clientY + (i && i.scrollTop || s && s.scrollTop || 0) - (i && i.clientTop || s && s.clientTop || 0)
            }
            return [n, r]
        },
        getTarget: function(t) {
            t = t.browserEvent || t;
            return e.resolveTextNode(t.target || t.srcElement)
        },
        resolveTextNode: Ext.isGecko ?
        function(e) {
            if (e) {
                var t = HTMLElement.prototype.toString.call(e);
                if (t !== "[xpconnect wrapped native prototype]" && t !== "[object XULElement]") {
                    return e.nodeType == 3 ? e.parentNode: e
                }
            }
        }: function(e) {
            return e && e.nodeType == 3 ? e.parentNode: e
        },
        curWidth: 0,
        curHeight: 0,
        onWindowResize: function(t, r, i) {
            var s = e.resizeEvent;
            if (!s) {
                e.resizeEvent = s = new Ext.util.Event;
                e.on(n, "resize", e.fireResize, null, {
                    buffer: 100
                })
            }
            s.addListener(t, r, i)
        },
        fireResize: function() {
            var t = Ext.Element.getViewWidth(),
            n = Ext.Element.getViewHeight();
            if (e.curHeight != n || e.curWidth != t) {
                e.curHeight = n;
                e.curWidth = t;
                e.resizeEvent.fire(t, n)
            }
        },
        removeResizeListener: function(t, n) {
            var r = e.resizeEvent;
            if (r) {
                r.removeListener(t, n)
            }
        },
        onWindowUnload: function(t, r, i) {
            var s = e.unloadEvent;
            if (!s) {
                e.unloadEvent = s = new Ext.util.Event;
                e.addListener(n, "unload", e.fireUnload)
            }
            if (t) {
                s.addListener(t, r, i)
            }
        },
        fireUnload: function() {
            try {
                t = n = undefined;
                var r, i, s, o, u;
                e.unloadEvent.fire();
                if (Ext.isGecko3) {
                    r = Ext.ComponentQuery.query("gridview");
                    i = 0;
                    s = r.length;
                    for (; i < s; i++) {
                        r[i].scrollToTop()
                    }
                }
                u = Ext.cache;
                for (o in u) {
                    if (u.hasOwnProperty(o)) {
                        e.removeAll(o)
                    }
                }
            } catch(a) {}
        },
        removeUnloadListener: function(t, n) {
            var r = e.unloadEvent;
            if (r) {
                r.removeListener(t, n)
            }
        },
        useKeyDown: Ext.isWebKit ? parseInt(navigator.userAgent.match(/AppleWebKit\/(\d+)/)[1], 10) >= 525 : !(Ext.isGecko && !Ext.isWindows || Ext.isOpera && Ext.operaVersion < 12),
        getKeyEvent: function() {
            return e.useKeyDown ? "keydown": "keypress"
        }
    });
    if (!o && document.attachEvent) {
        Ext.apply(e, {
            pollScroll: function() {
                var t = true;
                try {
                    document.documentElement.doScroll("left")
                } catch(n) {
                    t = false
                }
                if (t && document.body) {
                    e.onReadyEvent({
                        type: "doScroll"
                    })
                } else {
                    e.scrollTimeout = setTimeout(e.pollScroll, 20)
                }
                return t
            },
            scrollTimeout: null,
            readyStatesRe: /complete/i,
            checkReadyState: function() {
                var t = document.readyState;
                if (e.readyStatesRe.test(t)) {
                    e.onReadyEvent({
                        type: t
                    })
                }
            },
            bindReadyEvent: function() {
                var n = true;
                if (e.hasBoundOnReady) {
                    return
                }
                try {
                    n = window.frameElement === undefined
                } catch(r) {
                    n = false
                }
                if (!n || !t.documentElement.doScroll) {
                    e.pollScroll = Ext.emptyFn
                }
                if (e.pollScroll() === true) {
                    return
                }
                if (t.readyState == "complete") {
                    e.onReadyEvent({
                        type: "already " + (t.readyState || "body")
                    })
                } else {
                    t.attachEvent("onreadystatechange", e.checkReadyState);
                    window.attachEvent("onload", e.onReadyEvent);
                    e.hasBoundOnReady = true
                }
            },
            onReadyEvent: function(t) {
                if (t && t.type) {
                    e.onReadyChain.push(t.type)
                }
                if (e.hasBoundOnReady) {
                    document.detachEvent("onreadystatechange", e.checkReadyState);
                    window.detachEvent("onload", e.onReadyEvent)
                }
                if (Ext.isNumber(e.scrollTimeout)) {
                    clearTimeout(e.scrollTimeout);
                    delete e.scrollTimeout
                }
                if (!Ext.isReady) {
                    e.fireDocReady()
                }
            },
            onReadyChain: []
        })
    }
    Ext.onReady = function(e, t, n) {
        Ext.Loader.onReady(e, t, true, n)
    };
    Ext.onDocumentReady = e.onDocumentReady;
    e.on = e.addListener;
    e.un = e.removeListener;
    Ext.onReady(a)
};
Ext.define("Ext.util.Observable",
function(e) {
    var t = Ext.emptyFn,
    n = [],
    r = Array.prototype,
    i = r.slice,
    s = Ext.util.Event,
    o = function(e) {
        if (e instanceof o) {
            return e
        }
        this.observable = e;
        if (arguments[1].isObservable) {
            this.managedListeners = true
        }
        this.args = i.call(arguments, 1)
    };
    o.prototype.destroy = function() {
        this.observable[this.managedListeners ? "mun": "un"].apply(this.observable, this.args)
    };
    return {
        statics: {
            releaseCapture: function(e) {
                e.fireEventArgs = this.prototype.fireEventArgs
            },
            capture: function(e, t, n) {
                var r = function(e, r) {
                    return t.apply(n, [e].concat(r))
                };
                this.captureArgs(e, r, n)
            },
            captureArgs: function(e, t, n) {
                e.fireEventArgs = Ext.Function.createInterceptor(e.fireEventArgs, t, n)
            },
            observe: function(e, t) {
                if (e) {
                    if (!e.isObservable) {
                        Ext.applyIf(e, new this);
                        this.captureArgs(e.prototype, e.fireEventArgs, e)
                    }
                    if (Ext.isObject(t)) {
                        e.on(t)
                    }
                }
                return e
            },
            prepareClass: function(t, n) {
                if (!t.HasListeners) {
                    var r = function() {},
                    i = t.superclass.HasListeners || n && n.HasListeners || e.HasListeners;
                    t.prototype.HasListeners = t.HasListeners = r;
                    r.prototype = t.hasListeners = new i
                }
            }
        },
        isObservable: true,
        eventsSuspended: 0,
        constructor: function(e) {
            var t = this;
            Ext.apply(t, e);
            if (!t.hasListeners) {
                t.hasListeners = new t.HasListeners
            }
            t.events = t.events || {};
            if (t.listeners) {
                t.on(t.listeners);
                t.listeners = null
            }
            if (t.bubbleEvents) {
                t.enableBubble(t.bubbleEvents)
            }
        },
        onClassExtended: function(t) {
            if (!t.HasListeners) {
                e.prepareClass(t)
            }
        },
        eventOptionsRe: /^(?:scope|delay|buffer|single|stopEvent|preventDefault|stopPropagation|normalized|args|delegate|element|destroyable|vertical|horizontal|freezeEvent|priority)$/,
        addManagedListener: function(e, n, r, i, s, u) {
            var a = this,
            f = a.managedListeners = a.managedListeners || [],
            l,
            c;
            if (typeof n !== "string") {
                c = arguments.length > 4 ? s: n;
                s = n;
                for (n in s) {
                    if (s.hasOwnProperty(n)) {
                        l = s[n];
                        if (!a.eventOptionsRe.test(n)) {
                            a.addManagedListener(e, n, l.fn || l, l.scope || s.scope || i, l.fn ? l: c, true)
                        }
                    }
                }
                if (s && s.destroyable) {
                    return new o(a, e, s)
                }
            } else {
                if (typeof r === "string") {
                    i = i || a;
                    r = Ext.resolveMethod(r, i)
                }
                if (r !== t) {
                    f.push({
                        item: e,
                        ename: n,
                        fn: r,
                        scope: i,
                        options: s
                    });
                    e.on(n, r, i, s);
                    if (!u && s && s.destroyable) {
                        return new o(a, e, n, r, i)
                    }
                }
            }
        },
        removeManagedListener: function(e, t, n, r) {
            var i = this,
            s, o, u, a, f;
            if (typeof t !== "string") {
                s = t;
                for (t in s) {
                    if (s.hasOwnProperty(t)) {
                        o = s[t];
                        if (!i.eventOptionsRe.test(t)) {
                            i.removeManagedListener(e, t, o.fn || o, o.scope || s.scope || r)
                        }
                    }
                }
            } else {
                u = i.managedListeners ? i.managedListeners.slice() : [];
                if (typeof n === "string") {
                    r = r || i;
                    n = Ext.resolveMethod(n, r)
                }
                for (f = 0, a = u.length; f < a; f++) {
                    i.removeManagedListenerItem(false, u[f], e, t, n, r)
                }
            }
        },
        fireEvent: function(e) {
            return this.fireEventArgs(e, i.call(arguments, 1))
        },
        fireEventArgs: function(e, t) {
            e = e.toLowerCase();
            var r = this,
            i = r.events,
            s = i && i[e],
            o = true;
            if (s && r.hasListeners[e]) {
                o = r.continueFireEvent(e, t || n, s.bubble)
            }
            return o
        },
        continueFireEvent: function(e, t, n) {
            var r = this,
            i, s, o = true;
            do {
                if (r.eventsSuspended) {
                    if (i = r.eventQueue) {
                        i.push([e, t, n])
                    }
                    return o
                } else {
                    s = r.events[e];
                    if (s && s !== true) {
                        if ((o = s.fire.apply(s, t)) === false) {
                            break
                        }
                    }
                }
            } while ( n && ( r = r . getBubbleParent ()));
            return o
        },
        getBubbleParent: function() {
            var e = this,
            t = e.getBubbleTarget && e.getBubbleTarget();
            if (t && t.isObservable) {
                return t
            }
            return null
        },
        addListener: function(e, n, r, i) {
            var u = this,
            a, f, l = 0;
            if (typeof e !== "string") {
                i = e;
                for (e in i) {
                    if (i.hasOwnProperty(e)) {
                        a = i[e];
                        if (!u.eventOptionsRe.test(e)) {
                            u.addListener(e, a.fn || a, a.scope || i.scope, a.fn ? a: i)
                        }
                    }
                }
                if (i && i.destroyable) {
                    return new o(u, i)
                }
            } else {
                e = e.toLowerCase();
                f = u.events[e];
                if (f && f.isEvent) {
                    l = f.listeners.length
                } else {
                    u.events[e] = f = new s(u, e)
                }
                if (typeof n === "string") {
                    r = r || u;
                    n = Ext.resolveMethod(n, r)
                }
                if (n !== t) {
                    f.addListener(n, r, i);
                    if (f.listeners.length !== l) {
                        u.hasListeners._incr_(e)
                    }
                    if (i && i.destroyable) {
                        return new o(u, e, n, r, i)
                    }
                }
            }
        },
        removeListener: function(e, t, n) {
            var r = this,
            i, s, o;
            if (typeof e !== "string") {
                o = e;
                for (e in o) {
                    if (o.hasOwnProperty(e)) {
                        i = o[e];
                        if (!r.eventOptionsRe.test(e)) {
                            r.removeListener(e, i.fn || i, i.scope || o.scope)
                        }
                    }
                }
            } else {
                e = e.toLowerCase();
                s = r.events[e];
                if (s && s.isEvent) {
                    if (typeof t === "string") {
                        n = n || r;
                        t = Ext.resolveMethod(t, n)
                    }
                    if (s.removeListener(t, n)) {
                        r.hasListeners._decr_(e)
                    }
                }
            }
        },
        clearListeners: function() {
            var e = this.events,
            t = this.hasListeners,
            n, r;
            for (r in e) {
                if (e.hasOwnProperty(r)) {
                    n = e[r];
                    if (n.isEvent) {
                        delete t[r];
                        n.clearListeners()
                    }
                }
            }
            this.clearManagedListeners()
        },
        clearManagedListeners: function() {
            var e = this.managedListeners || [],
            t = 0,
            n = e.length;
            for (; t < n; t++) {
                this.removeManagedListenerItem(true, e[t])
            }
            this.managedListeners = []
        },
        removeManagedListenerItem: function(e, t, n, r, i, s) {
            if (e || t.item === n && t.ename === r && (!i || t.fn === i) && (!s || t.scope === s)) {
                t.item.un(t.ename, t.fn, t.scope);
                if (!e) {
                    Ext.Array.remove(this.managedListeners, t)
                }
            }
        },
        addEvents: function(e) {
            var t = this,
            n = t.events || (t.events = {}),
            r,
            i,
            s;
            if (typeof e == "string") {
                for (i = arguments, s = i.length; s--;) {
                    r = i[s];
                    if (!n[r]) {
                        n[r] = true
                    }
                }
            } else {
                Ext.applyIf(t.events, e)
            }
        },
        hasListener: function(e) {
            return !! this.hasListeners[e.toLowerCase()]
        },
        isSuspended: function(e) {
            var t = this.eventsSuspended > 0;
            if (!t && e) {
                e = this.events[e];
                if (e && e.isEvent) {
                    return e.isSuspended()
                }
            }
            return t
        },
        suspendEvents: function(e) {
            this.eventsSuspended += 1;
            if (e && !this.eventQueue) {
                this.eventQueue = []
            }
        },
        suspendEvent: function(e) {
            var t = arguments.length,
            n = this.events,
            r, i, o;
            for (r = 0; r < t; r++) {
                o = arguments[r];
                i = n[o];
                if (!i || typeof i == "boolean") {
                    n[o] = i = new s(this, o)
                }
                i.suspend()
            }
        },
        resumeEvent: function() {
            var e = arguments.length,
            t, n;
            for (t = 0; t < e; t++) {
                n = this.events[arguments[t]];
                if (n && n.resume) {
                    n.resume()
                }
            }
        },
        resumeEvents: function() {
            var e = this,
            t = e.eventQueue,
            n, r;
            if (e.eventsSuspended && !--e.eventsSuspended) {
                delete e.eventQueue;
                if (t) {
                    n = t.length;
                    for (r = 0; r < n; r++) {
                        e.continueFireEvent.apply(e, t[r])
                    }
                }
            }
        },
        relayEvents: function(e, t, n) {
            var r = this,
            i = t.length,
            s = 0,
            u, a = {};
            for (; s < i; s++) {
                u = t[s];
                a[u] = r.createRelayer(n ? n + u: u)
            }
            r.mon(e, a, null, null, undefined);
            return new o(r, e, a)
        },
        createRelayer: function(e, t) {
            var n = this;
            return function() {
                return n.fireEventArgs.call(n, e, t ? i.apply(arguments, t) : arguments)
            }
        },
        enableBubble: function(e) {
            if (e) {
                var t = this,
                n = typeof e == "string" ? arguments: e,
                r = n.length,
                i = t.events,
                o,
                u,
                a;
                for (a = 0; a < r; ++a) {
                    o = n[a].toLowerCase();
                    u = i[o];
                    if (!u || typeof u == "boolean") {
                        i[o] = u = new s(t, o)
                    }
                    t.hasListeners._incr_(o);
                    u.bubble = true
                }
            }
        }
    }
},
function() {
    function s(e) {
        var t = (this.methodEvents = this.methodEvents || {})[e],
        n,
        r,
        i,
        s = this,
        o;
        if (!t) {
            this.methodEvents[e] = t = {};
            t.originalFn = this[e];
            t.methodName = e;
            t.before = [];
            t.after = [];
            o = function(e, t, o) {
                if ((r = e.apply(t || s, o)) !== undefined) {
                    if (typeof r == "object") {
                        if (r.returnValue !== undefined) {
                            n = r.returnValue
                        } else {
                            n = r
                        }
                        i = !!r.cancel
                    } else {
                        if (r === false) {
                            i = true
                        } else {
                            n = r
                        }
                    }
                }
            };
            this[e] = function() {
                var e = Array.prototype.slice.call(arguments, 0),
                u,
                a,
                f;
                n = r = undefined;
                i = false;
                for (a = 0, f = t.before.length; a < f; a++) {
                    u = t.before[a];
                    o(u.fn, u.scope, e);
                    if (i) {
                        return n
                    }
                }
                if ((r = t.originalFn.apply(s, e)) !== undefined) {
                    n = r
                }
                for (a = 0, f = t.after.length; a < f; a++) {
                    u = t.after[a];
                    o(u.fn, u.scope, e);
                    if (i) {
                        return n
                    }
                }
                return n
            }
        }
        return t
    }
    var e = this,
    t = e.prototype,
    n = function() {},
    r = function(t) {
        if (!t.HasListeners) {
            var n = t.prototype;
            e.prepareClass(t, this);
            t.onExtended(function(t) {
                e.prepareClass(t)
            });
            if (n.onClassMixedIn) {
                Ext.override(t, {
                    onClassMixedIn: function(e) {
                        r.call(this, e);
                        this.callParent(arguments)
                    }
                })
            } else {
                n.onClassMixedIn = function(e) {
                    r.call(this, e)
                }
            }
        }
    },
    i;
    n.prototype = {
        _decr_: function(e) {
            if (!--this[e]) {
                delete this[e]
            }
        },
        _incr_: function(e) {
            if (this.hasOwnProperty(e)) {++this[e]
            } else {
                this[e] = 1
            }
        }
    };
    t.HasListeners = e.HasListeners = n;
    e.createAlias({
        on: "addListener",
        un: "removeListener",
        mon: "addManagedListener",
        mun: "removeManagedListener"
    });
    e.observeClass = e.observe;
    Ext.globalEvents = i = new e({
        events: {
            idle: Ext.EventManager.idleEvent,
            ready: Ext.EventManager.readyEvent
        }
    });
    Ext.on = function() {
        return i.addListener.apply(i, arguments)
    };
    Ext.un = function() {
        return i.removeListener.apply(i, arguments)
    };
    Ext.apply(t, {
        onClassMixedIn: r,
        beforeMethod: function(e, t, n) {
            s.call(this, e).before.push({
                fn: t,
                scope: n
            })
        },
        afterMethod: function(e, t, n) {
            s.call(this, e).after.push({
                fn: t,
                scope: n
            })
        },
        removeMethodListener: function(e, t, n) {
            var r = this.getMethodEvent(e),
            i,
            s;
            for (i = 0, s = r.before.length; i < s; i++) {
                if (r.before[i].fn == t && r.before[i].scope == n) {
                    Ext.Array.erase(r.before, i, 1);
                    return
                }
            }
            for (i = 0, s = r.after.length; i < s; i++) {
                if (r.after[i].fn == t && r.after[i].scope == n) {
                    Ext.Array.erase(r.after, i, 1);
                    return
                }
            }
        },
        toggleEventLogging: function(e) {
            Ext.util.Observable[e ? "capture": "releaseCapture"](this,
            function(e) {
                if (Ext.isDefined(Ext.global.console)) {
                    Ext.global.console.log(e, arguments)
                }
            })
        }
    })
});
Ext.define("Ext.EventObjectImpl", {
    BACKSPACE: 8,
    TAB: 9,
    NUM_CENTER: 12,
    ENTER: 13,
    RETURN: 13,
    SHIFT: 16,
    CTRL: 17,
    ALT: 18,
    PAUSE: 19,
    CAPS_LOCK: 20,
    ESC: 27,
    SPACE: 32,
    PAGE_UP: 33,
    PAGE_DOWN: 34,
    END: 35,
    HOME: 36,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    PRINT_SCREEN: 44,
    INSERT: 45,
    DELETE: 46,
    ZERO: 48,
    ONE: 49,
    TWO: 50,
    THREE: 51,
    FOUR: 52,
    FIVE: 53,
    SIX: 54,
    SEVEN: 55,
    EIGHT: 56,
    NINE: 57,
    A: 65,
    B: 66,
    C: 67,
    D: 68,
    E: 69,
    F: 70,
    G: 71,
    H: 72,
    I: 73,
    J: 74,
    K: 75,
    L: 76,
    M: 77,
    N: 78,
    O: 79,
    P: 80,
    Q: 81,
    R: 82,
    S: 83,
    T: 84,
    U: 85,
    V: 86,
    W: 87,
    X: 88,
    Y: 89,
    Z: 90,
    CONTEXT_MENU: 93,
    NUM_ZERO: 96,
    NUM_ONE: 97,
    NUM_TWO: 98,
    NUM_THREE: 99,
    NUM_FOUR: 100,
    NUM_FIVE: 101,
    NUM_SIX: 102,
    NUM_SEVEN: 103,
    NUM_EIGHT: 104,
    NUM_NINE: 105,
    NUM_MULTIPLY: 106,
    NUM_PLUS: 107,
    NUM_MINUS: 109,
    NUM_PERIOD: 110,
    NUM_DIVISION: 111,
    F1: 112,
    F2: 113,
    F3: 114,
    F4: 115,
    F5: 116,
    F6: 117,
    F7: 118,
    F8: 119,
    F9: 120,
    F10: 121,
    F11: 122,
    F12: 123,
    WHEEL_SCALE: function() {
        var e;
        if (Ext.isGecko) {
            e = 3
        } else {
            if (Ext.isMac) {
                if (Ext.isSafari && Ext.webKitVersion >= 532) {
                    e = 120
                } else {
                    e = 12
                }
                e *= 3
            } else {
                e = 120
            }
        }
        return e
    } (),
    clickRe: /(dbl)?click/,
    safariKeys: {
        3 : 13,
        63234 : 37,
        63235 : 39,
        63232 : 38,
        63233 : 40,
        63276 : 33,
        63277 : 34,
        63272 : 46,
        63273 : 36,
        63275 : 35
    },
    btnMap: Ext.isIE9m ? {
        1 : 0,
        4 : 1,
        2 : 2
    }: {
        0 : 0,
        1 : 1,
        2 : 2
    },
    isEvent: true,
    constructor: function(e, t) {
        if (e) {
            this.setEvent(e.browserEvent || e, t)
        }
    },
    setEvent: function(e, t) {
        var n = this,
        r;
        if (e === n || e && e.browserEvent) {
            return e
        }
        n.browserEvent = e;
        if (e) {
            r = e.button ? n.btnMap[e.button] : e.which ? e.which - 1 : -1;
            if (n.clickRe.test(e.type) && r == -1) {
                r = 0
            }
            n.type = e.type;
            n.button = r;
            n.shiftKey = e.shiftKey;
            n.ctrlKey = e.ctrlKey || e.metaKey || false;
            n.altKey = e.altKey;
            n.keyCode = e.keyCode;
            n.charCode = e.charCode;
            n.target = Ext.EventManager.getTarget(e);
            n.relatedTarget = Ext.EventManager.getRelatedTarget(e);
            n.currentTarget = e.currentTarget;
            n.xy = t ? n.getXY() : null
        } else {
            n.button = -1;
            n.shiftKey = false;
            n.ctrlKey = false;
            n.altKey = false;
            n.keyCode = 0;
            n.charCode = 0;
            n.target = null;
            n.xy = [0, 0]
        }
        return n
    },
    clone: function() {
        return new this.self(this.browserEvent, this)
    },
    stopEvent: function() {
        this.stopPropagation();
        this.preventDefault()
    },
    preventDefault: function() {
        if (this.browserEvent) {
            Ext.EventManager.preventDefault(this.browserEvent)
        }
    },
    stopPropagation: function() {
        var e = this.browserEvent;
        if (e) {
            if (e.type == "mousedown") {
                Ext.EventManager.stoppedMouseDownEvent.fire(this)
            }
            Ext.EventManager.stopPropagation(e)
        }
    },
    getCharCode: function() {
        return this.charCode || this.keyCode
    },
    getKey: function() {
        return this.normalizeKey(this.keyCode || this.charCode)
    },
    normalizeKey: function(e) {
        return Ext.isWebKit ? this.safariKeys[e] || e: e
    },
    getPageX: function() {
        return this.getX()
    },
    getPageY: function() {
        return this.getY()
    },
    getX: function() {
        return this.getXY()[0]
    },
    getY: function() {
        return this.getXY()[1]
    },
    getXY: function() {
        if (!this.xy) {
            this.xy = Ext.EventManager.getPageXY(this.browserEvent)
        }
        return this.xy
    },
    getTarget: function(e, t, n) {
        if (e) {
            return Ext.fly(this.target).findParent(e, t, n)
        }
        return n ? Ext.get(this.target) : this.target
    },
    getRelatedTarget: function(e, t, n) {
        if (e && this.relatedTarget) {
            return Ext.fly(this.relatedTarget).findParent(e, t, n)
        }
        return n ? Ext.get(this.relatedTarget) : this.relatedTarget
    },
    correctWheelDelta: function(e) {
        var t = this.WHEEL_SCALE,
        n = Math.round(e / t);
        if (!n && e) {
            n = e < 0 ? -1 : 1
        }
        return n
    },
    getWheelDeltas: function() {
        var e = this,
        t = e.browserEvent,
        n = 0,
        r = 0;
        if (Ext.isDefined(t.wheelDeltaX)) {
            n = t.wheelDeltaX;
            r = t.wheelDeltaY
        } else {
            if (t.wheelDelta) {
                r = t.wheelDelta
            } else {
                if (t.detail) {
                    r = -t.detail;
                    if (r > 100) {
                        r = 3
                    } else {
                        if (r < -100) {
                            r = -3
                        }
                    }
                    if (Ext.isDefined(t.axis) && t.axis === t.HORIZONTAL_AXIS) {
                        n = r;
                        r = 0
                    }
                }
            }
        }
        return {
            x: e.correctWheelDelta(n),
            y: e.correctWheelDelta(r)
        }
    },
    getWheelDelta: function() {
        var e = this.getWheelDeltas();
        return e.y
    },
    within: function(e, t, n) {
        if (e) {
            var r = t ? this.getRelatedTarget() : this.getTarget(),
            i;
            if (r) {
                i = Ext.fly(e, "_internal").contains(r);
                if (!i && n) {
                    i = r == Ext.getDom(e)
                }
                return i
            }
        }
        return false
    },
    isNavKeyPress: function() {
        var e = this,
        t = this.normalizeKey(e.keyCode);
        return t >= 33 && t <= 40 || t == e.RETURN || t == e.TAB || t == e.ESC
    },
    isSpecialKey: function() {
        var e = this.normalizeKey(this.keyCode);
        return this.type == "keypress" && this.ctrlKey || this.isNavKeyPress() || e == this.BACKSPACE || e >= 16 && e <= 20 || e >= 44 && e <= 46
    },
    getPoint: function() {
        var e = this.getXY();
        return new Ext.util.Point(e[0], e[1])
    },
    hasModifier: function() {
        var e = this;
        return !! (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)
    },
    injectEvent: function() {
        function r(t, n) {
            var r = t != "mousemove";
            return function(i, s) {
                var o = s.getXY(),
                u = e.createMouseEvent(i.ownerDocument, t, true, r, n, o[0], o[1], s.ctrlKey, s.altKey, s.shiftKey, s.metaKey, s.button, s.relatedTarget);
                e.fireEvent(i, t, u)
            }
        }
        function i(e, t) {}
        var e, t = {},
        n;
        if (!Ext.isIE9m && document.createEvent) {
            e = {
                createHtmlEvent: function(e, t, n, r) {
                    var i = e.createEvent("HTMLEvents");
                    i.initEvent(t, n, r);
                    return i
                },
                createMouseEvent: function(e, t, n, r, i, s, o, u, a, f, l, c, h) {
                    var p = e.createEvent("MouseEvents"),
                    d = e.defaultView || window;
                    if (p.initMouseEvent) {
                        p.initMouseEvent(t, n, r, d, i, s, o, s, o, u, a, f, l, c, h)
                    } else {
                        p = e.createEvent("UIEvents");
                        p.initEvent(t, n, r);
                        p.view = d;
                        p.detail = i;
                        p.screenX = s;
                        p.screenY = o;
                        p.clientX = s;
                        p.clientY = o;
                        p.ctrlKey = u;
                        p.altKey = a;
                        p.metaKey = l;
                        p.shiftKey = f;
                        p.button = c;
                        p.relatedTarget = h
                    }
                    return p
                },
                createUIEvent: function(e, t, n, r, i) {
                    var s = e.createEvent("UIEvents"),
                    o = e.defaultView || window;
                    s.initUIEvent(t, n, r, o, i);
                    return s
                },
                fireEvent: function(e, t, n) {
                    e.dispatchEvent(n)
                },
                fixTarget: function(e) {
                    if (e == window && !e.dispatchEvent) {
                        return document
                    }
                    return e
                }
            }
        } else {
            if (document.createEventObject) {
                n = {
                    0 : 1,
                    1 : 4,
                    2 : 2
                };
                e = {
                    createHtmlEvent: function(e, t, n, r) {
                        var i = e.createEventObject();
                        i.bubbles = n;
                        i.cancelable = r;
                        return i
                    },
                    createMouseEvent: function(e, t, r, i, s, o, u, a, f, l, h, p, d) {
                        var v = e.createEventObject();
                        v.bubbles = r;
                        v.cancelable = i;
                        v.detail = s;
                        v.screenX = o;
                        v.screenY = u;
                        v.clientX = o;
                        v.clientY = u;
                        v.ctrlKey = a;
                        v.altKey = f;
                        v.shiftKey = l;
                        v.metaKey = h;
                        v.button = n[p] || p;
                        v.relatedTarget = d;
                        return v
                    },
                    createUIEvent: function(e, t, n, r, i) {
                        var s = e.createEventObject();
                        s.bubbles = n;
                        s.cancelable = r;
                        return s
                    },
                    fireEvent: function(e, t, n) {
                        e.fireEvent("on" + t, n)
                    },
                    fixTarget: function(e) {
                        if (e == document) {
                            return document.documentElement
                        }
                        return e
                    }
                }
            }
        }
        Ext.Object.each({
            load: [false, false],
            unload: [false, false],
            select: [true, false],
            change: [true, false],
            submit: [true, true],
            reset: [true, false],
            resize: [true, false],
            scroll: [true, false]
        },
        function(n, r) {
            var i = r[0],
            s = r[1];
            t[n] = function(t, r) {
                var o = e.createHtmlEvent(n, i, s);
                e.fireEvent(t, n, o)
            }
        });
        Ext.each(["click", "dblclick", "mousedown", "mouseup", "mouseover", "mousemove", "mouseout"],
        function(e) {
            t[e] = r(e, 1)
        });
        Ext.Object.each({
            focusin: [true, false],
            focusout: [true, false],
            activate: [true, true],
            focus: [false, false],
            blur: [false, false]
        },
        function(n, r) {
            var i = r[0],
            s = r[1];
            t[n] = function(t, r) {
                var o = e.createUIEvent(t.ownerDocument, n, i, s, 1);
                e.fireEvent(t, n, o)
            }
        });
        if (!e) {
            t = {};
            e = {
                fixTarget: Ext.identityFn
            }
        }
        return function(n) {
            var r = this,
            s = t[r.type] || i,
            o = n ? n.dom || n: r.getTarget();
            o = e.fixTarget(o);
            s(o, r)
        }
    } ()
},
function() {
    Ext.EventObject = new Ext.EventObjectImpl
});
Ext.define("Ext.dom.AbstractQuery", {
    select: function(e, t) {
        var n = [],
        r,
        i,
        s,
        o,
        u;
        t = t || document;
        if (typeof t == "string") {
            t = document.getElementById(t)
        }
        e = Ext.splitAndUnescape(e, ",");
        for (i = 0, o = e.length; i < o; i++) {
            if (typeof e[i] == "string") {
                if (typeof e[i][0] == "@") {
                    r = t.getAttributeNode(e[i].substring(1));
                    n.push(r)
                } else {
                    r = t.querySelectorAll(e[i]);
                    for (s = 0, u = r.length; s < u; s++) {
                        n.push(r[s])
                    }
                }
            }
        }
        return n
    },
    selectNode: function(e, t) {
        return this.select(e, t)[0]
    },
    is: function(e, t) {
        if (typeof e == "string") {
            e = document.getElementById(e)
        }
        return this.select(t).indexOf(e) !== -1
    }
});
Ext.define("Ext.dom.AbstractHelper", {
    emptyTags: /^(?:br|frame|hr|img|input|link|meta|range|spacer|wbr|area|param|col)$/i,
    confRe: /^(?:tag|children|cn|html|tpl|tplData)$/i,
    endRe: /end/i,
    styleSepRe: /\s*(?::|;)\s*/,
    attributeTransform: {
        cls: "class",
        htmlFor: "for"
    },
    closeTags: {},
    decamelizeName: function() {
        function n(e, t, n) {
            return t + "-" + n.toLowerCase()
        }
        var e = /([a-z])([A-Z])/g,
        t = {};
        return function(r) {
            return t[r] || (t[r] = r.replace(e, n))
        }
    } (),
    generateMarkup: function(e, t) {
        var n = this,
        r = typeof e,
        i, s, o, u, a;
        if (r == "string" || r == "number") {
            t.push(e)
        } else {
            if (Ext.isArray(e)) {
                for (u = 0; u < e.length; u++) {
                    if (e[u]) {
                        n.generateMarkup(e[u], t)
                    }
                }
            } else {
                o = e.tag || "div";
                t.push("<", o);
                for (i in e) {
                    if (e.hasOwnProperty(i)) {
                        s = e[i];
                        if (!n.confRe.test(i)) {
                            if (typeof s == "object") {
                                t.push(" ", i, '="');
                                n.generateStyles(s, t, true).push('"')
                            } else {
                                t.push(" ", n.attributeTransform[i] || i, '="', s, '"')
                            }
                        }
                    }
                }
                if (n.emptyTags.test(o)) {
                    t.push("/>")
                } else {
                    t.push(">");
                    if (s = e.tpl) {
                        s.applyOut(e.tplData, t)
                    }
                    if (s = e.html) {
                        t.push(s)
                    }
                    if (s = e.cn || e.children) {
                        n.generateMarkup(s, t)
                    }
                    a = n.closeTags;
                    t.push(a[o] || (a[o] = "</" + o + ">"))
                }
            }
        }
        return t
    },
    generateStyles: function(e, t, n) {
        var r = t || [],
        i,
        s;
        for (i in e) {
            if (e.hasOwnProperty(i)) {
                s = e[i];
                i = this.decamelizeName(i);
                if (n && Ext.String.hasHtmlCharacters(s)) {
                    s = Ext.String.htmlEncode(s)
                }
                r.push(i, ":", s, ";")
            }
        }
        return t || r.join("")
    },
    markup: function(e) {
        if (typeof e == "string") {
            return e
        }
        var t = this.generateMarkup(e, []);
        return t.join("")
    },
    applyStyles: function(e, t) {
        if (t) {
            var n = 0,
            r;
            e = Ext.fly(e, "_applyStyles");
            if (typeof t == "function") {
                t = t.call()
            }
            if (typeof t == "string") {
                t = Ext.util.Format.trim(t).split(this.styleSepRe);
                for (r = t.length; n < r;) {
                    e.setStyle(t[n++], t[n++])
                }
            } else {
                if (Ext.isObject(t)) {
                    e.setStyle(t)
                }
            }
        }
    },
    insertHtml: function(e, t, n) {
        var r = {},
        i, s, o, u;
        e = e.toLowerCase();
        r.beforebegin = ["BeforeBegin", "previousSibling"];
        r.afterend = ["AfterEnd", "nextSibling"];
        s = t.ownerDocument.createRange();
        i = "setStart" + (this.endRe.test(e) ? "After": "Before");
        if (r[e]) {
            s[i](t);
            o = s.createContextualFragment(n);
            t.parentNode.insertBefore(o, e == "beforebegin" ? t: t.nextSibling);
            return t[(e == "beforebegin" ? "previous": "next") + "Sibling"]
        } else {
            u = (e == "afterbegin" ? "first": "last") + "Child";
            if (t.firstChild) {
                s[i](t[u]);
                o = s.createContextualFragment(n);
                if (e == "afterbegin") {
                    t.insertBefore(o, t.firstChild)
                } else {
                    t.appendChild(o)
                }
            } else {
                t.innerHTML = n
            }
            return t[u]
        }
        throw 'Illegal insertion point -> "' + e + '"'
    },
    insertBefore: function(e, t, n) {
        return this.doInsert(e, t, n, "beforebegin")
    },
    insertAfter: function(e, t, n) {
        return this.doInsert(e, t, n, "afterend", "nextSibling")
    },
    insertFirst: function(e, t, n) {
        return this.doInsert(e, t, n, "afterbegin", "firstChild")
    },
    append: function(e, t, n) {
        return this.doInsert(e, t, n, "beforeend", "", true)
    },
    overwrite: function(e, t, n) {
        e = Ext.getDom(e);
        e.innerHTML = this.markup(t);
        return n ? Ext.get(e.firstChild) : e.firstChild
    },
    doInsert: function(e, t, n, r, i, s) {
        var o = this.insertHtml(r, Ext.getDom(e), this.markup(t));
        return n ? Ext.get(o, true) : o
    }
});
Ext.define("Ext.dom.AbstractElement_static", {
    override: "Ext.dom.AbstractElement",
    inheritableStatics: {
        unitRe: /\d+(px|em|%|en|ex|pt|in|cm|mm|pc)$/i,
        camelRe: /(-[a-z])/gi,
        msRe: /^-ms-/,
        cssRe: /([a-z0-9\-]+)\s*:\s*([^;\s]+(?:\s*[^;\s]+)*)?;?/gi,
        opacityRe: /alpha\(opacity=(.*)\)/i,
        propertyCache: {},
        defaultUnit: "px",
        borders: {
            l: "border-left-width",
            r: "border-right-width",
            t: "border-top-width",
            b: "border-bottom-width"
        },
        paddings: {
            l: "padding-left",
            r: "padding-right",
            t: "padding-top",
            b: "padding-bottom"
        },
        margins: {
            l: "margin-left",
            r: "margin-right",
            t: "margin-top",
            b: "margin-bottom"
        },
        addUnits: function(e, t) {
            if (typeof e == "number") {
                return e + (t || this.defaultUnit || "px")
            }
            if (e === "" || e == "auto" || e === undefined || e === null) {
                return e || ""
            }
            if (!this.unitRe.test(e)) {
                return e || ""
            }
            return e
        },
        isAncestor: function(e, t) {
            var n = false;
            e = Ext.getDom(e);
            t = Ext.getDom(t);
            if (e && t) {
                if (e.contains) {
                    return e.contains(t)
                } else {
                    if (e.compareDocumentPosition) {
                        return !! (e.compareDocumentPosition(t) & 16)
                    } else {
                        while (t = t.parentNode) {
                            n = t == e || n
                        }
                    }
                }
            }
            return n
        },
        parseBox: function(e) {
            e = e || 0;
            var t = typeof e,
            n, r;
            if (t === "number") {
                return {
                    top: e,
                    right: e,
                    bottom: e,
                    left: e
                }
            } else {
                if (t !== "string") {
                    return e
                }
            }
            n = e.split(" ");
            r = n.length;
            if (r == 1) {
                n[1] = n[2] = n[3] = n[0]
            } else {
                if (r == 2) {
                    n[2] = n[0];
                    n[3] = n[1]
                } else {
                    if (r == 3) {
                        n[3] = n[1]
                    }
                }
            }
            return {
                top: parseFloat(n[0]) || 0,
                right: parseFloat(n[1]) || 0,
                bottom: parseFloat(n[2]) || 0,
                left: parseFloat(n[3]) || 0
            }
        },
        unitizeBox: function(e, t) {
            var n = this.addUnits,
            r = this.parseBox(e);
            return n(r.top, t) + " " + n(r.right, t) + " " + n(r.bottom, t) + " " + n(r.left, t)
        },
        camelReplaceFn: function(e, t) {
            return t.charAt(1).toUpperCase()
        },
        normalize: function(e) {
            if (e == "float") {
                e = Ext.supports.Float ? "cssFloat": "styleFloat"
            }
            return this.propertyCache[e] || (this.propertyCache[e] = e.replace(this.msRe, "ms-").replace(this.camelRe, this.camelReplaceFn))
        },
        getDocumentHeight: function() {
            return Math.max(!Ext.isStrict ? document.body.scrollHeight: document.documentElement.scrollHeight, this.getViewportHeight())
        },
        getDocumentWidth: function() {
            return Math.max(!Ext.isStrict ? document.body.scrollWidth: document.documentElement.scrollWidth, this.getViewportWidth())
        },
        getViewportHeight: function() {
            return window.innerHeight
        },
        getViewportWidth: function() {
            return window.innerWidth
        },
        getViewSize: function() {
            return {
                width: window.innerWidth,
                height: window.innerHeight
            }
        },
        getOrientation: function() {
            if (Ext.supports.OrientationChange) {
                return window.orientation == 0 ? "portrait": "landscape"
            }
            return window.innerHeight > window.innerWidth ? "portrait": "landscape"
        },
        fromPoint: function(e, t) {
            return Ext.get(document.elementFromPoint(e, t))
        },
        parseStyles: function(e) {
            var t = {},
            n = this.cssRe,
            r;
            if (e) {
                n.lastIndex = 0;
                while (r = n.exec(e)) {
                    t[r[1]] = r[2] || ""
                }
            }
            return t
        }
    }
},
function() {
    function r(e, t, n) {
        return function() {
            e.selectionStart = t;
            e.selectionEnd = n
        }
    }
    var e = document,
    t = null,
    n = e.compatMode == "CSS1Compat";
    if (! ("activeElement" in e) && e.addEventListener) {
        e.addEventListener("focus",
        function(n) {
            if (n && n.target) {
                t = n.target == e ? null: n.target
            }
        },
        true)
    }
    this.addInheritableStatics({
        getActiveElement: function() {
            var n;
            try {
                n = e.activeElement
            } catch(r) {}
            n = n || t;
            if (!n) {
                n = t = document.body
            }
            return n
        },
        getRightMarginFixCleaner: function(n) {
            var i = Ext.supports,
            s = i.DisplayChangeInputSelectionBug,
            o = i.DisplayChangeTextAreaSelectionBug,
            u, a, f, l;
            if (s || o) {
                u = e.activeElement || t;
                a = u && u.tagName;
                if (o && a == "TEXTAREA" || s && a == "INPUT" && u.type == "text") {
                    if (Ext.dom.Element.isAncestor(n, u)) {
                        f = u.selectionStart;
                        l = u.selectionEnd;
                        if (Ext.isNumber(f) && Ext.isNumber(l)) {
                            return r(u, f, l)
                        }
                    }
                }
            }
            return Ext.emptyFn
        },
        getViewWidth: function(e) {
            return e ? Ext.dom.Element.getDocumentWidth() : Ext.dom.Element.getViewportWidth()
        },
        getViewHeight: function(e) {
            return e ? Ext.dom.Element.getDocumentHeight() : Ext.dom.Element.getViewportHeight()
        },
        getDocumentHeight: function() {
            return Math.max(!n ? e.body.scrollHeight: e.documentElement.scrollHeight, Ext.dom.Element.getViewportHeight())
        },
        getDocumentWidth: function() {
            return Math.max(!n ? e.body.scrollWidth: e.documentElement.scrollWidth, Ext.dom.Element.getViewportWidth())
        },
        getViewportHeight: function() {
            return Ext.isIE9m ? Ext.isStrict ? e.documentElement.clientHeight: e.body.clientHeight: self.innerHeight
        },
        getViewportWidth: function() {
            return ! Ext.isStrict && !Ext.isOpera ? e.body.clientWidth: Ext.isIE9m ? e.documentElement.clientWidth: self.innerWidth
        },
        serializeForm: function(e) {
            var t = e.elements || (document.forms[e] || Ext.getDom(e)).elements,
            n = false,
            r = encodeURIComponent,
            i = "",
            s = t.length,
            o,
            u,
            a,
            f,
            l,
            c,
            h,
            p,
            d;
            for (c = 0; c < s; c++) {
                o = t[c];
                u = o.name;
                a = o.type;
                f = o.options;
                if (!o.disabled && u) {
                    if (/select-(one|multiple)/i.test(a)) {
                        p = f.length;
                        for (h = 0; h < p; h++) {
                            d = f[h];
                            if (d.selected) {
                                l = d.hasAttribute ? d.hasAttribute("value") : d.getAttributeNode("value").specified;
                                i += Ext.String.format("{0}={1}&", r(u), r(l ? d.value: d.text))
                            }
                        }
                    } else {
                        if (!/file|undefined|reset|button/i.test(a)) {
                            if (! (/radio|checkbox/i.test(a) && !o.checked) && !(a == "submit" && n)) {
                                i += r(u) + "=" + r(o.value) + "&";
                                n = /submit/i.test(a)
                            }
                        }
                    }
                }
            }
            return i.substr(0, i.length - 1)
        }
    })
});
Ext.define("Ext.dom.AbstractElement_insertion", {
    override: "Ext.dom.AbstractElement",
    appendChild: function(e, t) {
        var n = this,
        r, i, s, o;
        if (e.nodeType || e.dom || typeof e == "string") {
            e = Ext.getDom(e);
            n.dom.appendChild(e);
            return ! t ? Ext.get(e) : e
        } else {
            if (e.length) {
                r = Ext.fly(document.createDocumentFragment(), "_internal");
                i = e.length;
                Ext.DomHelper.useDom = true;
                for (s = 0; s < i; s++) {
                    r.appendChild(e[s], t)
                }
                Ext.DomHelper.useDom = o;
                n.dom.appendChild(r.dom);
                return t ? r.dom: r
            } else {
                return n.createChild(e, null, t)
            }
        }
    },
    appendTo: function(e) {
        Ext.getDom(e).appendChild(this.dom);
        return this
    },
    insertBefore: function(e) {
        e = Ext.getDom(e);
        e.parentNode.insertBefore(this.dom, e);
        return this
    },
    insertAfter: function(e) {
        e = Ext.getDom(e);
        e.parentNode.insertBefore(this.dom, e.nextSibling);
        return this
    },
    insertFirst: function(e, t) {
        e = e || {};
        if (e.nodeType || e.dom || typeof e == "string") {
            e = Ext.getDom(e);
            this.dom.insertBefore(e, this.dom.firstChild);
            return ! t ? Ext.get(e) : e
        } else {
            return this.createChild(e, this.dom.firstChild, t)
        }
    },
    insertSibling: function(e, t, n) {
        var r = this,
        i = Ext.core.DomHelper,
        s = i.useDom,
        o = (t || "before").toLowerCase() == "after",
        u,
        a,
        f,
        l;
        if (Ext.isArray(e)) {
            a = Ext.fly(document.createDocumentFragment(), "_internal");
            f = e.length;
            i.useDom = true;
            for (l = 0; l < f; l++) {
                u = a.appendChild(e[l], n)
            }
            i.useDom = s;
            r.dom.parentNode.insertBefore(a.dom, o ? r.dom.nextSibling: r.dom);
            return u
        }
        e = e || {};
        if (e.nodeType || e.dom) {
            u = r.dom.parentNode.insertBefore(Ext.getDom(e), o ? r.dom.nextSibling: r.dom);
            if (!n) {
                u = Ext.get(u)
            }
        } else {
            if (o && !r.dom.nextSibling) {
                u = i.append(r.dom.parentNode, e, !n)
            } else {
                u = i[o ? "insertAfter": "insertBefore"](r.dom, e, !n)
            }
        }
        return u
    },
    replace: function(e) {
        e = Ext.get(e);
        this.insertBefore(e);
        e.remove();
        return this
    },
    replaceWith: function(e) {
        var t = this;
        if (e.nodeType || e.dom || typeof e == "string") {
            e = Ext.get(e);
            t.dom.parentNode.insertBefore(e.dom, t.dom)
        } else {
            e = Ext.core.DomHelper.insertBefore(t.dom, e)
        }
        delete Ext.cache[t.id];
        Ext.removeNode(t.dom);
        t.id = Ext.id(t.dom = e);
        Ext.dom.AbstractElement.addToCache(t.isFlyweight ? new Ext.dom.AbstractElement(t.dom) : t);
        return t
    },
    createChild: function(e, t, n) {
        e = e || {
            tag: "div"
        };
        if (t) {
            return Ext.core.DomHelper.insertBefore(t, e, n !== true)
        } else {
            return Ext.core.DomHelper.append(this.dom, e, n !== true)
        }
    },
    wrap: function(e, t, n) {
        var r = Ext.core.DomHelper.insertBefore(this.dom, e || {
            tag: "div"
        },
        true),
        i = r;
        if (n) {
            i = Ext.DomQuery.selectNode(n, r.dom)
        }
        i.appendChild(this.dom);
        return t ? r.dom: r
    },
    insertHtml: function(e, t, n) {
        var r = Ext.core.DomHelper.insertHtml(e, this.dom, t);
        return n ? Ext.get(r) : r
    }
});
Ext.define("Ext.dom.AbstractElement_style", {
    override: "Ext.dom.AbstractElement"
},
function() {
    var e = this,
    t = /\w/g,
    n = /\s+/,
    r = /^(?:transparent|(?:rgba[(](?:\s*\d+\s*[,]){3}\s*0\s*[)]))$/i,
    i = Ext.supports.ClassList,
    s = "padding",
    o = "margin",
    u = "border",
    a = "-left",
    f = "-right",
    l = "-top",
    c = "-bottom",
    h = "-width",
    p = {
        l: u + a + h,
        r: u + f + h,
        t: u + l + h,
        b: u + c + h
    },
    d = {
        l: s + a,
        r: s + f,
        t: s + l,
        b: s + c
    },
    v = {
        l: o + a,
        r: o + f,
        t: o + l,
        b: o + c
    },
    m = new e.Fly;
    Ext.override(e, {
        styleHooks: {},
        addStyles: function(e, n) {
            var r = 0,
            i = (e || "").match(t),
            s,
            o = i.length,
            u,
            a = [];
            if (o == 1) {
                r = Math.abs(parseFloat(this.getStyle(n[i[0]])) || 0)
            } else {
                if (o) {
                    for (s = 0; s < o; s++) {
                        u = i[s];
                        a.push(n[u])
                    }
                    a = this.getStyle(a);
                    for (s = 0; s < o; s++) {
                        u = i[s];
                        r += Math.abs(parseFloat(a[n[u]]) || 0)
                    }
                }
            }
            return r
        },
        addCls: function() {
            var e = function(e) {
                var r = this,
                i = r.dom,
                s = r.trimRe,
                o = e,
                u, a, f, l, c;
                if (typeof e == "string") {
                    e = e.replace(s, "").split(n)
                }
                if (i && e && !!(l = e.length)) {
                    if (!i.className) {
                        i.className = e.join(" ")
                    } else {
                        u = i.classList;
                        if (u) {
                            for (f = 0; f < l; ++f) {
                                c = e[f];
                                if (c) {
                                    if (!u.contains(c)) {
                                        if (a) {
                                            a.push(c)
                                        } else {
                                            a = i.className.replace(s, "");
                                            a = a ? [a, c] : [c]
                                        }
                                    }
                                }
                            }
                            if (a) {
                                i.className = a.join(" ")
                            }
                        } else {
                            t(o)
                        }
                    }
                }
                return r
            },
            t = function(e) {
                var t = this,
                n = t.dom,
                r;
                if (n && e && e.length) {
                    r = Ext.Element.mergeClsList(n.className, e);
                    if (r.changed) {
                        n.className = r.join(" ")
                    }
                }
                return t
            };
            return i ? e: t
        } (),
        removeCls: function(e) {
            var t = this,
            r = t.dom,
            i, s, o;
            if (typeof e == "string") {
                e = e.replace(t.trimRe, "").split(n)
            }
            if (r && r.className && e && !!(s = e.length)) {
                i = r.classList;
                if (s === 1 && i) {
                    if (e[0]) {
                        i.remove(e[0])
                    }
                } else {
                    o = Ext.Element.removeCls(r.className, e);
                    if (o.changed) {
                        r.className = o.join(" ")
                    }
                }
            }
            return t
        },
        radioCls: function(e) {
            var t = this.dom.parentNode.childNodes,
            n, r, i;
            e = Ext.isArray(e) ? e: [e];
            for (r = 0, i = t.length; r < i; r++) {
                n = t[r];
                if (n && n.nodeType == 1) {
                    m.attach(n).removeCls(e)
                }
            }
            return this.addCls(e)
        },
        toggleCls: function() {
            var e = function(e) {
                var n = this,
                r = n.dom,
                i;
                if (r) {
                    e = e.replace(n.trimRe, "");
                    if (e) {
                        i = r.classList;
                        if (i) {
                            i.toggle(e)
                        } else {
                            t(e)
                        }
                    }
                }
                return n
            },
            t = function(e) {
                return this.hasCls(e) ? this.removeCls(e) : this.addCls(e)
            };
            return i ? e: t
        } (),
        hasCls: function() {
            var e = function(e) {
                var n = this.dom,
                r = false,
                i;
                if (n && e) {
                    i = n.classList;
                    if (i) {
                        r = i.contains(e)
                    } else {
                        r = t(e)
                    }
                }
                return r
            },
            t = function(e) {
                var t = this.dom;
                return t ? e && (" " + t.className + " ").indexOf(" " + e + " ") !== -1 : false
            };
            return i ? e: t
        } (),
        replaceCls: function(e, t) {
            return this.removeCls(e).addCls(t)
        },
        isStyle: function(e, t) {
            return this.getStyle(e) == t
        },
        getStyle: function(t, n) {
            var r = this,
            i = r.dom,
            s = typeof t != "string",
            o = r.styleHooks,
            u = t,
            a = u,
            f = 1,
            l, c, h, p, d, v, m;
            if (s) {
                h = {};
                u = a[0];
                m = 0;
                if (! (f = a.length)) {
                    return h
                }
            }
            if (!i || i.documentElement) {
                return h || ""
            }
            l = i.style;
            if (n) {
                v = l
            } else {
                v = i.ownerDocument.defaultView.getComputedStyle(i, null);
                if (!v) {
                    n = true;
                    v = l
                }
            }
            do {
                p = o[u];
                if (!p) {
                    o[u] = p = {
                        name: e.normalize(u)
                    }
                }
                if (p.get) {
                    d = p.get(i, r, n, v)
                } else {
                    c = p.name;
                    d = v[c]
                }
                if (!s) {
                    return d
                }
                h[u] = d;
                u = a[++m]
            } while ( m < f );
            return h
        },
        getStyles: function() {
            var e = Ext.Array.slice(arguments),
            t = e.length,
            n;
            if (t && typeof e[t - 1] == "boolean") {
                n = e.pop()
            }
            return this.getStyle(e, n)
        },
        isTransparent: function(e) {
            var t = this.getStyle(e);
            return t ? r.test(t) : false
        },
        setStyle: function(t, n) {
            var r = this,
            i = r.dom,
            s = r.styleHooks,
            o = i.style,
            u = t,
            a;
            if (typeof u == "string") {
                a = s[u];
                if (!a) {
                    s[u] = a = {
                        name: e.normalize(u)
                    }
                }
                n = n == null ? "": n;
                if (a.set) {
                    a.set(i, n, r)
                } else {
                    o[a.name] = n
                }
                if (a.afterSet) {
                    a.afterSet(i, n, r)
                }
            } else {
                for (u in t) {
                    if (t.hasOwnProperty(u)) {
                        a = s[u];
                        if (!a) {
                            s[u] = a = {
                                name: e.normalize(u)
                            }
                        }
                        n = t[u];
                        n = n == null ? "": n;
                        if (a.set) {
                            a.set(i, n, r)
                        } else {
                            o[a.name] = n
                        }
                        if (a.afterSet) {
                            a.afterSet(i, n, r)
                        }
                    }
                }
            }
            return r
        },
        getHeight: function(e) {
            var t = this.dom,
            n = e ? t.clientHeight - this.getPadding("tb") : t.offsetHeight;
            return n > 0 ? n: 0
        },
        getWidth: function(e) {
            var t = this.dom,
            n = e ? t.clientWidth - this.getPadding("lr") : t.offsetWidth;
            return n > 0 ? n: 0
        },
        setWidth: function(t) {
            var n = this;
            n.dom.style.width = e.addUnits(t);
            return n
        },
        setHeight: function(t) {
            var n = this;
            n.dom.style.height = e.addUnits(t);
            return n
        },
        getBorderWidth: function(e) {
            return this.addStyles(e, p)
        },
        getPadding: function(e) {
            return this.addStyles(e, d)
        },
        margins: v,
        applyStyles: function(t) {
            if (t) {
                var n, r, i = this.dom;
                if (typeof t == "function") {
                    t = t.call()
                }
                if (typeof t == "string") {
                    t = Ext.util.Format.trim(t).split(/\s*(?::|;)\s*/);
                    for (n = 0, r = t.length; n < r;) {
                        i.style[e.normalize(t[n++])] = t[n++]
                    }
                } else {
                    if (typeof t == "object") {
                        this.setStyle(t)
                    }
                }
            }
        },
        setSize: function(t, n) {
            var r = this,
            i = r.dom.style;
            if (Ext.isObject(t)) {
                n = t.height;
                t = t.width
            }
            i.width = e.addUnits(t);
            i.height = e.addUnits(n);
            return r
        },
        getViewSize: function() {
            var t = document,
            n = this.dom;
            if (n == t || n == t.body) {
                return {
                    width: e.getViewportWidth(),
                    height: e.getViewportHeight()
                }
            } else {
                return {
                    width: n.clientWidth,
                    height: n.clientHeight
                }
            }
        },
        getSize: function(e) {
            var t = this.dom;
            return {
                width: Math.max(0, e ? t.clientWidth - this.getPadding("lr") : t.offsetWidth),
                height: Math.max(0, e ? t.clientHeight - this.getPadding("tb") : t.offsetHeight)
            }
        },
        repaint: function() {
            var e = this.dom;
            this.addCls(Ext.baseCSSPrefix + "repaint");
            setTimeout(function() {
                m.attach(e).removeCls(Ext.baseCSSPrefix + "repaint")
            },
            1);
            return this
        },
        getMargin: function(e) {
            var t = this,
            n = {
                t: "top",
                l: "left",
                r: "right",
                b: "bottom"
            },
            r,
            i,
            s;
            if (!e) {
                s = [];
                for (r in t.margins) {
                    if (t.margins.hasOwnProperty(r)) {
                        s.push(t.margins[r])
                    }
                }
                i = t.getStyle(s);
                if (i && typeof i == "object") {
                    for (r in t.margins) {
                        if (t.margins.hasOwnProperty(r)) {
                            i[n[r]] = parseFloat(i[t.margins[r]]) || 0
                        }
                    }
                }
                return i
            } else {
                return t.addStyles(e, t.margins)
            }
        },
        mask: function(e, t, n) {
            var r = this,
            i = r.dom,
            s = (r.$cache || r.getCache()).data,
            o = s.mask,
            u,
            a,
            f = "",
            l = Ext.baseCSSPrefix;
            r.addCls(l + "masked");
            if (r.getStyle("position") == "static") {
                r.addCls(l + "masked-relative")
            }
            if (o) {
                o.remove()
            }
            if (t && typeof t == "string") {
                f = " " + t
            } else {
                f = " " + l + "mask-gray"
            }
            u = r.createChild({
                role: "presentation",
                cls: l + "mask" + (n !== false ? "": " " + l + "mask-gray"),
                html: e ? '<div class="' + (t || l + "mask-message") + '" role="presentation">' + e + "</div>": ""
            });
            a = r.getSize();
            s.mask = u;
            if (i === document.body) {
                a.height = window.innerHeight;
                if (r.orientationHandler) {
                    Ext.EventManager.unOrientationChange(r.orientationHandler, r)
                }
                r.orientationHandler = function() {
                    a = r.getSize();
                    a.height = window.innerHeight;
                    u.setSize(a)
                };
                Ext.EventManager.onOrientationChange(r.orientationHandler, r)
            }
            u.setSize(a);
            if (Ext.is.iPad) {
                Ext.repaint()
            }
        },
        unmask: function() {
            var e = this,
            t = (e.$cache || e.getCache()).data,
            n = t.mask,
            r = Ext.baseCSSPrefix;
            if (n) {
                n.remove();
                delete t.mask
            }
            e.removeCls([r + "masked", r + "masked-relative"]);
            if (e.dom === document.body) {
                Ext.EventManager.unOrientationChange(e.orientationHandler, e);
                delete e.orientationHandler
            }
        }
    });
    Ext.onReady(function() {
        function a(e, t, n, i) {
            var s = i[this.name] || "";
            return r.test(s) ? "transparent": s
        }
        function f(e, t, n, r) {
            var i = r.marginRight,
            s, o;
            if (i != "0px") {
                s = e.style;
                o = s.display;
                s.display = "inline-block";
                i = (n ? r: e.ownerDocument.defaultView.getComputedStyle(e, null)).marginRight;
                s.display = o
            }
            return i
        }
        function l(t, n, r, i) {
            var s = i.marginRight,
            o, u, a;
            if (s != "0px") {
                o = t.style;
                u = e.getRightMarginFixCleaner(t);
                a = o.display;
                o.display = "inline-block";
                s = (r ? i: t.ownerDocument.defaultView.getComputedStyle(t, "")).marginRight;
                o.display = a;
                u()
            }
            return s
        }
        var t = Ext.supports,
        n, i, s, o, u;
        n = e.prototype.styleHooks;
        if (t.init) {
            t.init()
        }
        if (!t.RightMargin) {
            n.marginRight = n["margin-right"] = {
                name: "marginRight",
                get: t.DisplayChangeInputSelectionBug || t.DisplayChangeTextAreaSelectionBug ? l: f
            }
        }
        if (!t.TransparentColor) {
            i = ["background-color", "border-color", "color", "outline-color"];
            for (s = i.length; s--;) {
                o = i[s];
                u = e.normalize(o);
                n[o] = n[u] = {
                    name: u,
                    get: a
                }
            }
        }
    })
});
Ext.define("Ext.dom.AbstractElement_traversal", {
    override: "Ext.dom.AbstractElement",
    findParent: function(e, t, n) {
        var r = this.dom,
        i = document.documentElement,
        s = 0,
        o;
        t = t || 50;
        if (isNaN(t)) {
            o = Ext.getDom(t);
            t = Number.MAX_VALUE
        }
        while (r && r.nodeType == 1 && s < t && r != i && r != o) {
            if (Ext.DomQuery.is(r, e)) {
                return n ? Ext.get(r) : r
            }
            s++;
            r = r.parentNode
        }
        return null
    },
    findParentNode: function(e, t, n) {
        var r = Ext.fly(this.dom.parentNode, "_internal");
        return r ? r.findParent(e, t, n) : null
    },
    up: function(e, t, n) {
        return this.findParentNode(e, t, !n)
    },
    select: function(e, t) {
        return Ext.dom.Element.select(e, this.dom, t)
    },
    query: function(e) {
        return Ext.DomQuery.select(e, this.dom)
    },
    down: function(e, t) {
        var n = Ext.DomQuery.selectNode(e, this.dom);
        return t ? n: Ext.get(n)
    },
    child: function(e, t) {
        var n, r = this,
        i;
        i = Ext.id(r.dom);
        i = Ext.escapeId(i);
        n = Ext.DomQuery.selectNode("#" + i + " > " + e, r.dom);
        return t ? n: Ext.get(n)
    },
    parent: function(e, t) {
        return this.matchNode("parentNode", "parentNode", e, t)
    },
    next: function(e, t) {
        return this.matchNode("nextSibling", "nextSibling", e, t)
    },
    prev: function(e, t) {
        return this.matchNode("previousSibling", "previousSibling", e, t)
    },
    first: function(e, t) {
        return this.matchNode("nextSibling", "firstChild", e, t)
    },
    last: function(e, t) {
        return this.matchNode("previousSibling", "lastChild", e, t)
    },
    matchNode: function(e, t, n, r) {
        if (!this.dom) {
            return null
        }
        var i = this.dom[t];
        while (i) {
            if (i.nodeType == 1 && (!n || Ext.DomQuery.is(i, n))) {
                return ! r ? Ext.get(i) : i
            }
            i = i[e]
        }
        return null
    },
    isAncestor: function(e) {
        return this.self.isAncestor.call(this.self, this.dom, e)
    }
});
Ext.define("Ext.dom.AbstractElement", {
    trimRe: /^\s+|\s+$/g,
    whitespaceRe: /\s/,
    inheritableStatics: {
        trimRe: /^\s+|\s+$/g,
        whitespaceRe: /\s/,
        get: function(e) {
            var t = this,
            n = window.document,
            r = Ext.dom.Element,
            i, s, o, u, a;
            if (!e) {
                return null
            }
            if (e.isFly) {
                e = e.dom
            }
            if (typeof e == "string") {
                if (e == Ext.windowId) {
                    return r.get(window)
                } else {
                    if (e == Ext.documentId) {
                        return r.get(n)
                    }
                }
                i = Ext.cache[e];
                if (i && i.skipGarbageCollection) {
                    o = i.el;
                    return o
                }
                if (! (u = n.getElementById(e))) {
                    return null
                }
                if (i && i.el) {
                    o = Ext.updateCacheEntry(i, u).el
                } else {
                    o = new r(u, !!i)
                }
                return o
            } else {
                if (e.tagName) {
                    if (! (a = e.id)) {
                        a = Ext.id(e)
                    }
                    i = Ext.cache[a];
                    if (i && i.el) {
                        o = Ext.updateCacheEntry(i, e).el
                    } else {
                        o = new r(e, !!i)
                    }
                    return o
                } else {
                    if (e instanceof t) {
                        if (e != t.docEl && e != t.winEl) {
                            a = e.id;
                            i = Ext.cache[a];
                            if (i) {
                                Ext.updateCacheEntry(i, n.getElementById(a) || e.dom)
                            }
                        }
                        return e
                    } else {
                        if (e.isComposite) {
                            return e
                        } else {
                            if (Ext.isArray(e)) {
                                return t.select(e)
                            } else {
                                if (e === n) {
                                    if (!t.docEl) {
                                        s = t.docEl = Ext.Object.chain(r.prototype);
                                        s.dom = n;
                                        s.el = s;
                                        s.id = Ext.id(n);
                                        t.addToCache(s)
                                    }
                                    return t.docEl
                                } else {
                                    if (e === window) {
                                        if (!t.winEl) {
                                            t.winEl = Ext.Object.chain(r.prototype);
                                            t.winEl.dom = window;
                                            t.winEl.id = Ext.id(window);
                                            t.addToCache(t.winEl)
                                        }
                                        return t.winEl
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return null
        },
        addToCache: function(e, t) {
            if (e) {
                Ext.addCacheEntry(t, e)
            }
            return e
        },
        addMethods: function() {
            this.override.apply(this, arguments)
        },
        mergeClsList: function() {
            var e, t = {},
            n, r, i, s, o, u = [],
            a = false,
            f = this.trimRe,
            l = this.whitespaceRe;
            for (n = 0, r = arguments.length; n < r; n++) {
                e = arguments[n];
                if (Ext.isString(e)) {
                    e = e.replace(f, "").split(l)
                }
                if (e) {
                    for (i = 0, s = e.length; i < s; i++) {
                        o = e[i];
                        if (!t[o]) {
                            if (n) {
                                a = true
                            }
                            t[o] = true
                        }
                    }
                }
            }
            for (o in t) {
                u.push(o)
            }
            u.changed = a;
            return u
        },
        removeCls: function(e, t) {
            var n = {},
            r, i, s, o = [],
            u = false,
            a = this.whitespaceRe;
            if (e) {
                if (Ext.isString(e)) {
                    e = e.replace(this.trimRe, "").split(a)
                }
                for (r = 0, i = e.length; r < i; r++) {
                    n[e[r]] = true
                }
            }
            if (t) {
                if (Ext.isString(t)) {
                    t = t.split(a)
                }
                for (r = 0, i = t.length; r < i; r++) {
                    s = t[r];
                    if (n[s]) {
                        u = true;
                        delete n[s]
                    }
                }
            }
            for (s in n) {
                o.push(s)
            }
            o.changed = u;
            return o
        },
        VISIBILITY: 1,
        DISPLAY: 2,
        OFFSETS: 3,
        ASCLASS: 4
    },
    constructor: function(e, t) {
        var n = this,
        r = typeof e == "string" ? document.getElementById(e) : e,
        i;
        n.el = n;
        if (!r) {
            return null
        }
        i = r.id;
        if (!t && i && Ext.cache[i]) {
            return Ext.cache[i].el
        }
        n.dom = r;
        n.id = i || Ext.id(r);
        n.self.addToCache(n)
    },
    set: function(e, t) {
        var n = this.dom,
        r, i;
        for (r in e) {
            if (e.hasOwnProperty(r)) {
                i = e[r];
                if (r == "style") {
                    this.applyStyles(i)
                } else {
                    if (r == "cls") {
                        n.className = i
                    } else {
                        if (t !== false) {
                            if (i === undefined) {
                                n.removeAttribute(r)
                            } else {
                                n.setAttribute(r, i)
                            }
                        } else {
                            n[r] = i
                        }
                    }
                }
            }
        }
        return this
    },
    defaultUnit: "px",
    is: function(e) {
        return Ext.DomQuery.is(this.dom, e)
    },
    getValue: function(e) {
        var t = this.dom.value;
        return e ? parseInt(t, 10) : t
    },
    remove: function() {
        var e = this,
        t = e.dom;
        if (e.isAnimate) {
            e.stopAnimation()
        }
        if (t) {
            Ext.removeNode(t);
            delete e.dom
        }
    },
    contains: function() {
        var e = function(e) {
            var t;
            try {
                e = e.dom || e
            } catch(n) {
                return true
            }
            t = HTMLElement.prototype.toString.call(e);
            return t === "[xpconnect wrapped native prototype]" || t === "[object XULElement]"
        };
        return function(t) {
            if (!t || Ext.isGecko3 && e(t)) {
                return false
            }
            var n = this,
            r = t.dom || t;
            return r === n.dom || Ext.dom.AbstractElement.isAncestor(n.dom, r)
        }
    } (),
    getAttribute: function(e, t) {
        var n = this.dom;
        return n.getAttributeNS(t, e) || n.getAttribute(t + ":" + e) || n.getAttribute(e) || n[e]
    },
    update: function(e) {
        if (this.dom) {
            this.dom.innerHTML = e
        }
        return this
    },
    setHTML: function(e) {
        if (this.dom) {
            this.dom.innerHTML = e
        }
        return this
    },
    getHTML: function() {
        return this.dom ? this.dom.innerHTML: ""
    },
    hide: function() {
        this.setVisible(false);
        return this
    },
    show: function() {
        this.setVisible(true);
        return this
    },
    setVisible: function(e, t) {
        var n = this,
        r = n.self,
        i = n.getVisibilityMode(),
        s = Ext.baseCSSPrefix;
        switch (i) {
        case r.VISIBILITY:
            n.removeCls([s + "hidden-display", s + "hidden-offsets"]);
            n[e ? "removeCls": "addCls"](s + "hidden-visibility");
            break;
        case r.DISPLAY:
            n.removeCls([s + "hidden-visibility", s + "hidden-offsets"]);
            n[e ? "removeCls": "addCls"](s + "hidden-display");
            break;
        case r.OFFSETS:
            n.removeCls([s + "hidden-visibility", s + "hidden-display"]);
            n[e ? "removeCls": "addCls"](s + "hidden-offsets");
            break
        }
        return n
    },
    getVisibilityMode: function() {
        var e = (this.$cache || this.getCache()).data,
        t = e.visibilityMode;
        if (t === undefined) {
            e.visibilityMode = t = this.self.DISPLAY
        }
        return t
    },
    setVisibilityMode: function(e) { (this.$cache || this.getCache()).data.visibilityMode = e;
        return this
    },
    getCache: function() {
        var e = this,
        t = e.dom.id || Ext.id(e.dom);
        e.$cache = Ext.cache[t] || Ext.addCacheEntry(t, null, e.dom);
        return e.$cache
    }
},
function() {
    var e = this;
    Ext.getDetachedBody = function() {
        var t = e.detachedBodyEl;
        if (!t) {
            t = document.createElement("div");
            e.detachedBodyEl = t = new e.Fly(t);
            t.isDetachedBody = true
        }
        return t
    };
    Ext.getElementById = function(t) {
        var n = document.getElementById(t),
        r;
        if (!n && (r = e.detachedBodyEl)) {
            n = r.dom.querySelector("#" + Ext.escapeId(t))
        }
        return n
    };
    Ext.get = function(e) {
        return Ext.dom.Element.get(e)
    };
    this.addStatics({
        Fly: new Ext.Class({
            extend: e,
            isFly: true,
            constructor: function(e) {
                this.dom = e;
                this.el = this
            },
            attach: function(e) {
                this.dom = e;
                this.$cache = e && e.id ? Ext.cache[e.id] : null;
                return this
            }
        }),
        _flyweights: {},
        fly: function(t, n) {
            var r = null,
            i = e._flyweights;
            n = n || "_global";
            t = Ext.getDom(t);
            if (t) {
                r = i[n] || (i[n] = new e.Fly);
                r.dom = t;
                r.$cache = t.id ? Ext.cache[t.id] : null
            }
            return r
        }
    });
    Ext.fly = function() {
        return e.fly.apply(e, arguments)
    }; (function(e) {
        e.destroy = e.remove;
        if (document.querySelector) {
            e.getById = function(e, t) {
                var n = document.getElementById(e) || this.dom.querySelector("#" + Ext.escapeId(e));
                return t ? n: n ? Ext.get(n) : null
            }
        } else {
            e.getById = function(e, t) {
                var n = document.getElementById(e);
                return t ? n: n ? Ext.get(n) : null
            }
        }
    })(this.prototype)
});
Ext.define("Ext.dom.Helper",
function() {
    var e = "afterbegin",
    t = "afterend",
    n = "beforebegin",
    r = "beforeend",
    i = "<table>",
    s = "</table>",
    o = i + "<tbody>",
    u = "</tbody>" + s,
    a = o + "<tr>",
    f = "</tr>" + u,
    l = document.createElement("div"),
    c = ["BeforeBegin", "previousSibling"],
    h = ["AfterEnd", "nextSibling"],
    p = {
        beforebegin: c,
        afterend: h
    },
    d = {
        beforebegin: c,
        afterend: h,
        afterbegin: ["AfterBegin", "firstChild"],
        beforeend: ["BeforeEnd", "lastChild"]
    };
    return {
        extend: Ext.dom.AbstractHelper,
        tableRe: /^(?:table|thead|tbody|tr|td)$/i,
        tableElRe: /td|tr|tbody|thead/i,
        useDom: false,
        createDom: function(e, t) {
            var n, r = document,
            i, s, o, u, a, f;
            if (Ext.isArray(e)) {
                n = r.createDocumentFragment();
                for (a = 0, f = e.length; a < f; a++) {
                    this.createDom(e[a], n)
                }
            } else {
                if (typeof e == "string") {
                    n = r.createTextNode(e)
                } else {
                    n = r.createElement(e.tag || "div");
                    i = !!n.setAttribute;
                    for (s in e) {
                        if (!this.confRe.test(s)) {
                            o = e[s];
                            if (s == "cls") {
                                n.className = o
                            } else {
                                if (i) {
                                    n.setAttribute(s, o)
                                } else {
                                    n[s] = o
                                }
                            }
                        }
                    }
                    Ext.DomHelper.applyStyles(n, e.style);
                    if (u = e.children || e.cn) {
                        this.createDom(u, n)
                    } else {
                        if (e.html) {
                            n.innerHTML = e.html
                        }
                    }
                }
            }
            if (t) {
                t.appendChild(n)
            }
            return n
        },
        ieTable: function(e, t, n, r) {
            l.innerHTML = [t, n, r].join("");
            var i = -1,
            s = l,
            o;
            while (++i < e) {
                s = s.firstChild
            }
            o = s.nextSibling;
            if (o) {
                o = s;
                s = document.createDocumentFragment();
                while (o) {
                    nx = o.nextSibling;
                    s.appendChild(o);
                    o = nx
                }
            }
            return s
        },
        insertIntoTable: function(l, c, h, p) {
            var d, v, g = c == n,
            y = c == e,
            w = c == r,
            E = c == t;
            if (l == "td" && (y || w) || !this.tableElRe.test(l) && (g || E)) {
                return null
            }
            v = g ? h: E ? h.nextSibling: y ? h.firstChild: null;
            if (g || E) {
                h = h.parentNode
            }
            if (l == "td" || l == "tr" && (w || y)) {
                d = this.ieTable(4, a, p, f)
            } else {
                if ((l == "tbody" || l == "thead") && (w || y) || l == "tr" && (g || E)) {
                    d = this.ieTable(3, o, p, u)
                } else {
                    d = this.ieTable(2, i, p, s)
                }
            }
            h.insertBefore(d, v);
            return d
        },
        createContextualFragment: function(e) {
            var t = document.createDocumentFragment(),
            n,
            r;
            l.innerHTML = e;
            r = l.childNodes;
            n = r.length;
            while (n--) {
                t.appendChild(r[0])
            }
            return t
        },
        applyStyles: function(e, t) {
            if (t) {
                if (typeof t == "function") {
                    t = t.call()
                }
                if (typeof t == "string") {
                    t = Ext.dom.Element.parseStyles(t)
                }
                if (typeof t == "object") {
                    Ext.fly(e, "_applyStyles").setStyle(t)
                }
            }
        },
        createHtml: function(e) {
            return this.markup(e)
        },
        doInsert: function(e, t, n, r, i, s) {
            e = e.dom || Ext.getDom(e);
            var o;
            if (this.useDom) {
                o = this.createDom(t, null);
                if (s) {
                    e.appendChild(o)
                } else { (i == "firstChild" ? e: e.parentNode).insertBefore(o, e[i] || e)
                }
            } else {
                o = this.insertHtml(r, e, this.markup(t))
            }
            return n ? Ext.get(o, true) : o
        },
        overwrite: function(e, t, n) {
            var r;
            e = Ext.getDom(e);
            t = this.markup(t);
            if (Ext.isIE && this.tableRe.test(e.tagName)) {
                while (e.firstChild) {
                    e.removeChild(e.firstChild)
                }
                if (t) {
                    r = this.insertHtml("afterbegin", e, t);
                    return n ? Ext.get(r) : r
                }
                return null
            }
            e.innerHTML = t;
            return n ? Ext.get(e.firstChild) : e.firstChild
        },
        insertHtml: function(t, r, i) {
            var s, o, u, a, f;
            t = t.toLowerCase();
            if (r.insertAdjacentHTML) {
                if (Ext.isIE && this.tableRe.test(r.tagName) && (f = this.insertIntoTable(r.tagName.toLowerCase(), t, r, i))) {
                    return f
                }
                if (s = d[t]) {
                    if (Ext.global.MSApp && Ext.global.MSApp.execUnsafeLocalFunction) {
                        MSApp.execUnsafeLocalFunction(function() {
                            r.insertAdjacentHTML(s[0], i)
                        })
                    } else {
                        r.insertAdjacentHTML(s[0], i)
                    }
                    return r[s[1]]
                }
            } else {
                if (r.nodeType === 3) {
                    t = t === "afterbegin" ? "beforebegin": t;
                    t = t === "beforeend" ? "afterend": t
                }
                o = Ext.supports.CreateContextualFragment ? r.ownerDocument.createRange() : undefined;
                a = "setStart" + (this.endRe.test(t) ? "After": "Before");
                if (p[t]) {
                    if (o) {
                        o[a](r);
                        f = o.createContextualFragment(i)
                    } else {
                        f = this.createContextualFragment(i)
                    }
                    r.parentNode.insertBefore(f, t == n ? r: r.nextSibling);
                    return r[(t == n ? "previous": "next") + "Sibling"]
                } else {
                    u = (t == e ? "first": "last") + "Child";
                    if (r.firstChild) {
                        if (o) {
                            o[a](r[u]);
                            f = o.createContextualFragment(i)
                        } else {
                            f = this.createContextualFragment(i)
                        }
                        if (t == e) {
                            r.insertBefore(f, r.firstChild)
                        } else {
                            r.appendChild(f)
                        }
                    } else {
                        r.innerHTML = i
                    }
                    return r[u]
                }
            }
        },
        createTemplate: function(e) {
            var t = this.markup(e);
            return new Ext.Template(t)
        }
    }
} (),
function() {
    Ext.ns("Ext.core");
    Ext.DomHelper = Ext.core.DomHelper = new this
});
Ext.define("Ext.Template", {
    inheritableStatics: {
        from: function(e, t) {
            e = Ext.getDom(e);
            return new this(e.value || e.innerHTML, t || "")
        }
    },
    useEval: Ext.isGecko,
    constructor: function(e) {
        var t = this,
        n = arguments,
        r = [],
        i = 0,
        s = n.length,
        o;
        t.initialConfig = {};
        if (s === 1 && Ext.isArray(e)) {
            n = e;
            s = n.length
        }
        if (s > 1) {
            for (; i < s; i++) {
                o = n[i];
                if (typeof o == "object") {
                    Ext.apply(t.initialConfig, o);
                    Ext.apply(t, o)
                } else {
                    r.push(o)
                }
            }
        } else {
            r.push(e)
        }
        t.html = r.join("");
        if (t.compiled) {
            t.compile()
        }
    },
    isTemplate: true,
    disableFormats: false,
    re: /\{(?:(?:(\d*)|([\w\-]+))(?:\:([A-Za-z_\.]*)(?:\((.*?)?\))?)?)\}/g,
    apply: function(e) {
        if (this.compiled) {
            return this.compiled(e).join("")
        }
        return this.evaluate(e)
    },
    evaluate: function(e) {
        function s(t, s, o, u, f) {
            if (o == null || o == "") {
                o = s
            }
            if (u && n) {
                if (f) {
                    f = [e[o]].concat(Ext.functionFactory("return [" + f + "];")())
                } else {
                    f = [e[o]]
                }
                if (u.substr(0, 5) === "this.") {
                    return i[u.substr(5)].apply(i, f)
                } else {
                    if (r[u]) {
                        return r[u].apply(r, f)
                    } else {
                        return t
                    }
                }
            } else {
                return e[o] !== undefined ? e[o] : ""
            }
        }
        var t = this,
        n = t.disableFormats !== true,
        r = Ext.util.Format,
        i = t;
        return t.html.replace(t.re, s)
    },
    applyOut: function(e, t) {
        var n = this;
        if (n.compiled) {
            t.push.apply(t, n.compiled(e))
        } else {
            t.push(n.apply(e))
        }
        return t
    },
    applyTemplate: function() {
        return this.apply.apply(this, arguments)
    },
    set: function(e, t) {
        var n = this;
        n.html = e;
        n.compiled = null;
        return t ? n.compile() : n
    },
    compileARe: /\\/g,
    compileBRe: /(\r\n|\n)/g,
    compileCRe: /'/g,
    compile: function() {
        var e = this,
        t;
        t = e.html.replace(e.compileARe, "\\\\").replace(e.compileBRe, "\\n").replace(e.compileCRe, "\\'").replace(e.re, Ext.Function.bind(e.regexReplaceFn, e));
        t = (this.disableFormats !== true ? "var fm=Ext.util.Format;": "") + (e.useEval ? "$=": "return") + " function(v){return ['" + t + "'];};";
        e.compiled = e.useEval ? e.evalCompiled(t) : (new Function("Ext", t))(Ext);
        return e
    },
    evalCompiled: function($) {
        eval($);
        return $
    },
    regexReplaceFn: function(t, n, r, i, s) {
        if (n == null || n == "") {
            n = '"' + r + '"'
        } else {
            if (this.stringFormat) {
                n = parseInt(n) + 1
            }
        }
        if (i && this.disableFormats !== true) {
            s = s ? "," + s: "";
            if (i.substr(0, 5) === "this.") {
                i = i + "("
            } else {
                if (Ext.util.Format[i]) {
                    i = "fm." + i + "("
                } else {
                    return t
                }
            }
            return "'," + i + "v[" + n + "]" + s + "),'"
        } else {
            return "',v[" + n + "] == undefined ? '' : v[" + n + "],'"
        }
    },
    insertFirst: function(e, t, n) {
        return this.doInsert("afterBegin", e, t, n)
    },
    insertBefore: function(e, t, n) {
        return this.doInsert("beforeBegin", e, t, n)
    },
    insertAfter: function(e, t, n) {
        return this.doInsert("afterEnd", e, t, n)
    },
    append: function(e, t, n) {
        return this.doInsert("beforeEnd", e, t, n)
    },
    doInsert: function(e, t, n, r) {
        var i = Ext.DomHelper.insertHtml(e, Ext.getDom(t), this.apply(n));
        return r ? Ext.get(i) : i
    },
    overwrite: function(e, t, n) {
        var r = Ext.DomHelper.overwrite(Ext.getDom(e), this.apply(t));
        return n ? Ext.get(r) : r
    }
});
Ext.define("Ext.XTemplateParser", {
    constructor: function(e) {
        Ext.apply(this, e)
    },
    doTpl: Ext.emptyFn,
    parse: function(e) {
        var t = this,
        n = e.length,
        r = {
            elseif: "elif"
        },
        i = t.topRe,
        s = t.actionsRe,
        o,
        u,
        a,
        f,
        l,
        c,
        h,
        p,
        d,
        v,
        m,
        g,
        y;
        t.level = 0;
        t.stack = u = [];
        for (o = 0; o < n; o = v) {
            i.lastIndex = o;
            f = i.exec(e);
            if (!f) {
                t.doText(e.substring(o, n));
                break
            }
            d = f.index;
            v = i.lastIndex;
            if (o < d) {
                a = e.substring(o, d);
                if (! (y && Ext.String.trim(a) === "")) {
                    t.doText(a)
                }
            }
            y = false;
            if (f[1]) {
                v = e.indexOf("%}", d + 2);
                t.doEval(e.substring(d + 2, v));
                v += 2
            } else {
                if (f[2]) {
                    v = e.indexOf("]}", d + 2);
                    t.doExpr(e.substring(d + 2, v));
                    v += 2
                } else {
                    if (f[3]) {
                        t.doTag(f[3])
                    } else {
                        if (f[4]) {
                            m = null;
                            while ((p = s.exec(f[4])) !== null) {
                                a = p[2] || p[3];
                                if (a) {
                                    a = Ext.String.htmlDecode(a);
                                    l = p[1];
                                    l = r[l] || l;
                                    m = m || {};
                                    c = m[l];
                                    if (typeof c == "string") {
                                        m[l] = [c, a]
                                    } else {
                                        if (c) {
                                            m[l].push(a)
                                        } else {
                                            m[l] = a
                                        }
                                    }
                                }
                            }
                            if (!m) {
                                if (t.elseRe.test(f[4])) {
                                    t.doElse()
                                } else {
                                    if (t.defaultRe.test(f[4])) {
                                        t.doDefault()
                                    } else {
                                        t.doTpl();
                                        u.push({
                                            type: "tpl"
                                        })
                                    }
                                }
                            } else {
                                if (m["if"]) {
                                    t.doIf(m["if"], m);
                                    u.push({
                                        type: "if"
                                    })
                                } else {
                                    if (m["switch"]) {
                                        t.doSwitch(m["switch"], m);
                                        u.push({
                                            type: "switch"
                                        });
                                        y = true
                                    } else {
                                        if (m["case"]) {
                                            t.doCase(m["case"], m)
                                        } else {
                                            if (m.elif) {
                                                t.doElseIf(m.elif, m)
                                            } else {
                                                if (m["for"]) {++t.level;
                                                    if (g = t.propRe.exec(f[4])) {
                                                        m.propName = g[1] || g[2]
                                                    }
                                                    t.doFor(m["for"], m);
                                                    u.push({
                                                        type: "for",
                                                        actions: m
                                                    })
                                                } else {
                                                    if (m.foreach) {++t.level;
                                                        if (g = t.propRe.exec(f[4])) {
                                                            m.propName = g[1] || g[2]
                                                        }
                                                        t.doForEach(m.foreach, m);
                                                        u.push({
                                                            type: "foreach",
                                                            actions: m
                                                        })
                                                    } else {
                                                        if (m.exec) {
                                                            t.doExec(m.exec, m);
                                                            u.push({
                                                                type: "exec",
                                                                actions: m
                                                            })
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if (f[0].length === 5) {
                                u.push({
                                    type: "tpl"
                                })
                            } else {
                                h = u.pop();
                                t.doEnd(h.type, h.actions);
                                if (h.type == "for" || h.type == "foreach") {--t.level
                                }
                            }
                        }
                    }
                }
            }
        }
    },
    topRe: /(?:(\{\%)|(\{\[)|\{([^{}]+)\})|(?:<tpl([^>]*)\>)|(?:<\/tpl>)/g,
    actionsRe: /\s*(elif|elseif|if|for|foreach|exec|switch|case|eval|between)\s*\=\s*(?:(?:"([^"]*)")|(?:'([^']*)'))\s*/g,
    propRe: /prop=(?:(?:"([^"]*)")|(?:'([^']*)'))/,
    defaultRe: /^\s*default\s*$/,
    elseRe: /^\s*else\s*$/
});
Ext.define("Ext.XTemplateCompiler", {
    extend: Ext.XTemplateParser,
    useEval: Ext.isGecko,
    useIndex: Ext.isIE8m,
    useFormat: true,
    propNameRe: /^[\w\d\$]*$/,
    compile: function(e) {
        var t = this,
        n = t.generate(e);
        return t.useEval ? t.evalTpl(n) : (new Function("Ext", n))(Ext)
    },
    generate: function(e) {
        var t = this,
        n = "var fm=Ext.util.Format,ts=Object.prototype.toString;",
        r;
        t.maxLevel = 0;
        t.body = ["var c0=values, a0=" + t.createArrayTest(0) + ", p0=parent, n0=xcount, i0=xindex, k0, v;\n"];
        if (t.definitions) {
            if (typeof t.definitions === "string") {
                t.definitions = [t.definitions, n]
            } else {
                t.definitions.push(n)
            }
        } else {
            t.definitions = [n]
        }
        t.switches = [];
        t.parse(e);
        t.definitions.push((t.useEval ? "$=": "return") + " function (" + t.fnArgs + ") {", t.body.join(""), "}");
        r = t.definitions.join("\n");
        t.definitions.length = t.body.length = t.switches.length = 0;
        delete t.definitions;
        delete t.body;
        delete t.switches;
        return r
    },
    doText: function(e) {
        var t = this,
        n = t.body;
        e = e.replace(t.aposRe, "\\'").replace(t.newLineRe, "\\n");
        if (t.useIndex) {
            n.push("out[out.length]='", e, "'\n")
        } else {
            n.push("out.push('", e, "')\n")
        }
    },
    doExpr: function(e) {
        var t = this.body;
        t.push("if ((v=" + e + ") != null) out");
        if (this.useIndex) {
            t.push("[out.length]=v+''\n")
        } else {
            t.push(".push(v+'')\n")
        }
    },
    doTag: function(e) {
        var t = this.parseTag(e);
        if (t) {
            this.doExpr(t)
        } else {
            this.doText("{" + e + "}")
        }
    },
    doElse: function() {
        this.body.push("} else {\n")
    },
    doEval: function(e) {
        this.body.push(e, "\n")
    },
    doIf: function(e, t) {
        var n = this;
        if (e === ".") {
            n.body.push("if (values) {\n")
        } else {
            if (n.propNameRe.test(e)) {
                n.body.push("if (", n.parseTag(e), ") {\n")
            } else {
                n.body.push("if (", n.addFn(e), n.callFn, ") {\n")
            }
        }
        if (t.exec) {
            n.doExec(t.exec)
        }
    },
    doElseIf: function(e, t) {
        var n = this;
        if (e === ".") {
            n.body.push("else if (values) {\n")
        } else {
            if (n.propNameRe.test(e)) {
                n.body.push("} else if (", n.parseTag(e), ") {\n")
            } else {
                n.body.push("} else if (", n.addFn(e), n.callFn, ") {\n")
            }
        }
        if (t.exec) {
            n.doExec(t.exec)
        }
    },
    doSwitch: function(e) {
        var t = this,
        n;
        if (e === "." || e === "#") {
            n = e === "." ? "values": "xindex";
            t.body.push("switch (", n, ") {\n")
        } else {
            if (t.propNameRe.test(e)) {
                t.body.push("switch (", t.parseTag(e), ") {\n")
            } else {
                t.body.push("switch (", t.addFn(e), t.callFn, ") {\n")
            }
        }
        t.switches.push(0)
    },
    doCase: function(e) {
        var t = this,
        n = Ext.isArray(e) ? e: [e],
        r = t.switches.length - 1,
        i,
        s;
        if (t.switches[r]) {
            t.body.push("break;\n")
        } else {
            t.switches[r]++
        }
        for (s = 0, r = n.length; s < r; ++s) {
            i = t.intRe.exec(n[s]);
            n[s] = i ? i[1] : "'" + n[s].replace(t.aposRe, "\\'") + "'"
        }
        t.body.push("case ", n.join(": case "), ":\n")
    },
    doDefault: function() {
        var e = this,
        t = e.switches.length - 1;
        if (e.switches[t]) {
            e.body.push("break;\n")
        } else {
            e.switches[t]++
        }
        e.body.push("default:\n")
    },
    doEnd: function(e, t) {
        var n = this,
        r = n.level - 1;
        if (e == "for" || e == "foreach") {
            if (t.exec) {
                n.doExec(t.exec)
            }
            n.body.push("}\n");
            n.body.push("parent=p", r, ";values=r", r + 1, ";xcount=n" + r + ";xindex=i", r, "+1;xkey=k", r, ";\n")
        } else {
            if (e == "if" || e == "switch") {
                n.body.push("}\n")
            }
        }
    },
    doFor: function(e, t) {
        var n = this,
        r, i = n.level,
        s = i - 1,
        o;
        if (e === ".") {
            r = "values"
        } else {
            if (n.propNameRe.test(e)) {
                r = n.parseTag(e)
            } else {
                r = n.addFn(e) + n.callFn
            }
        }
        if (n.maxLevel < i) {
            n.maxLevel = i;
            n.body.push("var ")
        }
        if (e == ".") {
            o = "c" + i
        } else {
            o = "a" + s + "?c" + s + "[i" + s + "]:c" + s
        }
        n.body.push("i", i, "=0,n", i, "=0,c", i, "=", r, ",a", i, "=", n.createArrayTest(i), ",r", i, "=values,p", i, ",k", i, ";\n", "p", i, "=parent=", o, "\n", "if (c", i, "){if(a", i, "){n", i, "=c", i, ".length;}else if (c", i, ".isMixedCollection){c", i, "=c", i, ".items;n", i, "=c", i, ".length;}else if(c", i, ".isStore){c", i, "=c", i, ".data.items;n", i, "=c", i, ".length;}else{c", i, "=[c", i, "];n", i, "=1;}}\n", "for (xcount=n", i, ";i", i, "<n" + i + ";++i", i, "){\n", "values=c", i, "[i", i, "]");
        if (t.propName) {
            n.body.push(".", t.propName)
        }
        n.body.push("\n", "xindex=i", i, "+1\n");
        if (t.between) {
            n.body.push('if(xindex>1){ out.push("', t.between, '"); } \n')
        }
    },
    doForEach: function(e, t) {
        var n = this,
        r, i = n.level,
        s = i - 1,
        o;
        if (e === ".") {
            r = "values"
        } else {
            if (n.propNameRe.test(e)) {
                r = n.parseTag(e)
            } else {
                r = n.addFn(e) + n.callFn
            }
        }
        if (n.maxLevel < i) {
            n.maxLevel = i;
            n.body.push("var ")
        }
        if (e == ".") {
            o = "c" + i
        } else {
            o = "a" + s + "?c" + s + "[i" + s + "]:c" + s
        }
        n.body.push("i", i, "=-1,n", i, "=0,c", i, "=", r, ",a", i, "=", n.createArrayTest(i), ",r", i, "=values,p", i, ",k", i, ";\n", "p", i, "=parent=", o, "\n", "for(k", i, " in c", i, "){\n", "xindex=++i", i, "+1;\n", "xkey=k", i, ";\n", "values=c", i, "[k", i, "];");
        if (t.propName) {
            n.body.push(".", t.propName)
        }
        if (t.between) {
            n.body.push('if(xindex>1){ out.push("', t.between, '"); } \n')
        }
    },
    createArrayTest: "isArray" in Array ?
    function(e) {
        return "Array.isArray(c" + e + ")"
    }: function(e) {
        return "ts.call(c" + e + ')==="[object Array]"'
    },
    doExec: function(e, t) {
        var n = this,
        r = "f" + n.definitions.length;
        n.definitions.push("function " + r + "(" + n.fnArgs + ") {", " try { with(values) {", "  " + e, " }} catch(e) {", "}", "}");
        n.body.push(r + n.callFn + "\n")
    },
    addFn: function(e) {
        var t = this,
        n = "f" + t.definitions.length;
        if (e === ".") {
            t.definitions.push("function " + n + "(" + t.fnArgs + ") {", " return values", "}")
        } else {
            if (e === "..") {
                t.definitions.push("function " + n + "(" + t.fnArgs + ") {", " return parent", "}")
            } else {
                t.definitions.push("function " + n + "(" + t.fnArgs + ") {", " try { with(values) {", "  return(" + e + ")", " }} catch(e) {", "}", "}")
            }
        }
        return n
    },
    parseTag: function(e) {
        var t = this,
        n = t.tagRe.exec(e),
        r,
        i,
        s,
        o,
        u;
        if (!n) {
            return null
        }
        r = n[1];
        i = n[2];
        s = n[3];
        o = n[4];
        if (r == ".") {
            if (!t.validTypes) {
                t.definitions.push("var validTypes={string:1,number:1,boolean:1};");
                t.validTypes = true
            }
            u = 'validTypes[typeof values] || ts.call(values) === "[object Date]" ? values : ""'
        } else {
            if (r == "#") {
                u = "xindex"
            } else {
                if (r == "$") {
                    u = "xkey"
                } else {
                    if (r.substr(0, 7) == "parent.") {
                        u = r
                    } else {
                        if (isNaN(r) && r.indexOf("-") == -1 && r.indexOf(".") != -1) {
                            u = "values." + r
                        } else {
                            u = "values['" + r + "']"
                        }
                    }
                }
            }
        }
        if (o) {
            u = "(" + u + o + ")"
        }
        if (i && t.useFormat) {
            s = s ? "," + s: "";
            if (i.substr(0, 5) != "this.") {
                i = "fm." + i + "("
            } else {
                i += "("
            }
        } else {
            return u
        }
        return i + u + s + ")"
    },
    evalTpl: function($) {
        eval($);
        return $
    },
    newLineRe: /\r\n|\r|\n/g,
    aposRe: /[']/g,
    intRe: /^\s*(\d+)\s*$/,
    tagRe: /^([\w-\.\#\$]+)(?:\:([\w\.]*)(?:\((.*?)?\))?)?(\s?[\+\-\*\/]\s?[\d\.\+\-\*\/\(\)]+)?$/
},
function() {
    var e = this.prototype;
    e.fnArgs = "out,values,parent,xindex,xcount,xkey";
    e.callFn = ".call(this," + e.fnArgs + ")"
});
Ext.define("Ext.XTemplate", {
    extend: Ext.Template,
    emptyObj: {},
    apply: function(e, t) {
        return this.applyOut(e, [], t).join("")
    },
    applyOut: function(e, t, n) {
        var r = this,
        i;
        if (!r.fn) {
            i = new Ext.XTemplateCompiler({
                useFormat: r.disableFormats !== true,
                definitions: r.definitions
            });
            r.fn = i.compile(r.html)
        }
        r.fn(t, e, n || r.emptyObj, 1, 1);
        return t
    },
    compile: function() {
        return this
    },
    statics: {
        getTpl: function(e, t) {
            var n = e[t],
            r;
            if (n && !n.isTemplate) {
                n = Ext.ClassManager.dynInstantiate("Ext.XTemplate", n);
                if (e.hasOwnProperty(t)) {
                    r = e
                } else {
                    for (r = e.self.prototype; r && !r.hasOwnProperty(t); r = r.superclass) {}
                }
                r[t] = n;
                n.owner = r
            }
            return n || null
        }
    }
});
Ext.ns("Ext.core");
Ext.dom.Query = Ext.core.DomQuery = Ext.DomQuery = function() {
    function children(e) {
        var t = e.firstChild,
        n = -1,
        r;
        while (t) {
            r = t.nextSibling;
            if (t.nodeType == 3 && !nonSpace.test(t.nodeValue)) {
                e.removeChild(t)
            } else {
                t.nodeIndex = ++n
            }
            t = r
        }
        return this
    }
    function attrValue(e, t) {
        if (!e.tagName && typeof e.length != "undefined") {
            e = e[0]
        }
        if (!e) {
            return null
        }
        if (t == "for") {
            return e.htmlFor
        }
        if (t == "class" || t == "className") {
            return e.className
        }
        return e.getAttribute(t) || e[t]
    }
    function getNodes(e, t, n) {
        var r = [],
        i = -1,
        s,
        o,
        u,
        a,
        f,
        l,
        c,
        h,
        p;
        if (!e) {
            return r
        }
        n = n.replace("|", ":") || "*";
        if (typeof e.getElementsByTagName != "undefined") {
            e = [e]
        }
        if (!t) {
            n = unescapeCssSelector(n);
            if (!supportsColonNsSeparator && DQ.isXml(e[0]) && n.indexOf(":") !== -1) {
                for (o = 0; u = e[o]; o++) {
                    s = u.getElementsByTagName(n.split(":").pop());
                    for (a = 0; f = s[a]; a++) {
                        if (f.tagName === n) {
                            r[++i] = f
                        }
                    }
                }
            } else {
                for (o = 0; u = e[o]; o++) {
                    s = u.getElementsByTagName(n);
                    for (a = 0; f = s[a]; a++) {
                        r[++i] = f
                    }
                }
            }
        } else {
            if (t == "/" || t == ">") {
                c = n.toUpperCase();
                for (o = 0; u = e[o]; o++) {
                    l = u.childNodes;
                    for (a = 0; p = l[a]; a++) {
                        if (p.nodeName == c || p.nodeName == n || n == "*") {
                            r[++i] = p
                        }
                    }
                }
            } else {
                if (t == "+") {
                    c = n.toUpperCase();
                    for (o = 0; h = e[o]; o++) {
                        while ((h = h.nextSibling) && h.nodeType != 1) {}
                        if (h && (h.nodeName == c || h.nodeName == n || n == "*")) {
                            r[++i] = h
                        }
                    }
                } else {
                    if (t == "~") {
                        c = n.toUpperCase();
                        for (o = 0; h = e[o]; o++) {
                            while (h = h.nextSibling) {
                                if (h.nodeName == c || h.nodeName == n || n == "*") {
                                    r[++i] = h
                                }
                            }
                        }
                    }
                }
            }
        }
        return r
    }
    function concat(e, t) {
        e.push.apply(e, t);
        return e
    }
    function byTag(e, t) {
        if (e.tagName || e === doc) {
            e = [e]
        }
        if (!t) {
            return e
        }
        var n = [],
        r = -1,
        i,
        s;
        t = t.toLowerCase();
        for (i = 0; s = e[i]; i++) {
            if (s.nodeType == 1 && s.tagName.toLowerCase() == t) {
                n[++r] = s
            }
        }
        return n
    }
    function byId(e, t) {
        t = unescapeCssSelector(t);
        if (e.tagName || e === doc) {
            e = [e]
        }
        if (!t) {
            return e
        }
        var n = [],
        r = -1,
        i,
        s;
        for (i = 0; s = e[i]; i++) {
            if (s && s.id == t) {
                n[++r] = s;
                return n
            }
        }
        return n
    }
    function byAttribute(e, t, n, r, i) {
        var s = [],
        o = -1,
        u = i == "{",
        a = DQ.operators[r],
        f,
        l,
        c,
        h,
        p;
        n = unescapeCssSelector(n);
        for (h = 0; p = e[h]; h++) {
            if (p.nodeType === 1) {
                if (!c) {
                    l = DQ.isXml(p);
                    c = true
                }
                if (!l) {
                    if (u) {
                        f = DQ.getStyle(p, t)
                    } else {
                        if (t == "class" || t == "className") {
                            f = p.className
                        } else {
                            if (t == "for") {
                                f = p.htmlFor
                            } else {
                                if (t == "href") {
                                    f = p.getAttribute("href", 2)
                                } else {
                                    f = p.getAttribute(t)
                                }
                            }
                        }
                    }
                } else {
                    f = p.getAttribute(t)
                }
                if (a && a(f, n) || !a && f) {
                    s[++o] = p
                }
            }
        }
        return s
    }
    function byPseudo(e, t, n) {
        n = unescapeCssSelector(n);
        return DQ.pseudos[t](e, n)
    }
    function nodupIEXml(e) {
        var t = ++key,
        n, r, i, s;
        e[0].setAttribute("_nodup", t);
        n = [e[0]];
        for (r = 1, i = e.length; r < i; r++) {
            s = e[r];
            if (!s.getAttribute("_nodup") != t) {
                s.setAttribute("_nodup", t);
                n[n.length] = s
            }
        }
        for (r = 0, i = e.length; r < i; r++) {
            e[r].removeAttribute("_nodup")
        }
        return n
    }
    function nodup(e) {
        if (!e) {
            return []
        }
        var t = e.length,
        n, r, i = e,
        s, o = -1,
        u, a;
        if (!t || typeof e.nodeType != "undefined" || t == 1) {
            return e
        }
        if (isIE && typeof e[0].selectSingleNode != "undefined") {
            return nodupIEXml(e)
        }
        u = ++key;
        e[0]._nodup = u;
        for (r = 1; n = e[r]; r++) {
            if (n._nodup != u) {
                n._nodup = u
            } else {
                i = [];
                for (a = 0; a < r; a++) {
                    i[++o] = e[a]
                }
                for (a = r + 1; s = e[a]; a++) {
                    if (s._nodup != u) {
                        s._nodup = u;
                        i[++o] = s
                    }
                }
                return i
            }
        }
        return i
    }
    function quickDiffIEXml(e, t) {
        var n = ++key,
        r = [],
        i,
        s;
        for (i = 0, s = e.length; i < s; i++) {
            e[i].setAttribute("_qdiff", n)
        }
        for (i = 0, s = t.length; i < s; i++) {
            if (t[i].getAttribute("_qdiff") != n) {
                r[r.length] = t[i]
            }
        }
        for (i = 0, s = e.length; i < s; i++) {
            e[i].removeAttribute("_qdiff")
        }
        return r
    }
    function quickDiff(e, t) {
        var n = e.length,
        r = ++key,
        i = [],
        s,
        o;
        if (!n) {
            return t
        }
        if (isIE && typeof e[0].selectSingleNode != "undefined") {
            return quickDiffIEXml(e, t)
        }
        for (s = 0; s < n; s++) {
            e[s]._qdiff = r
        }
        for (s = 0, o = t.length; s < o; s++) {
            if (t[s]._qdiff != r) {
                i[i.length] = t[s]
            }
        }
        return i
    }
    function quickId(e, t, n, r) {
        if (e == n) {
            r = unescapeCssSelector(r);
            var i = n.ownerDocument || n;
            return i.getElementById(r)
        }
        e = getNodes(e, t, "*");
        return byId(e, r)
    }
    var DQ, doc = document,
    cache, simpleCache, valueCache, useClassList = !!doc.documentElement.classList,
    useElementPointer = !!doc.documentElement.firstElementChild,
    useChildrenCollection = function() {
        var e = doc.createElement("div");
        e.innerHTML = "<!-- -->text<!-- -->";
        return e.children && e.children.length === 0
    } (),
    nonSpace = /\S/,
    trimRe = /^\s+|\s+$/g,
    tplRe = /\{(\d+)\}/g,
    modeRe = /^(\s?[\/>+~]\s?|\s|$)/,
    tagTokenRe = /^(#)?([\w\-\*\|\\]+)/,
    nthRe = /(\d*)n\+?(\d*)/,
    nthRe2 = /\D/,
    startIdRe = /^\s*#/,
    isIE = window.ActiveXObject ? true: false,
    key = 30803,
    longHex = /\\([0-9a-fA-F]{6})/g,
    shortHex = /\\([0-9a-fA-F]{1,6})\s{0,1}/g,
    nonHex = /\\([^0-9a-fA-F]{1})/g,
    escapes = /\\/g,
    num,
    hasEscapes,
    supportsColonNsSeparator = function() {
        var e, t = '<r><a:b xmlns:a="n"></a:b></r>';
        if (window.DOMParser) {
            e = (new DOMParser).parseFromString(t, "application/xml")
        } else {
            e = new ActiveXObject("Microsoft.XMLDOM");
            e.loadXML(t)
        }
        return !! e.getElementsByTagName("a:b").length
    } (),
    longHexToChar = function(e, t) {
        return String.fromCharCode(parseInt(t, 16))
    },
    shortToLongHex = function(e, t) {
        while (t.length < 6) {
            t = "0" + t
        }
        return "\\" + t
    },
    charToLongHex = function(e, t) {
        num = t.charCodeAt(0).toString(16);
        if (num.length === 1) {
            num = "0" + num
        }
        return "\\0000" + num
    },
    unescapeCssSelector = function(e) {
        return hasEscapes ? e.replace(longHex, longHexToChar) : e
    },
    setupEscapes = function(e) {
        hasEscapes = e.indexOf("\\") > -1;
        if (hasEscapes) {
            e = e.replace(shortHex, shortToLongHex).replace(nonHex, charToLongHex).replace(escapes, "\\\\")
        }
        return e
    };
    eval("var batch = 30803, child, next, prev, byClassName;");
    child = useChildrenCollection ?
    function(t, n) {
        return t.children[n]
    }: function(t, n) {
        var r = 0,
        i = t.firstChild;
        while (i) {
            if (i.nodeType == 1) {
                if (++r == n) {
                    return i
                }
            }
            i = i.nextSibling
        }
        return null
    };
    next = useElementPointer ?
    function(e) {
        return e.nextElementSibling
    }: function(e) {
        while ((e = e.nextSibling) && e.nodeType != 1) {}
        return e
    };
    prev = useElementPointer ?
    function(e) {
        return e.previousElementSibling
    }: function(e) {
        while ((e = e.previousSibling) && e.nodeType != 1) {}
        return e
    };
    byClassName = useClassList ?
    function(e, t) {
        t = unescapeCssSelector(t);
        if (!t) {
            return e
        }
        var n = [],
        r = -1,
        i,
        s,
        o;
        for (i = 0; s = e[i]; i++) {
            o = s.classList;
            if (o) {
                if (o.contains(t)) {
                    n[++r] = s
                }
            } else {
                if ((" " + s.className + " ").indexOf(t) !== -1) {
                    n[++r] = s
                }
            }
        }
        return n
    }: function(e, t) {
        t = unescapeCssSelector(t);
        if (!t) {
            return e
        }
        var n = [],
        r = -1,
        i,
        s;
        for (i = 0; s = e[i]; i++) {
            if ((" " + s.className + " ").indexOf(t) !== -1) {
                n[++r] = s
            }
        }
        return n
    };
    return DQ = {
        clearCache: function() {
            cache && cache.clear();
            valueCache && valueCache.clear();
            simpleCache && simpleCache.clear()
        },
        getStyle: function(e, t) {
            return Ext.fly(e, "_DomQuery").getStyle(t)
        },
        compile: function(path, type) {
            type = type || "select";
            var fn = ["var f = function(root) {\n var mode; ++batch; var n = root || document;\n"],
            lastPath,
            matchers = DQ.matchers,
            matchersLn = matchers.length,
            modeMatch,
            lmode = path.match(modeRe),
            tokenMatch,
            matched,
            j,
            t,
            m;
            path = setupEscapes(path);
            if (lmode && lmode[1]) {
                fn[fn.length] = 'mode="' + lmode[1].replace(trimRe, "") + '";';
                path = path.replace(lmode[1], "")
            }
            while (path.substr(0, 1) == "/") {
                path = path.substr(1)
            }
            while (path && lastPath != path) {
                lastPath = path;
                tokenMatch = path.match(tagTokenRe);
                if (type == "select") {
                    if (tokenMatch) {
                        if (tokenMatch[1] == "#") {
                            fn[fn.length] = 'n = quickId(n, mode, root, "' + tokenMatch[2] + '");'
                        } else {
                            fn[fn.length] = 'n = getNodes(n, mode, "' + tokenMatch[2] + '");'
                        }
                        path = path.replace(tokenMatch[0], "")
                    } else {
                        if (path.substr(0, 1) != "@") {
                            fn[fn.length] = 'n = getNodes(n, mode, "*");'
                        }
                    }
                } else {
                    if (tokenMatch) {
                        if (tokenMatch[1] == "#") {
                            fn[fn.length] = 'n = byId(n, "' + tokenMatch[2] + '");'
                        } else {
                            fn[fn.length] = 'n = byTag(n, "' + tokenMatch[2] + '");'
                        }
                        path = path.replace(tokenMatch[0], "")
                    }
                }
                while (! (modeMatch = path.match(modeRe))) {
                    matched = false;
                    for (j = 0; j < matchersLn; j++) {
                        t = matchers[j];
                        m = path.match(t.re);
                        if (m) {
                            fn[fn.length] = t.select.replace(tplRe,
                            function(e, t) {
                                return m[t]
                            });
                            path = path.replace(m[0], "");
                            matched = true;
                            break
                        }
                    }
                    if (!matched) {
                        Ext.Error.raise({
                            sourceClass: "Ext.DomQuery",
                            sourceMethod: "compile",
                            msg: 'Error parsing selector. Parsing failed at "' + path + '"'
                        })
                    }
                }
                if (modeMatch[1]) {
                    fn[fn.length] = 'mode="' + modeMatch[1].replace(trimRe, "") + '";';
                    path = path.replace(modeMatch[1], "")
                }
            }
            fn[fn.length] = "return nodup(n);\n}";
            eval(fn.join(""));
            return f
        },
        jsSelect: function(e, t, n) {
            if (!cache) {
                DQ._cache = cache = new Ext.util.LruCache({
                    maxSize: 200
                })
            }
            t = t || doc;
            if (typeof t == "string") {
                t = doc.getElementById(t)
            }
            var r = Ext.splitAndUnescape(e, ","),
            i = [],
            s,
            o,
            u,
            a,
            f;
            for (o = 0, u = r.length; o < u; o++) {
                a = r[o].replace(trimRe, "");
                s = cache.get(a);
                if (!s) {
                    s = DQ.compile(a, n);
                    if (!s) {
                        Ext.Error.raise({
                            sourceClass: "Ext.DomQuery",
                            sourceMethod: "jsSelect",
                            msg: a + " is not a valid selector"
                        })
                    }
                    cache.add(a, s)
                } else {
                    setupEscapes(a)
                }
                f = s(t);
                if (f && f !== doc) {
                    i = i.concat(f)
                }
            }
            if (r.length > 1) {
                return nodup(i)
            }
            return i
        },
        isXml: function(e) {
            var t = (e ? e.ownerDocument || e: 0).documentElement;
            return t ? t.nodeName !== "HTML": false
        },
        select: doc.querySelectorAll ?
        function(e, t, n, r) {
            t = t || doc;
            if (!DQ.isXml(t)) {
                try {
                    if (t.parentNode && t.nodeType !== 9 && e.indexOf(",") === -1 && !startIdRe.test(e)) {
                        e = "#" + Ext.escapeId(Ext.id(t)) + " " + e;
                        t = t.parentNode
                    }
                    return r ? [t.querySelector(e)] : Ext.Array.toArray(t.querySelectorAll(e))
                } catch(i) {}
            }
            return DQ.jsSelect.call(this, e, t, n)
        }: function(e, t, n) {
            return DQ.jsSelect.call(this, e, t, n)
        },
        selectNode: function(e, t) {
            return Ext.DomQuery.select(e, t, null, true)[0]
        },
        selectValue: function(e, t, n) {
            if (!valueCache) {
                DQ._valueCache = valueCache = new Ext.util.LruCache({
                    maxSize: 200
                })
            }
            e = e.replace(trimRe, "");
            var r = valueCache.get(e),
            i,
            s;
            if (!r) {
                r = DQ.compile(e, "select");
                valueCache.add(e, r)
            } else {
                setupEscapes(e)
            }
            i = r(t);
            i = i[0] ? i[0] : i;
            if (typeof i.normalize == "function") {
                i.normalize()
            }
            s = i && i.firstChild ? i.firstChild.nodeValue: null;
            return s === null || s === undefined || s === "" ? n: s
        },
        selectNumber: function(e, t, n) {
            var r = DQ.selectValue(e, t, n || 0);
            return parseFloat(r)
        },
        is: function(e, t) {
            if (typeof e == "string") {
                e = doc.getElementById(e)
            }
            var n = Ext.isArray(e),
            r = DQ.filter(n ? e: [e], t);
            return n ? r.length == e.length: r.length > 0
        },
        filter: function(e, t, n) {
            t = t.replace(trimRe, "");
            if (!simpleCache) {
                DQ._simpleCache = simpleCache = new Ext.util.LruCache({
                    maxSize: 200
                })
            }
            var r = simpleCache.get(t),
            i;
            if (!r) {
                r = DQ.compile(t, "simple");
                simpleCache.add(t, r)
            } else {
                setupEscapes(t)
            }
            i = r(e);
            return n ? quickDiff(i, e) : i
        },
        matchers: [{
            re: /^\.([\w\-\\]+)/,
            select: useClassList ? 'n = byClassName(n, "{1}");': 'n = byClassName(n, " {1} ");'
        },
        {
            re: /^\:([\w\-]+)(?:\(((?:[^\s>\/]*|.*?))\))?/,
            select: 'n = byPseudo(n, "{1}", "{2}");'
        },
        {
            re: /^(?:([\[\{])(?:@)?([\w\-]+)\s?(?:(=|.=)\s?['"]?(.*?)["']?)?[\]\}])/,
            select: 'n = byAttribute(n, "{2}", "{4}", "{3}", "{1}");'
        },
        {
            re: /^#([\w\-\\]+)/,
            select: 'n = byId(n, "{1}");'
        },
        {
            re: /^@([\w\-\.]+)/,
            select: 'return {firstChild:{nodeValue:attrValue(n, "{1}")}};'
        }],
        operators: {
            "=": function(e, t) {
                return e == t
            },
            "!=": function(e, t) {
                return e != t
            },
            "^=": function(e, t) {
                return e && e.substr(0, t.length) == t
            },
            "$=": function(e, t) {
                return e && e.substr(e.length - t.length) == t
            },
            "*=": function(e, t) {
                return e && e.indexOf(t) !== -1
            },
            "%=": function(e, t) {
                return e % t === 0
            },
            "|=": function(e, t) {
                return e && (e == t || e.substr(0, t.length + 1) == t + "-")
            },
            "~=": function(e, t) {
                return e && (" " + e + " ").indexOf(" " + t + " ") != -1
            }
        },
        pseudos: {
            "first-child": function(e) {
                var t = [],
                n = -1,
                r,
                i,
                s;
                for (i = 0; s = r = e[i]; i++) {
                    while ((r = r.previousSibling) && r.nodeType != 1) {}
                    if (!r) {
                        t[++n] = s
                    }
                }
                return t
            },
            "last-child": function(e) {
                var t = [],
                n = -1,
                r,
                i,
                s;
                for (i = 0; s = r = e[i]; i++) {
                    while ((r = r.nextSibling) && r.nodeType != 1) {}
                    if (!r) {
                        t[++n] = s
                    }
                }
                return t
            },
            "nth-child": function(e, t) {
                var n = [],
                r = -1,
                i = nthRe.exec(t == "even" && "2n" || t == "odd" && "2n+1" || !nthRe2.test(t) && "n+" + t || t),
                s = (i[1] || 1) - 0,
                o = i[2] - 0,
                u,
                a,
                f,
                l,
                c;
                for (u = 0; a = e[u]; u++) {
                    c = a.parentNode;
                    if (batch != c._batch) {
                        f = 0;
                        for (l = c.firstChild; l; l = l.nextSibling) {
                            if (l.nodeType == 1) {
                                l.nodeIndex = ++f
                            }
                        }
                        c._batch = batch
                    }
                    if (s == 1) {
                        if (o === 0 || a.nodeIndex == o) {
                            n[++r] = a
                        }
                    } else {
                        if ((a.nodeIndex + o) % s === 0) {
                            n[++r] = a
                        }
                    }
                }
                return n
            },
            "only-child": function(e) {
                var t = [],
                n = -1,
                r,
                i;
                for (r = 0; i = e[r]; r++) {
                    if (!prev(i) && !next(i)) {
                        t[++n] = i
                    }
                }
                return t
            },
            empty: function(e) {
                var t = [],
                n = -1,
                r,
                i,
                s,
                o,
                u,
                a;
                for (r = 0; i = e[r]; r++) {
                    s = i.childNodes;
                    o = 0;
                    a = true;
                    while (u = s[o]) {++o;
                        if (u.nodeType == 1 || u.nodeType == 3) {
                            a = false;
                            break
                        }
                    }
                    if (a) {
                        t[++n] = i
                    }
                }
                return t
            },
            contains: function(e, t) {
                var n = [],
                r = -1,
                i,
                s;
                for (i = 0; s = e[i]; i++) {
                    if ((s.textContent || s.innerText || s.text || "").indexOf(t) != -1) {
                        n[++r] = s
                    }
                }
                return n
            },
            nodeValue: function(e, t) {
                var n = [],
                r = -1,
                i,
                s;
                for (i = 0; s = e[i]; i++) {
                    if (s.firstChild && s.firstChild.nodeValue == t) {
                        n[++r] = s
                    }
                }
                return n
            },
            checked: function(e) {
                var t = [],
                n = -1,
                r,
                i;
                for (r = 0; i = e[r]; r++) {
                    if (i.checked === true) {
                        t[++n] = i
                    }
                }
                return t
            },
            not: function(e, t) {
                return DQ.filter(e, t, true)
            },
            any: function(e, t) {
                var n = t.split("|"),
                r = [],
                i = -1,
                s,
                o,
                u,
                a;
                for (o = 0; u = e[o]; o++) {
                    for (a = 0; s = n[a]; a++) {
                        if (DQ.is(u, s)) {
                            r[++i] = u;
                            break
                        }
                    }
                }
                return r
            },
            odd: function(e) {
                return this["nth-child"](e, "odd")
            },
            even: function(e) {
                return this["nth-child"](e, "even")
            },
            nth: function(e, t) {
                return e[t - 1] || []
            },
            first: function(e) {
                return e[0] || []
            },
            last: function(e) {
                return e[e.length - 1] || []
            },
            has: function(e, t) {
                var n = DQ.select,
                r = [],
                i = -1,
                s,
                o;
                for (s = 0; o = e[s]; s++) {
                    if (n(t, o).length > 0) {
                        r[++i] = o
                    }
                }
                return r
            },
            next: function(e, t) {
                var n = DQ.is,
                r = [],
                i = -1,
                s,
                o,
                u;
                for (s = 0; o = e[s]; s++) {
                    u = next(o);
                    if (u && n(u, t)) {
                        r[++i] = o
                    }
                }
                return r
            },
            prev: function(e, t) {
                var n = DQ.is,
                r = [],
                i = -1,
                s,
                o,
                u;
                for (s = 0; o = e[s]; s++) {
                    u = prev(o);
                    if (u && n(u, t)) {
                        r[++i] = o
                    }
                }
                return r
            },
            focusable: function(e) {
                var t = e.length,
                n = [],
                r = 0,
                i;
                for (; r < t; r++) {
                    i = e[r];
                    if (Ext.fly(i, "_DomQuery").isFocusable()) {
                        n.push(i)
                    }
                }
                return n
            },
            visible: function(e, t) {
                var n = e.length,
                r = [],
                i = 0,
                s;
                for (; i < n; i++) {
                    s = e[i];
                    if (Ext.fly(s, "_DomQuery").isVisible(t)) {
                        r.push(s)
                    }
                }
                return r
            }
        }
    }
} ();
Ext.query = Ext.DomQuery.select;
Ext.define("Ext.dom.Element_anim", {
    override: "Ext.dom.Element",
    animate: function(e) {
        var t = this,
        n = t.dom.id || Ext.id(t.dom),
        r,
        i,
        s;
        if (!Ext.fx.Manager.hasFxBlock(n)) {
            if (e.listeners) {
                r = e.listeners;
                delete e.listeners
            }
            if (e.internalListeners) {
                e.listeners = e.internalListeners;
                delete e.internalListeners
            }
            s = e.autoEnd;
            delete e.autoEnd;
            i = new Ext.fx.Anim(t.anim(e));
            if (r) {
                i.on(r)
            }
            Ext.fx.Manager.queueFx(i);
            if (s) {
                i.jumpToEnd()
            }
        }
        return t
    },
    anim: function(e) {
        if (!Ext.isObject(e)) {
            return e ? {}: false
        }
        var t = this,
        n = e.duration || Ext.fx.Anim.prototype.duration,
        r = e.easing || "ease",
        i;
        if (e.stopAnimation) {
            t.stopAnimation()
        }
        Ext.applyIf(e, Ext.fx.Manager.getFxDefaults(t.id));
        Ext.fx.Manager.setFxDefaults(t.id, {
            delay: 0
        });
        i = {
            target: t.dom,
            remove: e.remove,
            alternate: e.alternate || false,
            duration: n,
            easing: r,
            callback: e.callback,
            listeners: e.listeners,
            iterations: e.iterations || 1,
            scope: e.scope,
            block: e.block,
            concurrent: e.concurrent,
            delay: e.delay || 0,
            paused: true,
            keyframes: e.keyframes,
            from: e.from || {},
            to: Ext.apply({},
            e)
        };
        Ext.apply(i.to, e.to);
        delete i.to.to;
        delete i.to.from;
        delete i.to.remove;
        delete i.to.alternate;
        delete i.to.keyframes;
        delete i.to.iterations;
        delete i.to.listeners;
        delete i.to.target;
        delete i.to.paused;
        delete i.to.callback;
        delete i.to.scope;
        delete i.to.duration;
        delete i.to.easing;
        delete i.to.concurrent;
        delete i.to.block;
        delete i.to.stopAnimation;
        delete i.to.delay;
        return i
    },
    slideIn: function(e, t, n) {
        var r = this,
        i = r.dom,
        s = i.style,
        o, u, a, f;
        e = e || "t";
        t = t || {};
        o = function() {
            var o = this,
            p = t.listeners,
            v = Ext.fly(i, "_anim"),
            m,
            y,
            w,
            E;
            if (!n) {
                v.fixDisplay()
            }
            m = v.getBox();
            if ((e == "t" || e == "b") && m.height === 0) {
                m.height = i.scrollHeight
            } else {
                if ((e == "l" || e == "r") && m.width === 0) {
                    m.width = i.scrollWidth
                }
            }
            y = v.getStyles("width", "height", "left", "right", "top", "bottom", "position", "z-index", true);
            v.setSize(m.width, m.height);
            if (t.preserveScroll) {
                a = v.cacheScrollValues()
            }
            E = v.wrap({
                role: "presentation",
                id: Ext.id() + "-anim-wrap-for-" + v.dom.id,
                style: {
                    visibility: n ? "visible": "hidden"
                }
            });
            f = E.dom.parentNode;
            E.setPositioning(v.getPositioning(true));
            if (E.isStyle("position", "static")) {
                E.position("relative")
            }
            v.clearPositioning("auto");
            E.clip();
            if (a) {
                a()
            }
            v.setStyle({
                visibility: "",
                position: "absolute"
            });
            if (n) {
                E.setSize(m.width, m.height)
            }
            switch (e) {
            case "t":
                w = {
                    from: {
                        width: m.width + "px",
                        height: "0px"
                    },
                    to: {
                        width: m.width + "px",
                        height: m.height + "px"
                    }
                };
                s.bottom = "0px";
                break;
            case "l":
                w = {
                    from: {
                        width: "0px",
                        height: m.height + "px"
                    },
                    to: {
                        width: m.width + "px",
                        height: m.height + "px"
                    }
                };
                r.anchorAnimX(e);
                break;
            case "r":
                w = {
                    from: {
                        x: m.x + m.width,
                        width: "0px",
                        height: m.height + "px"
                    },
                    to: {
                        x: m.x,
                        width: m.width + "px",
                        height: m.height + "px"
                    }
                };
                r.anchorAnimX(e);
                break;
            case "b":
                w = {
                    from: {
                        y: m.y + m.height,
                        width: m.width + "px",
                        height: "0px"
                    },
                    to: {
                        y: m.y,
                        width: m.width + "px",
                        height: m.height + "px"
                    }
                };
                break;
            case "tl":
                w = {
                    from: {
                        x: m.x,
                        y: m.y,
                        width: "0px",
                        height: "0px"
                    },
                    to: {
                        width: m.width + "px",
                        height: m.height + "px"
                    }
                };
                s.bottom = "0px";
                r.anchorAnimX("l");
                break;
            case "bl":
                w = {
                    from: {
                        y: m.y + m.height,
                        width: "0px",
                        height: "0px"
                    },
                    to: {
                        y: m.y,
                        width: m.width + "px",
                        height: m.height + "px"
                    }
                };
                r.anchorAnimX("l");
                break;
            case "br":
                w = {
                    from: {
                        x: m.x + m.width,
                        y: m.y + m.height,
                        width: "0px",
                        height: "0px"
                    },
                    to: {
                        x: m.x,
                        y: m.y,
                        width: m.width + "px",
                        height: m.height + "px"
                    }
                };
                r.anchorAnimX("r");
                break;
            case "tr":
                w = {
                    from: {
                        x: m.x + m.width,
                        width: "0px",
                        height: "0px"
                    },
                    to: {
                        x: m.x,
                        width: m.width + "px",
                        height: m.height + "px"
                    }
                };
                s.bottom = "0px";
                r.anchorAnimX("r");
                break
            }
            E.show();
            u = Ext.apply({},
            t);
            delete u.listeners;
            u = new Ext.fx.Anim(Ext.applyIf(u, {
                target: E,
                duration: 500,
                easing: "ease-out",
                from: n ? w.to: w.from,
                to: n ? w.from: w.to
            }));
            u.on("afteranimate",
            function() {
                var e = Ext.fly(i, "_anim");
                e.setStyle(y);
                if (n) {
                    if (t.useDisplay) {
                        e.setDisplayed(false)
                    } else {
                        e.hide()
                    }
                }
                if (E.dom) {
                    if (E.dom.parentNode) {
                        E.dom.parentNode.insertBefore(e.dom, E.dom)
                    } else {
                        f.appendChild(e.dom)
                    }
                    E.remove()
                }
                if (a) {
                    a()
                }
                o.end()
            });
            if (p) {
                u.on(p)
            }
        };
        r.animate({
            duration: t.duration ? Math.max(t.duration, 500) * 2 : 1e3,
            listeners: {
                beforeanimate: o
            }
        });
        return r
    },
    slideOut: function(e, t) {
        return this.slideIn(e, t, true)
    },
    puff: function(e) {
        var t = this,
        n = t.dom,
        r, i = t.getBox(),
        s = t.getStyles("width", "height", "left", "right", "top", "bottom", "position", "z-index", "font-size", "opacity", true);
        e = Ext.applyIf(e || {},
        {
            easing: "ease-out",
            duration: 500,
            useDisplay: false
        });
        r = function() {
            var t = Ext.fly(n, "_anim");
            t.clearOpacity();
            t.show();
            this.to = {
                width: i.width * 2,
                height: i.height * 2,
                x: i.x - i.width / 2,
                y: i.y - i.height / 2,
                opacity: 0,
                fontSize: "200%"
            };
            this.on("afteranimate",
            function() {
                var t = Ext.fly(n, "_anim");
                if (t) {
                    if (e.useDisplay) {
                        t.setDisplayed(false)
                    } else {
                        t.hide()
                    }
                    t.setStyle(s);
                    Ext.callback(e.callback, e.scope)
                }
            })
        };
        t.animate({
            duration: e.duration,
            easing: e.easing,
            listeners: {
                beforeanimate: {
                    fn: r
                }
            }
        });
        return t
    },
    switchOff: function(e) {
        var t = this,
        n = t.dom,
        r;
        e = Ext.applyIf(e || {},
        {
            easing: "ease-in",
            duration: 500,
            remove: false,
            useDisplay: false
        });
        r = function() {
            var t = Ext.fly(n, "_anim"),
            r = this,
            i = t.getSize(),
            s = t.getXY(),
            o,
            u;
            t.clearOpacity();
            t.clip();
            u = t.getPositioning();
            o = new Ext.fx.Animator({
                target: n,
                duration: e.duration,
                easing: e.easing,
                keyframes: {
                    33 : {
                        opacity: .3
                    },
                    66 : {
                        height: 1,
                        y: s[1] + i.height / 2
                    },
                    100 : {
                        width: 1,
                        x: s[0] + i.width / 2
                    }
                }
            });
            o.on("afteranimate",
            function() {
                var t = Ext.fly(n, "_anim");
                if (e.useDisplay) {
                    t.setDisplayed(false)
                } else {
                    t.hide()
                }
                t.clearOpacity();
                t.setPositioning(u);
                t.setSize(i);
                r.end()
            })
        };
        t.animate({
            duration: Math.max(e.duration, 500) * 2,
            listeners: {
                beforeanimate: {
                    fn: r
                }
            },
            callback: e.callback,
            scope: e.scope
        });
        return t
    },
    frame: function(e, t, n) {
        var r = this,
        i = r.dom,
        s;
        e = e || "#C3DAF9";
        t = t || 1;
        n = n || {};
        s = function() {
            var r = Ext.fly(i, "_anim"),
            s = this,
            o,
            u,
            f;
            r.show();
            o = r.getBox();
            u = Ext.getBody().createChild({
                role: "presentation",
                id: r.dom.id + "-anim-proxy",
                style: {
                    position: "absolute",
                    "pointer-events": "none",
                    "z-index": 35e3,
                    border: "0px solid " + e
                }
            });
            f = new Ext.fx.Anim({
                target: u,
                duration: n.duration || 1e3,
                iterations: t,
                from: {
                    top: o.y,
                    left: o.x,
                    borderWidth: 0,
                    opacity: 1,
                    height: o.height,
                    width: o.width
                },
                to: {
                    top: o.y - 20,
                    left: o.x - 20,
                    borderWidth: 10,
                    opacity: 0,
                    height: o.height + 40,
                    width: o.width + 40
                }
            });
            f.on("afteranimate",
            function() {
                u.remove();
                s.end()
            })
        };
        r.animate({
            duration: Math.max(n.duration, 500) * 2 || 2e3,
            listeners: {
                beforeanimate: {
                    fn: s
                }
            },
            callback: n.callback,
            scope: n.scope
        });
        return r
    },
    ghost: function(e, t) {
        var n = this,
        r = n.dom,
        i;
        e = e || "b";
        i = function() {
            var t = Ext.fly(r, "_anim"),
            n = t.getWidth(),
            i = t.getHeight(),
            s = t.getXY(),
            o = t.getPositioning(),
            u = {
                opacity: 0
            };
            switch (e) {
            case "t":
                u.y = s[1] - i;
                break;
            case "l":
                u.x = s[0] - n;
                break;
            case "r":
                u.x = s[0] + n;
                break;
            case "b":
                u.y = s[1] + i;
                break;
            case "tl":
                u.x = s[0] - n;
                u.y = s[1] - i;
                break;
            case "bl":
                u.x = s[0] - n;
                u.y = s[1] + i;
                break;
            case "br":
                u.x = s[0] + n;
                u.y = s[1] + i;
                break;
            case "tr":
                u.x = s[0] + n;
                u.y = s[1] - i;
                break
            }
            this.to = u;
            this.on("afteranimate",
            function() {
                var e = Ext.fly(r, "_anim");
                if (e) {
                    e.hide();
                    e.clearOpacity();
                    e.setPositioning(o)
                }
            })
        };
        n.animate(Ext.applyIf(t || {},
        {
            duration: 500,
            easing: "ease-out",
            listeners: {
                beforeanimate: i
            }
        }));
        return n
    },
    highlight: function(e, t) {
        var n = this,
        r = n.dom,
        i = {},
        s, o, u, a, f, l;
        if (r.tagName.match(n.tableTagRe)) {
            return n.select("div").highlight(e, t)
        }
        t = t || {};
        a = t.listeners || {};
        u = t.attr || "backgroundColor";
        i[u] = e || "ffff9c";
        if (!t.to) {
            o = {};
            o[u] = t.endColor || n.getColor(u, "ffffff", "")
        } else {
            o = t.to
        }
        t.listeners = Ext.apply(Ext.apply({},
        a), {
            beforeanimate: function() {
                s = r.style[u];
                var e = Ext.fly(r, "_anim");
                e.clearOpacity();
                e.show();
                f = a.beforeanimate;
                if (f) {
                    l = f.fn || f;
                    return l.apply(f.scope || a.scope || window, arguments)
                }
            },
            afteranimate: function() {
                if (r) {
                    r.style[u] = s
                }
                f = a.afteranimate;
                if (f) {
                    l = f.fn || f;
                    l.apply(f.scope || a.scope || window, arguments)
                }
            }
        });
        n.animate(Ext.apply({},
        t, {
            duration: 1e3,
            easing: "ease-in",
            from: i,
            to: o
        }));
        return n
    },
    pause: function(e) {
        var t = this;
        Ext.fx.Manager.setFxDefaults(t.id, {
            delay: e
        });
        return t
    },
    fadeIn: function(e) {
        var t = this,
        n = t.dom;
        t.animate(Ext.apply({},
        e, {
            opacity: 1,
            internalListeners: {
                beforeanimate: function(e) {
                    var t = Ext.fly(n, "_anim");
                    if (t.isStyle("display", "none")) {
                        t.setDisplayed("")
                    } else {
                        t.show()
                    }
                }
            }
        }));
        return this
    },
    fadeOut: function(e) {
        var t = this,
        n = t.dom;
        e = Ext.apply({
            opacity: 0,
            internalListeners: {
                afteranimate: function(t) {
                    if (n && t.to.opacity === 0) {
                        var r = Ext.fly(n, "_anim");
                        if (e.useDisplay) {
                            r.setDisplayed(false)
                        } else {
                            r.hide()
                        }
                    }
                }
            }
        },
        e);
        t.animate(e);
        return t
    },
    scale: function(e, t, n) {
        this.animate(Ext.apply({},
        n, {
            width: e,
            height: t
        }));
        return this
    },
    shift: function(e) {
        this.animate(e);
        return this
    },
    anchorAnimX: function(e) {
        var t = e === "l" ? "right": "left";
        this.dom.style[t] = "0px"
    }
});
Ext.define("Ext.dom.Element_dd", {
    override: "Ext.dom.Element",
    initDD: function(e, t, n) {
        var r = new Ext.dd.DD(Ext.id(this.dom), e, t);
        return Ext.apply(r, n)
    },
    initDDProxy: function(e, t, n) {
        var r = new Ext.dd.DDProxy(Ext.id(this.dom), e, t);
        return Ext.apply(r, n)
    },
    initDDTarget: function(e, t, n) {
        var r = new Ext.dd.DDTarget(Ext.id(this.dom), e, t);
        return Ext.apply(r, n)
    }
});
Ext.define("Ext.dom.Element_fx", {
    override: "Ext.dom.Element"
},
function() {
    var e = Ext.dom.Element,
    t = "visibility",
    n = "display",
    r = "none",
    i = "hidden",
    s = "visible",
    o = "offsets",
    u = "asclass",
    a = "nosize",
    f = "originalDisplay",
    l = "visibilityMode",
    c = "isVisible",
    h = Ext.baseCSSPrefix + "hide-offsets",
    p = function(e) {
        var t = (e.$cache || e.getCache()).data,
        n = t[f];
        if (n === undefined) {
            t[f] = n = ""
        }
        return n
    },
    d = function(t) {
        var n = (t.$cache || t.getCache()).data,
        r = n[l];
        if (r === undefined) {
            n[l] = r = e.VISIBILITY
        }
        return r
    };
    e.override({
        originalDisplay: "",
        visibilityMode: 1,
        setVisible: function(r, s) {
            var f = this,
            l = f.dom,
            p = d(f);
            if (typeof s == "string") {
                switch (s) {
                case n:
                    p = e.DISPLAY;
                    break;
                case t:
                    p = e.VISIBILITY;
                    break;
                case o:
                    p = e.OFFSETS;
                    break;
                case a:
                case u:
                    p = e.ASCLASS;
                    break
                }
                f.setVisibilityMode(p);
                s = false
            }
            if (!s || !f.anim) {
                if (p == e.DISPLAY) {
                    return f.setDisplayed(r)
                } else {
                    if (p == e.OFFSETS) {
                        f[r ? "removeCls": "addCls"](h)
                    } else {
                        if (p == e.VISIBILITY) {
                            f.fixDisplay();
                            l.style.visibility = r ? "": i
                        } else {
                            if (p == e.ASCLASS) {
                                f[r ? "removeCls": "addCls"](f.visibilityCls || e.visibilityCls)
                            }
                        }
                    }
                }
            } else {
                if (r) {
                    f.setOpacity(.01);
                    f.setVisible(true)
                }
                if (!Ext.isObject(s)) {
                    s = {
                        duration: 350,
                        easing: "ease-in"
                    }
                }
                f.animate(Ext.applyIf({
                    callback: function() {
                        if (!r) {
                            Ext.fly(l, "_internal").setVisible(false).setOpacity(1)
                        }
                    },
                    to: {
                        opacity: r ? 1 : 0
                    }
                },
                s))
            } (f.$cache || f.getCache()).data[c] = r;
            return f
        },
        hasMetrics: function() {
            var t = d(this);
            return this.isVisible() || t == e.OFFSETS || t == e.VISIBILITY
        },
        toggle: function(e) {
            var t = this;
            t.setVisible(!t.isVisible(), t.anim(e));
            return t
        },
        setDisplayed: function(e) {
            if (typeof e == "boolean") {
                e = e ? p(this) : r
            }
            this.setStyle(n, e);
            return this
        },
        fixDisplay: function() {
            var e = this;
            if (e.isStyle(n, r)) {
                e.setStyle(t, i);
                e.setStyle(n, p(e));
                if (e.isStyle(n, r)) {
                    e.setStyle(n, "block")
                }
            }
        },
        hide: function(e) {
            if (typeof e == "string") {
                this.setVisible(false, e);
                return this
            }
            this.setVisible(false, this.anim(e));
            return this
        },
        show: function(e) {
            if (typeof e == "string") {
                this.setVisible(true, e);
                return this
            }
            this.setVisible(true, this.anim(e));
            return this
        }
    })
});
Ext.define("Ext.dom.Element_position", {
    override: "Ext.dom.Element"
},
function() {
    var e, t = this,
    n = "left",
    r = "right",
    i = "top",
    s = "bottom",
    o = "position",
    u = "static",
    a = "relative",
    f = "z-index",
    l = "BODY",
    c = "padding",
    h = "border",
    p = "-left",
    d = "-right",
    v = "-top",
    m = "-bottom",
    g = "-width",
    y = {
        l: h + p + g,
        r: h + d + g,
        t: h + v + g,
        b: h + m + g
    },
    b = {
        l: c + p,
        r: c + d,
        t: c + v,
        b: c + m
    },
    w = [b.l, b.r, b.t, b.b],
    E = [y.l, y.r, y.t, y.b],
    S = Math.round,
    x = document,
    T = function(t) {
        if (!e) {
            e = new Ext.Element.Fly
        }
        e.attach(t);
        return e
    };
    t.override({
        pxRe: /^-?\d+(?:\.\d*)?px$/i,
        inheritableStatics: {
            getX: function(e) {
                return t.getXY(e)[0]
            },
            getXY: function(e) {
                var t = x.body,
                n = x.documentElement,
                r = 0,
                i = 0,
                s = [0, 0],
                o,
                u;
                e = Ext.getDom(e);
                if (e != x && e != t) {
                    if (Ext.isIE) {
                        try {
                            o = e.getBoundingClientRect();
                            i = n.clientTop || t.clientTop;
                            r = n.clientLeft || t.clientLeft
                        } catch(a) {
                            o = {
                                left: 0,
                                top: 0
                            }
                        }
                    } else {
                        o = e.getBoundingClientRect()
                    }
                    u = T(x).getScroll();
                    s = [S(o.left + u.left - r), S(o.top + u.top - i)]
                }
                return s
            },
            getY: function(e) {
                return t.getXY(e)[1]
            },
            setX: function(e, n) {
                t.setXY(e, [n, false])
            },
            setXY: function(e, t) { (e = Ext.fly(e, "_setXY")).position();
                var n = e.translatePoints(t),
                r = e.dom.style,
                i;
                r.right = "auto";
                for (i in n) {
                    if (!isNaN(n[i])) {
                        r[i] = n[i] + "px"
                    }
                }
            },
            setY: function(e, n) {
                t.setXY(e, [false, n])
            }
        },
        center: function(e) {
            return this.alignTo(e || x, "c-c")
        },
        clearPositioning: function(e) {
            e = e || "";
            return this.setStyle({
                left: e,
                right: e,
                top: e,
                bottom: e,
                "z-index": "",
                position: u
            })
        },
        getAnchorToXY: function(e, t, n, r) {
            return e.getAnchorXY(t, n, r)
        },
        getBottom: function(e) {
            return (e ? this.getLocalY() : this.getY()) + this.getHeight()
        },
        getBorderPadding: function() {
            var e = this.getStyle(w),
            t = this.getStyle(E);
            return {
                beforeX: (parseFloat(t[y.l]) || 0) + (parseFloat(e[b.l]) || 0),
                afterX: (parseFloat(t[y.r]) || 0) + (parseFloat(e[b.r]) || 0),
                beforeY: (parseFloat(t[y.t]) || 0) + (parseFloat(e[b.t]) || 0),
                afterY: (parseFloat(t[y.b]) || 0) + (parseFloat(e[b.b]) || 0)
            }
        },
        getCenterXY: function() {
            return this.getAlignToXY(x, "c-c")
        },
        getLeft: function(e) {
            return e ? this.getLocalX() : this.getX()
        },
        getLocalX: function() {
            var e = this,
            n = e.dom.offsetParent,
            r = e.getStyle("left");
            if (!r || r === "auto") {
                r = 0
            } else {
                if (e.pxRe.test(r)) {
                    r = parseFloat(r)
                } else {
                    r = e.getX();
                    if (n) {
                        r -= t.getX(n)
                    }
                }
            }
            return r
        },
        getLocalXY: function() {
            var e = this,
            n = e.dom.offsetParent,
            r = e.getStyle(["left", "top"]),
            i = r.left,
            s = r.top;
            if (!i || i === "auto") {
                i = 0
            } else {
                if (e.pxRe.test(i)) {
                    i = parseFloat(i)
                } else {
                    i = e.getX();
                    if (n) {
                        i -= t.getX(n)
                    }
                }
            }
            if (!s || s === "auto") {
                s = 0
            } else {
                if (e.pxRe.test(s)) {
                    s = parseFloat(s)
                } else {
                    s = e.getY();
                    if (n) {
                        s -= t.getY(n)
                    }
                }
            }
            return [i, s]
        },
        getLocalY: function() {
            var e = this,
            n = e.dom.offsetParent,
            r = e.getStyle("top");
            if (!r || r === "auto") {
                r = 0
            } else {
                if (e.pxRe.test(r)) {
                    r = parseFloat(r)
                } else {
                    r = e.getY();
                    if (n) {
                        r -= t.getY(n)
                    }
                }
            }
            return r
        },
        getPageBox: function(e) {
            var t = this,
            n = t.dom,
            r = n.nodeName == l,
            i = r ? Ext.Element.getViewWidth() : n.offsetWidth,
            s = r ? Ext.Element.getViewHeight() : n.offsetHeight,
            o = t.getXY(),
            u = o[1],
            a = o[0] + i,
            f = o[1] + s,
            c = o[0];
            if (e) {
                return new Ext.util.Region(u, a, f, c)
            } else {
                return {
                    left: c,
                    top: u,
                    width: i,
                    height: s,
                    right: a,
                    bottom: f
                }
            }
        },
        getPositioning: function(e) {
            var t = this.getStyle(["left", "top", "position", "z-index"]),
            n = this.dom;
            if (e) {
                if (t.left === "auto") {
                    t.left = n.offsetLeft + "px"
                }
                if (t.top === "auto") {
                    t.top = n.offsetTop + "px"
                }
            }
            return t
        },
        getRight: function(e) {
            return (e ? this.getLocalX() : this.getX()) + this.getWidth()
        },
        getTop: function(e) {
            return e ? this.getLocalY() : this.getY()
        },
        getX: function() {
            return t.getX(this.dom)
        },
        getXY: function() {
            return t.getXY(this.dom)
        },
        getY: function() {
            return t.getY(this.dom)
        },
        moveTo: function(e, t, n) {
            return this.setXY([e, t], n)
        },
        position: function(e, t, n, r) {
            var i = this;
            if (!e && i.isStyle(o, u)) {
                i.setStyle(o, a)
            } else {
                if (e) {
                    i.setStyle(o, e)
                }
            }
            if (t) {
                i.setStyle(f, t)
            }
            if (n || r) {
                i.setXY([n || false, r || false])
            }
        },
        setBottom: function(e) {
            this.dom.style[s] = this.addUnits(e);
            return this
        },
        setBounds: function(e, t, n, r, i) {
            return this.setBox({
                x: e,
                y: t,
                width: n,
                height: r
            },
            i)
        },
        setLeft: function(e) {
            this.dom.style[n] = this.addUnits(e);
            return this
        },
        setLeftTop: function(e, t) {
            var n = this,
            r = n.dom.style;
            r.left = n.addUnits(e);
            r.top = n.addUnits(t);
            return n
        },
        setLocalX: function(e) {
            var t = this.dom.style;
            t.right = "auto";
            t.left = e === null ? "auto": e + "px"
        },
        setLocalXY: function(e, t) {
            var n = this.dom.style;
            n.right = "auto";
            if (e && e.length) {
                t = e[1];
                e = e[0]
            }
            if (e === null) {
                n.left = "auto"
            } else {
                if (e !== undefined) {
                    n.left = e + "px"
                }
            }
            if (t === null) {
                n.top = "auto"
            } else {
                if (t !== undefined) {
                    n.top = t + "px"
                }
            }
        },
        setLocalY: function(e) {
            this.dom.style.top = e === null ? "auto": e + "px"
        },
        setLocation: function(e, t, n) {
            return this.setXY([e, t], n)
        },
        setPositioning: function(e) {
            return this.setStyle(e)
        },
        setRight: function(e) {
            this.dom.style[r] = this.addUnits(e);
            return this
        },
        setTop: function(e) {
            this.dom.style[i] = this.addUnits(e);
            return this
        },
        setX: function(e, t) {
            return this.setXY([e, this.getY()], t)
        },
        setXY: function(e, n) {
            var r = this;
            if (!n || !r.anim) {
                t.setXY(r.dom, e)
            } else {
                if (!Ext.isObject(n)) {
                    n = {}
                }
                r.animate(Ext.applyIf({
                    to: {
                        x: e[0],
                        y: e[1]
                    }
                },
                n))
            }
            return this
        },
        setY: function(e, t) {
            return this.setXY([this.getX(), e], t)
        }
    });
    t.getTrueXY = t.getXY
});
Ext.define("Ext.dom.Element_scroll", {
    override: "Ext.dom.Element",
    isScrollable: function() {
        var e = this.dom;
        return e.scrollHeight > e.clientHeight || e.scrollWidth > e.clientWidth
    },
    getScroll: function() {
        var e = this,
        t = e.dom,
        n = document,
        r = n.body,
        i = n.documentElement,
        s, o;
        if (t === n || t === r) {
            s = i.scrollLeft || (r ? r.scrollLeft: 0);
            o = i.scrollTop || (r ? r.scrollTop: 0)
        } else {
            s = t.scrollLeft;
            o = t.scrollTop
        }
        return {
            left: s,
            top: o
        }
    },
    getScrollLeft: function() {
        var e = this.dom,
        t = document;
        if (e === t || e === t.body) {
            return this.getScroll().left
        } else {
            return e.scrollLeft
        }
    },
    getScrollTop: function() {
        var e = this.dom,
        t = document;
        if (e === t || e === t.body) {
            return this.getScroll().top
        } else {
            return e.scrollTop
        }
    },
    setScrollLeft: function(e) {
        this.dom.scrollLeft = e;
        return this
    },
    setScrollTop: function(e) {
        this.dom.scrollTop = e;
        return this
    },
    scrollBy: function(e, t, n) {
        var r = this,
        i = r.dom;
        if (e.length) {
            n = t;
            t = e[1];
            e = e[0]
        } else {
            if (typeof e != "number") {
                n = t;
                t = e.y;
                e = e.x
            }
        }
        if (e) {
            r.scrollTo("left", r.constrainScrollLeft(i.scrollLeft + e), n)
        }
        if (t) {
            r.scrollTo("top", r.constrainScrollTop(i.scrollTop + t), n)
        }
        return r
    },
    scrollTo: function(e, t, n) {
        var r = /top/i.test(e),
        i = this,
        s = r ? "scrollTop": "scrollLeft",
        o = i.dom,
        u;
        if (!n || !i.anim) {
            o[s] = t;
            o[s] = t
        } else {
            u = {
                to: {}
            };
            u.to[s] = t;
            if (Ext.isObject(n)) {
                Ext.applyIf(u, n)
            }
            i.animate(u)
        }
        return i
    },
    scrollIntoView: function(e, t, n, r) {
        var i = this,
        s = i.dom,
        o = i.getOffsetsTo(e = Ext.getDom(e) || Ext.getBody().dom),
        u = o[0] + e.scrollLeft,
        a = o[1] + e.scrollTop,
        f = a + s.offsetHeight,
        l = u + s.offsetWidth,
        c = e.clientHeight,
        h = parseInt(e.scrollTop, 10),
        p = parseInt(e.scrollLeft, 10),
        d = h + c,
        v = p + e.clientWidth,
        m;
        if (r) {
            if (n) {
                n = Ext.apply({
                    listeners: {
                        afteranimate: function() {
                            i.scrollChildFly.attach(s).highlight()
                        }
                    }
                },
                n)
            } else {
                i.scrollChildFly.attach(s).highlight()
            }
        }
        if (s.offsetHeight > c || a < h) {
            m = a
        } else {
            if (f > d) {
                m = f - c
            }
        }
        if (m != null) {
            i.scrollChildFly.attach(e).scrollTo("top", m, n)
        }
        if (t !== false) {
            m = null;
            if (s.offsetWidth > e.clientWidth || u < p) {
                m = u
            } else {
                if (l > v) {
                    m = l - e.clientWidth
                }
            }
            if (m != null) {
                i.scrollChildFly.attach(e).scrollTo("left", m, n)
            }
        }
        return i
    },
    scrollChildIntoView: function(e, t) {
        this.scrollChildFly.attach(Ext.getDom(e)).scrollIntoView(this, t)
    },
    scroll: function(e, t, n) {
        if (!this.isScrollable()) {
            return false
        }
        e = e.charAt(0);
        var r = this,
        i = r.dom,
        s = e === "r" || e === "l" ? "left": "top",
        o = false,
        u,
        a;
        if (e === "l" || e === "t" || e === "u") {
            t = -t
        }
        if (s === "left") {
            u = i.scrollLeft;
            a = r.constrainScrollLeft(u + t)
        } else {
            u = i.scrollTop;
            a = r.constrainScrollTop(u + t)
        }
        if (a !== u) {
            this.scrollTo(s, a, n);
            o = true
        }
        return o
    },
    constrainScrollLeft: function(e) {
        var t = this.dom;
        return Math.max(Math.min(e, t.scrollWidth - t.clientWidth), 0)
    },
    constrainScrollTop: function(e) {
        var t = this.dom;
        return Math.max(Math.min(e, t.scrollHeight - t.clientHeight), 0)
    }
},
function() {
    this.prototype.scrollChildFly = new this.Fly;
    this.prototype.scrolltoFly = new this.Fly
});
Ext.define("Ext.dom.Element_style", {
    override: "Ext.dom.Element"
},
function() {
    var e = this,
    t = document.defaultView,
    n = /table-row|table-.*-group/,
    r = "_internal",
    i = "hidden",
    s = "height",
    o = "width",
    u = "isClipped",
    a = "overflow",
    f = "overflow-x",
    l = "overflow-y",
    c = "originalClip",
    h = /#document|body/i,
    p, d, v, m, g, y, b;
    if (!t || !t.getComputedStyle) {
        e.prototype.getStyle = function(t, n) {
            var r = this,
            i = r.dom,
            s = typeof t != "string",
            o = r.styleHooks,
            u = t,
            a = u,
            f = 1,
            l = n,
            c, h, p, d, v, m, g;
            if (s) {
                p = {};
                u = a[0];
                g = 0;
                if (! (f = a.length)) {
                    return p
                }
            }
            if (!i || i.documentElement) {
                return p || ""
            }
            h = i.style;
            if (n) {
                m = h
            } else {
                m = i.currentStyle;
                if (!m) {
                    l = true;
                    m = h
                }
            }
            do {
                d = o[u];
                if (!d) {
                    o[u] = d = {
                        name: e.normalize(u)
                    }
                }
                if (d.get) {
                    v = d.get(i, r, l, m)
                } else {
                    c = d.name;
                    if (d.canThrow) {
                        try {
                            v = m[c]
                        } catch(y) {
                            v = ""
                        }
                    } else {
                        v = m ? m[c] : ""
                    }
                }
                if (!s) {
                    return v
                }
                p[u] = v;
                u = a[++g]
            } while ( g < f );
            return p
        }
    }
    e.override({
        getHeight: function(e, t) {
            var n = this,
            r = n.isStyle("display", "none"),
            i,
            o;
            if (r) {
                return 0
            }
            i = n.dom.offsetHeight;
            if (Ext.supports.Direct2DBug) {
                o = n.adjustDirect2DDimension(s);
                if (t) {
                    i += o
                } else {
                    if (o > 0 && o < .5) {
                        i++
                    }
                }
            }
            if (e) {
                i -= n.getBorderWidth("tb") + n.getPadding("tb")
            }
            return i < 0 ? 0 : i
        },
        getWidth: function(e, t) {
            var n = this,
            r = n.dom,
            i = n.isStyle("display", "none"),
            s,
            u,
            a;
            if (i) {
                return 0
            }
            if (Ext.supports.BoundingClientRect) {
                s = r.getBoundingClientRect();
                u = n.vertical && !Ext.isIE9 && !Ext.supports.RotatedBoundingClientRect ? s.bottom - s.top: s.right - s.left;
                u = t ? u: Math.ceil(u)
            } else {
                u = r.offsetWidth
            }
            if (Ext.supports.Direct2DBug && !n.vertical) {
                a = n.adjustDirect2DDimension(o);
                if (t) {
                    u += a
                } else {
                    if (a > 0 && a < .5) {
                        u++
                    }
                }
            }
            if (e) {
                u -= n.getBorderWidth("lr") + n.getPadding("lr")
            }
            return u < 0 ? 0 : u
        },
        setWidth: function(e, t) {
            var n = this;
            e = n.adjustWidth(e);
            if (!t || !n.anim) {
                n.dom.style.width = n.addUnits(e)
            } else {
                if (!Ext.isObject(t)) {
                    t = {}
                }
                n.animate(Ext.applyIf({
                    to: {
                        width: e
                    }
                },
                t))
            }
            return n
        },
        setHeight: function(e, t) {
            var n = this;
            e = n.adjustHeight(e);
            if (!t || !n.anim) {
                n.dom.style.height = n.addUnits(e)
            } else {
                if (!Ext.isObject(t)) {
                    t = {}
                }
                n.animate(Ext.applyIf({
                    to: {
                        height: e
                    }
                },
                t))
            }
            return n
        },
        applyStyles: function(e) {
            Ext.DomHelper.applyStyles(this.dom, e);
            return this
        },
        setSize: function(e, t, n) {
            var r = this;
            if (Ext.isObject(e)) {
                n = t;
                t = e.height;
                e = e.width
            }
            e = r.adjustWidth(e);
            t = r.adjustHeight(t);
            if (!n || !r.anim) {
                r.dom.style.width = r.addUnits(e);
                r.dom.style.height = r.addUnits(t)
            } else {
                if (n === true) {
                    n = {}
                }
                r.animate(Ext.applyIf({
                    to: {
                        width: e,
                        height: t
                    }
                },
                n))
            }
            return r
        },
        getViewSize: function() {
            var t = this,
            n = t.dom,
            r = h.test(n.nodeName),
            i;
            if (r) {
                i = {
                    width: e.getViewWidth(),
                    height: e.getViewHeight()
                }
            } else {
                i = {
                    width: n.clientWidth,
                    height: n.clientHeight
                }
            }
            return i
        },
        getSize: function(e) {
            return {
                width: this.getWidth(e),
                height: this.getHeight(e)
            }
        },
        adjustWidth: function(e) {
            var t = this,
            n = typeof e == "number";
            if (n && t.autoBoxAdjust && !t.isBorderBox()) {
                e -= t.getBorderWidth("lr") + t.getPadding("lr")
            }
            return n && e < 0 ? 0 : e
        },
        adjustHeight: function(e) {
            var t = this,
            n = typeof e == "number";
            if (n && t.autoBoxAdjust && !t.isBorderBox()) {
                e -= t.getBorderWidth("tb") + t.getPadding("tb")
            }
            return n && e < 0 ? 0 : e
        },
        getColor: function(e, t, n) {
            var r = this.getStyle(e),
            i = n || n === "" ? n: "#",
            s,
            o,
            u = 0;
            if (!r || /transparent|inherit/.test(r)) {
                return t
            }
            if (/^r/.test(r)) {
                r = r.slice(4, r.length - 1).split(",");
                o = r.length;
                for (; u < o; u++) {
                    s = parseInt(r[u], 10);
                    i += (s < 16 ? "0": "") + s.toString(16)
                }
            } else {
                r = r.replace("#", "");
                i += r.length == 3 ? r.replace(/^(\w)(\w)(\w)$/, "$1$1$2$2$3$3") : r
            }
            return i.length > 5 ? i.toLowerCase() : t
        },
        setOpacity: function(e, t) {
            var n = this;
            if (!n.dom) {
                return n
            }
            if (!t || !n.anim) {
                n.setStyle("opacity", e)
            } else {
                if (typeof t != "object") {
                    t = {
                        duration: 350,
                        easing: "ease-in"
                    }
                }
                n.animate(Ext.applyIf({
                    to: {
                        opacity: e
                    }
                },
                t))
            }
            return n
        },
        clearOpacity: function() {
            return this.setOpacity("")
        },
        adjustDirect2DDimension: function(e) {
            var t = this,
            r = t.dom,
            i = t.getStyle("display"),
            s = r.style.display,
            u = r.style.position,
            a = e === o ? 0 : 1,
            f = r.currentStyle,
            l;
            if (i === "inline") {
                r.style.display = "inline-block"
            }
            r.style.position = i.match(n) ? "absolute": "static";
            l = (parseFloat(f[e]) || parseFloat(f.msTransformOrigin.split(" ")[a]) * 2) % 1;
            r.style.position = u;
            if (i === "inline") {
                r.style.display = s
            }
            return l
        },
        clip: function() {
            var e = this,
            t = (e.$cache || e.getCache()).data,
            n;
            if (!t[u]) {
                t[u] = true;
                n = e.getStyle([a, f, l]);
                t[c] = {
                    o: n[a],
                    x: n[f],
                    y: n[l]
                };
                e.setStyle(a, i);
                e.setStyle(f, i);
                e.setStyle(l, i)
            }
            return e
        },
        unclip: function() {
            var e = this,
            t = (e.$cache || e.getCache()).data,
            n;
            if (t[u]) {
                t[u] = false;
                n = t[c];
                if (n.o) {
                    e.setStyle(a, n.o)
                }
                if (n.x) {
                    e.setStyle(f, n.x)
                }
                if (n.y) {
                    e.setStyle(l, n.y)
                }
            }
            return e
        },
        boxWrap: function(t) {
            t = t || Ext.baseCSSPrefix + "box";
            var n = Ext.get(this.insertHtml("beforeBegin", "<div class='" + t + "' role='presentation'>" + Ext.String.format(e.boxMarkup, t) + "</div>"));
            Ext.DomQuery.selectNode("." + t + "-mc", n.dom).appendChild(this.dom);
            return n
        },
        getComputedHeight: function() {
            var e = this,
            t = Math.max(e.dom.offsetHeight, e.dom.clientHeight);
            if (!t) {
                t = parseFloat(e.getStyle(s)) || 0;
                if (!e.isBorderBox()) {
                    t += e.getFrameWidth("tb")
                }
            }
            return t
        },
        getComputedWidth: function() {
            var e = this,
            t = Math.max(e.dom.offsetWidth, e.dom.clientWidth);
            if (!t) {
                t = parseFloat(e.getStyle(o)) || 0;
                if (!e.isBorderBox()) {
                    t += e.getFrameWidth("lr")
                }
            }
            return t
        },
        getFrameWidth: function(e, t) {
            return t && this.isBorderBox() ? 0 : this.getPadding(e) + this.getBorderWidth(e)
        },
        addClsOnOver: function(e, t, n) {
            var i = this,
            s = i.dom,
            o = Ext.isFunction(t);
            i.hover(function() {
                if (o && t.call(n || i, i) === false) {
                    return
                }
                Ext.fly(s, r).addCls(e)
            },
            function() {
                Ext.fly(s, r).removeCls(e)
            });
            return i
        },
        addClsOnFocus: function(e, t, n) {
            var i = this,
            s = i.dom,
            o = Ext.isFunction(t);
            i.on("focus",
            function() {
                if (o && t.call(n || i, i) === false) {
                    return false
                }
                Ext.fly(s, r).addCls(e)
            });
            i.on("blur",
            function() {
                Ext.fly(s, r).removeCls(e)
            });
            return i
        },
        addClsOnClick: function(e, t, n) {
            var i = this,
            s = i.dom,
            o = Ext.isFunction(t);
            i.on("mousedown",
            function() {
                if (o && t.call(n || i, i) === false) {
                    return false
                }
                Ext.fly(s, r).addCls(e);
                var u = Ext.getDoc(),
                a = function() {
                    Ext.fly(s, r).removeCls(e);
                    u.removeListener("mouseup", a)
                };
                u.on("mouseup", a)
            });
            return i
        },
        getStyleSize: function() {
            var t = this,
            n = this.dom,
            r = h.test(n.nodeName),
            i,
            u,
            a;
            if (r) {
                return {
                    width: e.getViewWidth(),
                    height: e.getViewHeight()
                }
            }
            i = t.getStyle([s, o], true);
            if (i.width && i.width != "auto") {
                u = parseFloat(i.width);
                if (t.isBorderBox()) {
                    u -= t.getFrameWidth("lr")
                }
            }
            if (i.height && i.height != "auto") {
                a = parseFloat(i.height);
                if (t.isBorderBox()) {
                    a -= t.getFrameWidth("tb")
                }
            }
            return {
                width: u || t.getWidth(true),
                height: a || t.getHeight(true)
            }
        },
        statics: {
            selectableCls: Ext.baseCSSPrefix + "selectable",
            unselectableCls: Ext.baseCSSPrefix + "unselectable"
        },
        selectable: function() {
            var t = this;
            t.dom.unselectable = "";
            t.removeCls(e.unselectableCls);
            t.addCls(e.selectableCls);
            return t
        },
        unselectable: function() {
            var t = this;
            if (Ext.isOpera) {
                t.dom.unselectable = "on"
            }
            t.removeCls(e.selectableCls);
            t.addCls(e.unselectableCls);
            return t
        },
        setVertical: function(t, n) {
            var r = this,
            i = e.prototype,
            s;
            r.vertical = true;
            if (n) {
                r.addCls(r.verticalCls = n)
            }
            r.setWidth = i.setHeight;
            r.setHeight = i.setWidth;
            if (!Ext.isIE9m) {
                r.getWidth = i.getHeight;
                r.getHeight = i.getWidth
            }
            r.styleHooks = t === 270 ? e.prototype.verticalStyleHooks270: e.prototype.verticalStyleHooks90
        },
        setHorizontal: function() {
            var e = this,
            t = e.verticalCls;
            delete e.vertical;
            if (t) {
                delete e.verticalCls;
                e.removeCls(t)
            }
            delete e.setWidth;
            delete e.setHeight;
            if (!Ext.isIE9m) {
                delete e.getWidth;
                delete e.getHeight
            }
            delete e.styleHooks
        }
    });
    e.prototype.styleHooks = p = Ext.dom.AbstractElement.prototype.styleHooks;
    e.prototype.verticalStyleHooks90 = d = Ext.Object.chain(e.prototype.styleHooks);
    e.prototype.verticalStyleHooks270 = v = Ext.Object.chain(e.prototype.styleHooks);
    d.width = {
        name: "height"
    };
    d.height = {
        name: "width"
    };
    d["margin-top"] = {
        name: "marginLeft"
    };
    d["margin-right"] = {
        name: "marginTop"
    };
    d["margin-bottom"] = {
        name: "marginRight"
    };
    d["margin-left"] = {
        name: "marginBottom"
    };
    d["padding-top"] = {
        name: "paddingLeft"
    };
    d["padding-right"] = {
        name: "paddingTop"
    };
    d["padding-bottom"] = {
        name: "paddingRight"
    };
    d["padding-left"] = {
        name: "paddingBottom"
    };
    d["border-top"] = {
        name: "borderLeft"
    };
    d["border-right"] = {
        name: "borderTop"
    };
    d["border-bottom"] = {
        name: "borderRight"
    };
    d["border-left"] = {
        name: "borderBottom"
    };
    v.width = {
        name: "height"
    };
    v.height = {
        name: "width"
    };
    v["margin-top"] = {
        name: "marginRight"
    };
    v["margin-right"] = {
        name: "marginBottom"
    };
    v["margin-bottom"] = {
        name: "marginLeft"
    };
    v["margin-left"] = {
        name: "marginTop"
    };
    v["padding-top"] = {
        name: "paddingRight"
    };
    v["padding-right"] = {
        name: "paddingBottom"
    };
    v["padding-bottom"] = {
        name: "paddingLeft"
    };
    v["padding-left"] = {
        name: "paddingTop"
    };
    v["border-top"] = {
        name: "borderRight"
    };
    v["border-right"] = {
        name: "borderBottom"
    };
    v["border-bottom"] = {
        name: "borderLeft"
    };
    v["border-left"] = {
        name: "borderTop"
    };
    if (Ext.isIE7m) {
        p.fontSize = p["font-size"] = {
            name: "fontSize",
            canThrow: true
        };
        p.fontStyle = p["font-style"] = {
            name: "fontStyle",
            canThrow: true
        };
        p.fontFamily = p["font-family"] = {
            name: "fontFamily",
            canThrow: true
        }
    }
    if (Ext.isIEQuirks || Ext.isIE && Ext.ieVersion <= 8) {
        function w(e, t, n, r) {
            if (r[this.styleName] == "none") {
                return "0px"
            }
            return r[this.name]
        }
        m = ["Top", "Right", "Bottom", "Left"];
        g = m.length;
        while (g--) {
            y = m[g];
            b = "border" + y + "Width";
            p["border-" + y.toLowerCase() + "-width"] = p[b] = {
                name: b,
                styleName: "border" + y + "Style",
                get: w
            }
        }
    }
    Ext.getDoc().on("selectstart",
    function(t, n) {
        var r = document.documentElement,
        i = e.selectableCls,
        s = e.unselectableCls,
        o = n && n.tagName;
        o = o && o.toLowerCase();
        if (o === "input" || o === "textarea") {
            return
        }
        while (n && n.nodeType === 1 && n !== r) {
            var u = Ext.fly(n);
            if (u.hasCls(i)) {
                return
            }
            if (u.hasCls(s)) {
                t.stopEvent();
                return
            }
            n = n.parentNode
        }
    })
});
Ext.onReady(function() {
    var e = /alpha\(opacity=(.*)\)/i,
    t = /^\s+|\s+$/g,
    n = Ext.dom.Element.prototype.styleHooks;
    n.opacity = {
        name: "opacity",
        afterSet: function(e, t, n) {
            if (n.isLayer) {
                n.onOpacitySet(t)
            }
        }
    };
    if (!Ext.supports.Opacity && Ext.isIE) {
        Ext.apply(n.opacity, {
            get: function(t) {
                var n = t.style.filter,
                r, i;
                if (n.match) {
                    r = n.match(e);
                    if (r) {
                        i = parseFloat(r[1]);
                        if (!isNaN(i)) {
                            return i ? i / 100 : 0
                        }
                    }
                }
                return 1
            },
            set: function(n, r) {
                var i = n.style,
                s = i.filter.replace(e, "").replace(t, "");
                i.zoom = 1;
                if (typeof r == "number" && r >= 0 && r < 1) {
                    r *= 100;
                    i.filter = s + (s.length ? " ": "") + "alpha(opacity=" + r + ")"
                } else {
                    i.filter = s
                }
            }
        })
    }
});
Ext.define("Ext.util.Positionable", {
    _positionTopLeft: ["position", "top", "left"],
    _alignRe: /^([a-z]+)-([a-z]+)(\?)?$/,
    afterSetPosition: Ext.emptyFn,
    adjustForConstraints: function(e, t) {
        var n = this.getConstrainVector(t, e);
        if (n) {
            e[0] += n[0];
            e[1] += n[1]
        }
        return e
    },
    alignTo: function(e, t, n, r) {
        var i = this,
        s = i.el;
        return i.setXY(i.getAlignToXY(e, t, n), s.anim && !!r ? s.anim(r) : false)
    },
    anchorTo: function(e, t, n, r, i, s) {
        var o = this,
        u = !Ext.isEmpty(i),
        a = function() {
            o.alignTo(e, t, n, r);
            Ext.callback(s, o)
        },
        f = o.getAnchor();
        o.removeAnchor();
        Ext.apply(f, {
            fn: a,
            scroll: u
        });
        Ext.EventManager.onWindowResize(a, null);
        if (u) {
            Ext.EventManager.on(window, "scroll", a, null, {
                buffer: !isNaN(i) ? i: 50
            })
        }
        a();
        return o
    },
    calculateAnchorXY: function(e, t, n, r) {
        var i = this,
        s = i.el,
        o = document,
        u = s.dom == o.body || s.dom == o,
        a = Math.round,
        f, l, c;
        e = (e || "tl").toLowerCase();
        r = r || {};
        l = r.width || (u ? Ext.Element.getViewWidth() : i.getWidth());
        c = r.height || (u ? Ext.Element.getViewHeight() : i.getHeight());
        switch (e) {
        case "tl":
            f = [0, 0];
            break;
        case "bl":
            f = [0, c];
            break;
        case "tr":
            f = [l, 0];
            break;
        case "c":
            f = [a(l * .5), a(c * .5)];
            break;
        case "t":
            f = [a(l * .5), 0];
            break;
        case "l":
            f = [0, a(c * .5)];
            break;
        case "r":
            f = [l, a(c * .5)];
            break;
        case "b":
            f = [a(l * .5), c];
            break;
        case "tc":
            f = [a(l * .5), 0];
            break;
        case "bc":
            f = [a(l * .5), c];
            break;
        case "br":
            f = [l, c]
        }
        return [f[0] + t, f[1] + n]
    },
    convertPositionSpec: Ext.identityFn,
    getAlignToXY: function(e, t, n) {
        var r = this,
        i, s, o, u, a, f, l, c, h, p, d, v, m, g, y, b, w, E, S;
        e = Ext.get(e.el || e);
        if (!e || !e.dom) {}
        n = n || [0, 0];
        t = (!t || t == "?" ? "tl-bl?": !/-/.test(t) && t !== "" ? "tl-" + t: t || "tl-bl").toLowerCase();
        t = r.convertPositionSpec(t);
        o = t.match(r._alignRe);
        v = o[1];
        m = o[2];
        d = !!o[3];
        u = r.getAnchorXY(v, true);
        a = r.getAnchorToXY(e, m, false);
        E = a[0] - u[0] + n[0];
        S = a[1] - u[1] + n[1];
        if (d) {
            i = r.constrainTo || r.container || r.el.parent();
            i = Ext.get(i.el || i);
            s = i.getViewRegion();
            s.right = s.left + i.el.dom.clientWidth;
            if (r.constrainToBottom) {
                s.bottom = s.top + i.el.dom.clientHeight
            }
            f = r.getWidth();
            l = r.getHeight();
            c = e.getRegion();
            g = v.charAt(0);
            y = v.charAt(v.length - 1);
            b = m.charAt(0);
            w = m.charAt(m.length - 1);
            h = E < c.right && E + f >= c.left && (g == "t" && b == "b" || g == "b" && b == "t");
            p = S < c.bottom && S + l >= c.top && (y == "r" && w == "l" || y == "l" && w == "r");
            if (E + f > s.right) {
                if (p) {
                    E = c.left - f;
                    p = false
                } else {
                    E = s.right - f
                }
            }
            if (E < s.left) {
                E = p ? c.right: s.left
            }
            if (S + l > s.bottom) {
                if (h) {
                    S = c.top - l;
                    h = false
                } else {
                    S = s.bottom - l
                }
            }
            if (S < s.top) {
                S = h ? c.bottom: s.top
            }
        }
        return [E, S]
    },
    getAnchor: function() {
        var e = this.el,
        t = (e.$cache || e.getCache()).data,
        n;
        if (!e.dom) {
            return
        }
        n = t._anchor;
        if (!n) {
            n = t._anchor = {}
        }
        return n
    },
    getAnchorXY: function(e, t, n) {
        var r = this,
        i = r.getXY(),
        s = r.el,
        o = document,
        u = s.dom == o.body || s.dom == o,
        a = s.getScroll(),
        f = u ? a.left: t ? 0 : i[0],
        l = u ? a.top: t ? 0 : i[1];
        return r.calculateAnchorXY(e, f, l, n)
    },
    getBox: function(e, t) {
        var n = this,
        r = t ? n.getLocalXY() : n.getXY(),
        i = r[0],
        s = r[1],
        o = n.getWidth(),
        u = n.getHeight(),
        a,
        f,
        l;
        if (e) {
            a = n.getBorderPadding();
            f = a.beforeX;
            l = a.beforeY;
            i += f;
            s += l;
            o -= f + a.afterX;
            u -= l + a.afterY
        }
        return {
            x: i,
            left: i,
            0 : i,
            y: s,
            top: s,
            1 : s,
            width: o,
            height: u,
            right: i + o,
            bottom: s + u
        }
    },
    calculateConstrainedPosition: function(e, t, n, r) {
        var i = this,
        s, o = i.floatParent,
        u = o ? o.getTargetEl() : null,
        a,
        f,
        l,
        c = false;
        if (n && o) {
            a = u.getXY();
            f = u.getBorderPadding();
            a[0] += f.beforeX;
            a[1] += f.beforeY;
            if (t) {
                l = [t[0] + a[0], t[1] + a[1]]
            }
        } else {
            l = t
        }
        e = e || i.constrainTo || u || i.container || i.el.parent();
        s = (i.constrainHeader ? i.header: i).getConstrainVector(e, l, r);
        if (s) {
            c = t || i.getPosition(n);
            c[0] += s[0];
            c[1] += s[1]
        }
        return c
    },
    getConstrainVector: function(e, t, n) {
        var r = this.getRegion(),
        i = [0, 0],
        s = this.shadow && this.constrainShadow && !this.shadowDisabled ? this.shadow.getShadowSize() : undefined,
        o = false,
        u,
        a = this.constraintInsets;
        if (! (e instanceof Ext.util.Region)) {
            e = Ext.get(e.el || e);
            u = e.getViewSize();
            e = e.getViewRegion();
            e.right = e.left + u.width;
            e.bottom = e.top + u.height
        }
        if (a) {
            a = Ext.isObject(a) ? a: Ext.Element.parseBox(a);
            e.adjust(a.top, a.right, a.bottom, a.length)
        }
        if (t) {
            r.translateBy(t[0] - r.x, t[1] - r.y)
        }
        if (n) {
            r.right = r.left + n[0];
            r.bottom = r.top + n[1]
        }
        if (s) {
            e.adjust(s[0], -s[1], -s[2], s[3])
        }
        if (r.right > e.right) {
            o = true;
            i[0] = e.right - r.right
        }
        if (r.left + i[0] < e.left) {
            o = true;
            i[0] = e.left - r.left
        }
        if (r.bottom > e.bottom) {
            o = true;
            i[1] = e.bottom - r.bottom
        }
        if (r.top + i[1] < e.top) {
            o = true;
            i[1] = e.top - r.top
        }
        return o ? i: false
    },
    getOffsetsTo: function(e) {
        var t = this.getXY(),
        n = Ext.fly(e.el || e, "_internal").getXY();
        return [t[0] - n[0], t[1] - n[1]]
    },
    getRegion: function() {
        var e = this.getBox();
        return new Ext.util.Region(e.top, e.right, e.bottom, e.left)
    },
    getViewRegion: function() {
        var e = this,
        t = e.el,
        n = t.dom.nodeName === "BODY",
        r, i, s, o, u, a, f;
        if (n) {
            i = t.getScroll();
            u = i.left;
            o = i.top;
            a = Ext.dom.AbstractElement.getViewportWidth();
            f = Ext.dom.AbstractElement.getViewportHeight()
        } else {
            r = e.getBorderPadding();
            s = e.getXY();
            u = s[0] + r.beforeX;
            o = s[1] + r.beforeY;
            a = e.getWidth(true);
            f = e.getHeight(true)
        }
        return new Ext.util.Region(o, u + a, o + f, u)
    },
    move: function(e, t, n) {
        var r = this,
        i = r.getXY(),
        s = i[0],
        o = i[1],
        u = [s - t, o],
        a = [s + t, o],
        f = [s, o - t],
        l = [s, o + t],
        c = {
            l: u,
            left: u,
            r: a,
            right: a,
            t: f,
            top: f,
            up: f,
            b: l,
            bottom: l,
            down: l
        };
        e = e.toLowerCase();
        r.setXY([c[e][0], c[e][1]], n)
    },
    removeAnchor: function() {
        var e = this.getAnchor();
        if (e && e.fn) {
            Ext.EventManager.removeResizeListener(e.fn);
            if (e.scroll) {
                Ext.EventManager.un(window, "scroll", e.fn)
            }
            delete e.fn
        }
        return this
    },
    setBox: function(e, t) {
        var n = this,
        r = n.el,
        i = e.x,
        s = e.y,
        o = [i, s],
        u = e.width,
        a = e.height,
        f = n.constrain || n.constrainHeader,
        l = f && n.calculateConstrainedPosition(null, [i, s], false, [u, a]);
        if (l) {
            i = l[0];
            s = l[1]
        }
        if (!t || !r.anim) {
            n.setSize(u, a);
            n.setXY([i, s]);
            n.afterSetPosition(i, s)
        } else {
            n.animate(Ext.applyIf({
                to: {
                    x: i,
                    y: s,
                    width: r.adjustWidth(u),
                    height: r.adjustHeight(a)
                },
                listeners: {
                    afteranimate: Ext.Function.bind(n.afterSetPosition, n, [i, s])
                }
            },
            t))
        }
        return n
    },
    setRegion: function(e, t) {
        return this.setBox({
            x: e.left,
            y: e.top,
            width: e.right - e.left,
            height: e.bottom - e.top
        },
        t)
    },
    translatePoints: function(e, t) {
        var n = this.translateXY(e, t);
        return {
            left: n.x,
            top: n.y
        }
    },
    translateXY: function(e, t) {
        var n = this,
        r = n.el,
        i = r.getStyle(n._positionTopLeft),
        s = i.position == "relative",
        o = parseFloat(i.left),
        u = parseFloat(i.top),
        a = n.getXY();
        if (Ext.isArray(e)) {
            t = e[1];
            e = e[0]
        }
        if (isNaN(o)) {
            o = s ? 0 : r.dom.offsetLeft
        }
        if (isNaN(u)) {
            u = s ? 0 : r.dom.offsetTop
        }
        o = typeof e == "number" ? e - a[0] + o: undefined;
        u = typeof t == "number" ? t - a[1] + u: undefined;
        return {
            x: o,
            y: u
        }
    }
});
Ext.define("Ext.dom.Element",
function(e) {
    var t = "hidden",
    n = document,
    r = "visibility",
    i = "display",
    s = "none",
    o = Ext.baseCSSPrefix + "masked",
    u = Ext.baseCSSPrefix + "masked-relative",
    a = Ext.baseCSSPrefix + "mask-msg",
    f = /^body/i,
    l, c = Ext.isStrict ? {
        select: 1
    }: {
        input: 1,
        select: 1,
        textarea: 1
    },
    h = function(e) {
        var t = [],
        n = -1,
        r,
        i;
        for (r = 0; i = e[r]; r++) {
            if (i.scrollTop > 0 || i.scrollLeft > 0) {
                t[++n] = i
            }
        }
        return t
    };
    return {
        extend: Ext.dom.AbstractElement,
        alternateClassName: ["Ext.Element", "Ext.core.Element"],
        isElement: true,
        tableTagRe: /^(?:tr|td|table|tbody)$/i,
        mixins: [Ext.util.Positionable],
        addUnits: function() {
            return e.addUnits.apply(e, arguments)
        },
        focus: function(e, t) {
            var n = this;
            t = t || n.dom;
            try {
                if (Number(e)) {
                    Ext.defer(n.focus, e, n, [null, t])
                } else {
                    Ext.globalEvents.fireEvent("beforefocus", t);
                    t.focus()
                }
            } catch(r) {}
            return n
        },
        blur: function() {
            var e = this,
            t = e.dom;
            if (t !== document.body) {
                try {
                    t.blur()
                } catch(n) {}
                return e
            } else {
                return e.focus(undefined, t)
            }
        },
        isBorderBox: function() {
            var e = Ext.isBorderBox;
            if (Ext.isIE7m && !e) {
                e = (this.dom.tagName || "").toLowerCase() in c
            }
            return e
        },
        hover: function(e, t, n, r) {
            var i = this;
            i.on("mouseenter", e, n || i.dom, r);
            i.on("mouseleave", t, n || i.dom, r);
            return i
        },
        getAttributeNS: function(e, t) {
            return this.getAttribute(t, e)
        },
        getAttribute: Ext.isIE && !(Ext.isIE9p && n.documentMode >= 9) ?
        function(e, t) {
            var n = this.dom,
            r;
            if (t) {
                r = typeof n[t + ":" + e];
                if (r != "undefined" && r != "unknown") {
                    return n[t + ":" + e] || null
                }
                return null
            }
            if (e === "for") {
                e = "htmlFor"
            }
            return n[e] || null
        }: function(e, t) {
            var n = this.dom;
            if (t) {
                return n.getAttributeNS(t, e) || n.getAttribute(t + ":" + e)
            }
            return n.getAttribute(e) || n[e] || null
        },
        cacheScrollValues: function() {
            var e = this,
            t, n, r, i = [],
            s = function() {
                for (r = 0; r < t.length; r++) {
                    n = t[r];
                    n.scrollLeft = i[r][0];
                    n.scrollTop = i[r][1]
                }
            };
            if (!Ext.DomQuery.pseudos.isScrolled) {
                Ext.DomQuery.pseudos.isScrolled = h
            }
            t = e.query(":isScrolled");
            for (r = 0; r < t.length; r++) {
                n = t[r];
                i[r] = [n.scrollLeft, n.scrollTop]
            }
            return s
        },
        autoBoxAdjust: true,
        isVisible: function(n) {
            var o = this,
            u = o.dom,
            a = u.ownerDocument.documentElement;
            if (!l) {
                l = new e.Fly
            }
            while (u !== a) {
                if (!u || u.nodeType === 11 || l.attach(u).isStyle(r, t) || l.isStyle(i, s)) {
                    return false
                }
                if (!n) {
                    break
                }
                u = u.parentNode
            }
            return true
        },
        isDisplayed: function() {
            return ! this.isStyle(i, s)
        },
        enableDisplayMode: function(t) {
            var n = this;
            n.setVisibilityMode(e.DISPLAY);
            if (!Ext.isEmpty(t)) { (n.$cache || n.getCache()).data.originalDisplay = t
            }
            return n
        },
        mask: function(e, t, r, i) {
            var s = this,
            l = s.dom,
            c = l.style.setExpression,
            h = (s.$cache || s.getCache()).data,
            p = h.maskShimEl,
            d = h.maskEl,
            v = h.maskMsg,
            y,
            b,
            w,
            E;
            if (! (f.test(l.tagName) && s.getStyle("position") == "static")) {
                s.addCls(u)
            }
            if (d) {
                d.remove()
            }
            if (v) {
                v.remove()
            }
            if (p) {
                p.remove()
            }
            if (Ext.isIE6) {
                p = Ext.DomHelper.append(l, {
                    tag: "iframe",
                    role: "presentation",
                    cls: Ext.baseCSSPrefix + "shim " + Ext.baseCSSPrefix + "mask-shim"
                },
                true);
                h.maskShimEl = p;
                p.setDisplayed(true)
            }
            Ext.DomHelper.append(l, [{
                role: "presentation",
                cls: Ext.baseCSSPrefix + "mask" + (i ? " wb_opacity": ""),
                style: "top:0;left:0;"
            },
            {
                role: "presentation",
                cls: (t ? a + " " + t: a) + (i ? " wb_opacity": ""),
                cn: {
                    tag: "div",
                    role: "presentation",
                    cls: Ext.baseCSSPrefix + "mask-msg-inner",
                    cn: {
                        tag: "div",
                        role: "presentation",
                        cls: Ext.baseCSSPrefix + "mask-msg-text",
                        html: e || ""
                    }
                }
            }]);
            v = Ext.get(l.lastChild);
            d = Ext.get(v.dom.previousSibling);
            if (i) {
                setTimeout(function() {
                    try {
                        v.removeCls("wb_opacity");
                        d.removeCls("wb_opacity")
                    } catch(e) {}
                },
                i)
            }
            h.maskMsg = v;
            h.maskEl = d;
            s.addCls(o);
            d.setDisplayed(true);
            if (typeof e == "string") {
                v.setDisplayed(true);
                v.center(s)
            } else {
                v.setDisplayed(false)
            }
            if (Ext.isStrict && !Ext.isIE6 && l === n.body) {
                d.addCls(Ext.baseCSSPrefix + "mask-fixed")
            }
            if (l !== n.body || Ext.isIE6 || Ext.isIEQuirks) {
                if (!Ext.supports.IncludePaddingInWidthCalculation && c) {
                    try {
                        d.dom.style.setExpression("width", 'this.parentNode.clientWidth + "px"');
                        y = 'this.parentNode.clientWidth + "px"';
                        if (p) {
                            p.dom.style.setExpression("width", y)
                        }
                        d.dom.style.setExpression("width", y)
                    } catch(S) {}
                }
                if (!Ext.supports.IncludePaddingInHeightCalculation && c) {
                    try {
                        b = "this.parentNode." + (l == n.body ? "scrollHeight": "offsetHeight") + ' + "px"';
                        if (p) {
                            p.dom.style.setExpression("height", b)
                        }
                        d.dom.style.setExpression("height", b)
                    } catch(S) {}
                } else {
                    if (Ext.isIE9m && !(Ext.isIE7 && Ext.isStrict) && s.getStyle("height") == "auto") {
                        if (Ext.isIE6 && Ext.isStrict) {
                            w = l.parentNode;
                            E = Math.max(w.clientHeight, w.scrollHeight)
                        }
                        if (p) {
                            p.setSize(undefined, r || E || s.getHeight())
                        }
                        d.setSize(undefined, r || E || s.getHeight())
                    }
                }
            }
            return d
        },
        unmask: function() {
            var e = this,
            t = (e.$cache || e.getCache()).data,
            n = t.maskEl,
            r = t.maskShimEl,
            i = t.maskMsg,
            s;
            if (n) {
                s = n.dom.style;
                if (s.clearExpression) {
                    s.clearExpression("width");
                    s.clearExpression("height")
                }
                if (n) {
                    n.remove();
                    delete t.maskEl
                }
                if (i) {
                    i.remove();
                    delete t.maskMsg
                }
                e.removeCls([o, u]);
                if (r) {
                    s = r.dom.style;
                    if (s.clearExpression) {
                        s.clearExpression("width");
                        s.clearExpression("height")
                    }
                    r.remove();
                    delete t.maskShimEl
                }
            }
        },
        isMasked: function() {
            var e = this,
            t = (e.$cache || e.getCache()).data,
            n = t.maskEl,
            r = t.maskMsg,
            i = false;
            if (n && n.isVisible()) {
                if (r) {
                    r.center(e)
                }
                i = true
            }
            return i
        },
        createShim: function() {
            var e = n.createElement("iframe"),
            t;
            e.frameBorder = "0";
            e.className = Ext.baseCSSPrefix + "shim";
            e.src = Ext.SSL_SECURE_URL;
            e.setAttribute("role", "presentation");
            t = Ext.get(this.dom.parentNode.insertBefore(e, this.dom));
            t.autoBoxAdjust = false;
            return t
        },
        addKeyListener: function(e, t, n) {
            var r;
            if (typeof e != "object" || Ext.isArray(e)) {
                r = {
                    target: this,
                    key: e,
                    fn: t,
                    scope: n
                }
            } else {
                r = {
                    target: this,
                    key: e.key,
                    shift: e.shift,
                    ctrl: e.ctrl,
                    alt: e.alt,
                    fn: t,
                    scope: n
                }
            }
            return new Ext.util.KeyMap(r)
        },
        addKeyMap: function(e) {
            return new Ext.util.KeyMap(Ext.apply({
                target: this
            },
            e))
        },
        on: function(e, t, n, r) {
            Ext.EventManager.on(this, e, t, n || this, r);
            return this
        },
        un: function(e, t, n) {
            Ext.EventManager.un(this, e, t, n || this);
            return this
        },
        removeAllListeners: function() {
            Ext.EventManager.removeAll(this);
            return this
        },
        purgeAllListeners: function() {
            Ext.EventManager.purgeElement(this);
            return this
        },
        select: function(t) {
            return e.select(t, false, this.dom)
        }
    }
},
function() {
    function h() {
        if (!Ext.enableGarbageCollector) {
            clearInterval(n.collectorThreadId)
        } else {
            var e, r, i, s;
            for (e in t) {
                if (!t.hasOwnProperty(e)) {
                    continue
                }
                i = t[e];
                if (i.skipGarbageCollection) {
                    continue
                }
                r = i.dom;
                if (r && (!r.parentNode || !r.offsetParent && !Ext.getElementById(e))) {
                    if (Ext.enableListenerCollection) {
                        Ext.EventManager.removeAll(r)
                    }
                    delete t[e]
                }
            }
            if (Ext.isIE) {
                s = {};
                for (e in t) {
                    if (!t.hasOwnProperty(e)) {
                        continue
                    }
                    s[e] = t[e]
                }
                t = Ext.cache = s
            }
        }
    }
    var e = document,
    t = Ext.cache,
    n = this,
    r = Ext.dom.AbstractElement,
    i = /^a|button|embed|iframe|input|object|select|textarea$/i,
    s = /\S/,
    o = /(?:<script([^>]*)?>)((\n|\r|.)*?)(?:<\/script>)/ig,
    u = /(?:<script.*?>)((\n|\r|.)*?)(?:<\/script>)/ig,
    a = /\ssrc=([\'\"])(.*?)\1/i,
    f = /\stype=([\'\"])(.*?)\1/i,
    l = !Ext.isIE8m,
    c;
    n.boxMarkup = ['<div class="{0}-tl" role="presentation">', '<div class="{0}-tr" role="presentation">', '<div class="{0}-tc" role="presentation"></div>', "</div>", "</div>", '<div class="{0}-ml" role="presentation">', '<div class="{0}-mr" role="presentation">', '<div class="{0}-mc" role="presentation"></div>', "</div>", "</div>", '<div class="{0}-bl" role="presentation">', '<div class="{0}-br" role="presentation">', '<div class="{0}-bc" role="presentation"></div>', "</div>", "</div>"].join("");
    n.collectorThreadId = setInterval(h, 3e4);
    n.addMethods({
        monitorMouseLeave: function(e, t, n) {
            var r = this,
            i, s = {
                mouseleave: function(s) {
                    i = setTimeout(Ext.Function.bind(t, n || r, [s]), e)
                },
                mouseenter: function() {
                    clearTimeout(i)
                },
                freezeEvent: true
            };
            r.on(s);
            return s
        },
        swallowEvent: function(e, t) {
            var n = this,
            r, i, s = function(e) {
                e.stopPropagation();
                if (t) {
                    e.preventDefault()
                }
            };
            if (Ext.isArray(e)) {
                i = e.length;
                for (r = 0; r < i; r++) {
                    n.on(e[r], s)
                }
                return n
            }
            n.on(e, s);
            return n
        },
        relayEvent: function(e, t) {
            this.on(e,
            function(n) {
                t.fireEvent(e, n)
            })
        },
        clean: function(e) {
            var t = this,
            n = t.dom,
            r = (t.$cache || t.getCache()).data,
            i = n.firstChild,
            o = -1,
            u;
            if (r.isCleaned && e !== true) {
                return t
            }
            while (i) {
                u = i.nextSibling;
                if (i.nodeType == 3) {
                    if (!s.test(i.nodeValue)) {
                        n.removeChild(i)
                    } else {
                        if (u && u.nodeType == 3) {
                            i.appendData(Ext.String.trim(u.data));
                            n.removeChild(u);
                            u = i.nextSibling;
                            i.nodeIndex = ++o
                        }
                    }
                } else {
                    c.attach(i).clean();
                    i.nodeIndex = ++o
                }
                i = u
            }
            r.isCleaned = true;
            return t
        },
        load: function(e) {
            this.getLoader().load(e);
            return this
        },
        getLoader: function() {
            var e = this,
            t = (e.$cache || e.getCache()).data,
            n = t.loader;
            if (!n) {
                t.loader = n = new Ext.ElementLoader({
                    target: e
                })
            }
            return n
        },
        syncContent: function(e) {
            e = Ext.getDom(e);
            var t = e.childNodes,
            n = t.length,
            r = this.dom,
            i = r.childNodes,
            s = i.length,
            o, u, a, f, l, h, p;
            if (Ext.isIE9m && r.mergeAttributes) {
                r.mergeAttributes(e, true);
                r.src = e.src
            } else {
                l = e.attributes;
                h = l.length;
                for (o = 0; o < h; o++) {
                    p = l[o].name;
                    if (p !== "id") {
                        r.setAttribute(p, l[o].value)
                    }
                }
            }
            if (n !== s) {
                r.innerHTML = e.innerHTML;
                return
            }
            for (o = 0; o < n; o++) {
                a = t[o];
                u = i[o];
                f = a.nodeType;
                if (f !== u.nodeType || f === 1 && a.tagName !== u.tagName) {
                    r.innerHTML = e.innerHTML;
                    return
                }
                if (f === 3) {
                    u.data = a.data
                } else {
                    if (a.id && u.id !== a.id) {
                        u.id = a.id
                    }
                    u.style.cssText = a.style.cssText;
                    u.className = a.className;
                    c.attach(u).syncContent(a)
                }
            }
        },
        update: function(t, n, r) {
            var i = this,
            s, l, c;
            if (!i.dom) {
                return i
            }
            t = t || "";
            l = i.dom;
            if (n !== true) {
                l.innerHTML = t;
                Ext.callback(r, i);
                return i
            }
            s = Ext.id();
            t += '<span id="' + s + '" role="presentation"></span>';
            c = setInterval(function() {
                var n, u, l, h, p, d, v;
                if (! (d = e.getElementById(s))) {
                    return false
                }
                clearInterval(c);
                Ext.removeNode(d);
                n = Ext.getHead().dom;
                while (u = o.exec(t)) {
                    l = u[1];
                    h = l ? l.match(a) : false;
                    if (h && h[2]) {
                        v = e.createElement("script");
                        v.src = h[2];
                        p = l.match(f);
                        if (p && p[2]) {
                            v.type = p[2]
                        }
                        n.appendChild(v)
                    } else {
                        if (u[2] && u[2].length > 0) {
                            if (window.execScript) {
                                window.execScript(u[2])
                            } else {
                                window.eval(u[2])
                            }
                        }
                    }
                }
                Ext.callback(r, i)
            },
            20);
            l.innerHTML = t.replace(u, "");
            return i
        },
        removeAllListeners: function() {
            this.removeAnchor();
            Ext.EventManager.removeAll(this.dom);
            return this
        },
        createProxy: function(e, t, r) {
            e = typeof e == "object" ? e: {
                tag: "div",
                role: "presentation",
                cls: e
            };
            var i = this,
            s = t ? Ext.DomHelper.append(t, e, true) : Ext.DomHelper.insertBefore(i.dom, e, true);
            s.setVisibilityMode(n.DISPLAY);
            s.hide();
            if (r && i.setBox && i.getBox) {
                s.setBox(i.getBox())
            }
            return s
        },
        needsTabIndex: function() {
            if (this.dom) {
                if (this.dom.nodeName === "a" && !this.dom.href) {
                    return true
                }
                return ! i.test(this.dom.nodeName)
            }
        },
        isFocusable: function(e) {
            var t = this.dom,
            n = t.getAttributeNode("tabIndex"),
            r,
            s = t.nodeName,
            o = false;
            if (n && n.specified) {
                r = n.value
            }
            if (t && !t.disabled) {
                if (r == -1) {
                    o = Ext.enableFocusManager && e
                } else {
                    if (i.test(s)) {
                        if (s !== "a" || t.href) {
                            o = true
                        }
                    } else {
                        o = r != null && r >= 0
                    }
                }
                o = o && this.isVisible(true)
            }
            return o
        }
    });
    if (Ext.isIE9m) {
        n.prototype.getById = function(r, i) {
            var s = this.dom,
            o, u, a;
            if (s) {
                u = l && e.getElementById(r) || s.all[r];
                if (u) {
                    if (i) {
                        a = u
                    } else {
                        o = t[r];
                        if (o && o.el) {
                            a = Ext.updateCacheEntry(o, u).el
                        } else {
                            a = new n(u)
                        }
                    }
                    return a
                }
            }
            return i ? Ext.getDom(r) : n.get(r)
        }
    }
    n.createAlias({
        addListener: "on",
        removeListener: "un",
        clearListeners: "removeAllListeners",
        focusable: "isFocusable"
    });
    n.Fly = r.Fly = new Ext.Class({
        extend: n,
        isFly: true,
        constructor: function(e) {
            this.dom = e;
            this.el = this
        },
        attach: r.Fly.prototype.attach
    });
    c = new n.Fly;
    if (Ext.isIE9m) {
        Ext.getElementById = function(t) {
            var n = e.getElementById(t),
            i;
            if (!n && (i = r.detachedBodyEl)) {
                n = i.dom.all[t]
            }
            return n
        }
    } else {
        if (!e.querySelector) {
            Ext.getDetachedBody = Ext.getBody;
            Ext.getElementById = function(t) {
                return e.getElementById(t)
            }
        }
    }
});
Ext.define("Ext.dom.CompositeElementLite", {
    alternateClassName: "Ext.CompositeElementLite",
    statics: {
        importElementMethods: function() {
            var e, t = Ext.dom.Element.prototype,
            n = this.prototype;
            for (e in t) {
                if (typeof t[e] == "function") { (function(e) {
                        n[e] = n[e] ||
                        function() {
                            return this.invoke(e, arguments)
                        }
                    }).call(n, e)
                }
            }
        }
    },
    constructor: function(e, t) {
        this.elements = [];
        this.add(e, t);
        this.el = new Ext.dom.AbstractElement.Fly
    },
    isComposite: true,
    getElement: function(e) {
        return this.el.attach(e)
    },
    transformElement: function(e) {
        return Ext.getDom(e)
    },
    getCount: function() {
        return this.elements.length
    },
    add: function(e, t) {
        var n = this.elements,
        r, i;
        if (!e) {
            return this
        }
        if (typeof e == "string") {
            e = Ext.dom.Element.selectorFunction(e, t)
        } else {
            if (e.isComposite) {
                e = e.elements
            } else {
                if (!Ext.isIterable(e)) {
                    e = [e]
                }
            }
        }
        for (r = 0, i = e.length; r < i; ++r) {
            n.push(this.transformElement(e[r]))
        }
        return this
    },
    invoke: function(e, t) {
        var n = this.elements,
        r = n.length,
        i, s;
        e = Ext.dom.Element.prototype[e];
        for (s = 0; s < r; s++) {
            i = n[s];
            if (i) {
                e.apply(this.getElement(i), t)
            }
        }
        return this
    },
    item: function(e) {
        var t = this.elements[e],
        n = null;
        if (t) {
            n = this.getElement(t)
        }
        return n
    },
    slice: function() {
        return this.elements.slice.apply(this.elements, arguments)
    },
    addListener: function(e, t, n, r) {
        var i = this.elements,
        s = i.length,
        o, u;
        for (o = 0; o < s; o++) {
            u = i[o];
            if (u) {
                Ext.EventManager.on(u, e, t, n || u, r)
            }
        }
        return this
    },
    each: function(e, t) {
        var n = this,
        r = n.elements,
        i = r.length,
        s, o;
        for (s = 0; s < i; s++) {
            o = r[s];
            if (o) {
                o = this.getElement(o);
                if (e.call(t || o, o, n, s) === false) {
                    break
                }
            }
        }
        return n
    },
    fill: function(e) {
        var t = this;
        t.elements = [];
        t.add(e);
        return t
    },
    insert: function(e, t) {
        Ext.Array.insert(this.elements, e, t)
    },
    filter: function(e) {
        var t = this,
        n = t.elements,
        r = n.length,
        i = [],
        s = 0,
        o = typeof e == "function",
        u,
        a;
        for (; s < r; s++) {
            a = n[s];
            u = false;
            if (a) {
                a = t.getElement(a);
                if (o) {
                    u = e.call(a, a, t, s) !== false
                } else {
                    u = a.is(e)
                }
                if (u) {
                    i.push(t.transformElement(a))
                }
            }
        }
        t.elements = i;
        return t
    },
    indexOf: function(e) {
        return Ext.Array.indexOf(this.elements, this.transformElement(e))
    },
    replaceElement: function(e, t, n) {
        var r = !isNaN(e) ? e: this.indexOf(e),
        i;
        if (r > -1) {
            t = Ext.getDom(t);
            if (n) {
                i = this.elements[r];
                i.parentNode.insertBefore(t, i);
                Ext.removeNode(i)
            }
            Ext.Array.splice(this.elements, r, 1, t)
        }
        return this
    },
    clear: function(e) {
        var t = this,
        n = t.elements,
        r = n.length - 1;
        if (e) {
            for (; r >= 0; r--) {
                Ext.removeNode(n[r])
            }
        }
        this.elements = []
    },
    addElements: function(e, t) {
        if (!e) {
            return this
        }
        if (typeof e == "string") {
            e = Ext.dom.Element.selectorFunction(e, t)
        }
        var n = this.elements,
        r = e.length,
        i;
        for (i = 0; i < r; i++) {
            n.push(Ext.get(e[i]))
        }
        return this
    },
    first: function() {
        return this.item(0)
    },
    last: function() {
        return this.item(this.getCount() - 1)
    },
    contains: function(e) {
        return this.indexOf(e) != -1
    },
    removeElement: function(e, t) {
        e = [].concat(e);
        var n = this,
        r = n.elements,
        i = e.length,
        s, o, u;
        for (u = 0; u < i; u++) {
            s = e[u];
            if (o = r[s] || r[s = n.indexOf(s)]) {
                if (t) {
                    if (o.dom) {
                        o.remove()
                    } else {
                        Ext.removeNode(o)
                    }
                }
                Ext.Array.erase(r, s, 1)
            }
        }
        return n
    }
},
function() {
    this.importElementMethods();
    this.prototype.on = this.prototype.addListener;
    if (Ext.DomQuery) {
        Ext.dom.Element.selectorFunction = Ext.DomQuery.select
    }
    Ext.dom.Element.select = function(e, t) {
        var n;
        if (typeof e == "string") {
            n = Ext.dom.Element.selectorFunction(e, t)
        } else {
            if (e.length !== undefined) {
                n = e
            } else {}
        }
        return new Ext.CompositeElementLite(n)
    };
    Ext.select = function() {
        return Ext.dom.Element.select.apply(Ext.dom.Element, arguments)
    }
});
Ext.define("Ext.dom.CompositeElement", {
    alternateClassName: "Ext.CompositeElement",
    extend: Ext.dom.CompositeElementLite,
    getElement: function(e) {
        return e
    },
    transformElement: function(e) {
        return Ext.get(e)
    }
},
function() {
    Ext.dom.Element.select = function(e, t, n) {
        var r;
        if (typeof e == "string") {
            r = Ext.dom.Element.selectorFunction(e, n)
        } else {
            if (e.length !== undefined) {
                r = e
            } else {}
        }
        return t === true ? new Ext.CompositeElement(r) : new Ext.CompositeElementLite(r)
    }
});
Ext.select = Ext.Element.select;
Ext.define("Ext.util.HashMap", {
    mixins: {
        observable: Ext.util.Observable
    },
    generation: 0,
    constructor: function(e) {
        e = e || {};
        var t = this,
        n = e.keyFn;
        t.initialConfig = e;
        t.addEvents("add", "clear", "remove", "replace");
        t.mixins.observable.constructor.call(t, e);
        t.clear(true);
        if (n) {
            t.getKey = n
        }
    },
    getCount: function() {
        return this.length
    },
    getData: function(e, t) {
        if (t === undefined) {
            t = e;
            e = this.getKey(t)
        }
        return [e, t]
    },
    getKey: function(e) {
        return e.id
    },
    add: function(e, t) {
        var n = this;
        if (arguments.length === 1) {
            t = e;
            e = n.getKey(t)
        }
        if (n.containsKey(e)) {
            return n.replace(e, t)
        }
        n.map[e] = t; ++n.length;
        n.generation++;
        if (n.hasListeners.add) {
            n.fireEvent("add", n, e, t)
        }
        return t
    },
    replace: function(e, t) {
        var n = this,
        r = n.map,
        i;
        if (arguments.length === 1) {
            t = e;
            e = n.getKey(t)
        }
        if (!n.containsKey(e)) {
            n.add(e, t)
        }
        i = r[e];
        r[e] = t;
        n.generation++;
        if (n.hasListeners.replace) {
            n.fireEvent("replace", n, e, t, i)
        }
        return t
    },
    remove: function(e) {
        var t = this.findKey(e);
        if (t !== undefined) {
            return this.removeAtKey(t)
        }
        return false
    },
    removeAtKey: function(e) {
        var t = this,
        n;
        if (t.containsKey(e)) {
            n = t.map[e];
            delete t.map[e]; --t.length;
            t.generation++;
            if (t.hasListeners.remove) {
                t.fireEvent("remove", t, e, n)
            }
            return true
        }
        return false
    },
    get: function(e) {
        var t = this.map;
        return t.hasOwnProperty(e) ? t[e] : undefined
    },
    clear: function(e) {
        var t = this;
        if (e || t.generation) {
            t.map = {};
            t.length = 0;
            t.generation = e ? 0 : t.generation + 1
        }
        if (e !== true && t.hasListeners.clear) {
            t.fireEvent("clear", t)
        }
        return t
    },
    containsKey: function(e) {
        var t = this.map;
        return t.hasOwnProperty(e) && t[e] !== undefined
    },
    contains: function(e) {
        return this.containsKey(this.findKey(e))
    },
    getKeys: function() {
        return this.getArray(true)
    },
    getValues: function() {
        return this.getArray(false)
    },
    getArray: function(e) {
        var t = [],
        n,
        r = this.map;
        for (n in r) {
            if (r.hasOwnProperty(n)) {
                t.push(e ? n: r[n])
            }
        }
        return t
    },
    each: function(e, t) {
        var n = Ext.apply({},
        this.map),
        r,
        i = this.length;
        t = t || this;
        for (r in n) {
            if (n.hasOwnProperty(r)) {
                if (e.call(t, r, n[r], i) === false) {
                    break
                }
            }
        }
        return this
    },
    clone: function() {
        var e = new this.self(this.initialConfig),
        t = this.map,
        n;
        e.suspendEvents();
        for (n in t) {
            if (t.hasOwnProperty(n)) {
                e.add(n, t[n])
            }
        }
        e.resumeEvents();
        return e
    },
    findKey: function(e) {
        var t, n = this.map;
        for (t in n) {
            if (n.hasOwnProperty(t) && n[t] === e) {
                return t
            }
        }
        return undefined
    }
});
Ext.define("Ext.AbstractManager", {
    typeName: "type",
    constructor: function(e) {
        Ext.apply(this, e || {});
        this.all = new Ext.util.HashMap;
        this.types = {}
    },
    get: function(e) {
        return this.all.get(e)
    },
    register: function(e) {
        this.all.add(e);
        if (e.appScope && e.itemId) {
            e.appScope[e.itemId] = e
        }
    },
    unregister: function(e) {
        var t = this.all;
        t.removeAtKey(t.getKey(e));
        if (e.appScope && e.itemId) {
            delete e.appScope[e.itemId]
        }
    },
    registerType: function(e, t) {
        this.types[e] = t;
        t[this.typeName] = e
    },
    isRegistered: function(e) {
        return this.types[e] !== undefined
    },
    create: function(e, t) {
        var n = e[this.typeName] || e.type || t,
        r = this.types[n];
        return new r(e)
    },
    onAvailable: function(e, t, n) {
        var r = this.all,
        i, s;
        if (r.containsKey(e)) {
            i = r.get(e);
            t.call(n || i, i)
        } else {
            s = function(i, o, u) {
                if (o == e) {
                    t.call(n || u, u);
                    r.un("add", s)
                }
            };
            r.on("add", s)
        }
    },
    each: function(e, t) {
        this.all.each(e, t || this)
    },
    getCount: function() {
        return this.all.getCount()
    }
});
Ext.define("Ext.ComponentManager", {
    extend: Ext.AbstractManager,
    alternateClassName: "Ext.ComponentMgr",
    singleton: true,
    typeName: "xtype",
    create: function(e, t) {
        if (typeof e == "string") {
            return Ext.widget(e)
        }
        if (e.isComponent) {
            return e
        }
        return Ext.widget(e.xtype || t, e)
    },
    registerType: function(e, t) {
        this.types[e] = t;
        t[this.typeName] = e;
        t.prototype[this.typeName] = e
    }
},
function() {
    Ext.getCmp = function(e) {
        return Ext.ComponentManager.get(e)
    }
});
Ext.define("Ext.util.LruCache", {
    extend: Ext.util.HashMap,
    constructor: function(e) {
        Ext.apply(this, e);
        this.callParent([e])
    },
    add: function(e, t) {
        var n = this,
        r, i;
        n.removeAtKey(e);
        i = n.last;
        r = {
            prev: i,
            next: null,
            key: e,
            value: t
        };
        if (i) {
            i.next = r
        } else {
            n.first = r
        }
        n.last = r;
        n.callParent([e, r]);
        n.prune();
        return t
    },
    insertBefore: function(e, t, n) {
        var r = this,
        i, s;
        if (n = this.map[this.findKey(n)]) {
            i = r.findKey(t);
            if (i) {
                r.unlinkEntry(s = r.map[i])
            } else {
                s = {
                    prev: n.prev,
                    next: n,
                    key: e,
                    value: t
                }
            }
            if (n.prev) {
                s.prev.next = s
            } else {
                r.first = s
            }
            s.next = n;
            n.prev = s;
            r.prune();
            return t
        } else {
            return r.add(e, t)
        }
    },
    get: function(e) {
        var t = this.map[e];
        if (t) {
            if (t.next) {
                this.moveToEnd(t)
            }
            return t.value
        }
    },
    removeAtKey: function(e) {
        this.unlinkEntry(this.map[e]);
        return this.callParent(arguments)
    },
    clear: function(e) {
        this.first = this.last = null;
        return this.callParent(arguments)
    },
    unlinkEntry: function(e) {
        if (e) {
            if (e.next) {
                e.next.prev = e.prev
            } else {
                this.last = e.prev
            }
            if (e.prev) {
                e.prev.next = e.next
            } else {
                this.first = e.next
            }
            e.prev = e.next = null
        }
    },
    moveToEnd: function(e) {
        this.unlinkEntry(e);
        if (e.prev = this.last) {
            this.last.next = e
        } else {
            this.first = e
        }
        this.last = e
    },
    getArray: function(e) {
        var t = [],
        n = this.first;
        while (n) {
            t.push(e ? n.key: n.value);
            n = n.next
        }
        return t
    },
    each: function(e, t, n) {
        var r = this,
        i = n ? r.last: r.first,
        s = r.length;
        t = t || r;
        while (i) {
            if (e.call(t, i.key, i.value, s) === false) {
                break
            }
            i = n ? i.prev: i.next
        }
        return r
    },
    findKey: function(e) {
        var t, n = this.map;
        for (t in n) {
            if (n.hasOwnProperty(t) && n[t].value === e) {
                return t
            }
        }
        return undefined
    },
    clone: function() {
        var e = new this.self(this.initialConfig),
        t = this.map,
        n;
        e.suspendEvents();
        for (n in t) {
            if (t.hasOwnProperty(n)) {
                e.add(n, t[n].value)
            }
        }
        e.resumeEvents();
        return e
    },
    prune: function() {
        var e = this,
        t = e.maxSize ? e.length - e.maxSize: 0;
        if (t > 0) {
            for (; e.first && t; t--) {
                e.removeAtKey(e.first.key)
            }
        }
    }
});
Ext.define("Ext.ComponentQuery", {
    singleton: true
},
function() {
    var e = this,
    t = Ext.dom.Query.operators,
    n = /(\d*)n\+?(\d*)/,
    r = /\D/,
    i = /^(\s)+/,
    s = /\\(.)/g,
    o = new Ext.util.LruCache({
        maxSize: 100
    }),
    u = ["var r = [],", "i = 0,", "it = items,", "l = it.length,", "c;", "for (; i < l; i++) {", "c = it[i];", "if (c.{0}) {", "r.push(c);", "}", "}", "return r;"].join(""),
    a = function(e, t) {
        return t.method.apply(this, [e].concat(t.args))
    },
    f = function(e, t) {
        var n = [],
        r = 0,
        i = e.length,
        s,
        o = t !== ">";
        for (; r < i; r++) {
            s = e[r];
            if (s.getRefItems) {
                n = n.concat(s.getRefItems(o))
            }
        }
        return n
    },
    l = function(e) {
        var t = [],
        n = 0,
        r = e.length,
        i;
        for (; n < r; n++) {
            i = e[n];
            while ( !! (i = i.getRefOwner())) {
                t.push(i)
            }
        }
        return t
    },
    c = function(e, t, n) {
        if (t === "*") {
            return e.slice()
        } else {
            var r = [],
            i = 0,
            s = e.length,
            o;
            for (; i < s; i++) {
                o = e[i];
                if (o.isXType(t, n)) {
                    r.push(o)
                }
            }
            return r
        }
    },
    h = function(e, n, r, i) {
        var s = [],
        o = 0,
        u = e.length,
        a,
        f,
        l,
        c,
        h,
        p;
        if (n.charAt(0) === "@") {
            a = true;
            n = n.substr(1)
        }
        if (n.charAt(0) === "?") {
            a = true;
            f = true;
            n = n.substr(1)
        }
        for (; o < u; o++) {
            l = e[o];
            if (!a || l.hasOwnProperty(n)) {
                c = l[n];
                if (f) {
                    s.push(l)
                } else {
                    if (r === "~=") {
                        if (c) {
                            if (!Ext.isArray(c)) {
                                c = c.split(" ")
                            }
                            for (h = 0, p = c.length; h < p; h++) {
                                if (t[r](Ext.coerce(c[h], i), i)) {
                                    s.push(l);
                                    break
                                }
                            }
                        }
                    } else {
                        if (r === "/=") {
                            if (l[n] !== undefined && i.test(l[n])) {
                                s.push(l)
                            }
                        } else {
                            if (!i ? !!l[n] : t[r](Ext.coerce(c, i), i)) {
                                s.push(l)
                            }
                        }
                    }
                }
            }
        }
        return s
    },
    p = function(e, t) {
        var n = [],
        r = 0,
        i = e.length,
        s;
        for (; r < i; r++) {
            s = e[r];
            if (s.getItemId() === t) {
                n.push(s)
            }
        }
        return n
    },
    d = function(t, n, r) {
        return e.pseudos[n](t, r)
    },
    v = /^(\s?([>\^])\s?|\s|$)/,
    m = /^(#)?((?:\\\.|[\w\-])+|\*)(?:\((true|false)\))?/,
    g = [{
        re: /^\.((?:\\\.|[\w\-])+)(?:\((true|false)\))?/,
        method: c,
        argTransform: function(e) {
            if (e[1] !== undefined) {
                e[1] = e[1].replace(s, "$1")
            }
            return e.slice(1)
        }
    },
    {
        re: /^(?:\[((?:[@?$])?[\w\-]*)\s*(?:([\^$*~%!\/]?=)\s*(['"])?((?:\\\]|.)*?)\3)?(?!\\)\])/,
        method: h,
        argTransform: function(e) {
            var t = e[0],
            n = e[1],
            r = e[2],
            i = e[3],
            u = e[4],
            a;
            if (u !== undefined) {
                u = u.replace(s, "$1")
            }
            if (r === "/=") {
                a = o.get(u);
                if (a) {
                    u = a
                } else {
                    u = o.add(u, new RegExp(u))
                }
            }
            return [n, r, u]
        }
    },
    {
        re: /^#((?:\\\.|[\w\-])+)/,
        method: p
    },
    {
        re: /^\:([\w\-]+)(?:\(((?:\{[^\}]+\})|(?:(?!\{)[^\s>\/]*?(?!\})))\))?/,
        method: d,
        argTransform: function(e) {
            if (e[2] !== undefined) {
                e[2] = e[2].replace(s, "$1")
            }
            return e.slice(1)
        }
    },
    {
        re: /^(?:\{([^\}]+)\})/,
        method: u
    }];
    e.Query = Ext.extend(Object, {
        constructor: function(e) {
            e = e || {};
            Ext.apply(this, e)
        },
        execute: function(e) {
            var t = this.operations,
            n = [],
            r,
            i,
            s;
            for (i = 0, s = t.length; i < s; i++) {
                r = t[i];
                n = n.concat(this._execute(e, r))
            }
            return n
        },
        _execute: function(e, t) {
            var n = 0,
            r = t.length,
            i, s;
            if (!e) {
                s = Ext.ComponentManager.all.getArray()
            } else {
                if (Ext.isIterable(e)) {
                    s = e
                } else {
                    if (e.isMixedCollection) {
                        s = e.items
                    }
                }
            }
            for (; n < r; n++) {
                i = t[n];
                if (i.mode === "^") {
                    s = l(s || [e])
                } else {
                    if (i.mode) {
                        s = f(s || [e], i.mode)
                    } else {
                        s = a(s || f([e]), i)
                    }
                }
                if (n === r - 1) {
                    return s
                }
            }
            return []
        },
        is: function(e) {
            var t = this.operations,
            n = false,
            r = t.length,
            i, s;
            if (r === 0) {
                return true
            }
            for (s = 0; s < r; s++) {
                i = t[s];
                n = this._is(e, i);
                if (n) {
                    return n
                }
            }
            return false
        },
        _is: function(e, t) {
            var n = t.length,
            r = [e],
            i,
            s,
            o,
            u,
            c,
            h,
            p;
            for (s = n - 1; s >= 0; --s) {
                i = t[s];
                u = i.mode;
                if (u) {
                    if (u === "^") {
                        r = f(r, " ")
                    } else {
                        if (u === ">") {
                            h = [];
                            for (o = 0, n = r.length; o < n; ++o) {
                                p = r[o].getRefOwner();
                                if (p) {
                                    h.push(p)
                                }
                            }
                            r = h
                        } else {
                            r = l(r)
                        }
                    }
                    if (r.length === 0) {
                        return false
                    }
                } else {
                    r = a(r, i);
                    if (r.length === 0) {
                        return false
                    }
                }
            }
            return true
        },
        getMatches: function(e, t) {
            var n = t.length,
            r;
            for (r = 0; r < n; ++r) {
                e = a(e, t[r]);
                if (e.length === 0) {
                    break
                }
            }
            return e
        },
        isMultiMatch: function() {
            return this.operations.length > 1
        }
    });
    Ext.apply(this, {
        cache: new Ext.util.LruCache({
            maxSize: 100
        }),
        pseudos: {
            not: function(e, t) {
                var n = Ext.ComponentQuery,
                r = 0,
                i = e.length,
                s = [],
                o = -1,
                u;
                for (; r < i; ++r) {
                    u = e[r];
                    if (!n.is(u, t)) {
                        s[++o] = u
                    }
                }
                return s
            },
            first: function(e) {
                var t = [];
                if (e.length > 0) {
                    t.push(e[0])
                }
                return t
            },
            last: function(e) {
                var t = e.length,
                n = [];
                if (t > 0) {
                    n.push(e[t - 1])
                }
                return n
            },
            focusable: function(e) {
                var t = e.length,
                n = [],
                r = 0,
                i;
                for (; r < t; r++) {
                    i = e[r];
                    if (i.isFocusable()) {
                        n.push(i)
                    }
                }
                return n
            },
            "nth-child": function(e, t) {
                var i = [],
                s = n.exec(t == "even" && "2n" || t == "odd" && "2n+1" || !r.test(t) && "n+" + t || t),
                o = (s[1] || 1) - 0,
                u = s[2] - 0,
                a,
                f,
                l;
                for (a = 0; f = e[a]; a++) {
                    l = a + 1;
                    if (o == 1) {
                        if (u == 0 || l == u) {
                            i.push(f)
                        }
                    } else {
                        if ((l + u) % o == 0) {
                            i.push(f)
                        }
                    }
                }
                return i
            }
        },
        query: function(e, t) {
            if (!e) {
                return Ext.ComponentManager.all.getArray()
            }
            var n = [],
            r = [],
            i = {},
            s = this.cache.get(e),
            o,
            u,
            a;
            if (!s) {
                s = this.cache.add(e, this.parse(e))
            }
            n = s.execute(t);
            if (s.isMultiMatch()) {
                o = n.length;
                for (a = 0; a < o; a++) {
                    u = n[a];
                    if (!i[u.id]) {
                        r.push(u);
                        i[u.id] = true
                    }
                }
                n = r
            }
            return n
        },
        visitPreOrder: function(e, t, n, r, i) {
            this._visit(true, e, t, n, r, i)
        },
        visitPostOrder: function(e, t, n, r, i) {
            this._visit(false, e, t, n, r, i)
        },
        _visit: function(e, t, n, r, i, s) {
            var o = this,
            u = o.cache.get(t),
            a = [n],
            f,
            l = 0,
            c,
            h;
            if (!u) {
                u = o.cache.add(t, o.parse(t))
            }
            h = u.is(n);
            if (n.getRefItems) {
                f = n.getRefItems();
                l = f.length
            }
            if (s) {
                Ext.Array.push(a, s)
            }
            if (e) {
                if (h) {
                    if (r.apply(i || n, a) === false) {
                        return false
                    }
                }
            }
            for (c = 0; c < l; c++) {
                if (o._visit.call(o, e, t, f[c], r, i, s) === false) {
                    return false
                }
            }
            if (!e) {
                if (h) {
                    if (r.apply(i || n, a) === false) {
                        return false
                    }
                }
            }
        },
        is: function(e, t) {
            if (!t) {
                return true
            }
            var n = this.cache.get(t);
            if (!n) {
                n = this.cache.add(t, this.parse(t))
            }
            return n.is(e)
        },
        parse: function(t) {
            var n = [],
            r,
            i,
            s,
            o;
            r = Ext.splitAndUnescape(t, ",");
            for (s = 0, o = r.length; s < o; s++) {
                i = Ext.String.trim(r[s]);
                n.push(this._parse(i))
            }
            return new e.Query({
                operations: n
            })
        },
        _parse: function(e) {
            var t = [],
            n = Ext.String.trim,
            r = g.length,
            o,
            u,
            a,
            f,
            l,
            h,
            d,
            y,
            b,
            w,
            E;
            while (e && o !== e) {
                o = e;
                u = e.match(m);
                if (u) {
                    f = u[1];
                    a = n(u[2]).replace(s, "$1");
                    if (f === "#") {
                        t.push({
                            method: p,
                            args: [a]
                        })
                    } else {
                        t.push({
                            method: c,
                            args: [a, Boolean(u[3])]
                        })
                    }
                    e = e.replace(u[0], "").replace(i, "$1")
                }
                while (! (l = e.match(v))) {
                    for (y = 0; e && y < r; y++) {
                        b = g[y];
                        h = e.match(b.re);
                        w = b.method;
                        d = b.argTransform;
                        if (h) {
                            if (d) {
                                E = d(h)
                            } else {
                                E = h.slice(1)
                            }
                            t.push({
                                method: Ext.isString(b.method) ? Ext.functionFactory("items", Ext.String.format.apply(Ext.String, [w].concat(h.slice(1)))) : b.method,
                                args: E
                            });
                            e = e.replace(h[0], "").replace(i, "$1");
                            break
                        }
                        if (y === r - 1) {
                            Ext.Error.raise('Invalid ComponentQuery selector: "' + arguments[0] + '"')
                        }
                    }
                }
                if (l[1]) {
                    t.push({
                        mode: l[2] || l[1]
                    });
                    e = e.replace(l[0], "").replace(i, "")
                }
            }
            return t
        }
    })
});
Ext.define("Ext.util.ProtoElement",
function() {
    var e = Ext.String.splitWords,
    t = Ext.Array.toMap;
    return {
        isProtoEl: true,
        clsProp: "cls",
        styleProp: "style",
        removedProp: "removed",
        styleIsText: false,
        constructor: function(n) {
            var r = this;
            Ext.apply(r, n);
            r.classList = e(r.cls);
            r.classMap = t(r.classList);
            delete r.cls;
            if (Ext.isFunction(r.style)) {
                r.styleFn = r.style;
                delete r.style
            } else {
                if (typeof r.style == "string") {
                    r.style = Ext.Element.parseStyles(r.style)
                } else {
                    if (r.style) {
                        r.style = Ext.apply({},
                        r.style)
                    }
                }
            }
        },
        flush: function() {
            this.flushClassList = [];
            this.removedClasses = {};
            delete this.style;
            delete this.unselectableAttr
        },
        addCls: function(t) {
            var n = this,
            r = typeof t === "string" ? e(t) : t,
            i = r.length,
            s = n.classList,
            o = n.classMap,
            u = n.flushClassList,
            a = 0,
            f;
            for (; a < i; ++a) {
                f = r[a];
                if (!o[f]) {
                    o[f] = true;
                    s.push(f);
                    if (u) {
                        u.push(f);
                        delete n.removedClasses[f]
                    }
                }
            }
            return n
        },
        hasCls: function(e) {
            return e in this.classMap
        },
        removeCls: function(n) {
            var r = this,
            i = r.classList,
            s = r.classList = [],
            o = t(e(n)),
            u = i.length,
            f = r.classMap,
            l = r.removedClasses,
            c,
            h;
            for (c = 0; c < u; ++c) {
                h = i[c];
                if (o[h]) {
                    if (l) {
                        if (f[h]) {
                            l[h] = true;
                            Ext.Array.remove(r.flushClassList, h)
                        }
                    }
                    delete f[h]
                } else {
                    s.push(h)
                }
            }
            return r
        },
        setStyle: function(e, t) {
            var n = this,
            r = n.style || (n.style = {});
            if (typeof e == "string") {
                if (arguments.length === 1) {
                    n.setStyle(Ext.Element.parseStyles(e))
                } else {
                    r[e] = t
                }
            } else {
                Ext.apply(r, e)
            }
            return n
        },
        unselectable: function() {
            this.addCls(Ext.dom.Element.unselectableCls);
            if (Ext.isOpera) {
                this.unselectableAttr = true
            }
        },
        writeTo: function(e) {
            var t = this,
            n = t.flushClassList || t.classList,
            r = t.removedClasses,
            i;
            if (t.styleFn) {
                i = Ext.apply({},
                t.styleFn());
                Ext.apply(i, t.style)
            } else {
                i = t.style
            }
            e[t.clsProp] = n.join(" ");
            if (i) {
                e[t.styleProp] = t.styleIsText ? Ext.DomHelper.generateStyles(i, null, true) : i
            }
            if (r) {
                r = Ext.Object.getKeys(r);
                if (r.length) {
                    e[t.removedProp] = r.join(" ")
                }
            }
            if (t.unselectableAttr) {
                e.unselectable = "on"
            }
            return e
        }
    }
} ());
Ext.define("Ext.PluginManager", {
    extend: Ext.AbstractManager,
    alternateClassName: "Ext.PluginMgr",
    singleton: true,
    typeName: "ptype",
    create: function(e, t, n) {
        var r;
        if (e.init) {
            r = e
        } else {
            if (n) {
                e = Ext.apply({},
                e);
                e.cmp = n
            } else {
                n = e.cmp
            }
            if (e.xclass) {
                r = Ext.create(e)
            } else {
                r = Ext.ClassManager.getByAlias("plugin." + (e.ptype || t));
                if (typeof r === "function") {
                    r = new r(e)
                }
            }
        }
        if (r && n && r.setCmp && !r.setCmpCalled) {
            r.setCmp(n);
            r.setCmpCalled = true
        }
        return r
    },
    findByType: function(e, t) {
        var n = [],
        r = this.types,
        i,
        s;
        for (i in r) {
            if (!r.hasOwnProperty(i)) {
                continue
            }
            s = r[i];
            if (s.type == e && (!t || t === true && s.isDefault)) {
                n.push(s)
            }
        }
        return n
    }
},
function() {
    Ext.preg = function() {
        return Ext.PluginManager.registerType.apply(Ext.PluginManager, arguments)
    }
});
Ext.define("Ext.util.Filter", {
    id: null,
    anyMatch: false,
    exactMatch: false,
    caseSensitive: false,
    disabled: false,
    operator: null,
    statics: {
        createFilterFn: function(e) {
            return e && e.length ?
            function(t) {
                var n = true,
                r = e.length,
                i, s;
                for (i = 0; n && i < r; i++) {
                    s = e[i];
                    if (!s.disabled) {
                        n = n && s.filterFn.call(s.scope || s, t)
                    }
                }
                return n
            }: function() {
                return true
            }
        }
    },
    operatorFns: {
        "<": function(e) {
            return Ext.coerce(this.getRoot(e)[this.property], this.value) < this.value
        },
        "<=": function(e) {
            return Ext.coerce(this.getRoot(e)[this.property], this.value) <= this.value
        },
        "=": function(e) {
            return Ext.coerce(this.getRoot(e)[this.property], this.value) == this.value
        },
        ">=": function(e) {
            return Ext.coerce(this.getRoot(e)[this.property], this.value) >= this.value
        },
        ">": function(e) {
            return Ext.coerce(this.getRoot(e)[this.property], this.value) > this.value
        },
        "!=": function(e) {
            return Ext.coerce(this.getRoot(e)[this.property], this.value) != this.value
        }
    },
    constructor: function(e) {
        var t = this;
        t.initialConfig = e;
        Ext.apply(t, e);
        t.filter = t.filter || t.filterFn;
        if (t.filter === undefined) {
            t.setValue(e.value)
        }
    },
    setValue: function(e) {
        var t = this;
        t.value = e;
        if (t.property === undefined || t.value === undefined) {} else {
            t.filter = t.createFilterFn()
        }
        t.filterFn = t.filter
    },
    setFilterFn: function(e) {
        this.filterFn = this.filter = e
    },
    createFilterFn: function() {
        var e = this,
        t = e.createValueMatcher(),
        n = e.property;
        if (e.operator) {
            return e.operatorFns[e.operator]
        } else {
            return function(r) {
                var i = e.getRoot(r)[n];
                return t === null ? i === null: t.test(i)
            }
        }
    },
    getRoot: function(e) {
        var t = this.root;
        return t === undefined ? e: e[t]
    },
    createValueMatcher: function() {
        var e = this,
        t = e.value,
        n = e.anyMatch,
        r = e.exactMatch,
        i = e.caseSensitive,
        s = Ext.String.escapeRegex;
        if (t === null) {
            return t
        }
        if (!t.exec) {
            t = String(t);
            if (n === true) {
                t = s(t)
            } else {
                t = "^" + s(t);
                if (r === true) {
                    t += "$"
                }
            }
            t = new RegExp(t, i ? "": "i")
        }
        return t
    },
    serialize: function() {
        var e = this,
        t = Ext.apply({},
        e.initialConfig);
        t.value = e.value;
        return t
    }
},
function() {
    this.prototype.operatorFns["=="] = this.prototype.operatorFns["="]
});
Ext.define("Ext.util.AbstractMixedCollection", {
    mixins: {
        observable: Ext.util.Observable
    },
    isMixedCollection: true,
    generation: 0,
    indexGeneration: 0,
    constructor: function(e, t) {
        var n = this;
        if (arguments.length === 1 && Ext.isObject(e)) {
            n.initialConfig = e;
            Ext.apply(n, e)
        } else {
            n.allowFunctions = e === true;
            if (t) {
                n.getKey = t
            }
            n.initialConfig = {
                allowFunctions: n.allowFunctions,
                getKey: n.getKey
            }
        }
        n.items = [];
        n.map = {};
        n.keys = [];
        n.indexMap = {};
        n.length = 0;
        n.mixins.observable.constructor.call(n)
    },
    allowFunctions: false,
    add: function(e, t) {
        var n = this.length,
        r;
        if (arguments.length === 1) {
            r = this.insert(n, e)
        } else {
            r = this.insert(n, e, t)
        }
        return r
    },
    getKey: function(e) {
        return e.id
    },
    replace: function(e, t) {
        var n = this,
        r, i;
        if (arguments.length == 1) {
            t = arguments[0];
            e = n.getKey(t)
        }
        r = n.map[e];
        if (typeof e == "undefined" || e === null || typeof r == "undefined") {
            return n.add(e, t)
        }
        n.generation++;
        i = n.indexOfKey(e);
        n.items[i] = t;
        n.map[e] = t;
        if (n.hasListeners.replace) {
            n.fireEvent("replace", e, r, t)
        }
        return t
    },
    updateKey: function(e, t) {
        var n = this,
        r = n.map,
        i = n.indexOfKey(e),
        s = n.indexMap,
        o;
        if (i > -1) {
            o = r[e];
            delete r[e];
            delete s[e];
            r[t] = o;
            s[t] = i;
            n.keys[i] = t;
            n.indexGeneration = ++n.generation
        }
    },
    addAll: function(e) {
        var t = this,
        n;
        if (arguments.length > 1 || Ext.isArray(e)) {
            t.insert(t.length, arguments.length > 1 ? arguments: e)
        } else {
            for (n in e) {
                if (e.hasOwnProperty(n)) {
                    if (t.allowFunctions || typeof e[n] != "function") {
                        t.add(n, e[n])
                    }
                }
            }
        }
    },
    each: function(e, t) {
        var n = Ext.Array.push([], this.items),
        r = 0,
        i = n.length,
        s;
        for (; r < i; r++) {
            s = n[r];
            if (e.call(t || s, s, r, i) === false) {
                break
            }
        }
    },
    eachKey: function(e, t) {
        var n = this.keys,
        r = this.items,
        i = 0,
        s = n.length;
        for (; i < s; i++) {
            e.call(t || window, n[i], r[i], i, s)
        }
    },
    findBy: function(e, t) {
        var n = this.keys,
        r = this.items,
        i = 0,
        s = r.length;
        for (; i < s; i++) {
            if (e.call(t || window, r[i], n[i])) {
                return r[i]
            }
        }
        return null
    },
    find: function() {
        if (Ext.isDefined(Ext.global.console)) {
            Ext.global.console.warn("Ext.util.MixedCollection: find has been deprecated. Use findBy instead.")
        }
        return this.findBy.apply(this, arguments)
    },
    insert: function(e, t, n) {
        var r;
        if (Ext.isIterable(t)) {
            r = this.doInsert(e, t, n)
        } else {
            if (arguments.length > 2) {
                r = this.doInsert(e, [t], [n])
            } else {
                r = this.doInsert(e, [t])
            }
            r = r[0]
        }
        return r
    },
    doInsert: function(e, t, n) {
        var r = this,
        i, s, o, u = t.length,
        a = u,
        f = r.hasListeners.add,
        l, c = {},
        h, p, d;
        if (n != null) {
            r.useLinearSearch = true
        } else {
            n = t;
            t = new Array(u);
            for (o = 0; o < u; o++) {
                t[o] = this.getKey(n[o])
            }
        }
        r.suspendEvents();
        for (o = 0; o < u; o++) {
            i = t[o];
            s = r.indexOfKey(i);
            if (s !== -1) {
                if (s < e) {
                    e--
                }
                r.removeAt(s)
            }
            if (i != null) {
                if (c[i] != null) {
                    h = true;
                    a--
                }
                c[i] = o
            }
        }
        r.resumeEvents();
        if (h) {
            p = t;
            d = n;
            t = new Array(a);
            n = new Array(a);
            o = 0;
            for (i in c) {
                t[o] = p[c[i]];
                n[o] = d[c[i]];
                o++
            }
            u = a
        }
        l = e === r.length && r.indexGeneration === r.generation;
        Ext.Array.insert(r.items, e, n);
        Ext.Array.insert(r.keys, e, t);
        r.length += u;
        r.generation++;
        if (l) {
            r.indexGeneration = r.generation
        }
        for (o = 0; o < u; o++, e++) {
            i = t[o];
            if (i != null) {
                r.map[i] = n[o];
                if (l) {
                    r.indexMap[i] = e
                }
            }
            if (f) {
                r.fireEvent("add", e, n[o], i)
            }
        }
        return n
    },
    remove: function(e) {
        var t = this,
        n, r;
        if (!t.useLinearSearch && (n = t.getKey(e))) {
            r = t.indexOfKey(n)
        } else {
            r = Ext.Array.indexOf(t.items, e)
        }
        return r === -1 ? false: t.removeAt(r)
    },
    removeAll: function(e) {
        var t = this,
        n;
        if (e || t.hasListeners.remove) {
            if (e) {
                for (n = e.length - 1; n >= 0; --n) {
                    t.remove(e[n])
                }
            } else {
                while (t.length) {
                    t.removeAt(0)
                }
            }
        } else {
            t.length = t.items.length = t.keys.length = 0;
            t.map = {};
            t.indexMap = {};
            t.generation++;
            t.indexGeneration = t.generation
        }
    },
    removeAt: function(e) {
        var t = this,
        n, r;
        if (e < t.length && e >= 0) {
            t.length--;
            n = t.items[e];
            Ext.Array.erase(t.items, e, 1);
            r = t.keys[e];
            if (typeof r != "undefined") {
                delete t.map[r]
            }
            Ext.Array.erase(t.keys, e, 1);
            if (t.hasListeners.remove) {
                t.fireEvent("remove", n, r)
            }
            t.generation++;
            return n
        }
        return false
    },
    removeRange: function(e, t) {
        var n = this,
        r, i, s, o, u, a;
        if (e < n.length && e >= 0) {
            if (!t) {
                t = 1
            }
            o = Math.min(e + t, n.length);
            t = o - e;
            a = o === n.length;
            u = a && n.indexGeneration === n.generation;
            for (s = e; s < o; s++) {
                i = n.keys[s];
                if (i != null) {
                    delete n.map[i];
                    if (u) {
                        delete n.indexMap[i]
                    }
                }
            }
            r = n.items[s - 1];
            n.length -= t;
            n.generation++;
            if (u) {
                n.indexGeneration = n.generation
            }
            if (a) {
                n.items.length = n.keys.length = n.length
            } else {
                n.items.splice(e, t);
                n.keys.splice(e, t)
            }
            return r
        }
        return false
    },
    removeAtKey: function(e) {
        var t = this,
        n = t.keys,
        r;
        if (e == null) {
            for (r = n.length - 1; r >= 0; r--) {
                if (n[r] == null) {
                    t.removeAt(r)
                }
            }
        } else {
            return t.removeAt(t.indexOfKey(e))
        }
    },
    getCount: function() {
        return this.length
    },
    indexOf: function(e) {
        var t = this,
        n;
        if (e != null) {
            if (!t.useLinearSearch && (n = t.getKey(e))) {
                return this.indexOfKey(n)
            }
            return Ext.Array.indexOf(t.items, e)
        }
        return - 1
    },
    indexOfKey: function(e) {
        if (!this.map.hasOwnProperty(e)) {
            return - 1
        }
        if (this.indexGeneration !== this.generation) {
            this.rebuildIndexMap()
        }
        return this.indexMap[e]
    },
    rebuildIndexMap: function() {
        var e = this,
        t = e.indexMap = {},
        n = e.keys,
        r = n.length,
        i;
        for (i = 0; i < r; i++) {
            t[n[i]] = i
        }
        e.indexGeneration = e.generation
    },
    get: function(e) {
        var t = this,
        n = t.map[e],
        r = n !== undefined ? n: typeof e == "number" ? t.items[e] : undefined;
        return typeof r != "function" || t.allowFunctions ? r: null
    },
    getAt: function(e) {
        return this.items[e]
    },
    getByKey: function(e) {
        return this.map[e]
    },
    contains: function(e) {
        var t = this,
        n;
        if (e != null) {
            if (!t.useLinearSearch && (n = t.getKey(e))) {
                return this.map[n] != null
            }
            return Ext.Array.indexOf(this.items, e) !== -1
        }
        return false
    },
    containsKey: function(e) {
        return this.map.hasOwnProperty(e)
    },
    clear: function() {
        var e = this;
        if (e.generation) {
            e.length = 0;
            e.items = [];
            e.keys = [];
            e.map = {};
            e.indexMap = {};
            e.generation++;
            e.indexGeneration = e.generation
        }
        if (e.hasListeners.clear) {
            e.fireEvent("clear")
        }
    },
    first: function() {
        return this.items[0]
    },
    last: function() {
        return this.items[this.length - 1]
    },
    sum: function(e, t, n, r) {
        var i = this.extractValues(e, t),
        s = i.length,
        o = 0,
        u;
        n = n || 0;
        r = r || r === 0 ? r: s - 1;
        for (u = n; u <= r; u++) {
            o += i[u]
        }
        return o
    },
    collect: function(e, t, n) {
        var r = this.extractValues(e, t),
        i = r.length,
        s = {},
        o = [],
        u,
        a,
        f;
        for (f = 0; f < i; f++) {
            u = r[f];
            a = String(u);
            if ((n || !Ext.isEmpty(u)) && !s[a]) {
                s[a] = true;
                o.push(u)
            }
        }
        return o
    },
    extractValues: function(e, t) {
        var n = this.items;
        if (t) {
            n = Ext.Array.pluck(n, t)
        }
        return Ext.Array.pluck(n, e)
    },
    hasRange: function(e, t) {
        return t < this.length
    },
    getRange: function(e, t) {
        var n = this,
        r = n.items,
        i = [],
        s = r.length,
        o,
        u;
        if (s < 1) {
            return i
        }
        if (e > t) {
            u = true;
            o = e;
            e = t;
            t = o
        }
        if (e < 0) {
            e = 0
        }
        if (t == null || t >= s) {
            t = s - 1
        }
        i = r.slice(e, t + 1);
        if (u && i.length) {
            i.reverse()
        }
        return i
    },
    filter: function(e, t, n, r) {
        var i = [];
        if (Ext.isString(e)) {
            i.push(new Ext.util.Filter({
                property: e,
                value: t,
                anyMatch: n,
                caseSensitive: r
            }))
        } else {
            if (Ext.isArray(e) || e instanceof Ext.util.Filter) {
                i = i.concat(e)
            }
        }
        return this.filterBy(Ext.util.Filter.createFilterFn(i))
    },
    filterBy: function(e, t) {
        var n = this,
        r = new n.self(n.initialConfig),
        i = n.keys,
        s = n.items,
        o = s.length,
        u;
        r.getKey = n.getKey;
        for (u = 0; u < o; u++) {
            if (e.call(t || n, s[u], i[u])) {
                r.add(i[u], s[u])
            }
        }
        r.useLinearSearch = n.useLinearSearch;
        return r
    },
    findIndex: function(e, t, n, r, i) {
        if (Ext.isEmpty(t, false)) {
            return - 1
        }
        t = this.createValueMatcher(t, r, i);
        return this.findIndexBy(function(n) {
            return n && t.test(n[e])
        },
        null, n)
    },
    findIndexBy: function(e, t, n) {
        var r = this,
        i = r.keys,
        s = r.items,
        o = n || 0,
        u = s.length;
        for (; o < u; o++) {
            if (e.call(t || r, s[o], i[o])) {
                return o
            }
        }
        return - 1
    },
    createValueMatcher: function(e, t, n, r) {
        if (!e.exec) {
            var i = Ext.String.escapeRegex;
            e = String(e);
            if (t === true) {
                e = i(e)
            } else {
                e = "^" + i(e);
                if (r === true) {
                    e += "$"
                }
            }
            e = new RegExp(e, n ? "": "i")
        }
        return e
    },
    clone: function() {
        var e = this,
        t = new e.self(e.initialConfig);
        t.add(e.keys, e.items);
        t.useLinearSearch = e.useLinearSearch;
        return t
    }
});
Ext.define("Ext.util.Sorter", {
    direction: "ASC",
    constructor: function(e) {
        var t = this;
        Ext.apply(t, e);
        if (t.direction) {
            t.direction = t.direction.toUpperCase()
        }
        t.updateSortFunction()
    },
    createSortFunction: function(e) {
        var t = this,
        n = t.direction || "ASC",
        r = n == "DESC" ? -1 : 1;
        return function(n, i) {
            return r * e.call(t, n, i)
        }
    },
    defaultSorterFn: function(e, t) {
        var n = this,
        r = n.transform,
        i = n.getRoot(e)[n.property],
        s = n.getRoot(t)[n.property];
        if (r) {
            i = r(i);
            s = r(s)
        }
        return i > s ? 1 : i < s ? -1 : 0
    },
    getRoot: function(e) {
        return this.root === undefined ? e: e[this.root]
    },
    setDirection: function(e) {
        var t = this;
        t.direction = e ? e.toUpperCase() : e;
        t.updateSortFunction()
    },
    toggle: function() {
        var e = this;
        e.direction = Ext.String.toggle(e.direction, "ASC", "DESC");
        e.updateSortFunction()
    },
    updateSortFunction: function(e) {
        var t = this;
        e = e || t.sorterFn || t.defaultSorterFn;
        t.sort = t.createSortFunction(e)
    },
    serialize: function() {
        return {
            root: this.root,
            property: this.property,
            direction: this.direction
        }
    }
});
Ext.define("Ext.util.Sortable", {
    isSortable: true,
    defaultSortDirection: "ASC",
    multiSortLimit: 3,
    statics: {
        createComparator: function(e) {
            return e && e.length ?
            function(t, n) {
                var r = e[0].sort(t, n),
                i = e.length,
                s = 1;
                for (; ! r && s < i; s++) {
                    r = e[s].sort.call(this, t, n)
                }
                return r
            }: function() {
                return 0
            }
        }
    },
    initSortable: function() {
        var e = this,
        t = e.sorters;
        e.sorters = new Ext.util.AbstractMixedCollection(false,
        function(e) {
            return e.id || e.property
        });
        if (t) {
            e.sorters.addAll(e.decodeSorters(t))
        }
    },
    sort: function(e, t, n, r) {
        var i = this,
        s, o;
        if (Ext.isArray(e)) {
            r = n;
            n = t
        } else {
            if (Ext.isObject(e)) {
                e = [e];
                r = n;
                n = t
            } else {
                if (Ext.isString(e)) {
                    s = i.sorters.get(e);
                    if (!s) {
                        s = {
                            property: e,
                            direction: t
                        }
                    } else {
                        if (t == null) {
                            s.toggle()
                        } else {
                            s.setDirection(t)
                        }
                    }
                    e = [s]
                }
            }
        }
        if (e && e.length) {
            e = i.decodeSorters(e);
            switch (n) {
            case "multi":
                i.sorters.insert(0, e[0]);
                o = i.sorters.getCount() - i.multiSortLimit;
                if (o > 0) {
                    i.sorters.removeRange(i.multiSortLimit, o)
                }
                break;
            case "prepend":
                i.sorters.insert(0, e);
                break;
            case "append":
                i.sorters.addAll(e);
                break;
            case undefined:
            case null:
            case "replace":
                i.sorters.clear();
                i.sorters.addAll(e);
                break;
            default:
            }
        }
        if (r !== false) {
            i.fireEvent("beforesort", i, e);
            i.onBeforeSort(e);
            if (i.getSorterCount()) {
                i.doSort(i.generateComparator())
            }
        }
        return e
    },
    getSorterCount: function() {
        return this.sorters.items.length
    },
    generateComparator: function() {
        var e = this.sorters.getRange();
        return e.length ? this.createComparator(e) : this.emptyComparator
    },
    emptyComparator: function() {
        return 0
    },
    onBeforeSort: Ext.emptyFn,
    decodeSorters: function(e) {
        if (!Ext.isArray(e)) {
            if (e === undefined) {
                e = []
            } else {
                e = [e]
            }
        }
        var t = e.length,
        n = Ext.util.Sorter,
        r = this.model ? this.model.prototype.fields: null,
        i,
        s,
        o;
        for (o = 0; o < t; o++) {
            s = e[o];
            if (! (s instanceof n)) {
                if (Ext.isString(s)) {
                    s = {
                        property: s
                    }
                }
                Ext.applyIf(s, {
                    root: this.sortRoot,
                    direction: "ASC"
                });
                if (s.fn) {
                    s.sorterFn = s.fn
                }
                if (typeof s == "function") {
                    s = {
                        sorterFn: s
                    }
                }
                if (r && !s.transform) {
                    i = r.get(s.property);
                    s.transform = i && i.sortType !== Ext.identityFn ? i.sortType: undefined
                }
                e[o] = new Ext.util.Sorter(s)
            }
        }
        return e
    },
    getSorters: function() {
        return this.sorters.items
    },
    getFirstSorter: function() {
        var e = this.sorters.items,
        t = e.length,
        n = 0,
        r;
        for (; n < t; ++n) {
            r = e[n];
            if (!r.isGrouper) {
                return r
            }
        }
        return null
    }
},
function() {
    this.prototype.createComparator = this.createComparator
});
Ext.define("Ext.util.MixedCollection", {
    extend: Ext.util.AbstractMixedCollection,
    mixins: {
        sortable: Ext.util.Sortable
    },
    constructor: function() {
        var e = this;
        e.callParent(arguments);
        e.addEvents("sort");
        e.mixins.sortable.initSortable.call(e)
    },
    doSort: function(e) {
        this.sortBy(e)
    },
    _sort: function(e, t, n) {
        var r = this,
        i, s, o = String(t).toUpperCase() == "DESC" ? -1 : 1,
        u = [],
        a = r.keys,
        f = r.items,
        l;
        n = n ||
        function(e, t) {
            return e - t
        };
        for (i = 0, s = f.length; i < s; i++) {
            u[u.length] = {
                key: a[i],
                value: f[i],
                index: i
            }
        }
        Ext.Array.sort(u,
        function(t, r) {
            return n(t[e], r[e]) * o || (t.index < r.index ? -1 : 1)
        });
        for (i = 0, s = u.length; i < s; i++) {
            l = u[i];
            f[i] = l.value;
            a[i] = l.key;
            r.indexMap[l.key] = i
        }
        r.generation++;
        r.indexGeneration = r.generation;
        r.fireEvent("sort", r)
    },
    sortBy: function(e) {
        var t = this,
        n = t.items,
        r, i = t.keys,
        s, o = n.length,
        u;
        for (u = 0; u < o; u++) {
            n[u].$extCollectionIndex = u
        }
        Ext.Array.sort(n,
        function(t, n) {
            return e(t, n) || (t.$extCollectionIndex < n.$extCollectionIndex ? -1 : 1)
        });
        for (u = 0; u < o; u++) {
            r = n[u];
            s = t.getKey(r);
            i[u] = s;
            t.indexMap[s] = u;
            delete n.$extCollectionIndex
        }
        t.generation++;
        t.indexGeneration = t.generation;
        t.fireEvent("sort", t, n, i)
    },
    findInsertionIndex: function(e, t) {
        var n = this,
        r = n.items,
        i = 0,
        s = r.length - 1,
        o, u;
        if (!t) {
            t = n.generateComparator()
        }
        while (i <= s) {
            o = i + s >> 1;
            u = t(e, r[o]);
            if (u >= 0) {
                i = o + 1
            } else {
                if (u < 0) {
                    s = o - 1
                }
            }
        }
        return i
    },
    reorder: function(e) {
        var t = this,
        n = t.items,
        r = 0,
        i = n.length,
        s = [],
        o = [],
        u;
        t.suspendEvents();
        for (u in e) {
            s[e[u]] = n[u]
        }
        for (r = 0; r < i; r++) {
            if (e[r] == undefined) {
                o.push(n[r])
            }
        }
        for (r = 0; r < i; r++) {
            if (s[r] == undefined) {
                s[r] = o.shift()
            }
        }
        t.clear();
        t.addAll(s);
        t.resumeEvents();
        t.fireEvent("sort", t)
    },
    sortByKey: function(e, t) {
        this._sort("key", e, t ||
        function(e, t) {
            var n = String(e).toUpperCase(),
            r = String(t).toUpperCase();
            return n > r ? 1 : n < r ? -1 : 0
        })
    }
});
Ext.define("Ext.fx.target.Target", {
    isAnimTarget: true,
    constructor: function(e) {
        this.target = e;
        this.id = this.getId()
    },
    getId: function() {
        return this.target.id
    },
    remove: function() {
        Ext.destroy(this.target)
    }
});
Ext.define("Ext.fx.target.Element", {
    extend: Ext.fx.target.Target,
    type: "element",
    getElVal: function(e, t, n) {
        if (n == undefined) {
            if (t === "x") {
                n = e.getX()
            } else {
                if (t === "y") {
                    n = e.getY()
                } else {
                    if (t === "scrollTop") {
                        n = e.getScroll().top
                    } else {
                        if (t === "scrollLeft") {
                            n = e.getScroll().left
                        } else {
                            if (t === "height") {
                                n = e.getHeight()
                            } else {
                                if (t === "width") {
                                    n = e.getWidth()
                                } else {
                                    n = e.getStyle(t)
                                }
                            }
                        }
                    }
                }
            }
        }
        return n
    },
    getAttr: function(e, t) {
        var n = this.target;
        return [[n, this.getElVal(n, e, t)]]
    },
    setAttr: function(e) {
        var t = this.target,
        n = e.length,
        r, i, s, o, u, a;
        for (o = 0; o < n; o++) {
            r = e[o].attrs;
            for (i in r) {
                if (r.hasOwnProperty(i)) {
                    a = r[i].length;
                    for (u = 0; u < a; u++) {
                        s = r[i][u];
                        this.setElVal(s[0], i, s[1])
                    }
                }
            }
        }
    },
    setElVal: function(e, t, n) {
        if (t === "x") {
            e.setX(n)
        } else {
            if (t === "y") {
                e.setY(n)
            } else {
                if (t === "scrollTop") {
                    e.scrollTo("top", n)
                } else {
                    if (t === "scrollLeft") {
                        e.scrollTo("left", n)
                    } else {
                        if (t === "width") {
                            e.setWidth(n)
                        } else {
                            if (t === "height") {
                                e.setHeight(n)
                            } else {
                                e.setStyle(t, n)
                            }
                        }
                    }
                }
            }
        }
    }
});
Ext.define("Ext.fx.target.ElementCSS", {
    extend: Ext.fx.target.Element,
    setAttr: function(e, t) {
        var n = {
            attrs: [],
            duration: [],
            easing: []
        },
        r = e.length,
        i,
        s,
        o,
        u,
        a,
        f,
        l,
        c,
        h;
        for (l = 0; l < r; l++) {
            s = e[l];
            a = s.duration;
            u = s.easing;
            s = s.attrs;
            for (o in s) {
                if (Ext.Array.indexOf(n.attrs, o) == -1) {
                    n.attrs.push(o.replace(/[A-Z]/g,
                    function(e) {
                        return "-" + e.toLowerCase()
                    }));
                    n.duration.push(a + "ms");
                    n.easing.push(u)
                }
            }
        }
        i = n.attrs.join(",");
        a = n.duration.join(",");
        u = n.easing.join(", ");
        for (l = 0; l < r; l++) {
            s = e[l].attrs;
            for (o in s) {
                h = s[o].length;
                for (c = 0; c < h; c++) {
                    f = s[o][c];
                    f[0].setStyle(Ext.supports.CSS3Prefix + "TransitionProperty", t ? "": i);
                    f[0].setStyle(Ext.supports.CSS3Prefix + "TransitionDuration", t ? "": a);
                    f[0].setStyle(Ext.supports.CSS3Prefix + "TransitionTimingFunction", t ? "": u);
                    f[0].setStyle(o, f[1]);
                    if (t) {
                        f = f[0].dom.offsetWidth
                    } else {
                        f[0].on(Ext.supports.CSS3TransitionEnd,
                        function() {
                            this.setStyle(Ext.supports.CSS3Prefix + "TransitionProperty", null);
                            this.setStyle(Ext.supports.CSS3Prefix + "TransitionDuration", null);
                            this.setStyle(Ext.supports.CSS3Prefix + "TransitionTimingFunction", null)
                        },
                        f[0], {
                            single: true
                        })
                    }
                }
            }
        }
    }
});
Ext.define("Ext.fx.target.CompositeElement", {
    extend: Ext.fx.target.Element,
    isComposite: true,
    constructor: function(e) {
        e.id = e.id || Ext.id(null, "ext-composite-");
        this.callParent([e])
    },
    getAttr: function(e, t) {
        var n = [],
        r = this.target,
        i = r.elements,
        s = i.length,
        o,
        u;
        for (o = 0; o < s; o++) {
            u = i[o];
            if (u) {
                u = r.getElement(u);
                n.push([u, this.getElVal(u, e, t)])
            }
        }
        return n
    },
    setAttr: function(e) {
        var t = this.target,
        n = e.length,
        r = t.elements,
        i = r.length,
        s, o, u, a, f, l, c, h;
        for (l = 0; l < n; l++) {
            u = e[l].attrs;
            for (a in u) {
                if (u.hasOwnProperty(a)) {
                    h = u[a].length;
                    for (c = 0; c < h; c++) {
                        s = u[a][c][1];
                        for (o = 0; o < i; ++o) {
                            el = r[o];
                            if (el) {
                                el = t.getElement(el);
                                this.setElVal(el, a, s)
                            }
                        }
                    }
                }
            }
        }
    },
    remove: function() {
        this.target.remove()
    }
});
Ext.define("Ext.fx.target.CompositeElementCSS", {
    extend: Ext.fx.target.CompositeElement,
    setAttr: function() {
        return Ext.fx.target.ElementCSS.prototype.setAttr.apply(this, arguments)
    }
});
Ext.define("Ext.fx.target.Sprite", {
    extend: Ext.fx.target.Target,
    type: "draw",
    getFromPrim: function(e, t) {
        var n;
        switch (t) {
        case "rotate":
        case "rotation":
            n = e.attr.rotation;
            return {
                x: n.x || 0,
                y: n.y || 0,
                degrees: n.degrees || 0
            };
        case "scale":
        case "scaling":
            n = e.attr.scaling;
            return {
                x: n.x || 1,
                y: n.y || 1,
                cx: n.cx || 0,
                cy: n.cy || 0
            };
        case "translate":
        case "translation":
            n = e.attr.translation;
            return {
                x: n.x || 0,
                y: n.y || 0
            };
        default:
            return e.attr[t]
        }
    },
    getAttr: function(e, t) {
        return [[this.target, t != undefined ? t: this.getFromPrim(this.target, e)]]
    },
    setAttr: function(e) {
        var t = e.length,
        n = [],
        r,
        i,
        s,
        o,
        u,
        a,
        f,
        l,
        c,
        h,
        p,
        d;
        for (l = 0; l < t; l++) {
            r = e[l].attrs;
            for (i in r) {
                s = r[i];
                d = s.length;
                for (c = 0; c < d; c++) {
                    u = s[c][0];
                    o = s[c][1];
                    if (i === "translate" || i === "translation") {
                        f = {
                            x: o.x,
                            y: o.y
                        }
                    } else {
                        if (i === "rotate" || i === "rotation") {
                            h = o.x;
                            if (isNaN(h)) {
                                h = null
                            }
                            p = o.y;
                            if (isNaN(p)) {
                                p = null
                            }
                            f = {
                                degrees: o.degrees,
                                x: h,
                                y: p
                            }
                        } else {
                            if (i === "scale" || i === "scaling") {
                                h = o.x;
                                if (isNaN(h)) {
                                    h = null
                                }
                                p = o.y;
                                if (isNaN(p)) {
                                    p = null
                                }
                                f = {
                                    x: h,
                                    y: p,
                                    cx: o.cx,
                                    cy: o.cy
                                }
                            } else {
                                if (i === "width" || i === "height" || i === "x" || i === "y") {
                                    f = parseFloat(o)
                                } else {
                                    f = o
                                }
                            }
                        }
                    }
                    a = Ext.Array.indexOf(n, u);
                    if (a == -1) {
                        n.push([u, {}]);
                        a = n.length - 1
                    }
                    n[a][1][i] = f
                }
            }
        }
        t = n.length;
        for (l = 0; l < t; l++) {
            n[l][0].setAttributes(n[l][1])
        }
        this.target.redraw()
    }
});
Ext.define("Ext.fx.target.CompositeSprite", {
    extend: Ext.fx.target.Sprite,
    getAttr: function(e, t) {
        var n = [],
        r = [].concat(this.target.items),
        i = r.length,
        s,
        o;
        for (s = 0; s < i; s++) {
            o = r[s];
            n.push([o, t != undefined ? t: this.getFromPrim(o, e)])
        }
        return n
    }
});
Ext.define("Ext.fx.target.Component", {
    extend: Ext.fx.target.Target,
    type: "component",
    getPropMethod: {
        top: function() {
            return this.getPosition(true)[1]
        },
        left: function() {
            return this.getPosition(true)[0]
        },
        x: function() {
            return this.getPosition()[0]
        },
        y: function() {
            return this.getPosition()[1]
        },
        height: function() {
            return this.getHeight()
        },
        width: function() {
            return this.getWidth()
        },
        opacity: function() {
            return this.el.getStyle("opacity")
        }
    },
    setMethods: {
        top: "setPosition",
        left: "setPosition",
        x: "setPagePosition",
        y: "setPagePosition",
        height: "setSize",
        width: "setSize",
        opacity: "setOpacity"
    },
    getAttr: function(e, t) {
        return [[this.target, t !== undefined ? t: this.getPropMethod[e].call(this.target)]]
    },
    setAttr: function(e, t, n) {
        var r = this,
        i = e.length,
        s, o, u, a, f, l, c, h, p, d, v = {},
        m;
        for (a = 0; a < i; a++) {
            s = e[a].attrs;
            for (o in s) {
                l = s[o].length;
                for (f = 0; f < l; f++) {
                    u = s[o][f];
                    m = v[r.setMethods[o]] || (v[r.setMethods[o]] = {});
                    m.target = u[0];
                    m[o] = u[1]
                }
            }
            if (v.setPosition) {
                u = v.setPosition;
                c = u.left === undefined ? undefined: parseFloat(u.left);
                h = u.top === undefined ? undefined: parseFloat(u.top);
                u.target.setPosition(c, h)
            }
            if (v.setPagePosition) {
                u = v.setPagePosition;
                u.target.setPagePosition(u.x, u.y)
            }
            if (v.setSize) {
                u = v.setSize;
                p = u.width === undefined ? u.target.getWidth() : parseFloat(u.width);
                d = u.height === undefined ? u.target.getHeight() : parseFloat(u.height);
                u.target.el.setSize(p, d);
                if (n || r.dynamic) {
                    Ext.globalEvents.on({
                        idle: Ext.Function.bind(u.target.setSize, u.target, [p, d]),
                        single: true
                    })
                }
            }
            if (v.setOpacity) {
                u = v.setOpacity;
                u.target.el.setStyle("opacity", u.opacity)
            }
        }
    }
});
Ext.define("Ext.fx.Queue", {
    constructor: function() {
        this.targets = new Ext.util.HashMap;
        this.fxQueue = {}
    },
    getFxDefaults: function(e) {
        var t = this.targets.get(e);
        if (t) {
            return t.fxDefaults
        }
        return {}
    },
    setFxDefaults: function(e, t) {
        var n = this.targets.get(e);
        if (n) {
            n.fxDefaults = Ext.apply(n.fxDefaults || {},
            t)
        }
    },
    stopAnimation: function(e) {
        var t = this,
        n = t.getFxQueue(e),
        r = n.length;
        while (r) {
            n[r - 1].end();
            r--
        }
    },
    getActiveAnimation: function(e) {
        var t = this.getFxQueue(e);
        return t && !!t.length ? t[0] : false
    },
    hasFxBlock: function(e) {
        var t = this.getFxQueue(e);
        return t && t[0] && t[0].block
    },
    getFxQueue: function(e) {
        if (!e) {
            return false
        }
        var t = this,
        n = t.fxQueue[e],
        r = t.targets.get(e);
        if (!r) {
            return false
        }
        if (!n) {
            t.fxQueue[e] = [];
            if (r.type != "element") {
                r.target.on("destroy",
                function() {
                    t.fxQueue[e] = []
                })
            }
        }
        return t.fxQueue[e]
    },
    queueFx: function(e) {
        var t = this,
        n = e.target,
        r, i;
        if (!n) {
            return
        }
        r = t.getFxQueue(n.getId());
        i = r.length;
        if (i) {
            if (e.concurrent) {
                e.paused = false
            } else {
                r[i - 1].on("afteranimate",
                function() {
                    e.paused = false
                })
            }
        } else {
            e.paused = false
        }
        e.on("afteranimate",
        function() {
            Ext.Array.remove(r, e);
            if (r.length === 0) {
                t.targets.remove(e.target)
            }
            if (e.remove) {
                if (n.type == "element") {
                    var i = Ext.get(n.id);
                    if (i) {
                        i.remove()
                    }
                }
            }
        },
        t, {
            single: true
        });
        r.push(e)
    }
});
Ext.define("Ext.fx.Manager", {
    singleton: true,
    mixins: {
        queue: Ext.fx.Queue
    },
    constructor: function() {
        var e = this;
        e.items = new Ext.util.MixedCollection;
        e.targetArr = {};
        e.mixins.queue.constructor.call(e);
        e.taskRunner = new Ext.util.TaskRunner
    },
    interval: 16,
    forceJS: true,
    createTarget: function(e) {
        var t = this,
        n = !t.forceJS && Ext.supports.Transitions,
        r;
        t.useCSS3 = n;
        if (e) {
            if (e.tagName || Ext.isString(e) || e.isFly) {
                e = Ext.get(e);
                r = new Ext.fx.target["Element" + (n ? "CSS": "")](e)
            } else {
                if (e.dom) {
                    r = new Ext.fx.target["Element" + (n ? "CSS": "")](e)
                } else {
                    if (e.isComposite) {
                        r = new Ext.fx.target["CompositeElement" + (n ? "CSS": "")](e)
                    } else {
                        if (e.isSprite) {
                            r = new Ext.fx.target.Sprite(e)
                        } else {
                            if (e.isCompositeSprite) {
                                r = new Ext.fx.target.CompositeSprite(e)
                            } else {
                                if (e.isComponent) {
                                    r = new Ext.fx.target.Component(e)
                                } else {
                                    if (e.isAnimTarget) {
                                        return e
                                    } else {
                                        return null
                                    }
                                }
                            }
                        }
                    }
                }
            }
            t.targets.add(r);
            return r
        } else {
            return null
        }
    },
    addAnim: function(e) {
        var t = this,
        n = t.items,
        r = t.task;
        n.add(e.id, e);
        if (!r && n.length) {
            r = t.task = {
                run: t.runner,
                interval: t.interval,
                scope: t
            };
            t.taskRunner.start(r)
        }
    },
    removeAnim: function(e) {
        var t = this,
        n = t.items,
        r = t.task;
        n.removeAtKey(e.id);
        if (r && !n.length) {
            t.taskRunner.stop(r);
            delete t.task
        }
    },
    runner: function() {
        var e = this,
        t = e.items.getRange(),
        n = 0,
        r = t.length,
        i;
        e.targetArr = {};
        e.timestamp = new Date;
        for (; n < r; n++) {
            i = t[n];
            if (i.isReady()) {
                e.startAnim(i)
            }
        }
        for (n = 0; n < r; n++) {
            i = t[n];
            if (i.isRunning()) {
                e.runAnim(i)
            }
        }
        e.applyPendingAttrs()
    },
    startAnim: function(e) {
        e.start(this.timestamp)
    },
    runAnim: function(e, t) {
        if (!e) {
            return
        }
        var n = this,
        r = n.useCSS3 && e.target.type == "element",
        i = n.timestamp - e.startTime,
        s = i >= e.duration,
        o, u;
        if (t) {
            i = e.duration;
            s = true
        }
        o = this.collectTargetData(e, i, r, s);
        if (r) {
            e.target.setAttr(o.anims[e.id].attributes, true);
            n.collectTargetData(e, e.duration, r, s);
            e.paused = true;
            o = e.target.target;
            if (e.target.isComposite) {
                o = e.target.target.last()
            }
            u = {};
            u[Ext.supports.CSS3TransitionEnd] = e.lastFrame;
            u.scope = e;
            u.single = true;
            o.on(u)
        }
        return o
    },
    jumpToEnd: function(e) {
        var t = this.runAnim(e, true);
        this.applyAnimAttrs(t, t.anims[e.id])
    },
    collectTargetData: function(e, t, n, r) {
        var i = e.target.getId(),
        s = this.targetArr[i];
        if (!s) {
            s = this.targetArr[i] = {
                id: i,
                el: e.target,
                anims: {}
            }
        }
        s.anims[e.id] = {
            id: e.id,
            anim: e,
            elapsed: t,
            isLastFrame: r,
            attributes: [{
                duration: e.duration,
                easing: n && e.reverse ? e.easingFn.reverse().toCSS3() : e.easing,
                attrs: e.runAnim(t)
            }]
        };
        return s
    },
    applyAnimAttrs: function(e, t) {
        var n = t.anim;
        if (t.attributes && n.isRunning()) {
            e.el.setAttr(t.attributes, false, t.isLastFrame);
            if (t.isLastFrame) {
                n.lastFrame()
            }
        }
    },
    applyPendingAttrs: function() {
        var e = this.targetArr,
        t, n, r, i, s;
        for (n in e) {
            if (e.hasOwnProperty(n)) {
                t = e[n];
                for (s in t.anims) {
                    if (t.anims.hasOwnProperty(s)) {
                        r = t.anims[s];
                        i = r.anim;
                        if (r.attributes && i.isRunning()) {
                            t.el.setAttr(r.attributes, false, r.isLastFrame);
                            if (r.isLastFrame) {
                                i.lastFrame()
                            }
                        }
                    }
                }
            }
        }
    }
});
Ext.define("Ext.fx.Animator", {
    mixins: {
        observable: Ext.util.Observable
    },
    isAnimator: true,
    duration: 250,
    delay: 0,
    delayStart: 0,
    dynamic: false,
    easing: "ease",
    running: false,
    paused: false,
    damper: 1,
    iterations: 1,
    currentIteration: 0,
    keyframeStep: 0,
    animKeyFramesRE: /^(from|to|\d+%?)$/,
    constructor: function(e) {
        var t = this;
        e = Ext.apply(t, e || {});
        t.config = e;
        t.id = Ext.id(null, "ext-animator-");
        t.addEvents("beforeanimate", "keyframe", "afteranimate");
        t.mixins.observable.constructor.call(t, e);
        t.timeline = [];
        t.createTimeline(t.keyframes);
        if (t.target) {
            t.applyAnimator(t.target);
            Ext.fx.Manager.addAnim(t)
        }
    },
    sorter: function(e, t) {
        return e.pct - t.pct
    },
    createTimeline: function(e) {
        var t = this,
        n = [],
        r = t.to || {},
        i = t.duration,
        s,
        o,
        u,
        a,
        f,
        l;
        for (f in e) {
            if (e.hasOwnProperty(f) && t.animKeyFramesRE.test(f)) {
                l = {
                    attrs: Ext.apply(e[f], r)
                };
                if (f == "from") {
                    f = 0
                } else {
                    if (f == "to") {
                        f = 100
                    }
                }
                l.pct = parseInt(f, 10);
                n.push(l)
            }
        }
        Ext.Array.sort(n, t.sorter);
        a = n.length;
        for (u = 0; u < a; u++) {
            s = n[u - 1] ? i * (n[u - 1].pct / 100) : 0;
            o = i * (n[u].pct / 100);
            t.timeline.push({
                duration: o - s,
                attrs: n[u].attrs
            })
        }
    },
    applyAnimator: function(e) {
        var t = this,
        n = [],
        r = t.timeline,
        i = r.length,
        s,
        o,
        u,
        a,
        f;
        if (t.fireEvent("beforeanimate", t) !== false) {
            for (f = 0; f < i; f++) {
                s = r[f];
                a = s.attrs;
                o = a.easing || t.easing;
                u = a.damper || t.damper;
                delete a.easing;
                delete a.damper;
                s = new Ext.fx.Anim({
                    target: e,
                    easing: o,
                    damper: u,
                    duration: s.duration,
                    paused: true,
                    to: a
                });
                n.push(s)
            }
            t.animations = n;
            t.target = s.target;
            for (f = 0; f < i - 1; f++) {
                s = n[f];
                s.nextAnim = n[f + 1];
                s.on("afteranimate",
                function() {
                    this.nextAnim.paused = false
                });
                s.on("afteranimate",
                function() {
                    this.fireEvent("keyframe", this, ++this.keyframeStep)
                },
                t)
            }
            n[i - 1].on("afteranimate",
            function() {
                this.lastFrame()
            },
            t)
        }
    },
    start: function(e) {
        var t = this,
        n = t.delay,
        r = t.delayStart,
        i;
        if (n) {
            if (!r) {
                t.delayStart = e;
                return
            } else {
                i = e - r;
                if (i < n) {
                    return
                } else {
                    e = new Date(r.getTime() + n)
                }
            }
        }
        if (t.fireEvent("beforeanimate", t) !== false) {
            t.startTime = e;
            t.running = true;
            t.animations[t.keyframeStep].paused = false
        }
    },
    lastFrame: function() {
        var e = this,
        t = e.iterations,
        n = e.currentIteration;
        n++;
        if (n < t) {
            e.startTime = new Date;
            e.currentIteration = n;
            e.keyframeStep = 0;
            e.applyAnimator(e.target);
            e.animations[e.keyframeStep].paused = false
        } else {
            e.currentIteration = 0;
            e.end()
        }
    },
    end: function() {
        var e = this;
        e.fireEvent("afteranimate", e, e.startTime, new Date - e.startTime)
    },
    isReady: function() {
        return this.paused === false && this.running === false && this.iterations > 0
    },
    isRunning: function() {
        return false
    }
});
Ext.define("Ext.fx.CubicBezier", {
    singleton: true,
    cubicBezierAtTime: function(e, t, n, r, i, s) {
        function h(e) {
            return ((a * e + u) * e + o) * e
        }
        function p(e, t) {
            var n = d(e, t);
            return ((c * n + l) * n + f) * n
        }
        function d(e, t) {
            var n, r, i, s, f, l;
            for (i = e, l = 0; l < 8; l++) {
                s = h(i) - e;
                if (Math.abs(s) < t) {
                    return i
                }
                f = (3 * a * i + 2 * u) * i + o;
                if (Math.abs(f) < 1e-6) {
                    break
                }
                i = i - s / f
            }
            n = 0;
            r = 1;
            i = e;
            if (i < n) {
                return n
            }
            if (i > r) {
                return r
            }
            while (n < r) {
                s = h(i);
                if (Math.abs(s - e) < t) {
                    return i
                }
                if (e > s) {
                    n = i
                } else {
                    r = i
                }
                i = (r - n) / 2 + n
            }
            return i
        }
        var o = 3 * t,
        u = 3 * (r - t) - o,
        a = 1 - o - u,
        f = 3 * n,
        l = 3 * (i - n) - f,
        c = 1 - f - l;
        return p(e, 1 / (200 * s))
    },
    cubicBezier: function(e, t, n, r) {
        var i = function(i) {
            return Ext.fx.CubicBezier.cubicBezierAtTime(i, e, t, n, r, 1)
        };
        i.toCSS3 = function() {
            return "cubic-bezier(" + [e, t, n, r].join(",") + ")"
        };
        i.reverse = function() {
            return Ext.fx.CubicBezier.cubicBezier(1 - n, 1 - r, 1 - e, 1 - t)
        };
        return i
    }
});
Ext.require("Ext.fx.CubicBezier",
function() {
    var e = Math,
    t = e.PI,
    n = e.pow,
    r = e.sin,
    i = e.sqrt,
    s = e.abs,
    o = 1.70158;
    Ext.define("Ext.fx.Easing", {
        singleton: true,
        linear: Ext.identityFn,
        ease: function(e) {
            var t = .07813 - e / 2,
            r = -.25,
            o = i(.0066 + t * t),
            u = o - t,
            f = n(s(u), 1 / 3) * (u < 0 ? -1 : 1),
            l = -o - t,
            c = n(s(l), 1 / 3) * (l < 0 ? -1 : 1),
            h = f + c + .25;
            return n(1 - h, 2) * 3 * h * .1 + (1 - h) * 3 * h * h + h * h * h
        },
        easeIn: function(e) {
            return n(e, 1.7)
        },
        easeOut: function(e) {
            return n(e, .48)
        },
        easeInOut: function(e) {
            var t = .48 - e / 1.04,
            r = i(.1734 + t * t),
            o = r - t,
            u = n(s(o), 1 / 3) * (o < 0 ? -1 : 1),
            f = -r - t,
            l = n(s(f), 1 / 3) * (f < 0 ? -1 : 1),
            c = u + l + .5;
            return (1 - c) * 3 * c * c + c * c * c
        },
        backIn: function(e) {
            return e * e * ((o + 1) * e - o)
        },
        backOut: function(e) {
            e = e - 1;
            return e * e * ((o + 1) * e + o) + 1
        },
        elasticIn: function(e) {
            if (e === 0 || e === 1) {
                return e
            }
            var i = .3,
            s = i / 4;
            return n(2, -10 * e) * r((e - s) * 2 * t / i) + 1
        },
        elasticOut: function(e) {
            return 1 - Ext.fx.Easing.elasticIn(1 - e)
        },
        bounceIn: function(e) {
            return 1 - Ext.fx.Easing.bounceOut(1 - e)
        },
        bounceOut: function(e) {
            var t = 7.5625,
            n = 2.75,
            r;
            if (e < 1 / n) {
                r = t * e * e
            } else {
                if (e < 2 / n) {
                    e -= 1.5 / n;
                    r = t * e * e + .75
                } else {
                    if (e < 2.5 / n) {
                        e -= 2.25 / n;
                        r = t * e * e + .9375
                    } else {
                        e -= 2.625 / n;
                        r = t * e * e + .984375
                    }
                }
            }
            return r
        }
    },
    function() {
        var e = Ext.fx.Easing.self,
        t = e.prototype;
        e.implement({
            "back-in": t.backIn,
            "back-out": t.backOut,
            "ease-in": t.easeIn,
            "ease-out": t.easeOut,
            "elastic-in": t.elasticIn,
            "elastic-out": t.elasticOut,
            "bounce-in": t.bounceIn,
            "bounce-out": t.bounceOut,
            "ease-in-out": t.easeInOut
        })
    })
});
Ext.define("Ext.draw.Color", {
    colorToHexRe: /(.*?)rgb\((\d+),\s*(\d+),\s*(\d+)\)/,
    rgbRe: /\s*rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)\s*/,
    hexRe: /\s*#([0-9a-fA-F][0-9a-fA-F]?)([0-9a-fA-F][0-9a-fA-F]?)([0-9a-fA-F][0-9a-fA-F]?)\s*/,
    lightnessFactor: .2,
    constructor: function(e, t, n) {
        var r = this,
        i = Ext.Number.constrain;
        r.r = i(e, 0, 255);
        r.g = i(t, 0, 255);
        r.b = i(n, 0, 255)
    },
    getRed: function() {
        return this.r
    },
    getGreen: function() {
        return this.g
    },
    getBlue: function() {
        return this.b
    },
    getRGB: function() {
        var e = this;
        return [e.r, e.g, e.b]
    },
    getHSL: function() {
        var e = this,
        t = e.r / 255,
        n = e.g / 255,
        r = e.b / 255,
        i = Math.max(t, n, r),
        s = Math.min(t, n, r),
        o = i - s,
        u,
        a = 0,
        f = .5 * (i + s);
        if (s != i) {
            a = f < .5 ? o / (i + s) : o / (2 - i - s);
            if (t == i) {
                u = 60 * (n - r) / o
            } else {
                if (n == i) {
                    u = 120 + 60 * (r - t) / o
                } else {
                    u = 240 + 60 * (t - n) / o
                }
            }
            if (u < 0) {
                u += 360
            }
            if (u >= 360) {
                u -= 360
            }
        }
        return [u, a, f]
    },
    getLighter: function(e) {
        var t = this.getHSL();
        e = e || this.lightnessFactor;
        t[2] = Ext.Number.constrain(t[2] + e, 0, 1);
        return this.fromHSL(t[0], t[1], t[2])
    },
    getDarker: function(e) {
        e = e || this.lightnessFactor;
        return this.getLighter( - e)
    },
    toString: function() {
        var e = this,
        t = Math.round,
        n = t(e.r).toString(16),
        r = t(e.g).toString(16),
        i = t(e.b).toString(16);
        n = n.length == 1 ? "0" + n: n;
        r = r.length == 1 ? "0" + r: r;
        i = i.length == 1 ? "0" + i: i;
        return ["#", n, r, i].join("")
    },
    toHex: function(e) {
        if (Ext.isArray(e)) {
            e = e[0]
        }
        if (!Ext.isString(e)) {
            return ""
        }
        if (e.substr(0, 1) === "#") {
            return e
        }
        var t = this.colorToHexRe.exec(e),
        n,
        r,
        i,
        s;
        if (Ext.isArray(t)) {
            n = parseInt(t[2], 10);
            r = parseInt(t[3], 10);
            i = parseInt(t[4], 10);
            s = i | r << 8 | n << 16;
            return t[1] + "#" + ("000000" + s.toString(16)).slice( - 6)
        } else {
            return e
        }
    },
    fromString: function(e) {
        var t, n, r, i, s = parseInt,
        o = e.substr(0, 1),
        u;
        if (o != "#") {
            u = Ext.draw.Color.cssColors[e];
            if (u) {
                e = u;
                o = e.substr(0, 1)
            }
        }
        if ((e.length == 4 || e.length == 7) && o === "#") {
            t = e.match(this.hexRe);
            if (t) {
                n = s(t[1], 16) >> 0;
                r = s(t[2], 16) >> 0;
                i = s(t[3], 16) >> 0;
                if (e.length == 4) {
                    n += n * 16;
                    r += r * 16;
                    i += i * 16
                }
            }
        } else {
            t = e.match(this.rgbRe);
            if (t) {
                n = t[1];
                r = t[2];
                i = t[3]
            }
        }
        return typeof n == "undefined" ? undefined: new Ext.draw.Color(n, r, i)
    },
    getGrayscale: function() {
        return this.r * .3 + this.g * .59 + this.b * .11
    },
    fromHSL: function(e, t, n) {
        var r, i, s, o, u = [],
        a = Math.abs,
        f = Math.floor;
        if (t == 0 || e == null) {
            u = [n, n, n]
        } else {
            e /= 60;
            r = t * (1 - a(2 * n - 1));
            i = r * (1 - a(e - 2 * f(e / 2) - 1));
            s = n - r / 2;
            switch (f(e)) {
            case 0:
                u = [r, i, 0];
                break;
            case 1:
                u = [i, r, 0];
                break;
            case 2:
                u = [0, r, i];
                break;
            case 3:
                u = [0, i, r];
                break;
            case 4:
                u = [i, 0, r];
                break;
            case 5:
                u = [r, 0, i];
                break
            }
            u = [u[0] + s, u[1] + s, u[2] + s]
        }
        return new Ext.draw.Color(u[0] * 255, u[1] * 255, u[2] * 255)
    }
},
function() {
    var e = this.prototype;
    this.addStatics({
        fromHSL: function() {
            return e.fromHSL.apply(e, arguments)
        },
        fromString: function() {
            return e.fromString.apply(e, arguments)
        },
        toHex: function() {
            return e.toHex.apply(e, arguments)
        },
        cssColors: {
            aliceblue: "#F0F8FF",
            antiquewhite: "#FAEBD7",
            aqua: "#00FFFF",
            aquamarine: "#7FFFD4",
            azure: "#F0FFFF",
            beige: "#F5F5DC",
            bisque: "#FFE4C4",
            black: "#000000",
            blanchedalmond: "#FFEBCD",
            blue: "#0000FF",
            blueviolet: "#8A2BE2",
            brown: "#A52A2A",
            burlywood: "#DEB887",
            cadetblue: "#5F9EA0",
            chartreuse: "#7FFF00",
            chocolate: "#D2691E",
            coral: "#FF7F50",
            cornflowerblue: "#6495ED",
            cornsilk: "#FFF8DC",
            crimson: "#DC143C",
            cyan: "#00FFFF",
            darkblue: "#00008B",
            darkcyan: "#008B8B",
            darkgoldenrod: "#B8860B",
            darkgray: "#A9A9A9",
            darkgreen: "#006400",
            darkgrey: "#A9A9A9",
            darkkhaki: "#BDB76B",
            darkmagenta: "#8B008B",
            darkolivegreen: "#556B2F",
            darkorange: "#FF8C00",
            darkorchid: "#9932CC",
            darkred: "#8B0000",
            darksalmon: "#E9967A",
            darkseagreen: "#8FBC8F",
            darkslateblue: "#483D8B",
            darkslategray: "#2F4F4F",
            darkslategrey: "#2F4F4F",
            darkturquoise: "#00CED1",
            darkviolet: "#9400D3",
            deeppink: "#FF1493",
            deepskyblue: "#00BFFF",
            dimgray: "#696969",
            dimgrey: "#696969",
            dodgerblue: "#1E90FF",
            firebrick: "#B22222",
            floralwhite: "#FFFAF0",
            forestgreen: "#228B22",
            fuchsia: "#FF00FF",
            gainsboro: "#DCDCDC",
            ghostwhite: "#F8F8FF",
            gold: "#FFD700",
            goldenrod: "#DAA520",
            gray: "#808080",
            grey: "#808080",
            green: "#008000",
            greenyellow: "#ADFF2F",
            honeydew: "#F0FFF0",
            hotpink: "#FF69B4",
            indianred: "#CD5C5C",
            indigo: "#4B0082",
            ivory: "#FFFFF0",
            khaki: "#F0E68C",
            lavender: "#E6E6FA",
            lavenderblush: "#FFF0F5",
            lawngreen: "#7CFC00",
            lemonchiffon: "#FFFACD",
            lightblue: "#ADD8E6",
            lightcoral: "#F08080",
            lightcyan: "#E0FFFF",
            lightgoldenrodyellow: "#FAFAD2",
            lightgray: "#D3D3D3",
            lightgreen: "#90EE90",
            lightgrey: "#D3D3D3",
            lightpink: "#FFB6C1",
            lightsalmon: "#FFA07A",
            lightseagreen: "#20B2AA",
            lightskyblue: "#87CEFA",
            lightslategray: "#778899",
            lightslategrey: "#778899",
            lightsteelblue: "#B0C4DE",
            lightyellow: "#FFFFE0",
            lime: "#00FF00",
            limegreen: "#32CD32",
            linen: "#FAF0E6",
            magenta: "#FF00FF",
            maroon: "#800000",
            mediumaquamarine: "#66CDAA",
            mediumblue: "#0000CD",
            mediumorchid: "#BA55D3",
            mediumpurple: "#9370DB",
            mediumseagreen: "#3CB371",
            mediumslateblue: "#7B68EE",
            mediumspringgreen: "#00FA9A",
            mediumturquoise: "#48D1CC",
            mediumvioletred: "#C71585",
            midnightblue: "#191970",
            mintcream: "#F5FFFA",
            mistyrose: "#FFE4E1",
            moccasin: "#FFE4B5",
            navajowhite: "#FFDEAD",
            navy: "#000080",
            oldlace: "#FDF5E6",
            olive: "#808000",
            olivedrab: "#6B8E23",
            orange: "#FFA500",
            orangered: "#FF4500",
            orchid: "#DA70D6",
            palegoldenrod: "#EEE8AA",
            palegreen: "#98FB98",
            paleturquoise: "#AFEEEE",
            palevioletred: "#DB7093",
            papayawhip: "#FFEFD5",
            peachpuff: "#FFDAB9",
            peru: "#CD853F",
            pink: "#FFC0CB",
            plum: "#DDA0DD",
            powderblue: "#B0E0E6",
            purple: "#800080",
            red: "#FF0000",
            rosybrown: "#BC8F8F",
            royalblue: "#4169E1",
            saddlebrown: "#8B4513",
            salmon: "#FA8072",
            sandybrown: "#F4A460",
            seagreen: "#2E8B57",
            seashell: "#FFF5EE",
            sienna: "#A0522D",
            silver: "#C0C0C0",
            skyblue: "#87CEEB",
            slateblue: "#6A5ACD",
            slategray: "#708090",
            slategrey: "#708090",
            snow: "#FFFAFA",
            springgreen: "#00FF7F",
            steelblue: "#4682B4",
            tan: "#D2B48C",
            teal: "#008080",
            thistle: "#D8BFD8",
            tomato: "#FF6347",
            turquoise: "#40E0D0",
            violet: "#EE82EE",
            wheat: "#F5DEB3",
            white: "#FFFFFF",
            whitesmoke: "#F5F5F5",
            yellow: "#FFFF00",
            yellowgreen: "#9ACD32"
        }
    })
});
Ext.define("Ext.draw.Draw", {
    singleton: true,
    pathToStringRE: /,?([achlmqrstvxz]),?/gi,
    pathCommandRE: /([achlmqstvz])[\s,]*((-?\d*\.?\d*(?:e[-+]?\d+)?\s*,?\s*)+)/ig,
    pathValuesRE: /(-?\d*\.?\d*(?:e[-+]?\d+)?)\s*,?\s*/ig,
    stopsRE: /^(\d+%?)$/,
    radian: Math.PI / 180,
    availableAnimAttrs: {
        along: "along",
        blur: null,
        "clip-rect": "csv",
        cx: null,
        cy: null,
        fill: "color",
        "fill-opacity": null,
        "font-size": null,
        height: null,
        opacity: null,
        path: "path",
        r: null,
        rotation: "csv",
        rx: null,
        ry: null,
        scale: "csv",
        stroke: "color",
        "stroke-opacity": null,
        "stroke-width": null,
        translation: "csv",
        width: null,
        x: null,
        y: null
    },
    is: function(e, t) {
        t = String(t).toLowerCase();
        return t == "object" && e === Object(e) || t == "undefined" && typeof e == t || t == "null" && e === null || t == "array" && Array.isArray && Array.isArray(e) || Object.prototype.toString.call(e).toLowerCase().slice(8, -1) == t
    },
    ellipsePath: function(e) {
        var t = e.attr;
        return Ext.String.format("M{0},{1}A{2},{3},0,1,1,{0},{4}A{2},{3},0,1,1,{0},{1}z", t.x, t.y - t.ry, t.rx, t.ry, t.y + t.ry)
    },
    rectPath: function(e) {
        var t = e.attr;
        if (t.radius) {
            return Ext.String.format("M{0},{1}l{2},0a{3},{3},0,0,1,{3},{3}l0,{5}a{3},{3},0,0,1,{4},{3}l{6},0a{3},{3},0,0,1,{4},{4}l0,{7}a{3},{3},0,0,1,{3},{4}z", t.x + t.radius, t.y, t.width - t.radius * 2, t.radius, -t.radius, t.height - t.radius * 2, t.radius * 2 - t.width, t.radius * 2 - t.height)
        } else {
            return Ext.String.format("M{0},{1}L{2},{1},{2},{3},{0},{3}z", t.x, t.y, t.width + t.x, t.height + t.y)
        }
    },
    path2string: function() {
        return this.join(",").replace(Ext.draw.Draw.pathToStringRE, "$1")
    },
    pathToString: function(e) {
        return e.join(",").replace(Ext.draw.Draw.pathToStringRE, "$1")
    },
    parsePathString: function(e) {
        if (!e) {
            return null
        }
        var t = {
            a: 7,
            c: 6,
            h: 1,
            l: 2,
            m: 2,
            q: 4,
            s: 4,
            t: 2,
            v: 1,
            z: 0
        },
        n = [],
        r = this;
        if (r.is(e, "array") && r.is(e[0], "array")) {
            n = r.pathClone(e)
        }
        if (!n.length) {
            String(e).replace(r.pathCommandRE,
            function(e, i, s) {
                var o = [],
                u = i.toLowerCase();
                s.replace(r.pathValuesRE,
                function(e, t) {
                    t && o.push( + t)
                });
                if (u == "m" && o.length > 2) {
                    n.push([i].concat(Ext.Array.splice(o, 0, 2)));
                    u = "l";
                    i = i == "m" ? "l": "L"
                }
                while (o.length >= t[u]) {
                    n.push([i].concat(Ext.Array.splice(o, 0, t[u])));
                    if (!t[u]) {
                        break
                    }
                }
            })
        }
        n.toString = r.path2string;
        return n
    },
    mapPath: function(e, t) {
        if (!t) {
            return e
        }
        var n, r, i, s, o, u, a;
        e = this.path2curve(e);
        for (i = 0, s = e.length; i < s; i++) {
            a = e[i];
            for (o = 1, u = a.length; o < u - 1; o += 2) {
                n = t.x(a[o], a[o + 1]);
                r = t.y(a[o], a[o + 1]);
                a[o] = n;
                a[o + 1] = r
            }
        }
        return e
    },
    pathClone: function(e) {
        var t = [],
        n,
        r,
        i,
        s;
        if (!this.is(e, "array") || !this.is(e && e[0], "array")) {
            e = this.parsePathString(e)
        }
        for (i = 0, s = e.length; i < s; i++) {
            t[i] = [];
            for (n = 0, r = e[i].length; n < r; n++) {
                t[i][n] = e[i][n]
            }
        }
        t.toString = this.path2string;
        return t
    },
    pathToAbsolute: function(e) {
        if (!this.is(e, "array") || !this.is(e && e[0], "array")) {
            e = this.parsePathString(e)
        }
        var t = [],
        n = 0,
        r = 0,
        i = 0,
        s = 0,
        o = 0,
        u = e.length,
        a,
        f,
        l,
        c;
        if (u && e[0][0] == "M") {
            n = +e[0][1];
            r = +e[0][2];
            i = n;
            s = r;
            o++;
            t[0] = ["M", n, r]
        }
        for (; o < u; o++) {
            a = t[o] = [];
            f = e[o];
            if (f[0] != f[0].toUpperCase()) {
                a[0] = f[0].toUpperCase();
                switch (a[0]) {
                case "A":
                    a[1] = f[1];
                    a[2] = f[2];
                    a[3] = f[3];
                    a[4] = f[4];
                    a[5] = f[5];
                    a[6] = +(f[6] + n);
                    a[7] = +(f[7] + r);
                    break;
                case "V":
                    a[1] = +f[1] + r;
                    break;
                case "H":
                    a[1] = +f[1] + n;
                    break;
                case "M":
                    i = +f[1] + n;
                    s = +f[2] + r;
                default:
                    l = 1;
                    c = f.length;
                    for (; l < c; l++) {
                        a[l] = +f[l] + (l % 2 ? n: r)
                    }
                }
            } else {
                l = 0;
                c = f.length;
                for (; l < c; l++) {
                    t[o][l] = f[l]
                }
            }
            switch (a[0]) {
            case "Z":
                n = i;
                r = s;
                break;
            case "H":
                n = a[1];
                break;
            case "V":
                r = a[1];
                break;
            case "M":
                f = t[o];
                c = f.length;
                i = f[c - 2];
                s = f[c - 1];
            default:
                f = t[o];
                c = f.length;
                n = f[c - 2];
                r = f[c - 1]
            }
        }
        t.toString = this.path2string;
        return t
    },
    pathToRelative: function(e) {
        if (!this.is(e, "array") || !this.is(e && e[0], "array")) {
            e = this.parsePathString(e)
        }
        var t = [],
        n = 0,
        r = 0,
        i = 0,
        s = 0,
        o = 0,
        u,
        a,
        f,
        l,
        c,
        h,
        p,
        d,
        v;
        if (e[0][0] == "M") {
            n = e[0][1];
            r = e[0][2];
            i = n;
            s = r;
            o++;
            t.push(["M", n, r])
        }
        for (f = o, p = e.length; f < p; f++) {
            u = t[f] = [];
            a = e[f];
            if (a[0] != a[0].toLowerCase()) {
                u[0] = a[0].toLowerCase();
                switch (u[0]) {
                case "a":
                    u[1] = a[1];
                    u[2] = a[2];
                    u[3] = a[3];
                    u[4] = a[4];
                    u[5] = a[5];
                    u[6] = +(a[6] - n).toFixed(3);
                    u[7] = +(a[7] - r).toFixed(3);
                    break;
                case "v":
                    u[1] = +(a[1] - r).toFixed(3);
                    break;
                case "m":
                    i = a[1];
                    s = a[2];
                default:
                    for (l = 1, d = a.length; l < d; l++) {
                        u[l] = +(a[l] - (l % 2 ? n: r)).toFixed(3)
                    }
                }
            } else {
                u = t[f] = [];
                if (a[0] == "m") {
                    i = a[1] + n;
                    s = a[2] + r
                }
                for (c = 0, v = a.length; c < v; c++) {
                    t[f][c] = a[c]
                }
            }
            h = t[f].length;
            switch (t[f][0]) {
            case "z":
                n = i;
                r = s;
                break;
            case "h":
                n += +t[f][h - 1];
                break;
            case "v":
                r += +t[f][h - 1];
                break;
            default:
                n += +t[f][h - 2];
                r += +t[f][h - 1]
            }
        }
        t.toString = this.path2string;
        return t
    },
    path2curve: function(e) {
        var t = this,
        n = t.pathToAbsolute(e),
        r = n.length,
        i = {
            x: 0,
            y: 0,
            bx: 0,
            by: 0,
            X: 0,
            Y: 0,
            qx: null,
            qy: null
        },
        s,
        o,
        u,
        a;
        for (s = 0; s < r; s++) {
            n[s] = t.command2curve(n[s], i);
            if (n[s].length > 7) {
                n[s].shift();
                a = n[s];
                while (a.length) {
                    Ext.Array.splice(n, s++, 0, ["C"].concat(Ext.Array.splice(a, 0, 6)))
                }
                Ext.Array.erase(n, s, 1);
                r = n.length;
                s--
            }
            o = n[s];
            u = o.length;
            i.x = o[u - 2];
            i.y = o[u - 1];
            i.bx = parseFloat(o[u - 4]) || i.x;
            i.by = parseFloat(o[u - 3]) || i.y
        }
        return n
    },
    interpolatePaths: function(e, t) {
        var n = this,
        r = n.pathToAbsolute(e),
        i = n.pathToAbsolute(t),
        s = {
            x: 0,
            y: 0,
            bx: 0,
            by: 0,
            X: 0,
            Y: 0,
            qx: null,
            qy: null
        },
        o = {
            x: 0,
            y: 0,
            bx: 0,
            by: 0,
            X: 0,
            Y: 0,
            qx: null,
            qy: null
        },
        u = function(e, t) {
            if (e[t].length > 7) {
                e[t].shift();
                var n = e[t];
                while (n.length) {
                    Ext.Array.splice(e, t++, 0, ["C"].concat(Ext.Array.splice(n, 0, 6)))
                }
                Ext.Array.erase(e, t, 1);
                l = Math.max(r.length, i.length || 0)
            }
        },
        a = function(e, t, n, s, o) {
            if (e && t && e[o][0] == "M" && t[o][0] != "M") {
                Ext.Array.splice(t, o, 0, ["M", s.x, s.y]);
                n.bx = 0;
                n.by = 0;
                n.x = e[o][1];
                n.y = e[o][2];
                l = Math.max(r.length, i.length || 0)
            }
        },
        f,
        l,
        c,
        h,
        p,
        d;
        for (f = 0, l = Math.max(r.length, i.length || 0); f < l; f++) {
            r[f] = n.command2curve(r[f], s);
            u(r, f);
            i[f] = n.command2curve(i[f], o);
            u(i, f);
            a(r, i, s, o, f);
            a(i, r, o, s, f);
            c = r[f];
            h = i[f];
            p = c.length;
            d = h.length;
            s.x = c[p - 2];
            s.y = c[p - 1];
            s.bx = parseFloat(c[p - 4]) || s.x;
            s.by = parseFloat(c[p - 3]) || s.y;
            o.bx = parseFloat(h[d - 4]) || o.x;
            o.by = parseFloat(h[d - 3]) || o.y;
            o.x = h[d - 2];
            o.y = h[d - 1]
        }
        return [r, i]
    },
    command2curve: function(e, t) {
        var n = this;
        if (!e) {
            return ["C", t.x, t.y, t.x, t.y, t.x, t.y]
        }
        if (e[0] != "T" && e[0] != "Q") {
            t.qx = t.qy = null
        }
        switch (e[0]) {
        case "M":
            t.X = e[1];
            t.Y = e[2];
            break;
        case "A":
            e = ["C"].concat(n.arc2curve.apply(n, [t.x, t.y].concat(e.slice(1))));
            break;
        case "S":
            e = ["C", t.x + (t.x - (t.bx || t.x)), t.y + (t.y - (t.by || t.y))].concat(e.slice(1));
            break;
        case "T":
            t.qx = t.x + (t.x - (t.qx || t.x));
            t.qy = t.y + (t.y - (t.qy || t.y));
            e = ["C"].concat(n.quadratic2curve(t.x, t.y, t.qx, t.qy, e[1], e[2]));
            break;
        case "Q":
            t.qx = e[1];
            t.qy = e[2];
            e = ["C"].concat(n.quadratic2curve(t.x, t.y, e[1], e[2], e[3], e[4]));
            break;
        case "L":
            e = ["C"].concat(t.x, t.y, e[1], e[2], e[1], e[2]);
            break;
        case "H":
            e = ["C"].concat(t.x, t.y, e[1], t.y, e[1], t.y);
            break;
        case "V":
            e = ["C"].concat(t.x, t.y, t.x, e[1], t.x, e[1]);
            break;
        case "Z":
            e = ["C"].concat(t.x, t.y, t.X, t.Y, t.X, t.Y);
            break
        }
        return e
    },
    quadratic2curve: function(e, t, n, r, i, s) {
        var o = 1 / 3,
        u = 2 / 3;
        return [o * e + u * n, o * t + u * r, o * i + u * n, o * s + u * r, i, s]
    },
    rotate: function(e, t, n) {
        var r = Math.cos(n),
        i = Math.sin(n),
        s = e * r - t * i,
        o = e * i + t * r;
        return {
            x: s,
            y: o
        }
    },
    arc2curve: function(e, t, n, r, i, s, o, u, a, f) {
        var l = this,
        c = Math.PI,
        h = l.radian,
        p = c * 120 / 180,
        d = h * ( + i || 0),
        v = [],
        m = Math,
        g = m.cos,
        y = m.sin,
        b = m.sqrt,
        w = m.abs,
        E = m.asin,
        S,
        x,
        T,
        N,
        C,
        k,
        L,
        A,
        O,
        M,
        _,
        D,
        P,
        H,
        B,
        j,
        F,
        I,
        q,
        R,
        U,
        z,
        W,
        X,
        V,
        $,
        J,
        K,
        Q;
        if (!f) {
            S = l.rotate(e, t, -d);
            e = S.x;
            t = S.y;
            S = l.rotate(u, a, -d);
            u = S.x;
            a = S.y;
            x = (e - u) / 2;
            T = (t - a) / 2;
            N = x * x / (n * n) + T * T / (r * r);
            if (N > 1) {
                N = b(N);
                n = N * n;
                r = N * r
            }
            C = n * n;
            k = r * r;
            L = (s == o ? -1 : 1) * b(w((C * k - C * T * T - k * x * x) / (C * T * T + k * x * x)));
            A = L * n * T / r + (e + u) / 2;
            O = L * -r * x / n + (t + a) / 2;
            M = E(((t - O) / r).toFixed(7));
            _ = E(((a - O) / r).toFixed(7));
            M = e < A ? c - M: M;
            _ = u < A ? c - _: _;
            if (M < 0) {
                M = c * 2 + M
            }
            if (_ < 0) {
                _ = c * 2 + _
            }
            if (o && M > _) {
                M = M - c * 2
            }
            if (!o && _ > M) {
                _ = _ - c * 2
            }
        } else {
            M = f[0];
            _ = f[1];
            A = f[2];
            O = f[3]
        }
        D = _ - M;
        if (w(D) > p) {
            J = _;
            K = u;
            Q = a;
            _ = M + p * (o && _ > M ? 1 : -1);
            u = A + n * g(_);
            a = O + r * y(_);
            v = l.arc2curve(u, a, n, r, i, 0, o, K, Q, [_, J, A, O])
        }
        D = _ - M;
        P = g(M);
        H = y(M);
        B = g(_);
        j = y(_);
        F = m.tan(D / 4);
        I = 4 / 3 * n * F;
        q = 4 / 3 * r * F;
        R = [e, t];
        U = [e + I * H, t - q * P];
        z = [u + I * j, a - q * B];
        W = [u, a];
        U[0] = 2 * R[0] - U[0];
        U[1] = 2 * R[1] - U[1];
        if (f) {
            return [U, z, W].concat(v)
        } else {
            v = [U, z, W].concat(v).join().split(",");
            X = [];
            $ = v.length;
            for (V = 0; V < $; V++) {
                X[V] = V % 2 ? l.rotate(v[V - 1], v[V], d).y: l.rotate(v[V], v[V + 1], d).x
            }
            return X
        }
    },
    rotateAndTranslatePath: function(e) {
        var t = e.rotation.degrees,
        n = e.rotation.x,
        r = e.rotation.y,
        i = e.translation.x,
        s = e.translation.y,
        o, u, a, f, l, c = [];
        if (!t && !i && !s) {
            return this.pathToAbsolute(e.attr.path)
        }
        i = i || 0;
        s = s || 0;
        o = this.pathToAbsolute(e.attr.path);
        for (u = o.length; u--;) {
            a = c[u] = o[u].slice();
            if (a[0] == "A") {
                f = this.rotatePoint(a[6], a[7], t, n, r);
                a[6] = f.x + i;
                a[7] = f.y + s
            } else {
                l = 1;
                while (a[l + 1] != null) {
                    f = this.rotatePoint(a[l], a[l + 1], t, n, r);
                    a[l] = f.x + i;
                    a[l + 1] = f.y + s;
                    l += 2
                }
            }
        }
        return c
    },
    rotatePoint: function(e, t, n, r, i) {
        if (!n) {
            return {
                x: e,
                y: t
            }
        }
        r = r || 0;
        i = i || 0;
        e = e - r;
        t = t - i;
        n = n * this.radian;
        var s = Math.cos(n),
        o = Math.sin(n);
        return {
            x: e * s - t * o + r,
            y: e * o + t * s + i
        }
    },
    pathDimensions: function(e) {
        if (!e || !(e + "")) {
            return {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            }
        }
        e = this.path2curve(e);
        var t = 0,
        n = 0,
        r = [],
        i = [],
        s = 0,
        o = e.length,
        u,
        a,
        f,
        l,
        c,
        h;
        for (; s < o; s++) {
            u = e[s];
            if (u[0] == "M") {
                t = u[1];
                n = u[2];
                r.push(t);
                i.push(n)
            } else {
                h = this.curveDim(t, n, u[1], u[2], u[3], u[4], u[5], u[6]);
                r = r.concat(h.min.x, h.max.x);
                i = i.concat(h.min.y, h.max.y);
                t = u[5];
                n = u[6]
            }
        }
        a = Math.min.apply(0, r);
        f = Math.min.apply(0, i);
        l = Math.max.apply(0, r);
        c = Math.max.apply(0, i);
        return {
            x: Math.round(a),
            y: Math.round(f),
            path: e,
            width: Math.round(l - a),
            height: Math.round(c - f)
        }
    },
    intersectInside: function(e, t, n) {
        return (n[0] - t[0]) * (e[1] - t[1]) > (n[1] - t[1]) * (e[0] - t[0])
    },
    intersectIntersection: function(e, t, n, r) {
        var i = [],
        s = n[0] - r[0],
        o = n[1] - r[1],
        u = e[0] - t[0],
        a = e[1] - t[1],
        f = n[0] * r[1] - n[1] * r[0],
        l = e[0] * t[1] - e[1] * t[0],
        c = 1 / (s * a - o * u);
        i[0] = (f * u - l * s) * c;
        i[1] = (f * a - l * o) * c;
        return i
    },
    intersect: function(e, t) {
        var n = this,
        r = 0,
        i = t.length,
        s = t[i - 1],
        o = e,
        u,
        a,
        f,
        l,
        c,
        h;
        for (; r < i; ++r) {
            u = t[r];
            c = o;
            o = [];
            a = c[c.length - 1];
            h = 0;
            l = c.length;
            for (; h < l; h++) {
                f = c[h];
                if (n.intersectInside(f, s, u)) {
                    if (!n.intersectInside(a, s, u)) {
                        o.push(n.intersectIntersection(a, f, s, u))
                    }
                    o.push(f)
                } else {
                    if (n.intersectInside(a, s, u)) {
                        o.push(n.intersectIntersection(a, f, s, u))
                    }
                }
                a = f
            }
            s = u
        }
        return o
    },
    bezier: function(e, t, n, r, i) {
        if (i === 0) {
            return e
        } else {
            if (i === 1) {
                return r
            }
        }
        var s = 1 - i,
        o = s * s * s,
        u = i / s;
        return o * (e + u * (3 * t + u * (3 * n + r * u)))
    },
    bezierDim: function(e, t, n, r) {
        var i = [],
        s,
        o,
        u,
        a,
        f,
        l,
        c,
        h,
        p,
        d;
        if (e + 3 * n == r + 3 * t) {
            s = e - t;
            s /= 2 * (e - t - t + n);
            if (s < 1 && s > 0) {
                i.push(s)
            }
        } else {
            o = e - 3 * t + 3 * n - r;
            u = 2 * (e - t - t + n);
            a = e - t;
            f = u * u - 4 * o * a;
            l = o + o;
            if (f === 0) {
                s = u / l;
                if (s < 1 && s > 0) {
                    i.push(s)
                }
            } else {
                if (f > 0) {
                    c = Math.sqrt(f);
                    s = (c + u) / l;
                    if (s < 1 && s > 0) {
                        i.push(s)
                    }
                    s = (u - c) / l;
                    if (s < 1 && s > 0) {
                        i.push(s)
                    }
                }
            }
        }
        h = Math.min(e, r);
        p = Math.max(e, r);
        for (d = 0; d < i.length; d++) {
            h = Math.min(h, this.bezier(e, t, n, r, i[d]));
            p = Math.max(p, this.bezier(e, t, n, r, i[d]))
        }
        return [h, p]
    },
    curveDim: function(e, t, n, r, i, s, o, u) {
        var a = this.bezierDim(e, n, i, o),
        f = this.bezierDim(t, r, s, u);
        return {
            min: {
                x: a[0],
                y: f[0]
            },
            max: {
                x: a[1],
                y: f[1]
            }
        }
    },
    getAnchors: function(e, t, n, r, i, s, o) {
        o = o || 4;
        var u = Math,
        a = u.PI,
        f = a / 2,
        l = u.abs,
        c = u.sin,
        h = u.cos,
        p = u.atan,
        d, v, m, g, y, b, w, E, S;
        d = (n - e) / o;
        v = (i - n) / o;
        if (r >= t && r >= s || r <= t && r <= s) {
            m = g = f
        } else {
            m = p((n - e) / l(r - t));
            if (t < r) {
                m = a - m
            }
            g = p((i - n) / l(r - s));
            if (s < r) {
                g = a - g
            }
        }
        S = f - (m + g) % (a * 2) / 2;
        if (S > f) {
            S -= a
        }
        m += S;
        g += S;
        y = n - d * c(m);
        b = r + d * h(m);
        w = n + v * c(g);
        E = r + v * h(g);
        if (r > t && b < t || r < t && b > t) {
            y += l(t - b) * (y - n) / (b - r);
            b = t
        }
        if (r > s && E < s || r < s && E > s) {
            w -= l(s - E) * (w - n) / (E - r);
            E = s
        }
        return {
            x1: y,
            y1: b,
            x2: w,
            y2: E
        }
    },
    smooth: function(e, t) {
        var n = this.path2curve(e),
        r = [n[0]],
        i = n[0][1],
        s = n[0][2],
        o,
        u,
        a = 1,
        f = n.length,
        l = 1,
        c = i,
        h = s,
        p,
        d,
        v,
        m,
        g,
        y,
        b;
        for (; a < f; a++) {
            p = n[a];
            d = p.length;
            v = n[a - 1];
            m = v.length;
            g = n[a + 1];
            y = g && g.length;
            if (p[0] == "M") {
                c = p[1];
                h = p[2];
                o = a + 1;
                while (n[o][0] != "C") {
                    o++
                }
                r.push(["M", c, h]);
                l = r.length;
                i = c;
                s = h;
                continue
            }
            if (p[d - 2] == c && p[d - 1] == h && (!g || g[0] == "M")) {
                b = r[l].length;
                u = this.getAnchors(v[m - 2], v[m - 1], c, h, r[l][b - 2], r[l][b - 1], t);
                r[l][1] = u.x2;
                r[l][2] = u.y2
            } else {
                if (!g || g[0] == "M") {
                    u = {
                        x1: p[d - 2],
                        y1: p[d - 1]
                    }
                } else {
                    u = this.getAnchors(v[m - 2], v[m - 1], p[d - 2], p[d - 1], g[y - 2], g[y - 1], t)
                }
            }
            r.push(["C", i, s, u.x1, u.y1, p[d - 2], p[d - 1]]);
            i = u.x2;
            s = u.y2
        }
        return r
    },
    findDotAtSegment: function(e, t, n, r, i, s, o, u, a) {
        var f = 1 - a;
        return {
            x: Math.pow(f, 3) * e + Math.pow(f, 2) * 3 * a * n + f * 3 * a * a * i + Math.pow(a, 3) * o,
            y: Math.pow(f, 3) * t + Math.pow(f, 2) * 3 * a * r + f * 3 * a * a * s + Math.pow(a, 3) * u
        }
    },
    snapEnds: function(e, t, n, r) {
        if (Ext.isDate(e)) {
            return this.snapEndsByDate(e, t, n)
        }
        var i = (t - e) / n,
        s = Math.floor(Math.log(i) / Math.LN10) + 1,
        o = Math.pow(10, s),
        u,
        a,
        f = Math.round(i % o * Math.pow(10, 2 - s)),
        l = [[0, 15], [10, 1], [20, 4], [25, 2], [50, 9], [100, 15]],
        c = 0,
        h,
        p,
        d,
        v,
        m = 1e9,
        g = l.length;
        a = Math.floor(e / o) * o;
        if (e == a && a > 0) {
            a = Math.floor((e - o / 10) / o) * o
        }
        if (r) {
            for (d = 0; d < g; d++) {
                h = l[d][0];
                p = h - f < 0 ? 1e6: (h - f) / l[d][1];
                if (p < m) {
                    v = h;
                    m = p
                }
            }
            i = Math.floor(i * Math.pow(10, -s)) * Math.pow(10, s) + v * Math.pow(10, s - 2);
            if (e < 0 && t >= 0) {
                u = 0;
                while (u > e) {
                    u -= i;
                    c++
                }
                e = +u.toFixed(10);
                u = 0;
                while (u < t) {
                    u += i;
                    c++
                }
                t = +u.toFixed(10)
            } else {
                u = e = a;
                while (u < t) {
                    u += i;
                    c++
                }
            }
            t = +u.toFixed(10)
        } else {
            e = a;
            c = n
        }
        return {
            from: e,
            to: t,
            power: s,
            step: i,
            steps: c
        }
    },
    snapEndsByDate: function(e, t, n, r) {
        var i = false,
        s = [[Ext.Date.MILLI, [1, 2, 5, 10, 20, 50, 100, 200, 250, 500]], [Ext.Date.SECOND, [1, 2, 5, 10, 15, 30]], [Ext.Date.MINUTE, [1, 2, 5, 10, 15, 30]], [Ext.Date.HOUR, [1, 2, 3, 4, 6, 12]], [Ext.Date.DAY, [1, 2, 7, 14]], [Ext.Date.MONTH, [1, 2, 3, 6]]],
        o = s.length,
        u = false,
        a,
        f,
        l,
        c;
        for (c = 0; c < o; c++) {
            a = s[c];
            if (!u) {
                for (f = 0; f < a[1].length; f++) {
                    if (t < Ext.Date.add(e, a[0], a[1][f] * n)) {
                        i = [a[0], a[1][f]];
                        u = true;
                        break
                    }
                }
            }
        }
        if (!i) {
            l = this.snapEnds(e.getFullYear(), t.getFullYear() + 1, n, r);
            i = [Date.YEAR, Math.round(l.step)]
        }
        return this.snapEndsByDateAndStep(e, t, i, r)
    },
    snapEndsByDateAndStep: function(e, t, n, r) {
        var i = [e.getFullYear(), e.getMonth(), e.getDate(), e.getHours(), e.getMinutes(), e.getSeconds(), e.getMilliseconds()],
        s,
        o,
        u,
        a,
        f,
        l,
        c,
        h,
        p = n[0],
        d = n[1],
        v = 0;
        if (r) {
            s = e
        } else {
            switch (p) {
            case Ext.Date.MILLI:
                s = new Date(i[0], i[1], i[2], i[3], i[4], i[5], Math.floor(i[6] / d) * d);
                break;
            case Ext.Date.SECOND:
                s = new Date(i[0], i[1], i[2], i[3], i[4], Math.floor(i[5] / d) * d, 0);
                break;
            case Ext.Date.MINUTE:
                s = new Date(i[0], i[1], i[2], i[3], Math.floor(i[4] / d) * d, 0, 0);
                break;
            case Ext.Date.HOUR:
                s = new Date(i[0], i[1], i[2], Math.floor(i[3] / d) * d, 0, 0, 0);
                break;
            case Ext.Date.DAY:
                s = new Date(i[0], i[1], Math.floor((i[2] - 1) / d) * d + 1, 0, 0, 0, 0);
                break;
            case Ext.Date.MONTH:
                s = new Date(i[0], Math.floor(i[1] / d) * d, 1, 0, 0, 0, 0);
                v = [];
                h = true;
                break;
            default:
                s = new Date(Math.floor(i[0] / d) * d, 0, 1, 0, 0, 0, 0);
                v = [];
                h = true;
                break
            }
        }
        c = p === Ext.Date.MONTH && (d == 1 / 2 || d == 1 / 3 || d == 1 / 4);
        o = new Date(s);
        while (o < t) {
            if (c) {
                u = new Date(o);
                a = u.getFullYear();
                f = u.getMonth();
                l = u.getDate();
                switch (d) {
                case 1 / 2 : if (l >= 15) {
                        l = 1;
                        if (++f > 11) {
                            a++
                        }
                    } else {
                        l = 15
                    }
                    break;
                case 1 / 3 : if (l >= 20) {
                        l = 1;
                        if (++f > 11) {
                            a++
                        }
                    } else {
                        if (l >= 10) {
                            l = 20
                        } else {
                            l = 10
                        }
                    }
                    break;
                case 1 / 4 : if (l >= 22) {
                        l = 1;
                        if (++f > 11) {
                            a++
                        }
                    } else {
                        if (l >= 15) {
                            l = 22
                        } else {
                            if (l >= 8) {
                                l = 15
                            } else {
                                l = 8
                            }
                        }
                    }
                    break
                }
                o.setYear(a);
                o.setMonth(f);
                o.setDate(l);
                v.push(new Date(o))
            } else {
                if (h) {
                    o = Ext.Date.add(o, p, d);
                    v.push(new Date(o))
                } else {
                    o = Ext.Date.add(o, p, d);
                    v++
                }
            }
        }
        if (r) {
            o = t
        }
        if (h) {
            return {
                from: +s,
                to: +o,
                steps: v
            }
        } else {
            return {
                from: +s,
                to: +o,
                step: (o - s) / v,
                steps: v
            }
        }
    },
    sorter: function(e, t) {
        return e.offset - t.offset
    },
    rad: function(e) {
        return e % 360 * Math.PI / 180
    },
    normalizeRadians: function(e) {
        var t = 2 * Math.PI;
        if (e >= 0) {
            return e % t
        }
        return (e % t + t) % t
    },
    degrees: function(e) {
        return e * 180 / Math.PI % 360
    },
    normalizeDegrees: function(e) {
        if (e >= 0) {
            return e % 360
        }
        return (e % 360 + 360) % 360
    },
    withinBox: function(e, t, n) {
        n = n || {};
        return e >= n.x && e <= n.x + n.width && t >= n.y && t <= n.y + n.height
    },
    parseGradient: function(e) {
        var t = this,
        n = e.type || "linear",
        r = e.angle || 0,
        i = t.radian,
        s = e.stops,
        o = [],
        u,
        a,
        f,
        l;
        if (n == "linear") {
            a = [0, 0, Math.cos(r * i), Math.sin(r * i)];
            f = 1 / (Math.max(Math.abs(a[2]), Math.abs(a[3])) || 1);
            a[2] *= f;
            a[3] *= f;
            if (a[2] < 0) {
                a[0] = -a[2];
                a[2] = 0
            }
            if (a[3] < 0) {
                a[1] = -a[3];
                a[3] = 0
            }
        }
        for (u in s) {
            if (s.hasOwnProperty(u) && t.stopsRE.test(u)) {
                l = {
                    offset: parseInt(u, 10),
                    color: Ext.draw.Color.toHex(s[u].color) || "#ffffff",
                    opacity: s[u].opacity || 1
                };
                o.push(l)
            }
        }
        Ext.Array.sort(o, t.sorter);
        if (n == "linear") {
            return {
                id: e.id,
                type: n,
                vector: a,
                stops: o
            }
        } else {
            return {
                id: e.id,
                type: n,
                centerX: e.centerX,
                centerY: e.centerY,
                focalX: e.focalX,
                focalY: e.focalY,
                radius: e.radius,
                vector: a,
                stops: o
            }
        }
    }
});
Ext.define("Ext.fx.PropertyHandler", {
    statics: {
        defaultHandler: {
            pixelDefaultsRE: /width|height|top$|bottom$|left$|right$/i,
            unitRE: /^(-?\d*\.?\d*){1}(em|ex|px|in|cm|mm|pt|pc|%)*$/,
            scrollRE: /^scroll/i,
            computeDelta: function(e, t, n, r, i) {
                n = typeof n == "number" ? n: 1;
                var s = this.unitRE,
                o = s.exec(e),
                u,
                a;
                if (o) {
                    e = o[1];
                    a = o[2];
                    if (!this.scrollRE.test(i) && !a && this.pixelDefaultsRE.test(i)) {
                        a = "px"
                    }
                }
                e = +e || 0;
                o = s.exec(t);
                if (o) {
                    t = o[1];
                    a = o[2] || a
                }
                t = +t || 0;
                u = r != null ? r: e;
                return {
                    from: e,
                    delta: (t - u) * n,
                    units: a
                }
            },
            get: function(e, t, n, r, i) {
                var s = e.length,
                o = [],
                u,
                a,
                f,
                l,
                c;
                for (u = 0; u < s; u++) {
                    if (r) {
                        a = r[u][1].from
                    }
                    if (Ext.isArray(e[u][1]) && Ext.isArray(t)) {
                        f = [];
                        l = 0;
                        c = e[u][1].length;
                        for (; l < c; l++) {
                            f.push(this.computeDelta(e[u][1][l], t[l], n, a, i))
                        }
                        o.push([e[u][0], f])
                    } else {
                        o.push([e[u][0], this.computeDelta(e[u][1], t, n, a, i)])
                    }
                }
                return o
            },
            set: function(e, t) {
                var n = e.length,
                r = [],
                i,
                s,
                o,
                u,
                a;
                for (i = 0; i < n; i++) {
                    s = e[i][1];
                    if (Ext.isArray(s)) {
                        o = [];
                        a = 0;
                        u = s.length;
                        for (; a < u; a++) {
                            o.push(s[a].from + s[a].delta * t + (s[a].units || 0))
                        }
                        r.push([e[i][0], o])
                    } else {
                        r.push([e[i][0], s.from + s.delta * t + (s.units || 0)])
                    }
                }
                return r
            }
        },
        stringHandler: {
            computeDelta: function(e, t, n, r, i) {
                return {
                    from: e,
                    delta: t
                }
            },
            get: function(e, t, n, r, i) {
                var s = e.length,
                o = [],
                u,
                a,
                f,
                l,
                c;
                for (u = 0; u < s; u++) {
                    o.push([e[u][0], this.computeDelta(e[u][1], t, n, a, i)])
                }
                return o
            },
            set: function(e, t) {
                var n = e.length,
                r = [],
                i,
                s,
                o,
                u,
                a;
                for (i = 0; i < n; i++) {
                    s = e[i][1];
                    r.push([e[i][0], s.delta])
                }
                return r
            }
        },
        color: {
            rgbRE: /^rgb\(([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\)$/i,
            hexRE: /^#?([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})$/i,
            hex3RE: /^#?([0-9A-F]{1})([0-9A-F]{1})([0-9A-F]{1})$/i,
            parseColor: function(e, t) {
                t = typeof t == "number" ? t: 1;
                var n = false,
                r = [this.hexRE, this.rgbRE, this.hex3RE],
                i = r.length,
                s,
                o,
                u,
                a;
                for (a = 0; a < i; a++) {
                    u = r[a];
                    o = a % 2 === 0 ? 16 : 10;
                    s = u.exec(e);
                    if (s && s.length === 4) {
                        if (a === 2) {
                            s[1] += s[1];
                            s[2] += s[2];
                            s[3] += s[3]
                        }
                        n = {
                            red: parseInt(s[1], o),
                            green: parseInt(s[2], o),
                            blue: parseInt(s[3], o)
                        };
                        break
                    }
                }
                return n || e
            },
            computeDelta: function(e, t, n, r) {
                e = this.parseColor(e);
                t = this.parseColor(t, n);
                var i = r ? r: e,
                s = typeof i,
                o = typeof t;
                if (s == "string" || s == "undefined" || o == "string" || o == "undefined") {
                    return t || i
                }
                return {
                    from: e,
                    delta: {
                        red: Math.round((t.red - i.red) * n),
                        green: Math.round((t.green - i.green) * n),
                        blue: Math.round((t.blue - i.blue) * n)
                    }
                }
            },
            get: function(e, t, n, r) {
                var i = e.length,
                s = [],
                o,
                u;
                for (o = 0; o < i; o++) {
                    if (r) {
                        u = r[o][1].from
                    }
                    s.push([e[o][0], this.computeDelta(e[o][1], t, n, u)])
                }
                return s
            },
            set: function(e, t) {
                var n = e.length,
                r = [],
                i,
                s,
                o,
                u,
                a;
                for (i = 0; i < n; i++) {
                    s = e[i][1];
                    if (s) {
                        u = s.from;
                        a = s.delta;
                        s = typeof s == "object" && "red" in s ? "rgb(" + s.red + ", " + s.green + ", " + s.blue + ")": s;
                        s = typeof s == "object" && s.length ? s[0] : s;
                        if (typeof s == "undefined") {
                            return []
                        }
                        o = typeof s == "string" ? s: "rgb(" + [(u.red + Math.round(a.red * t)) % 256, (u.green + Math.round(a.green * t)) % 256, (u.blue + Math.round(a.blue * t)) % 256].join(",") + ")";
                        r.push([e[i][0], o])
                    }
                }
                return r
            }
        },
        object: {
            interpolate: function(e, t) {
                t = typeof t == "number" ? t: 1;
                var n = {},
                r;
                for (r in e) {
                    n[r] = parseFloat(e[r]) * t
                }
                return n
            },
            computeDelta: function(e, t, n, r) {
                e = this.interpolate(e);
                t = this.interpolate(t, n);
                var i = r ? r: e,
                s = {},
                o;
                for (o in t) {
                    s[o] = t[o] - i[o]
                }
                return {
                    from: e,
                    delta: s
                }
            },
            get: function(e, t, n, r) {
                var i = e.length,
                s = [],
                o,
                u;
                for (o = 0; o < i; o++) {
                    if (r) {
                        u = r[o][1].from
                    }
                    s.push([e[o][0], this.computeDelta(e[o][1], t, n, u)])
                }
                return s
            },
            set: function(e, t) {
                var n = e.length,
                r = [],
                i = {},
                s,
                o,
                u,
                a,
                f;
                for (s = 0; s < n; s++) {
                    a = e[s][1];
                    o = a.from;
                    u = a.delta;
                    for (f in o) {
                        i[f] = o[f] + u[f] * t
                    }
                    r.push([e[s][0], i])
                }
                return r
            }
        },
        path: {
            computeDelta: function(e, t, n, r) {
                n = typeof n == "number" ? n: 1;
                var i;
                e = +e || 0;
                t = +t || 0;
                i = r != null ? r: e;
                return {
                    from: e,
                    delta: (t - i) * n
                }
            },
            forcePath: function(e) {
                if (!Ext.isArray(e) && !Ext.isArray(e[0])) {
                    e = Ext.draw.Draw.parsePathString(e)
                }
                return e
            },
            get: function(e, t, n, r) {
                var i = this.forcePath(t),
                s = [],
                o = e.length,
                u,
                a,
                f,
                l,
                c,
                h,
                p,
                d,
                v;
                for (f = 0; f < o; f++) {
                    v = this.forcePath(e[f][1]);
                    l = Ext.draw.Draw.interpolatePaths(v, i);
                    v = l[0];
                    i = l[1];
                    u = v.length;
                    d = [];
                    for (h = 0; h < u; h++) {
                        l = [v[h][0]];
                        a = v[h].length;
                        for (p = 1; p < a; p++) {
                            c = r && r[0][1][h][p].from;
                            l.push(this.computeDelta(v[h][p], i[h][p], n, c))
                        }
                        d.push(l)
                    }
                    s.push([e[f][0], d])
                }
                return s
            },
            set: function(e, t) {
                var n = e.length,
                r = [],
                i,
                s,
                o,
                u,
                a,
                f,
                l,
                c;
                for (i = 0; i < n; i++) {
                    f = e[i][1];
                    u = [];
                    l = f.length;
                    for (s = 0; s < l; s++) {
                        a = [f[s][0]];
                        c = f[s].length;
                        for (o = 1; o < c; o++) {
                            a.push(f[s][o].from + f[s][o].delta * t)
                        }
                        u.push(a.join(","))
                    }
                    r.push([e[i][0], u.join(",")])
                }
                return r
            }
        }
    }
},
function() {
    var e = ["outlineColor", "backgroundColor", "borderColor", "borderTopColor", "borderRightColor", "borderBottomColor", "borderLeftColor", "fill", "stroke"],
    t = e.length,
    n = 0,
    r;
    for (; n < t; n++) {
        r = e[n];
        this[r] = this.color
    }
    e = ["cursor"];
    t = e.length;
    n = 0;
    for (; n < t; n++) {
        r = e[n];
        this[r] = this.stringHandler
    }
});
Ext.define("Ext.fx.Anim", {
    mixins: {
        observable: Ext.util.Observable
    },
    isAnimation: true,
    duration: 250,
    delay: 0,
    delayStart: 0,
    dynamic: false,
    easing: "ease",
    damper: 1,
    bezierRE: /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/,
    reverse: false,
    running: false,
    paused: false,
    iterations: 1,
    autoEnd: false,
    alternate: false,
    currentIteration: 0,
    startTime: 0,
    frameCount: 0,
    constructor: function(e) {
        var t = this,
        n;
        e = e || {};
        if (e.keyframes) {
            return new Ext.fx.Animator(e)
        }
        Ext.apply(t, e);
        if (t.from === undefined) {
            t.from = {}
        }
        t.propHandlers = {};
        t.config = e;
        t.target = Ext.fx.Manager.createTarget(t.target);
        t.easingFn = Ext.fx.Easing[t.easing];
        t.target.dynamic = t.dynamic;
        if (!t.easingFn) {
            t.easingFn = String(t.easing).match(t.bezierRE);
            if (t.easingFn && t.easingFn.length == 5) {
                n = t.easingFn;
                t.easingFn = Ext.fx.CubicBezier.cubicBezier( + n[1], +n[2], +n[3], +n[4])
            }
        }
        t.id = Ext.id(null, "ext-anim-");
        t.addEvents("beforeanimate", "afteranimate", "lastframe");
        t.mixins.observable.constructor.call(t);
        Ext.fx.Manager.addAnim(t);
        if (e.autoEnd) {
            t.running = true;
            t.jumpToEnd()
        }
    },
    setAttr: function(e, t) {
        return Ext.fx.Manager.items.get(this.id).setAttr(this.target, e, t)
    },
    initAttrs: function() {
        var e = this,
        t = e.from,
        n = e.to,
        r = e.initialFrom || {},
        i = {},
        s, o, u, a;
        for (a in n) {
            if (n.hasOwnProperty(a)) {
                s = e.target.getAttr(a, t[a]);
                o = n[a];
                if (!Ext.fx.PropertyHandler[a]) {
                    if (Ext.isObject(o)) {
                        u = e.propHandlers[a] = Ext.fx.PropertyHandler.object
                    } else {
                        u = e.propHandlers[a] = Ext.fx.PropertyHandler.defaultHandler
                    }
                } else {
                    u = e.propHandlers[a] = Ext.fx.PropertyHandler[a]
                }
                i[a] = u.get(s, o, e.damper, r[a], a)
            }
        }
        e.currentAttrs = i
    },
    start: function(e) {
        var t = this,
        n = t.delay,
        r = t.delayStart,
        i;
        if (n) {
            if (!r) {
                t.delayStart = e;
                return
            } else {
                i = e - r;
                if (i < n) {
                    return
                } else {
                    e = new Date(r.getTime() + n)
                }
            }
        }
        if (t.fireEvent("beforeanimate", t) !== false) {
            t.startTime = e;
            if (!t.paused && !t.currentAttrs) {
                t.initAttrs()
            }
            t.running = true;
            t.frameCount = 0
        }
    },
    jumpToEnd: function() {
        var e = this;
        if (!e.endWasCalled) {
            if (!e.currentAttrs) {
                e.initAttrs()
            }
            Ext.fx.Manager.jumpToEnd(e);
            e.end()
        }
    },
    runAnim: function(e) {
        var t = this,
        n = t.currentAttrs,
        r = t.duration,
        i = t.easingFn,
        s = t.propHandlers,
        o = {},
        u, a, f, l;
        if (e >= r) {
            e = r;
            l = true
        }
        if (t.reverse) {
            e = r - e
        }
        for (f in n) {
            if (n.hasOwnProperty(f)) {
                a = n[f];
                u = l ? 1 : i(e / r);
                o[f] = s[f].set(a, u)
            }
        }
        t.frameCount++;
        return o
    },
    lastFrame: function() {
        var e = this,
        t = e.iterations,
        n = e.currentIteration;
        n++;
        if (n < t) {
            if (e.alternate) {
                e.reverse = !e.reverse
            }
            e.startTime = new Date;
            e.currentIteration = n;
            e.paused = false
        } else {
            e.currentIteration = 0;
            e.end();
            e.fireEvent("lastframe", e, e.startTime)
        }
    },
    endWasCalled: 0,
    end: function() {
        var e = this;
        if (e.endWasCalled++) {
            return
        }
        e.startTime = 0;
        e.paused = false;
        e.running = false;
        Ext.fx.Manager.removeAnim(e);
        e.fireEvent("afteranimate", e, e.startTime);
        Ext.callback(e.callback, e.scope, [e, e.startTime]);
        if (e.remove) {
            e.target.remove()
        }
    },
    isReady: function() {
        return this.paused === false && this.running === false && this.iterations > 0
    },
    isRunning: function() {
        return this.paused === false && this.running === true && this.isAnimator !== true
    }
});
Ext.enableFx = true;
Ext.define("Ext.util.Animate", {
    isAnimate: true,
    animate: function(e) {
        var t = this;
        if (Ext.fx.Manager.hasFxBlock(t.id)) {
            return t
        }
        Ext.fx.Manager.queueFx(new Ext.fx.Anim(t.anim(e)));
        return this
    },
    anim: function(e) {
        if (!Ext.isObject(e)) {
            return e ? {}: false
        }
        var t = this;
        if (e.stopAnimation) {
            t.stopAnimation()
        }
        Ext.applyIf(e, Ext.fx.Manager.getFxDefaults(t.id));
        return Ext.apply({
            target: t,
            paused: true
        },
        e)
    },
    getAnimationProps: function() {
        var e = this,
        t = e.layout;
        return t && t.animate ? t.animate: {}
    },
    stopFx: Ext.Function.alias(Ext.util.Animate, "stopAnimation"),
    stopAnimation: function() {
        Ext.fx.Manager.stopAnimation(this.id);
        return this
    },
    syncFx: function() {
        Ext.fx.Manager.setFxDefaults(this.id, {
            concurrent: true
        });
        return this
    },
    sequenceFx: function() {
        Ext.fx.Manager.setFxDefaults(this.id, {
            concurrent: false
        });
        return this
    },
    hasActiveFx: Ext.Function.alias(Ext.util.Animate, "getActiveAnimation"),
    getActiveAnimation: function() {
        return Ext.fx.Manager.getActiveAnimation(this.id)
    }
},
function() {
    Ext.applyIf(Ext.Element.prototype, this.prototype);
    Ext.CompositeElementLite.importElementMethods()
});
Ext.define("Ext.util.ElementContainer", {
    childEls: [],
    constructor: function() {
        var e = this,
        t;
        if (e.hasOwnProperty("childEls")) {
            t = e.childEls;
            delete e.childEls;
            e.addChildEls.apply(e, t)
        }
    },
    destroy: function() {
        var e = this,
        t = e.getChildEls(),
        n,
        r,
        i,
        s;
        for (i = t.length; i--;) {
            r = t[i];
            if (typeof r != "string") {
                r = r.name
            }
            n = e[r];
            if (n) {
                e[r] = null;
                n.remove()
            }
        }
    },
    addChildEls: function() {
        var e = this,
        t = arguments;
        if (e.hasOwnProperty("childEls")) {
            e.childEls.push.apply(e.childEls, t)
        } else {
            e.childEls = e.getChildEls().concat(Array.prototype.slice.call(t))
        }
        e.prune(e.childEls, false)
    },
    applyChildEls: function(e, t) {
        var n = this,
        r = n.getChildEls(),
        i,
        s,
        o,
        u,
        a;
        i = (t || n.id) + "-";
        for (o = r.length; o--;) {
            s = r[o];
            if (typeof s == "string") {
                a = e.getById(i + s)
            } else {
                if (u = s.select) {
                    a = Ext.select(u, true, e.dom)
                } else {
                    if (u = s.selectNode) {
                        a = Ext.get(Ext.DomQuery.selectNode(u, e.dom))
                    } else {
                        a = e.getById(s.id || i + s.itemId)
                    }
                }
                s = s.name
            }
            n[s] = a
        }
    },
    getChildEls: function() {
        var e = this,
        t;
        if (e.hasOwnProperty("childEls")) {
            return e.childEls
        }
        t = e.self;
        return t.$childEls || e.getClassChildEls(t)
    },
    getClassChildEls: function(e) {
        var t = this,
        n = e.$childEls,
        r, i, s, o, u, a, f, l, c, h, p;
        if (!n) {
            h = e.superclass;
            if (h) {
                h = h.self;
                l = [h.$childEls || t.getClassChildEls(h)];
                p = h.prototype.mixins || {}
            } else {
                l = [];
                p = {}
            }
            c = e.prototype;
            a = c.mixins;
            for (f in a) {
                if (a.hasOwnProperty(f) && !p.hasOwnProperty(f)) {
                    u = a[f].self;
                    l.push(u.$childEls || t.getClassChildEls(u))
                }
            }
            l.push(c.hasOwnProperty("childEls") && c.childEls);
            for (i = 0, s = l.length; i < s; ++i) {
                r = l[i];
                if (r && r.length) {
                    if (!n) {
                        n = r
                    } else {
                        if (!o) {
                            o = true;
                            n = n.slice(0)
                        }
                        n.push.apply(n, r)
                    }
                }
            }
            e.$childEls = n = n ? t.prune(n, !o) : []
        }
        return n
    },
    prune: function(e, t) {
        var n = e.length,
        r = {},
        i;
        while (n--) {
            i = e[n];
            if (typeof i != "string") {
                i = i.name
            }
            if (!r[i]) {
                r[i] = 1
            } else {
                if (t) {
                    t = false;
                    e = e.slice(0)
                }
                Ext.Array.erase(e, n, 1)
            }
        }
        return e
    },
    removeChildEls: function(e) {
        var t = this,
        n = t.getChildEls(),
        r = t.childEls = [],
        i,
        s,
        o;
        for (s = 0, i = n.length; s < i; ++s) {
            o = n[s];
            if (!e(o)) {
                r.push(o)
            }
        }
    }
});
Ext.define("Ext.util.Renderable", {
    frameCls: Ext.baseCSSPrefix + "frame",
    frameIdRegex: /[\-]frame\d+[TMB][LCR]$/,
    frameElNames: ["TL", "TC", "TR", "ML", "MC", "MR", "BL", "BC", "BR", "Table"],
    frameTpl: ["{%this.renderDockedItems(out,values,0);%}", '<tpl if="top">', '<tpl if="left"><div id="{fgid}TL" class="{frameCls}-tl {baseCls}-tl {baseCls}-{ui}-tl<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-tl</tpl>{frameElCls}" role="presentation"></tpl>', '<tpl if="right"><div id="{fgid}TR" class="{frameCls}-tr {baseCls}-tr {baseCls}-{ui}-tr<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-tr</tpl>{frameElCls}" role="presentation"></tpl>', '<div id="{fgid}TC" class="{frameCls}-tc {baseCls}-tc {baseCls}-{ui}-tc<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-tc</tpl>{frameElCls}" role="presentation"></div>', '<tpl if="right"></div></tpl>', '<tpl if="left"></div></tpl>', "</tpl>", '<tpl if="left"><div id="{fgid}ML" class="{frameCls}-ml {baseCls}-ml {baseCls}-{ui}-ml<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-ml</tpl>{frameElCls}" role="presentation"></tpl>', '<tpl if="right"><div id="{fgid}MR" class="{frameCls}-mr {baseCls}-mr {baseCls}-{ui}-mr<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-mr</tpl>{frameElCls}" role="presentation"></tpl>', '<div id="{fgid}MC" class="{frameCls}-mc {baseCls}-mc {baseCls}-{ui}-mc<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-mc</tpl>{frameElCls}" role="presentation">', "{%this.applyRenderTpl(out, values)%}", "</div>", '<tpl if="right"></div></tpl>', '<tpl if="left"></div></tpl>', '<tpl if="bottom">', '<tpl if="left"><div id="{fgid}BL" class="{frameCls}-bl {baseCls}-bl {baseCls}-{ui}-bl<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-bl</tpl>{frameElCls}" role="presentation"></tpl>', '<tpl if="right"><div id="{fgid}BR" class="{frameCls}-br {baseCls}-br {baseCls}-{ui}-br<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-br</tpl>{frameElCls}" role="presentation"></tpl>', '<div id="{fgid}BC" class="{frameCls}-bc {baseCls}-bc {baseCls}-{ui}-bc<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-bc</tpl>{frameElCls}" role="presentation"></div>', '<tpl if="right"></div></tpl>', '<tpl if="left"></div></tpl>', "</tpl>", "{%this.renderDockedItems(out,values,1);%}"],
    frameTableTpl: ["{%this.renderDockedItems(out,values,0);%}", '<table id="{fgid}Table" class="', Ext.plainTableCls, '" cellpadding="0" role="presentation">', '<tbody role="presentation">', '<tpl if="top">', '<tr role="presentation">', '<tpl if="left"><td id="{fgid}TL" class="{frameCls}-tl {baseCls}-tl {baseCls}-{ui}-tl<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-tl</tpl>{frameElCls}" role="presentation"></td></tpl>', '<td id="{fgid}TC" class="{frameCls}-tc {baseCls}-tc {baseCls}-{ui}-tc<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-tc</tpl>{frameElCls}" role="presentation"></td>', '<tpl if="right"><td id="{fgid}TR" class="{frameCls}-tr {baseCls}-tr {baseCls}-{ui}-tr<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-tr</tpl>{frameElCls}" role="presentation"></td></tpl>', "</tr>", "</tpl>", '<tr role="presentation">', '<tpl if="left"><td id="{fgid}ML" class="{frameCls}-ml {baseCls}-ml {baseCls}-{ui}-ml<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-ml</tpl>{frameElCls}" role="presentation"></td></tpl>', '<td id="{fgid}MC" class="{frameCls}-mc {baseCls}-mc {baseCls}-{ui}-mc<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-mc</tpl>{frameElCls}" role="presentation">', "{%this.applyRenderTpl(out, values)%}", "</td>", '<tpl if="right"><td id="{fgid}MR" class="{frameCls}-mr {baseCls}-mr {baseCls}-{ui}-mr<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-mr</tpl>{frameElCls}" role="presentation"></td></tpl>', "</tr>", '<tpl if="bottom">', '<tr role="presentation">', '<tpl if="left"><td id="{fgid}BL" class="{frameCls}-bl {baseCls}-bl {baseCls}-{ui}-bl<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-bl</tpl>{frameElCls}" role="presentation"></td></tpl>', '<td id="{fgid}BC" class="{frameCls}-bc {baseCls}-bc {baseCls}-{ui}-bc<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-bc</tpl>{frameElCls}" role="presentation"></td>', '<tpl if="right"><td id="{fgid}BR" class="{frameCls}-br {baseCls}-br {baseCls}-{ui}-br<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-br</tpl>{frameElCls}" role="presentation"></td></tpl>', "</tr>", "</tpl>", "</tbody></table>", "{%this.renderDockedItems(out,values,1);%}"],
    afterRender: function() {
        var e = this,
        t = {},
        n = e.protoEl,
        r = e.el,
        i, s, o, u;
        e.finishRenderChildren();
        if (e.contentEl) {
            s = Ext.baseCSSPrefix;
            o = s + "hide-";
            u = Ext.get(e.contentEl);
            u.removeCls([s + "hidden", o + "display", o + "offsets", o + "nosize"]);
            e.getContentTarget().appendChild(u.dom)
        }
        n.writeTo(t);
        i = t.removed;
        if (i) {
            r.removeCls(i)
        }
        i = t.cls;
        if (i.length) {
            r.addCls(i)
        }
        i = t.style;
        if (t.style) {
            r.setStyle(i)
        }
        e.protoEl = null;
        if (!e.ownerCt) {
            e.updateLayout()
        }
    },
    afterFirstLayout: function(e, t) {
        var n = this,
        r = n.x,
        i = n.y,
        s, o, u, a, f = n.defaultAlign,
        l = n.alignOffset;
        if (!n.ownerLayout) {
            s = Ext.isDefined(r);
            o = Ext.isDefined(i)
        }
        if (n.floating && (!s || !o)) {
            if (n.floatParent) {
                u = n.floatParent.getTargetEl().getViewRegion();
                a = n.el.getAlignToXY(n.alignTarget || n.floatParent.getTargetEl(), f, l);
                u.x = a[0] - u.x;
                u.y = a[1] - u.y
            } else {
                a = n.el.getAlignToXY(n.alignTarget || n.container, f, l);
                u = n.container.translateXY(a[0], a[1])
            }
            r = s ? r: u.x;
            i = o ? i: u.y;
            s = o = true
        }
        if (s || o) {
            n.setPosition(r, i)
        }
        n.onBoxReady(e, t)
    },
    applyRenderSelectors: function() {
        var e = this,
        t = e.renderSelectors,
        n = e.el,
        r = n.dom,
        i;
        e.applyChildEls(n);
        if (t) {
            for (i in t) {
                if (t.hasOwnProperty(i) && t[i]) {
                    e[i] = Ext.get(Ext.DomQuery.selectNode(t[i], r))
                }
            }
        }
    },
    beforeRender: function() {
        var e = this,
        t = e.getTargetEl(),
        n = e.getOverflowEl(),
        r = e.getComponentLayout(),
        i = e.getOverflowStyle();
        e.frame = e.frame || e.alwaysFramed;
        if (!r.initialized) {
            r.initLayout()
        }
        if (n) {
            n.setStyle(i);
            e.overflowStyleSet = true
        }
        e.setUI(e.ui);
        if (e.disabled) {
            e.disable(true)
        }
    },
    doApplyRenderTpl: function(e, t) {
        var n = t.$comp,
        r;
        if (!n.rendered) {
            r = n.initRenderTpl();
            r.applyOut(t.renderData, e)
        }
    },
    doAutoRender: function() {
        var e = this;
        if (!e.rendered) {
            if (e.floating) {
                e.render(e.renderTo || document.body)
            } else {
                e.render(Ext.isBoolean(e.autoRender) ? Ext.getBody() : e.autoRender)
            }
        }
    },
    doRenderContent: function(e, t) {
        var n = t.$comp;
        if (n.html) {
            Ext.DomHelper.generateMarkup(n.html, e);
            delete n.html
        }
        if (n.tpl) {
            if (!n.tpl.isTemplate) {
                n.tpl = new Ext.XTemplate(n.tpl)
            }
            if (n.data) {
                n.tpl.applyOut(n.data, e);
                delete n.data
            }
        }
    },
    doRenderFramingDockedItems: function(e, t, n) {
        var r = t.$comp;
        if (!r.rendered && r.doRenderDockedItems) {
            t.renderData.$skipDockedItems = true;
            r.doRenderDockedItems.call(this, e, t, n)
        }
    },
    finishRender: function(e) {
        var t = this,
        n, r, i;
        if (!t.el || t.$pid) {
            if (t.container) {
                i = t.container.getById(t.id, true)
            } else {
                i = Ext.getDom(t.id)
            }
            if (!t.el) {
                t.wrapPrimaryEl(i)
            } else {
                delete t.$pid;
                if (!t.el.dom) {
                    t.wrapPrimaryEl(t.el)
                }
                i.parentNode.insertBefore(t.el.dom, i);
                Ext.removeNode(i)
            }
        } else {
            if (!t.rendering) {
                n = t.initRenderTpl();
                if (n) {
                    r = t.initRenderData();
                    n.insertFirst(t.getTargetEl(), r)
                }
            }
        }
        if (!t.container) {
            t.container = Ext.get(t.el.dom.parentNode)
        }
        if (t.ctCls) {
            t.container.addCls(t.ctCls)
        }
        t.onRender(t.container, e);
        if (!t.overflowStyleSet) {
            t.getOverflowEl().setStyle(t.getOverflowStyle())
        }
        t.el.setVisibilityMode(Ext.Element[t.hideMode.toUpperCase()]);
        if (t.overCls) {
            t.el.hover(t.addOverCls, t.removeOverCls, t)
        }
        if (t.hasListeners.render) {
            t.fireEvent("render", t)
        }
        t.afterRender();
        if (t.hasListeners.afterrender) {
            t.fireEvent("afterrender", t)
        }
        t.initEvents();
        if (t.hidden) {
            t.el.hide()
        }
    },
    finishRenderChildren: function() {
        var e = this.getComponentLayout();
        e.finishRender()
    },
    getElConfig: function() {
        var e = this,
        t = e.autoEl,
        n = e.getFrameInfo(),
        r = {
            tag: "div",
            tpl: n ? e.initFramingTpl(n.table) : e.initRenderTpl()
        },
        i = e.protoEl,
        s,
        o,
        u,
        a,
        f,
        l;
        e.initStyles(i);
        i.writeTo(r);
        i.flush();
        if (Ext.isString(t)) {
            r.tag = t
        } else {
            Ext.apply(r, t)
        }
        r.id = e.id;
        if (r.tpl) {
            if (n) {
                o = e.frameElNames;
                u = o.length;
                r.tplData = l = e.getFrameRenderData();
                l.renderData = e.initRenderData();
                f = l.fgid;
                for (s = 0; s < u; s++) {
                    a = o[s];
                    e.addChildEls({
                        name: "frame" + a,
                        id: f + a
                    })
                }
                e.addChildEls({
                    name: "frameBody",
                    id: f + "MC"
                })
            } else {
                r.tplData = e.initRenderData()
            }
        }
        return r
    },
    initFramingTpl: function(e) {
        var t = this.getFrameTpl(e);
        if (t && !t.applyRenderTpl) {
            this.setupFramingTpl(t)
        }
        return t
    },
    setupFramingTpl: function(e) {
        e.applyRenderTpl = this.doApplyRenderTpl;
        e.renderDockedItems = this.doRenderFramingDockedItems
    },
    getInsertPosition: function(e) {
        if (e !== undefined) {
            if (Ext.isNumber(e)) {
                e = this.container.dom.childNodes[e]
            } else {
                e = Ext.getDom(e)
            }
        }
        return e
    },
    getRenderTree: function() {
        var e = this;
        if (!e.hasListeners.beforerender || e.fireEvent("beforerender", e) !== false) {
            e.beforeRender();
            e.rendering = true;
            if (e.el) {
                return {
                    tag: "div",
                    role: "presentation",
                    id: e.$pid = Ext.id()
                }
            }
            return e.getElConfig()
        }
        return null
    },
    initContainer: function(e) {
        var t = this;
        if (!e && t.el) {
            e = t.el.dom.parentNode;
            t.allowDomMove = false
        }
        t.container = e.dom ? e: Ext.get(e);
        return t.container
    },
    initRenderData: function() {
        var e = this;
        return Ext.apply({
            $comp: e,
            id: e.id,
            ui: e.ui,
            uiCls: e.uiCls,
            baseCls: e.baseCls,
            componentCls: e.componentCls,
            frame: e.frame,
            role: e.ariaRole,
            childElCls: ""
        },
        e.renderData)
    },
    initRenderTpl: function() {
        var e = this.getTpl("renderTpl");
        if (e && !e.renderContent) {
            this.setupRenderTpl(e)
        }
        return e
    },
    onRender: function(e, t) {
        var n = this,
        r = n.x,
        i = n.y,
        s = null,
        o, u, a = n.el;
        n.applyRenderSelectors();
        n.rendering = null;
        n.rendered = true;
        if (r != null) {
            s = {
                x: r
            }
        }
        if (i != null) { (s = s || {}).y = i
        }
        if (!n.getFrameInfo() && Ext.isBorderBox) {
            o = n.width;
            u = n.height;
            if (typeof o === "number") {
                s = s || {};
                s.width = o
            }
            if (typeof u === "number") {
                s = s || {};
                s.height = u
            }
        }
        n.lastBox = a.lastBox = s
    },
    render: function(e, t) {
        var n = this,
        r = n.el && (n.el = Ext.get(n.el)),
        i,
        s,
        o;
        Ext.suspendLayouts();
        e = n.initContainer(e);
        o = n.getInsertPosition(t);
        if (!r) {
            s = n.getRenderTree();
            if (n.ownerLayout && n.ownerLayout.transformItemRenderTree) {
                s = n.ownerLayout.transformItemRenderTree(s)
            }
            if (s) {
                if (o) {
                    r = Ext.DomHelper.insertBefore(o, s)
                } else {
                    r = Ext.DomHelper.append(e, s)
                }
                n.wrapPrimaryEl(r)
            }
        } else {
            if (!n.hasListeners.beforerender || n.fireEvent("beforerender", n) !== false) {
                n.beforeRender();
                n.initStyles(r);
                if (n.allowDomMove !== false) {
                    if (o) {
                        e.dom.insertBefore(r.dom, o)
                    } else {
                        e.dom.appendChild(r.dom)
                    }
                }
            } else {
                i = true
            }
        }
        if (r && !i) {
            n.finishRender(t)
        }
        Ext.resumeLayouts(!n.hidden && !e.isDetachedBody)
    },
    ensureAttachedToBody: function(e) {
        var t = this,
        n;
        while (t.ownerCt) {
            t = t.ownerCt
        }
        if (t.container.isDetachedBody) {
            t.container = n = Ext.getBody();
            n.appendChild(t.el.dom);
            if (e) {
                t.updateLayout()
            }
            if (typeof t.x == "number" || typeof t.y == "number") {
                t.setPosition(t.x, t.y)
            }
        }
    },
    setupRenderTpl: function(e) {
        e.renderBody = e.renderContent = this.doRenderContent
    },
    wrapPrimaryEl: function(e) {
        this.el = Ext.get(e, true)
    },
    initFrame: function() {
        if (Ext.supports.CSS3BorderRadius || !this.frame) {
            return
        }
        var e = this,
        t = e.getFrameInfo(),
        n,
        r,
        i = e.frameElNames,
        s = i.length,
        o,
        u,
        a;
        if (t) {
            n = e.getFrameTpl(t.table);
            u = e.getFrameRenderData();
            r = u.fgid;
            n.insertFirst(e.el, u);
            e.frameBody = e.el.down("." + e.frameCls + "-mc");
            e.removeChildEls(function(t) {
                return t.id && e.frameIdRegex.test(t.id)
            });
            for (o = 0; o < s; o++) {
                a = i[o];
                e["frame" + a] = e.el.getById(r + a)
            }
        }
    },
    getFrameRenderData: function() {
        var e = this,
        t = e.frameSize,
        n = (e.frameGenId || 0) + 1;
        e.frameGenId = n;
        return {
            $comp: e,
            fgid: e.id + "-frame" + n,
            ui: e.ui,
            uiCls: e.uiCls,
            frameCls: e.frameCls,
            baseCls: e.baseCls,
            top: !!t.top,
            left: !!t.left,
            right: !!t.right,
            bottom: !!t.bottom,
            frameElCls: ""
        }
    },
    updateFrame: function() {
        if (Ext.supports.CSS3BorderRadius || !this.frame) {
            return
        }
        var e = this,
        t = e.frameSize && e.frameSize.table,
        n = e.frameTL,
        r = e.frameBL,
        i = e.frameML,
        s = e.frameMC,
        o;
        e.initFrame();
        if (s) {
            if (e.frame) {
                o = e.frameMC.dom.className;
                s.insertAfter(e.frameMC);
                e.frameMC.remove();
                e.frameBody = e.frameMC = s;
                s.dom.className = o;
                if (t) {
                    e.el.query("> table")[1].remove()
                } else {
                    if (n) {
                        n.remove()
                    }
                    if (r) {
                        r.remove()
                    }
                    if (i) {
                        i.remove()
                    }
                }
            }
        } else {
            if (e.frame) {
                e.applyRenderSelectors()
            }
        }
    },
    getFrameInfo: function() {
        if (Ext.supports.CSS3BorderRadius || !this.frame) {
            return false
        }
        var e = this,
        t = e.frameInfoCache,
        n = e.getFramingInfoCls() + "-frameInfo",
        r = t[n],
        i = Math.max,
        s,
        o,
        u,
        a,
        f,
        l,
        c,
        h,
        p,
        d,
        v,
        m,
        g,
        y,
        b,
        w,
        E,
        S,
        x;
        if (r == null) {
            s = Ext.fly(e.getStyleProxy(n), "frame-style-el");
            u = s.getStyle("font-family");
            if (u) {
                u = u.split("-");
                w = parseInt(u[1], 10);
                E = parseInt(u[2], 10);
                S = parseInt(u[3], 10);
                x = parseInt(u[4], 10);
                h = parseInt(u[5], 10);
                p = parseInt(u[6], 10);
                d = parseInt(u[7], 10);
                v = parseInt(u[8], 10);
                m = parseInt(u[9], 10);
                g = parseInt(u[10], 10);
                y = parseInt(u[11], 10);
                b = parseInt(u[12], 10);
                a = i(h, i(w, E));
                f = i(p, i(E, S));
                l = i(d, i(x, S));
                c = i(v, i(w, x));
                r = {
                    table: u[0].charAt(0) === "t",
                    vertical: u[0].charAt(1) === "v",
                    top: a,
                    right: f,
                    bottom: l,
                    left: c,
                    width: c + f,
                    height: a + l,
                    maxWidth: i(a, f, l, c),
                    border: {
                        top: h,
                        right: p,
                        bottom: d,
                        left: v,
                        width: v + p,
                        height: h + d
                    },
                    padding: {
                        top: m,
                        right: g,
                        bottom: y,
                        left: b,
                        width: b + g,
                        height: m + y
                    },
                    radius: {
                        tl: w,
                        tr: E,
                        br: S,
                        bl: x
                    }
                }
            } else {
                r = false
            }
            t[n] = r
        }
        e.frame = !!r;
        e.frameSize = r;
        return r
    },
    getFramingInfoCls: function() {
        return this.baseCls + "-" + this.ui
    },
    getStyleProxy: function(e) {
        var t = this.styleProxyEl || (Ext.AbstractComponent.prototype.styleProxyEl = Ext.getBody().createChild({
            role: "presentation",
            style: {
                position: "absolute",
                top: "-10000px"
            }
        },
        null, true));
        t.className = e;
        return t
    },
    getFrameTpl: function(e) {
        return this.getTpl(e ? "frameTableTpl": "frameTpl")
    },
    frameInfoCache: {}
});
Ext.define("Ext.state.Provider", {
    mixins: {
        observable: Ext.util.Observable
    },
    prefix: "ext-",
    constructor: function(e) {
        e = e || {};
        var t = this;
        Ext.apply(t, e);
        t.addEvents("statechange");
        t.state = {};
        t.mixins.observable.constructor.call(t)
    },
    get: function(e, t) {
        return typeof this.state[e] == "undefined" ? t: this.state[e]
    },
    clear: function(e) {
        var t = this;
        delete t.state[e];
        t.fireEvent("statechange", t, e, null)
    },
    set: function(e, t) {
        var n = this;
        n.state[e] = t;
        n.fireEvent("statechange", n, e, t)
    },
    decodeValue: function(e) {
        var t = this,
        n = /^(a|n|d|b|s|o|e)\:(.*)$/,
        r = n.exec(unescape(e)),
        i,
        s,
        o,
        u,
        a,
        f;
        if (!r || !r[1]) {
            return
        }
        s = r[1];
        e = r[2];
        switch (s) {
        case "e":
            return null;
        case "n":
            return parseFloat(e);
        case "d":
            return new Date(Date.parse(e));
        case "b":
            return e == "1";
        case "a":
            i = [];
            if (e != "") {
                u = e.split("^");
                a = u.length;
                for (f = 0; f < a; f++) {
                    e = u[f];
                    i.push(t.decodeValue(e))
                }
            }
            return i;
        case "o":
            i = {};
            if (e != "") {
                u = e.split("^");
                a = u.length;
                for (f = 0; f < a; f++) {
                    e = u[f];
                    o = e.split("=");
                    i[o[0]] = t.decodeValue(o[1])
                }
            }
            return i;
        default:
            return e
        }
    },
    encodeValue: function(e) {
        var t = "",
        n = 0,
        r, i, s;
        if (e == null) {
            return "e:1"
        } else {
            if (typeof e == "number") {
                r = "n:" + e
            } else {
                if (typeof e == "boolean") {
                    r = "b:" + (e ? "1": "0")
                } else {
                    if (Ext.isDate(e)) {
                        r = "d:" + e.toUTCString()
                    } else {
                        if (Ext.isArray(e)) {
                            for (i = e.length; n < i; n++) {
                                t += this.encodeValue(e[n]);
                                if (n != i - 1) {
                                    t += "^"
                                }
                            }
                            r = "a:" + t
                        } else {
                            if (typeof e == "object") {
                                for (s in e) {
                                    if (typeof e[s] != "function" && e[s] !== undefined) {
                                        t += s + "=" + this.encodeValue(e[s]) + "^"
                                    }
                                }
                                r = "o:" + t.substring(0, t.length - 1)
                            } else {
                                r = "s:" + e
                            }
                        }
                    }
                }
            }
        }
        return escape(r)
    }
});
Ext.define("Ext.state.Manager", {
    singleton: true,
    constructor: function() {
        this.provider = new Ext.state.Provider
    },
    setProvider: function(e) {
        this.provider = e
    },
    get: function(e, t) {
        return this.provider.get(e, t)
    },
    set: function(e, t) {
        this.provider.set(e, t)
    },
    clear: function(e) {
        this.provider.clear(e)
    },
    getProvider: function() {
        return this.provider
    }
});
Ext.define("Ext.state.Stateful", {
    mixins: {
        observable: Ext.util.Observable
    },
    stateful: false,
    saveDelay: 100,
    constructor: function(e) {
        var t = this;
        e = e || {};
        if (e.stateful !== undefined) {
            t.stateful = e.stateful
        }
        if (e.saveDelay !== undefined) {
            t.saveDelay = e.saveDelay
        }
        t.stateId = t.stateId || e.stateId;
        if (!t.stateEvents) {
            t.stateEvents = []
        }
        if (e.stateEvents) {
            t.stateEvents.concat(e.stateEvents)
        }
        this.addEvents("beforestaterestore", "staterestore", "beforestatesave", "statesave");
        t.mixins.observable.constructor.call(t);
        if (t.stateful !== false) {
            t.addStateEvents(t.stateEvents);
            t.initState()
        }
    },
    addStateEvents: function(e) {
        var t = this,
        n, r, i, s;
        if (t.stateful && t.getStateId()) {
            s = typeof e == "string" ? arguments: e;
            i = t.stateEventsByName || (t.stateEventsByName = {});
            for (n = s.length; n--;) {
                r = s[n];
                if (!i[r]) {
                    i[r] = 1;
                    t.on(r, t.onStateChange, t)
                }
            }
        }
    },
    onStateChange: function() {
        var e = this,
        t = e.saveDelay,
        n, r;
        if (!e.stateful) {
            return
        }
        if (t) {
            if (!e.stateTask) {
                n = Ext.state.Stateful;
                r = n.runner || (n.runner = new Ext.util.TaskRunner);
                e.stateTask = r.newTask({
                    run: e.saveState,
                    scope: e,
                    interval: t,
                    repeat: 1
                })
            }
            e.stateTask.start()
        } else {
            e.saveState()
        }
    },
    saveState: function() {
        var e = this,
        t = e.stateful && e.getStateId(),
        n = e.hasListeners,
        r;
        if (t) {
            r = e.getState() || {};
            if (!n.beforestatesave || e.fireEvent("beforestatesave", e, r) !== false) {
                Ext.state.Manager.set(t, r);
                if (n.statesave) {
                    e.fireEvent("statesave", e, r)
                }
            }
        }
    },
    getState: function() {
        return null
    },
    applyState: function(e) {
        if (e) {
            Ext.apply(this, e)
        }
    },
    getStateId: function() {
        var e = this;
        return e.stateId || (e.autoGenId ? null: e.id)
    },
    initState: function() {
        var e = this,
        t = e.stateful && e.getStateId(),
        n = e.hasListeners,
        r;
        if (t) {
            r = Ext.state.Manager.get(t);
            if (r) {
                r = Ext.apply({},
                r);
                if (!n.beforestaterestore || e.fireEvent("beforestaterestore", e, r) !== false) {
                    e.applyState(r);
                    if (n.staterestore) {
                        e.fireEvent("staterestore", e, r)
                    }
                }
            }
        }
    },
    savePropToState: function(e, t, n) {
        var r = this,
        i = r[e],
        s = r.initialConfig;
        if (r.hasOwnProperty(e)) {
            if (!s || s[e] !== i) {
                if (t) {
                    t[n || e] = i
                }
                return true
            }
        }
        return false
    },
    savePropsToState: function(e, t) {
        var n = this,
        r, i;
        if (typeof e == "string") {
            n.savePropToState(e, t)
        } else {
            for (r = 0, i = e.length; r < i; ++r) {
                n.savePropToState(e[r], t)
            }
        }
        return t
    },
    destroy: function() {
        var e = this,
        t = e.stateTask;
        if (t) {
            t.destroy();
            e.stateTask = null
        }
        e.clearListeners()
    }
});
Ext.define("Ext.AbstractComponent", {
    mixins: {
        positionable: Ext.util.Positionable,
        observable: Ext.util.Observable,
        animate: Ext.util.Animate,
        elementCt: Ext.util.ElementContainer,
        renderable: Ext.util.Renderable,
        state: Ext.state.Stateful
    },
    statics: {
        AUTO_ID: 1e3,
        pendingLayouts: null,
        layoutSuspendCount: 0,
        cancelLayout: function(e, t) {
            var n = this.runningLayoutContext || this.pendingLayouts;
            if (n) {
                n.cancelComponent(e, false, t)
            }
        },
        findComponentByElement: function(e) {
            var t = document.body,
            n = e,
            r;
            while (n && n.nodeType === 1 && n !== t) {
                r = Ext.getCmp(n.id);
                if (r) {
                    return r
                }
                n = n.parentNode
            }
            return null
        },
        getComponentByElement: function(e) {
            var t = Ext.Component.componentIdAttribute,
            n;
            e = Ext.fly(e);
            if (!e) {
                return null
            }
            n = e.getAttribute(t);
            if (n) {
                return Ext.getCmp(n)
            } else {
                return Ext.Component.findComponentByElement(e.dom)
            }
        },
        flushLayouts: function() {
            var e = this,
            t = e.pendingLayouts;
            if (t && t.invalidQueue.length) {
                e.pendingLayouts = null;
                e.runningLayoutContext = t;
                Ext.override(t, {
                    runComplete: function() {
                        e.runningLayoutContext = null;
                        var t = this.callParent();
                        if (Ext.globalEvents.hasListeners.afterlayout) {
                            Ext.globalEvents.fireEvent("afterlayout")
                        }
                        return t
                    }
                });
                t.run()
            }
        },
        resumeLayouts: function(e) {
            if (this.layoutSuspendCount && !--this.layoutSuspendCount) {
                if (e) {
                    this.flushLayouts()
                }
                if (Ext.globalEvents.hasListeners.resumelayouts) {
                    Ext.globalEvents.fireEvent("resumelayouts")
                }
            }
        },
        suspendLayouts: function() {++this.layoutSuspendCount
        },
        updateLayout: function(e, t) {
            var n = this,
            r = n.runningLayoutContext,
            i;
            if (r) {
                r.queueInvalidate(e)
            } else {
                i = n.pendingLayouts || (n.pendingLayouts = new Ext.layout.Context);
                i.queueInvalidate(e);
                if (!t && !n.layoutSuspendCount && !e.isLayoutSuspended()) {
                    n.flushLayouts()
                }
            }
        }
    },
    isComponent: true,
    getAutoId: function() {
        this.autoGenId = true;
        return++Ext.AbstractComponent.AUTO_ID
    },
    deferLayouts: false,
    autoGenId: false,
    renderTpl: "{%this.renderContent(out,values)%}",
    maskElement: null,
    frameSize: null,
    tplWriteMode: "overwrite",
    baseCls: Ext.baseCSSPrefix + "component",
    disabledCls: Ext.baseCSSPrefix + "item-disabled",
    ui: "default",
    uiCls: [],
    hidden: false,
    disabled: false,
    disabledRe: /^(?:button|input|select|textarea|optgroup|option|fieldset)$/i,
    nonMaskableRe: function() {
        var e = ["input", "select", "textarea", "optgroup", "option", "table"];
        if (Ext.isIE9m && !(Ext.isIE9 && !Ext.isIEQuirks)) {
            e.push("p")
        }
        return new RegExp("^(?:" + e.join("|") + ")$", "i")
    } (),
    draggable: false,
    floating: false,
    hideMode: "display",
    autoShow: false,
    autoRender: false,
    allowDomMove: true,
    rendered: false,
    componentLayoutCounter: 0,
    shrinkWrap: 2,
    weight: 0,
    maskOnDisable: true,
    _isLayoutRoot: false,
    contentPaddingProperty: "padding",
    horizontalPosProp: "left",
    borderBoxCls: Ext.baseCSSPrefix + "border-box",
    rootCls: Ext.baseCSSPrefix + "body",
    constructor: function(e) {
        var t = this,
        n, r, i;
        if (e) {
            Ext.apply(t, e);
            i = t.xhooks;
            if (i) {
                delete t.xhooks;
                Ext.override(t, i)
            }
        } else {
            e = {}
        }
        t.initialConfig = e;
        t.mixins.elementCt.constructor.call(t);
        t.addEvents("beforeactivate", "activate", "beforedeactivate", "deactivate", "added", "disable", "enable", "beforeshow", "show", "beforehide", "hide", "removed", "beforerender", "render", "afterrender", "boxready", "beforedestroy", "destroy", "resize", "move", "focus", "blur");
        t.getId();
        t.setupProtoEl();
        if (t.cls) {
            t.initialCls = t.cls;
            t.protoEl.addCls(t.cls)
        }
        if (t.style) {
            t.initialStyle = t.style;
            t.protoEl.setStyle(t.style)
        }
        t.renderData = t.renderData || {};
        t.renderSelectors = t.renderSelectors || {};
        if (!t.hasListeners) {
            t.hasListeners = new t.HasListeners
        }
        t.initComponent();
        Ext.ComponentManager.register(t);
        t.mixins.observable.constructor.call(t);
        t.mixins.state.constructor.call(t, e);
        this.addStateEvents("resize");
        if (t.plugins) {
            for (n = 0, r = t.plugins.length; n < r; n++) {
                t.plugins[n] = t.initPlugin(t.plugins[n])
            }
        }
        t.loader = t.getLoader();
        if (t.renderTo) {
            t.render(t.renderTo)
        }
        if (t.autoShow && !t.isContained) {
            t.show()
        }
    },
    initComponent: function() {
        var e = this;
        if (e.plugins && !e.plugins.processed) {
            e.plugins = e.constructPlugins()
        }
        e.setSize(e.width, e.height)
    },
    getState: function() {
        var e = this,
        t = null,
        n = e.getSizeModel();
        if (n.width.configured) {
            t = e.addPropertyToState(t, "width")
        }
        if (n.height.configured) {
            t = e.addPropertyToState(t, "height")
        }
        return t
    },
    addPropertyToState: function(e, t, n) {
        var r = this,
        i = arguments.length;
        if (i == 3 || r.hasOwnProperty(t)) {
            if (i < 3) {
                n = r[t]
            }
            if (n !== r.initialConfig[t]) { (e || (e = {}))[t] = n
            }
        }
        return e
    },
    show: Ext.emptyFn,
    animate: function(e) {
        var t = this,
        n, r, i, s, o, u, a, f, l, c, h, p, d, v, m, g;
        e = e || {};
        o = e.to || {};
        if (Ext.fx.Manager.hasFxBlock(t.id)) {
            return t
        }
        n = Ext.isDefined(o.width);
        if (n) {
            s = Ext.Number.constrain(o.width, t.minWidth, t.maxWidth)
        }
        r = Ext.isDefined(o.height);
        if (r) {
            i = Ext.Number.constrain(o.height, t.minHeight, t.maxHeight)
        }
        if (!e.dynamic && (n || r)) {
            f = (e.from ? e.from.width: undefined) || t.getWidth();
            l = f;
            c = (e.from ? e.from.height: undefined) || t.getHeight();
            h = c;
            p = false;
            if (r && i > c) {
                h = i;
                p = true
            }
            if (n && s > f) {
                l = s;
                p = true
            }
            if (r || n) {
                g = t.el.getStyle("overflow");
                if (g !== "hidden") {
                    t.el.setStyle("overflow", "hidden")
                }
            }
            if (p) {
                u = !Ext.isNumber(t.width);
                a = !Ext.isNumber(t.height);
                t.setSize(l, h);
                t.el.setSize(f, c);
                if (u) {
                    delete t.width
                }
                if (a) {
                    delete t.height
                }
            }
            if (n) {
                o.width = s
            }
            if (r) {
                o.height = i
            }
        }
        d = t.constrain;
        v = t.constrainHeader;
        if (d || v) {
            t.constrain = t.constrainHeader = false;
            m = e.callback;
            e.callback = function() {
                t.constrain = d;
                t.constrainHeader = v;
                if (m) {
                    m.call(e.scope || t, arguments)
                }
                if (g !== "hidden") {
                    t.el.setStyle("overflow", g)
                }
            }
        }
        return t.mixins.animate.animate.apply(t, arguments)
    },
    setHiddenState: function(e) {
        var t = this.getHierarchyState();
        this.hidden = e;
        if (e) {
            t.hidden = true
        } else {
            delete t.hidden
        }
    },
    onHide: function() {
        if (this.ownerLayout) {
            this.updateLayout({
                isRoot: false
            })
        }
    },
    onShow: function() {
        this.updateLayout({
            isRoot: false
        })
    },
    constructPlugin: function(e) {
        var t = this;
        if (typeof e == "string") {
            e = Ext.PluginManager.create({},
            e, t)
        } else {
            e = Ext.PluginManager.create(e, null, t)
        }
        return e
    },
    constructPlugins: function() {
        var e = this,
        t = e.plugins,
        n, r, i;
        if (t) {
            n = [];
            n.processed = true;
            if (!Ext.isArray(t)) {
                t = [t]
            }
            for (r = 0, i = t.length; r < i; r++) {
                n[r] = e.constructPlugin(t[r])
            }
        }
        e.pluginsInitialized = true;
        return n
    },
    initPlugin: function(e) {
        e.init(this);
        return e
    },
    addPlugin: function(e) {
        var t = this;
        e = t.constructPlugin(e);
        if (t.plugins) {
            t.plugins.push(e)
        } else {
            t.plugins = [e]
        }
        if (t.pluginsInitialized) {
            t.initPlugin(e)
        }
        return e
    },
    removePlugin: function(e) {
        Ext.Array.remove(this.plugins, e);
        e.destroy()
    },
    findPlugin: function(e) {
        var t, n = this.plugins,
        r = n && n.length;
        for (t = 0; t < r; t++) {
            if (n[t].ptype === e) {
                return n[t]
            }
        }
    },
    getPlugin: function(e) {
        var t, n = this.plugins,
        r = n && n.length;
        for (t = 0; t < r; t++) {
            if (n[t].pluginId === e) {
                return n[t]
            }
        }
    },
    beforeLayout: Ext.emptyFn,
    registerFloatingItem: function(e) {
        var t = this;
        if (!t.floatingDescendants) {
            t.floatingDescendants = new Ext.ZIndexManager(t)
        }
        t.floatingDescendants.register(e)
    },
    unregisterFloatingItem: function(e) {
        var t = this;
        if (t.floatingDescendants) {
            t.floatingDescendants.unregister(e)
        }
    },
    layoutSuspendCount: 0,
    suspendLayouts: function() {
        var e = this;
        if (!e.rendered) {
            return
        }
        if (++e.layoutSuspendCount === 1) {
            e.suspendLayout = true
        }
    },
    resumeLayouts: function(e) {
        var t = this;
        if (!t.rendered) {
            return
        }
        if (t.layoutSuspendCount && !--t.layoutSuspendCount) {
            t.suspendLayout = false;
            if (e && !t.isLayoutSuspended()) {
                t.updateLayout(e)
            }
        }
    },
    setupProtoEl: function() {
        var e = this.initCls();
        this.protoEl = new Ext.util.ProtoElement({
            cls: e.join(" ")
        })
    },
    initCls: function() {
        var e = this,
        t = [e.baseCls, e.getComponentLayout().targetCls];
        if (Ext.isDefined(e.cmpCls)) {
            if (Ext.isDefined(Ext.global.console)) {
                Ext.global.console.warn("Ext.Component: cmpCls has been deprecated. Please use componentCls.")
            }
            e.componentCls = e.cmpCls;
            delete e.cmpCls
        }
        if (e.componentCls) {
            t.push(e.componentCls)
        } else {
            e.componentCls = e.baseCls
        }
        return t
    },
    setUI: function(e) {
        var t = this,
        n = t.uiCls,
        r = t.activeUI,
        i;
        if (e === r) {
            return
        }
        if (r) {
            i = t.removeClsWithUI(n, true);
            if (i.length) {
                t.removeCls(i)
            }
            t.removeUIFromElement()
        } else {
            t.uiCls = []
        }
        t.ui = e;
        t.activeUI = e;
        t.addUIToElement();
        i = t.addClsWithUI(n, true);
        if (i.length) {
            t.addCls(i)
        }
        if (t.rendered) {
            t.updateLayout()
        }
    },
    addClsWithUI: function(e, t) {
        var n = this,
        r = [],
        i = 0,
        s = n.uiCls = Ext.Array.clone(n.uiCls),
        o = n.activeUI,
        u,
        a;
        if (typeof e === "string") {
            e = e.indexOf(" ") < 0 ? [e] : Ext.String.splitWords(e)
        }
        u = e.length;
        for (; i < u; i++) {
            a = e[i];
            if (a && !n.hasUICls(a)) {
                s.push(a);
                if (o) {
                    r = r.concat(n.addUIClsToElement(a))
                }
            }
        }
        if (t !== true && o) {
            n.addCls(r)
        }
        return r
    },
    removeClsWithUI: function(e, t) {
        var n = this,
        r = [],
        i = 0,
        s = Ext.Array,
        o = s.remove,
        u = n.uiCls = s.clone(n.uiCls),
        a = n.activeUI,
        f,
        l;
        if (typeof e === "string") {
            e = e.indexOf(" ") < 0 ? [e] : Ext.String.splitWords(e)
        }
        f = e.length;
        for (i = 0; i < f; i++) {
            l = e[i];
            if (l && n.hasUICls(l)) {
                o(u, l);
                if (a) {
                    r = r.concat(n.removeUIClsFromElement(l))
                }
            }
        }
        if (t !== true && a) {
            n.removeCls(r)
        }
        return r
    },
    hasUICls: function(e) {
        var t = this,
        n = t.uiCls || [];
        return Ext.Array.contains(n, e)
    },
    frameElementsArray: ["tl", "tc", "tr", "ml", "mc", "mr", "bl", "bc", "br"],
    addUIClsToElement: function(e) {
        var t = this,
        n = t.baseCls + "-" + t.ui + "-" + e,
        r = [Ext.baseCSSPrefix + e, t.baseCls + "-" + e, n],
        i,
        s,
        o,
        u,
        a;
        if (t.rendered && t.frame && !Ext.supports.CSS3BorderRadius) {
            i = t.frameElementsArray;
            s = i.length;
            for (o = 0; o < s; o++) {
                a = i[o];
                u = t["frame" + a.toUpperCase()];
                if (u) {
                    u.addCls(n + "-" + a)
                }
            }
        }
        return r
    },
    removeUIClsFromElement: function(e) {
        var t = this,
        n = t.baseCls + "-" + t.ui + "-" + e,
        r = [Ext.baseCSSPrefix + e, t.baseCls + "-" + e, n],
        i,
        s,
        o,
        u,
        a;
        if (t.rendered && t.frame && !Ext.supports.CSS3BorderRadius) {
            i = t.frameElementsArray;
            s = i.length;
            for (o = 0; o < s; o++) {
                a = i[o];
                u = t["frame" + a.toUpperCase()];
                if (u) {
                    u.removeCls(n + "-" + a)
                }
            }
        }
        return r
    },
    addUIToElement: function() {
        var e = this,
        t = e.baseCls + "-" + e.ui,
        n, r, i, s, o;
        e.addCls(t);
        if (e.rendered && e.frame && !Ext.supports.CSS3BorderRadius) {
            n = e.frameElementsArray;
            r = n.length;
            for (i = 0; i < r; i++) {
                o = n[i];
                s = e["frame" + o.toUpperCase()];
                if (s) {
                    s.addCls(t + "-" + o)
                }
            }
        }
    },
    removeUIFromElement: function() {
        var e = this,
        t = e.baseCls + "-" + e.ui,
        n, r, i, s, o;
        e.removeCls(t);
        if (e.rendered && e.frame && !Ext.supports.CSS3BorderRadius) {
            n = e.frameElementsArray;
            r = n.length;
            for (i = 0; i < r; i++) {
                o = n[i];
                s = e["frame" + o.toUpperCase()];
                if (s) {
                    s.removeCls(t + "-" + o)
                }
            }
        }
    },
    getTpl: function(e) {
        return Ext.XTemplate.getTpl(this, e)
    },
    initStyles: function(e) {
        var t = this,
        n = Ext.Element,
        r = t.margin,
        i = t.border,
        s = t.cls,
        o = t.style,
        u = t.x,
        a = t.y,
        f, l;
        t.initPadding(e);
        if (r != null) {
            e.setStyle("margin", this.unitizeBox(r === true ? 5 : r))
        }
        if (i != null) {
            t.setBorder(i, e)
        }
        if (s && s != t.initialCls) {
            e.addCls(s);
            t.cls = t.initialCls = null
        }
        if (o && o != t.initialStyle) {
            e.setStyle(o);
            t.style = t.initialStyle = null
        }
        if (u != null) {
            e.setStyle(t.horizontalPosProp, typeof u == "number" ? u + "px": u)
        }
        if (a != null) {
            e.setStyle("top", typeof a == "number" ? a + "px": a)
        }
        if (!t.ownerCt || t.floating) {
            if (Ext.scopeCss) {
                e.addCls(t.rootCls)
            }
            if (Ext.isBorderBox) {
                e.addCls(t.borderBoxCls)
            }
        }
        if (!t.getFrameInfo()) {
            f = t.width;
            l = t.height;
            if (f != null) {
                if (typeof f === "number") {
                    if (Ext.isBorderBox) {
                        e.setStyle("width", f + "px")
                    }
                } else {
                    e.setStyle("width", f)
                }
            }
            if (l != null) {
                if (typeof l === "number") {
                    if (Ext.isBorderBox) {
                        e.setStyle("height", l + "px")
                    }
                } else {
                    e.setStyle("height", l)
                }
            }
        }
    },
    initPadding: function(e) {
        var t = this,
        n = t.padding;
        if (n != null) {
            if (t.layout && t.layout.managePadding && t.contentPaddingProperty === "padding") {
                e.setStyle("padding", 0)
            } else {
                e.setStyle("padding", this.unitizeBox(n === true ? 5 : n))
            }
        }
    },
    parseBox: function(e) {
        return Ext.dom.Element.parseBox(e)
    },
    unitizeBox: function(e) {
        return Ext.dom.Element.unitizeBox(e)
    },
    setMargin: function(e, t) {
        var n = this;
        if (n.rendered) {
            if (!e && e !== 0) {
                e = ""
            } else {
                if (e === true) {
                    e = 5
                }
                e = this.unitizeBox(e)
            }
            n.getTargetEl().setStyle("margin", e);
            if (!t) {
                n.updateLayout()
            }
        } else {
            n.margin = e
        }
    },
    initEvents: function() {
        var e = this,
        t = e.afterRenderEvents,
        n, r, i, s, o;
        if (t) {
            for (i in t) {
                r = e[i];
                if (r && r.on) {
                    n = t[i];
                    for (s = 0, o = n.length; s < o; ++s) {
                        e.mon(r, n[s])
                    }
                }
            }
        }
        e.addFocusListener()
    },
    addFocusListener: function() {
        var e = this,
        t = e.getFocusEl(),
        n;
        if (t) {
            if (t.isComponent) {
                return t.addFocusListener()
            }
            n = t.needsTabIndex();
            if (!e.focusListenerAdded && (!n || Ext.enableFocusManager)) {
                if (n) {
                    t.dom.tabIndex = -1
                }
                t.on({
                    focus: e.onFocus,
                    blur: e.onBlur,
                    scope: e
                });
                e.focusListenerAdded = true
            }
        }
    },
    getFocusEl: Ext.emptyFn,
    isFocusable: function() {
        var e = this,
        t;
        if (e.focusable !== false && (t = e.getFocusEl()) && e.rendered && !e.destroying && !e.isDestroyed && !e.disabled && e.isVisible(true)) {
            return t.isFocusable(true)
        }
    },
    beforeFocus: Ext.emptyFn,
    onFocus: function(e) {
        var t = this,
        n = t.focusCls,
        r = t.getFocusEl();
        if (!t.disabled) {
            t.beforeFocus(e);
            if (n && r) {
                r.addCls(t.addClsWithUI(n, true))
            }
            if (!t.hasFocus) {
                t.hasFocus = true;
                t.fireEvent("focus", t, e)
            }
        }
    },
    beforeBlur: Ext.emptyFn,
    onBlur: function(e) {
        var t = this,
        n = t.focusCls,
        r = t.getFocusEl();
        if (t.destroying) {
            return
        }
        t.beforeBlur(e);
        if (n && r) {
            r.removeCls(t.removeClsWithUI(n, true))
        }
        if (t.validateOnBlur) {
            t.validate()
        }
        t.hasFocus = false;
        t.fireEvent("blur", t, e);
        t.postBlur(e)
    },
    postBlur: Ext.emptyFn,
    owns: function(e) {
        var t = false,
        n;
        if (e.isEvent) {
            e = e.target
        } else {
            if (e.isElement) {
                e = e.dom
            }
        }
        n = Ext.AbstractComponent.findComponentByElement(e);
        if (n) {
            t = n === this || !!n.up(this)
        }
        return t
    },
    is: function(e) {
        return Ext.ComponentQuery.is(this, e)
    },
    up: function(e, t) {
        var n = this.getRefOwner(),
        r = typeof t === "string",
        i = typeof t === "number",
        s = t && t.isComponent,
        o = 0;
        if (e) {
            for (; n; n = n.getRefOwner()) {
                o++;
                if (e.isComponent) {
                    if (n === e) {
                        return n
                    }
                } else {
                    if (Ext.ComponentQuery.is(n, e)) {
                        return n
                    }
                }
                if (r && n.is(t)) {
                    return
                }
                if (i && o === t) {
                    return
                }
                if (s && n === t) {
                    return
                }
            }
        }
        return n
    },
    nextSibling: function(e) {
        var t = this.ownerCt,
        n, r, i, s;
        if (t) {
            n = t.items;
            i = n.indexOf(this) + 1;
            if (i) {
                if (e) {
                    for (r = n.getCount(); i < r; i++) {
                        if ((s = n.getAt(i)).is(e)) {
                            return s
                        }
                    }
                } else {
                    if (i < n.getCount()) {
                        return n.getAt(i)
                    }
                }
            }
        }
        return null
    },
    previousSibling: function(e) {
        var t = this.ownerCt,
        n, r, i;
        if (t) {
            n = t.items;
            r = n.indexOf(this);
            if (r != -1) {
                if (e) {
                    for (--r; r >= 0; r--) {
                        if ((i = n.getAt(r)).is(e)) {
                            return i
                        }
                    }
                } else {
                    if (r) {
                        return n.getAt(--r)
                    }
                }
            }
        }
        return null
    },
    previousNode: function(e, t) {
        var n = this,
        r = n.ownerCt,
        i, s, o, u;
        if (t && n.is(e)) {
            return n
        }
        if (r) {
            for (s = r.items.items, o = Ext.Array.indexOf(s, n) - 1; o > -1; o--) {
                u = s[o];
                if (u.query) {
                    i = u.query(e);
                    i = i[i.length - 1];
                    if (i) {
                        return i
                    }
                }
                if (u.is(e)) {
                    return u
                }
            }
            return r.previousNode(e, true)
        }
        return null
    },
    nextNode: function(e, t) {
        var n = this,
        r = n.ownerCt,
        i, s, o, u, a;
        if (t && n.is(e)) {
            return n
        }
        if (r) {
            for (s = r.items.items, u = Ext.Array.indexOf(s, n) + 1, o = s.length; u < o; u++) {
                a = s[u];
                if (a.is(e)) {
                    return a
                }
                if (a.down) {
                    i = a.down(e);
                    if (i) {
                        return i
                    }
                }
            }
            return r.nextNode(e)
        }
        return null
    },
    getId: function() {
        return this.id || (this.id = "ext-comp-" + this.getAutoId())
    },
    getItemId: function() {
        return this.itemId || this.id
    },
    getEl: function() {
        return this.el
    },
    getTargetEl: function() {
        return this.frameBody || this.el
    },
    getOverflowEl: function() {
        return this.getTargetEl()
    },
    getOverflowStyle: function() {
        var e = this,
        t = null,
        n = e.autoScroll,
        r, i, s;
        if (typeof n === "boolean") {
            t = {
                overflow: s = n ? "auto": ""
            };
            e.scrollFlags = {
                overflowX: s,
                overflowY: s,
                x: n,
                y: n,
                both: n
            }
        } else {
            r = e.overflowX;
            i = e.overflowY;
            if (r !== undefined || i !== undefined) {
                if (r && r === true) {
                    r = "auto"
                }
                if (i && i === true) {
                    i = "auto"
                }
                t = {
                    overflowX: r = r || "",
                    overflowY: i = i || ""
                };
                e.scrollFlags = {
                    overflowX: r,
                    overflowY: i,
                    x: r = r === "auto" || r === "scroll",
                    y: i = i === "auto" || i === "scroll",
                    both: r && i
                }
            } else {
                e.scrollFlags = {
                    overflowX: "",
                    overflowY: "",
                    x: false,
                    y: false,
                    both: false
                }
            }
        }
        if (t && Ext.isIE7m) {
            t.position = "relative"
        }
        return t
    },
    isXType: function(e, t) {
        if (t) {
            return this.xtype === e
        } else {
            return this.xtypesMap[e]
        }
    },
    getXTypes: function() {
        var e = this.self,
        t, n, r;
        if (!e.xtypes) {
            t = [];
            n = this;
            while (n) {
                r = n.xtypes;
                if (r !== undefined) {
                    t.unshift.apply(t, r)
                }
                n = n.superclass
            }
            e.xtypeChain = t;
            e.xtypes = t.join("/")
        }
        return e.xtypes
    },
    update: function(e, t, n) {
        var r = this,
        i = r.tpl && !Ext.isString(e),
        s,
        o = r.getSizeModel(),
        u = o.width.shrinkWrap || o.height.shrinkWrap;
        if (i) {
            r.data = e
        } else {
            r.html = Ext.isObject(e) ? Ext.DomHelper.markup(e) : e
        }
        if (r.rendered) {
            if (r.isContainer) {
                s = r.layout.getRenderTarget();
                u = u || r.items.items.length > 0
            } else {
                s = r.getTargetEl()
            }
            if (i) {
                r.tpl[r.tplWriteMode](s, e || {})
            } else {
                s.update(r.html, t, n)
            }
            if (u) {
                r.updateLayout()
            }
        }
    },
    setVisible: function(e) {
        return this[e ? "show": "hide"]()
    },
    isVisible: function(e) {
        var t = this,
        n;
        if (t.hidden || !t.rendered || t.isDestroyed) {
            n = true
        } else {
            if (e) {
                n = t.isHierarchicallyHidden()
            }
        }
        return ! n
    },
    isHierarchicallyHidden: function() {
        var e = this,
        t = false,
        n, r;
        for (; n = e.ownerCt || e.floatParent; e = n) {
            r = n.getHierarchyState();
            if (r.hidden) {
                t = true;
                break
            }
            if (e.getHierarchyState().collapseImmune) {
                if (n.collapsed && !e.collapseImmune) {
                    t = true;
                    break
                }
            } else {
                t = !!r.collapsed;
                break
            }
        }
        return t
    },
    onBoxReady: function(e, t) {
        var n = this;
        if (n.disableOnBoxReady) {
            n.onDisable()
        } else {
            if (n.enableOnBoxReady) {
                n.onEnable()
            }
        }
        if (n.resizable) {
            n.initResizable(n.resizable)
        }
        if (n.draggable) {
            n.initDraggable()
        }
        if (n.hasListeners.boxready) {
            n.fireEvent("boxready", n, e, t)
        }
    },
    enable: function(e) {
        var t = this;
        delete t.disableOnBoxReady;
        t.removeCls(t.disabledCls);
        if (t.rendered) {
            t.onEnable()
        } else {
            t.enableOnBoxReady = true
        }
        t.disabled = false;
        delete t.resetDisable;
        if (e !== true) {
            t.fireEvent("enable", t)
        }
        return t
    },
    disable: function(e) {
        var t = this;
        delete t.enableOnBoxReady;
        t.addCls(t.disabledCls);
        if (t.rendered) {
            t.onDisable()
        } else {
            t.disableOnBoxReady = true
        }
        t.disabled = true;
        if (e !== true) {
            delete t.resetDisable;
            t.fireEvent("disable", t)
        }
        return t
    },
    onEnable: function() {
        var e = this,
        t, n;
        if (e.maskOnDisable) {
            t = e.el.dom;
            n = t.nodeName;
            if (e.disabledRe.test(n)) {
                t.disabled = false
            }
            if (!e.nonMaskableRe.test(n)) {
                e.unmask()
            }
        }
    },
    onDisable: function() {
        var e = this,
        t = e.focusCls,
        n = e.getFocusEl(),
        r,
        i;
        if (t && n) {
            n.removeCls(e.removeClsWithUI(t, true))
        }
        if (e.maskOnDisable) {
            r = e.el.dom;
            i = r.nodeName;
            if (e.disabledRe.test(i)) {
                r.disabled = true
            }
            if (!e.nonMaskableRe.test(i)) {
                e.mask()
            }
        }
    },
    mask: function(e, t, n, r) {
        var i = this.lastBox,
        s = this.getMaskTarget() || this.el;
        if (i) {
            n = i.height
        }
        s.mask(e, t, n, r)
    },
    unmask: function() { (this.getMaskTarget() || this.el).unmask()
    },
    getMaskTarget: function() {
        return this.maskElement ? this[this.maskElement] : null
    },
    isDisabled: function() {
        return this.disabled
    },
    setDisabled: function(e) {
        return this[e ? "disable": "enable"]()
    },
    isHidden: function() {
        return this.hidden
    },
    addCls: function(e) {
        var t = this,
        n = t.rendered ? t.el: t.protoEl;
        n.addCls.apply(n, arguments);
        return t
    },
    addClass: function() {
        return this.addCls.apply(this, arguments)
    },
    hasCls: function(e) {
        var t = this,
        n = t.rendered ? t.el: t.protoEl;
        return n.hasCls.apply(n, arguments)
    },
    removeCls: function(e) {
        var t = this,
        n = t.rendered ? t.el: t.protoEl;
        n.removeCls.apply(n, arguments);
        return t
    },
    addOverCls: function() {
        var e = this;
        if (!e.disabled) {
            e.el.addCls(e.overCls)
        }
    },
    removeOverCls: function() {
        this.el.removeCls(this.overCls)
    },
    addListener: function(e, t, n, r) {
        var i = this,
        s, o;
        if (Ext.isString(e) && (Ext.isObject(t) || r && r.element)) {
            if (r.element) {
                s = t;
                t = {};
                t[e] = s;
                e = r.element;
                if (n) {
                    t.scope = n
                }
                for (o in r) {
                    if (r.hasOwnProperty(o)) {
                        if (i.eventOptionsRe.test(o)) {
                            t[o] = r[o]
                        }
                    }
                }
            }
            if (i[e] && i[e].on) {
                i.mon(i[e], t)
            } else {
                i.afterRenderEvents = i.afterRenderEvents || {};
                if (!i.afterRenderEvents[e]) {
                    i.afterRenderEvents[e] = []
                }
                i.afterRenderEvents[e].push(t)
            }
            return
        }
        return i.mixins.observable.addListener.apply(i, arguments)
    },
    removeManagedListenerItem: function(e, t, n, r, i, s) {
        var o = this,
        u = t.options ? t.options.element: null;
        if (u) {
            u = o[u];
            if (u && u.un) {
                if (e || t.item === n && t.ename === r && (!i || t.fn === i) && (!s || t.scope === s)) {
                    u.un(t.ename, t.fn, t.scope);
                    if (!e) {
                        Ext.Array.remove(o.managedListeners, t)
                    }
                }
            }
        } else {
            return o.mixins.observable.removeManagedListenerItem.apply(o, arguments)
        }
    },
    getBubbleTarget: function() {
        return this.ownerCt
    },
    isFloating: function() {
        return this.floating
    },
    isDraggable: function() {
        return !! this.draggable
    },
    isDroppable: function() {
        return !! this.droppable
    },
    onAdded: function(e, t) {
        var n = this;
        n.ownerCt = e;
        if (n.hierarchyState) {
            n.hierarchyState.invalid = true;
            delete n.hierarchyState
        }
        if (n.hasListeners.added) {
            n.fireEvent("added", n, e, t)
        }
    },
    onRemoved: function(e) {
        var t = this;
        if (t.hasListeners.removed) {
            t.fireEvent("removed", t, t.ownerCt)
        }
        delete t.ownerCt;
        delete t.ownerLayout
    },
    beforeDestroy: Ext.emptyFn,
    onResize: function(e, t, n, r) {
        var i = this;
        if (i.floating && i.constrain) {
            i.doConstrain()
        }
        if (i.hasListeners.resize) {
            i.fireEvent("resize", i, e, t, n, r)
        }
    },
    setSize: function(e, t) {
        var n = this;
        if (e && typeof e == "object") {
            t = e.height;
            e = e.width
        }
        if (typeof e == "number") {
            n.width = Ext.Number.constrain(e, n.minWidth, n.maxWidth)
        } else {
            if (e === null) {
                delete n.width
            }
        }
        if (typeof t == "number") {
            n.height = Ext.Number.constrain(t, n.minHeight, n.maxHeight)
        } else {
            if (t === null) {
                delete n.height
            }
        }
        if (n.rendered && n.isVisible()) {
            n.updateLayout({
                isRoot: false
            })
        }
        return n
    },
    isLayoutRoot: function() {
        var e = this,
        t = e.ownerLayout;
        if (!t || e._isLayoutRoot || e.floating) {
            return true
        }
        return t.isItemLayoutRoot(e)
    },
    isLayoutSuspended: function() {
        var e = this,
        t;
        while (e) {
            if (e.layoutSuspendCount || e.suspendLayout) {
                return true
            }
            t = e.ownerLayout;
            if (!t) {
                break
            }
            e = t.owner
        }
        return false
    },
    updateLayout: function(e) {
        var t = this,
        n, r = t.lastBox,
        i = e && e.isRoot;
        if (r) {
            r.invalid = true
        }
        if (!t.rendered || t.layoutSuspendCount || t.suspendLayout) {
            return
        }
        if (t.hidden) {
            Ext.AbstractComponent.cancelLayout(t)
        } else {
            if (typeof i != "boolean") {
                i = t.isLayoutRoot()
            }
        }
        if (i || !t.ownerLayout || !t.ownerLayout.onContentChange(t)) {
            if (!t.isLayoutSuspended()) {
                n = e && e.hasOwnProperty("defer") ? e.defer: t.deferLayouts;
                Ext.AbstractComponent.updateLayout(t, n)
            }
        }
    },
    getSizeModel: function(e) {
        var t = this,
        n = Ext.layout.SizeModel,
        r = t.componentLayout.ownerContext,
        i = t.width,
        s = t.height,
        o, u, a, f, l, c, h, p, d, v;
        if (r) {
            v = r.widthModel;
            l = r.heightModel
        }
        if (!v || !l) {
            a = (o = typeof i) == "number";
            f = (u = typeof s) == "number";
            d = t.floating || !(c = t.ownerLayout);
            if (d) {
                h = Ext.layout.Layout.prototype.autoSizePolicy;
                p = t.floating ? 3 : t.shrinkWrap;
                if (a) {
                    v = n.configured
                }
                if (f) {
                    l = n.configured
                }
            } else {
                h = c.getItemSizePolicy(t, e);
                p = c.isItemShrinkWrap(t)
            }
            if (r) {
                r.ownerSizePolicy = h
            }
            p = p === true ? 3 : p || 0;
            if (d && p) {
                if (i && o == "string") {
                    p &= 2
                }
                if (s && u == "string") {
                    p &= 1
                }
            }
            if (p !== 3) {
                if (!e) {
                    e = t.ownerCt && t.ownerCt.getSizeModel()
                }
                if (e) {
                    p |= (e.width.shrinkWrap ? 1 : 0) | (e.height.shrinkWrap ? 2 : 0)
                }
            }
            if (!v) {
                if (!h.setsWidth) {
                    if (a) {
                        v = n.configured
                    } else {
                        v = p & 1 ? n.shrinkWrap: n.natural
                    }
                } else {
                    if (h.readsWidth) {
                        if (a) {
                            v = n.calculatedFromConfigured
                        } else {
                            v = p & 1 ? n.calculatedFromShrinkWrap: n.calculatedFromNatural
                        }
                    } else {
                        v = n.calculated
                    }
                }
            }
            if (!l) {
                if (!h.setsHeight) {
                    if (f) {
                        l = n.configured
                    } else {
                        l = p & 2 ? n.shrinkWrap: n.natural
                    }
                } else {
                    if (h.readsHeight) {
                        if (f) {
                            l = n.calculatedFromConfigured
                        } else {
                            l = p & 2 ? n.calculatedFromShrinkWrap: n.calculatedFromNatural
                        }
                    } else {
                        l = n.calculated
                    }
                }
            }
        }
        return v.pairsByHeightOrdinal[l.ordinal]
    },
    isDescendant: function(e) {
        if (e.isContainer) {
            for (var t = this.ownerCt; t; t = t.ownerCt) {
                if (t === e) {
                    return true
                }
            }
        }
        return false
    },
    doComponentLayout: function() {
        this.updateLayout();
        return this
    },
    forceComponentLayout: function() {
        this.updateLayout()
    },
    setComponentLayout: function(e) {
        var t = this.componentLayout;
        if (t && t.isLayout && t != e) {
            t.setOwner(null)
        }
        this.componentLayout = e;
        e.setOwner(this)
    },
    getComponentLayout: function() {
        var e = this;
        if (!e.componentLayout || !e.componentLayout.isLayout) {
            e.setComponentLayout(Ext.layout.Layout.create(e.componentLayout, "autocomponent"))
        }
        return e.componentLayout
    },
    afterComponentLayout: function(e, t, n, r) {
        var i = this;
        if (++i.componentLayoutCounter === 1) {
            i.afterFirstLayout(e, t)
        }
        if (e !== n || t !== r) {
            i.onResize(e, t, n, r)
        }
    },
    beforeComponentLayout: function(e, t) {
        return true
    },
    setPosition: function(e, t, n) {
        var r = this,
        i = r.beforeSetPosition.apply(r, arguments);
        if (i && r.rendered) {
            e = i.x;
            t = i.y;
            if (n) {
                if (e !== r.getLocalX() || t !== r.getLocalY()) {
                    r.stopAnimation();
                    r.animate(Ext.apply({
                        duration: 1e3,
                        listeners: {
                            afteranimate: Ext.Function.bind(r.afterSetPosition, r, [e, t])
                        },
                        to: {
                            left: e,
                            top: t
                        }
                    },
                    n))
                }
            } else {
                r.setLocalXY(e, t);
                r.afterSetPosition(e, t)
            }
        }
        return r
    },
    beforeSetPosition: function(e, t, n) {
        var r, i;
        if (e) {
            if (Ext.isNumber(i = e[0])) {
                n = t;
                t = e[1];
                e = i
            } else {
                if ((i = e.x) !== undefined) {
                    n = t;
                    t = e.y;
                    e = i
                }
            }
        }
        if (this.constrain || this.constrainHeader) {
            r = this.calculateConstrainedPosition(null, [e, t], true);
            if (r) {
                e = r[0];
                t = r[1]
            }
        }
        r = {
            x: this.x = e,
            y: this.y = t,
            anim: n,
            hasX: e !== undefined,
            hasY: t !== undefined
        };
        return r.hasX || r.hasY ? r: null
    },
    afterSetPosition: function(e, t) {
        var n = this;
        n.onPosition(e, t);
        if (n.hasListeners.move) {
            n.fireEvent("move", n, e, t)
        }
    },
    onPosition: Ext.emptyFn,
    setWidth: function(e) {
        return this.setSize(e)
    },
    setHeight: function(e) {
        return this.setSize(undefined, e)
    },
    getSize: function(e) {
        return this.el.getSize(e)
    },
    getWidth: function() {
        return this.el.getWidth()
    },
    getHeight: function() {
        return this.el.getHeight()
    },
    getLoader: function() {
        var e = this,
        t = e.autoLoad ? Ext.isObject(e.autoLoad) ? e.autoLoad: {
            url: e.autoLoad
        }: null,
        n = e.loader || t;
        if (n) {
            if (!n.isLoader) {
                e.loader = new Ext.ComponentLoader(Ext.apply({
                    target: e,
                    autoLoad: t
                },
                n))
            } else {
                n.setTarget(e)
            }
            return e.loader
        }
        return null
    },
    setDocked: function(e, t) {
        var n = this;
        n.dock = e;
        if (t && n.ownerCt && n.rendered) {
            n.ownerCt.updateLayout()
        }
        return n
    },
    setBorder: function(e, t) {
        var n = this,
        r = !!t;
        if (n.rendered || r) {
            if (!r) {
                t = n.el
            }
            if (!e) {
                e = 0
            } else {
                if (e === true) {
                    e = "1px"
                } else {
                    e = this.unitizeBox(e)
                }
            }
            t.setStyle("border-width", e);
            if (!r) {
                n.updateLayout()
            }
        }
        n.border = e
    },
    onDestroy: function() {
        var e = this;
        Ext.destroy(e.componentLayout, e.loadMask, e.floatingDescendants)
    },
    destroy: function() {
        var e = this,
        t = e.renderSelectors,
        n, r;
        if (!e.isDestroyed) {
            if (!e.hasListeners.beforedestroy || e.fireEvent("beforedestroy", e) !== false) {
                e.destroying = true;
                e.beforeDestroy();
                if (e.floating) {
                    delete e.floatParent;
                    if (e.zIndexManager) {
                        e.zIndexManager.unregister(e)
                    }
                } else {
                    if (e.ownerCt && e.ownerCt.remove) {
                        e.ownerCt.remove(e, false)
                    }
                }
                e.stopAnimation();
                e.onDestroy();
                Ext.destroy(e.plugins);
                if (e.hasListeners.destroy) {
                    e.fireEvent("destroy", e)
                }
                Ext.ComponentManager.unregister(e);
                e.mixins.state.destroy.call(e);
                e.clearListeners();
                if (e.rendered) {
                    if (!e.preserveElOnDestroy) {
                        e.el.remove()
                    }
                    e.mixins.elementCt.destroy.call(e);
                    if (t) {
                        for (n in t) {
                            if (t.hasOwnProperty(n)) {
                                r = e[n];
                                if (r) {
                                    delete e[n];
                                    r.remove()
                                }
                            }
                        }
                    }
                    delete e.el;
                    delete e.frameBody;
                    delete e.rendered
                }
                delete e.initialConfig;
                e.destroying = false;
                e.isDestroyed = true
            }
        }
    },
    isDescendantOf: function(e) {
        return !! this.findParentBy(function(t) {
            return t === e
        })
    },
    getHierarchyState: function(e) {
        var t = this,
        n = e && t.hierarchyStateInner || t.hierarchyState,
        r = t.ownerCt,
        i, s, o, u;
        if (!n || n.invalid) {
            i = t.getRefOwner();
            if (r) {
                u = t.ownerLayout === r.layout
            }
            t.hierarchyState = n = Ext.Object.chain(i ? i.getHierarchyState(u) : Ext.rootHierarchyState);
            t.initHierarchyState(n);
            if ((s = t.componentLayout).initHierarchyState) {
                s.initHierarchyState(n)
            }
            if (t.isContainer) {
                t.hierarchyStateInner = o = Ext.Object.chain(n);
                s = t.layout;
                if (s && s.initHierarchyState) {
                    s.initHierarchyState(o, n)
                }
                if (e) {
                    n = o
                }
            }
        }
        return n
    },
    initHierarchyState: function(e) {
        var t = this;
        if (t.collapsed) {
            e.collapsed = true
        }
        if (t.hidden) {
            e.hidden = true
        }
        if (t.collapseImmune) {
            e.collapseImmune = true
        }
    },
    getAnchorToXY: function(e, t, n, r) {
        return e.getAnchorXY(t, n, r)
    },
    getBorderPadding: function() {
        return this.el.getBorderPadding()
    },
    getLocalX: function() {
        return this.el.getLocalX()
    },
    getLocalXY: function() {
        return this.el.getLocalXY()
    },
    getLocalY: function() {
        return this.el.getLocalY()
    },
    getX: function() {
        return this.el.getX()
    },
    getXY: function() {
        return this.el.getXY()
    },
    getY: function() {
        return this.el.getY()
    },
    setLocalX: function(e) {
        this.el.setLocalX(e)
    },
    setLocalXY: function(e, t) {
        this.el.setLocalXY(e, t)
    },
    setLocalY: function(e) {
        this.el.setLocalY(e)
    },
    setX: function(e, t) {
        this.el.setX(e, t)
    },
    setXY: function(e, t) {
        this.el.setXY(e, t)
    },
    setY: function(e, t) {
        this.el.setY(e, t)
    }
},
function() {
    var e = this;
    e.createAlias({
        on: "addListener",
        prev: "previousSibling",
        next: "nextSibling"
    });
    Ext.resumeLayouts = function(t) {
        e.resumeLayouts(t)
    };
    Ext.suspendLayouts = function() {
        e.suspendLayouts()
    };
    Ext.batchLayouts = function(t, n) {
        e.suspendLayouts();
        t.call(n);
        e.resumeLayouts(true)
    }
});
Ext.define("Ext.AbstractPlugin", {
    disabled: false,
    isPlugin: true,
    constructor: function(e) {
        if (e) {
            this.pluginConfig = e;
            Ext.apply(this, e)
        }
    },
    clonePlugin: function(e) {
        return new this.self(Ext.apply({},
        e, this.pluginConfig))
    },
    setCmp: function(e) {
        this.cmp = e
    },
    getCmp: function() {
        return this.cmp
    },
    init: Ext.emptyFn,
    destroy: Ext.emptyFn,
    enable: function() {
        this.disabled = false
    },
    disable: function() {
        this.disabled = true
    },
    onClassExtended: function(e, t, n) {
        var r = t.alias;
        if (r && !t.ptype) {
            if (Ext.isArray(r)) {
                r = r[0]
            }
            e.prototype.ptype = r.split("plugin.")[1]
        }
    }
});
Ext.define("Ext.Action", {
    constructor: function(e) {
        this.initialConfig = e;
        this.itemId = e.itemId = e.itemId || e.id || Ext.id();
        this.items = []
    },
    isAction: true,
    setText: function(e) {
        this.initialConfig.text = e;
        this.callEach("setText", [e])
    },
    getText: function() {
        return this.initialConfig.text
    },
    setIconCls: function(e) {
        this.initialConfig.iconCls = e;
        this.callEach("setIconCls", [e])
    },
    getIconCls: function() {
        return this.initialConfig.iconCls
    },
    setDisabled: function(e) {
        this.initialConfig.disabled = e;
        this.callEach("setDisabled", [e])
    },
    enable: function() {
        this.setDisabled(false)
    },
    disable: function() {
        this.setDisabled(true)
    },
    isDisabled: function() {
        return this.initialConfig.disabled
    },
    setHidden: function(e) {
        this.initialConfig.hidden = e;
        this.callEach("setVisible", [!e])
    },
    show: function() {
        this.setHidden(false)
    },
    hide: function() {
        this.setHidden(true)
    },
    isHidden: function() {
        return this.initialConfig.hidden
    },
    setHandler: function(e, t) {
        this.initialConfig.handler = e;
        this.initialConfig.scope = t;
        this.callEach("setHandler", [e, t])
    },
    each: function(e, t) {
        Ext.each(this.items, e, t)
    },
    callEach: function(e, t) {
        var n = this.items,
        r = 0,
        i = n.length,
        s;
        Ext.suspendLayouts();
        for (; r < i; r++) {
            s = n[r];
            s[e].apply(s, t)
        }
        Ext.resumeLayouts(true)
    },
    addComponent: function(e) {
        this.items.push(e);
        e.on("destroy", this.removeComponent, this)
    },
    removeComponent: function(e) {
        Ext.Array.remove(this.items, e)
    },
    execute: function() {
        this.initialConfig.handler.apply(this.initialConfig.scope || Ext.global, arguments)
    }
});
Ext.define("Ext.data.flash.BinaryXhr", {
    statics: {
        flashPluginActivated: function() {
            Ext.data.flash.BinaryXhr.flashPluginActive = true;
            Ext.data.flash.BinaryXhr.flashPlugin = document.getElementById("ext-flash-polyfill");
            Ext.globalEvents.fireEvent("flashready")
        },
        flashPluginActive: false,
        flashPluginInjected: false,
        connectionIndex: 1,
        liveConnections: {},
        flashPlugin: null,
        onFlashStateChange: function(e, t, n) {
            var r;
            r = this.liveConnections[Number(e)];
            if (r) {
                r.onFlashStateChange(t, n)
            }
        },
        registerConnection: function(e) {
            var t = this.connectionIndex;
            this.conectionIndex = this.connectionIndex + 1;
            this.liveConnections[t] = e;
            return t
        },
        injectFlashPlugin: function() {
            var e = this,
            t, n;
            e.flashPolyfillEl = Ext.getBody().appendChild({
                id: "ext-flash-polyfill",
                cn: [{
                    tag: "p",
                    html: "To view this page ensure that Adobe Flash Player version 11.1.0 or greater is installed."
                },
                {
                    tag: "a",
                    href: "http://www.adobe.com/go/getflashplayer",
                    cn: [{
                        tag: "img",
                        src: window.location.protocol + "//www.adobe.com/images/shared/download_buttons/get_flash_player.gif",
                        alt: "Get Adobe Flash player"
                    }]
                }]
            });
            t = [Ext.Loader.getPath("Ext.data.Connection"), "../../../plugins/flash/swfobject.js"].join("/");
            n = "/plugins/flash/FlashPlugin.swf";
            if (Ext.flashPluginPath) {
                n = Ext.flashPluginPath
            }
            Ext.Loader.loadScript({
                url: t,
                onLoad: function() {
                    var e = "11.4.0";
                    var t = "playerProductInstall.swf";
                    var r = {};
                    var i = {};
                    i.quality = "high";
                    i.bgcolor = "#ffffff";
                    i.allowscriptaccess = "sameDomain";
                    i.allowfullscreen = "true";
                    var s = {};
                    s.id = "ext-flash-polyfill";
                    s.name = "polyfill";
                    s.align = "middle";
                    swfobject.embedSWF(n, "ext-flash-polyfill", "0", "0", e, t, r, i, s)
                },
                onError: function() {},
                scope: e
            });
            Ext.globalEvents.addEvents("flashready");
            Ext.data.flash.BinaryXhr.flashPluginInjected = true
        }
    },
    readyState: 0,
    status: 0,
    statusText: "",
    responseBytes: null,
    javascriptId: null,
    constructor: function(e) {
        if (!Ext.data.flash.BinaryXhr.flashPluginInjected) {
            Ext.data.flash.BinaryXhr.injectFlashPlugin()
        }
        var t = this;
        Ext.apply(t, e);
        t.requestHeaders = {}
    },
    abort: function() {
        var e = this;
        if (e.readyState == 4) {
            return
        }
        e.aborted = true;
        if (!Ext.data.flash.BinaryXhr.flashPluginActive) {
            Ext.globalEvents.removeListener("flashready", e.onFlashReady, e);
            return
        }
        Ext.data.flash.BinaryXhr.flashPlugin.abortRequest(e.javascriptId);
        delete Ext.data.flash.BinaryXhr.liveConnections[e.javascriptId]
    },
    getAllResponseHeaders: function() {
        var e = [];
        Ext.Object.each(this.responseHeaders,
        function(t, n) {
            e.push(t + ": " + n)
        });
        return e.join("\r\n")
    },
    getResponseHeader: function(e) {
        var t = this.responseHeaders;
        return t && t[e] || null
    },
    open: function(e, t, n, r, i) {
        var s = this;
        s.method = e;
        s.url = t;
        s.async = n !== false;
        s.user = r;
        s.password = i
    },
    overrideMimeType: function(e) {
        this.mimeType = e
    },
    send: function(e) {
        var t = this;
        t.body = e;
        if (!Ext.data.flash.BinaryXhr.flashPluginActive) {
            Ext.globalEvents.addListener("flashready", t.onFlashReady, t)
        } else {
            this.onFlashReady()
        }
    },
    onFlashReady: function() {
        var e = this,
        t, n;
        e.javascriptId = Ext.data.flash.BinaryXhr.registerConnection(e);
        t = {
            method: e.method,
            url: e.url,
            user: e.user,
            password: e.password,
            mimeType: e.mimeType,
            requestHeaders: e.requestHeaders,
            body: e.body,
            javascriptId: e.javascriptId
        };
        n = Ext.data.flash.BinaryXhr.flashPlugin.postBinary(t)
    },
    setReadyState: function(e) {
        var t = this;
        if (t.readyState != e) {
            t.readyState = e;
            t.onreadystatechange()
        }
    },
    setRequestHeader: function(e, t) {
        this.requestHeaders[e] = t
    },
    onreadystatechange: Ext.emptyFn,
    parseData: function(e) {
        var t = this;
        this.status = e.status || 0;
        t.responseHeaders = {};
        if (t.mimeType) {
            t.responseHeaders["content-type"] = t.mimeType
        }
        if (e.reason == "complete") {
            this.responseBytes = e.data;
            t.responseHeaders["content-length"] = e.data.length
        } else {
            if (e.reason == "error" || e.reason == "securityError") {
                this.statusText = e.text;
                t.responseHeaders["content-length"] = 0
            }
        }
    },
    onFlashStateChange: function(e, t) {
        var n = this;
        if (e == 4) {
            n.parseData(t);
            delete Ext.data.flash.BinaryXhr.liveConnections[n.javascriptId]
        }
        n.setReadyState(e)
    }
});
Ext.define("Ext.data.Connection", {
    mixins: {
        observable: Ext.util.Observable
    },
    statics: {
        requestId: 0
    },
    url: null,
    async: true,
    method: null,
    username: "",
    password: "",
    disableCaching: false,
    withCredentials: false,
    binary: false,
    cors: false,
    isXdr: false,
    defaultXdrContentType: "text/plain",
    disableCachingParam: "_dc",
    timeout: 3e4,
    useDefaultHeader: true,
    defaultPostHeader: "application/x-www-form-urlencoded; charset=UTF-8",
    useDefaultXhrHeader: true,
    defaultXhrHeader: "XMLHttpRequest",
    constructor: function(e) {
        e = e || {};
        Ext.apply(this, e);
        this.requests = {};
        this.mixins.observable.constructor.call(this)
    },
    request: function(e) {
        e = e || {};
        var t = this,
        n = e.scope || window,
        r = e.username || t.username,
        i = e.password || t.password || "",
        s, o, u, a, f;
        if (t.fireEvent("beforerequest", t, e) !== false) {
            o = t.setOptions(e, n);
            if (t.isFormUpload(e)) {
                t.upload(e.form, o.url, o.data, e);
                return null
            }
            if (e.autoAbort || t.autoAbort) {
                t.abort()
            }
            s = e.async !== false ? e.async || t.async: false;
            f = t.openRequest(e, o, s, r, i);
            if (!t.isXdr) {
                a = t.setupHeaders(f, e, o.data, o.params)
            }
            u = {
                id: ++Ext.data.Connection.requestId,
                xhr: f,
                headers: a,
                options: e,
                async: s,
                binary: e.binary || t.binary
            };
            if (e.timeout != -1 && t.timeout != -1) {
                u.timeout = setTimeout(function() {
                    u.timedout = true;
                    t.abort(u)
                },
                e.timeout || t.timeout)
            }
            t.requests[u.id] = u;
            t.latestId = u.id;
            if (s) {
                if (!t.isXdr) {
                    f.onreadystatechange = Ext.Function.bind(t.onStateChange, t, [u])
                }
            }
            if (t.isXdr) {
                t.processXdrRequest(u, f)
            }
            f.send(o.data);
            if (!s) {
                return t.onComplete(u)
            }
            return u
        } else {
            Ext.callback(e.callback, e.scope, [e, undefined, undefined]);
            return null
        }
    },
    processXdrRequest: function(e, t) {
        var n = this;
        delete e.headers;
        e.contentType = e.options.contentType || n.defaultXdrContentType;
        t.onload = Ext.Function.bind(n.onStateChange, n, [e, true]);
        t.onerror = t.ontimeout = Ext.Function.bind(n.onStateChange, n, [e, false])
    },
    processXdrResponse: function(e, t) {
        e.getAllResponseHeaders = function() {
            return []
        };
        e.getResponseHeader = function() {
            return ""
        };
        e.contentType = t.contentType || this.defaultXdrContentType
    },
    upload: function(e, t, n, r) {
        e = Ext.getDom(e);
        r = r || {};
        var i = Ext.id(),
        s = document.createElement("iframe"),
        o = [],
        u = "multipart/form-data",
        a = {
            target: e.target,
            method: e.method,
            encoding: e.encoding,
            enctype: e.enctype,
            action: e.action
        },
        f = function(t, n) {
            l = document.createElement("input");
            Ext.fly(l).set({
                type: "hidden",
                value: n,
                name: t
            });
            e.appendChild(l);
            o.push(l)
        },
        l,
        c,
        h,
        p,
        d,
        v,
        m,
        g;
        Ext.fly(s).set({
            id: i,
            name: i,
            cls: Ext.baseCSSPrefix + "hide-display",
            src: Ext.SSL_SECURE_URL
        });
        document.body.appendChild(s);
        if (document.frames) {
            document.frames[i].name = i
        }
        Ext.fly(e).set({
            target: i,
            method: "POST",
            enctype: u,
            encoding: u,
            action: t || a.action
        });
        if (n) {
            c = Ext.Object.fromQueryString(n) || {};
            for (p in c) {
                if (c.hasOwnProperty(p)) {
                    h = c[p];
                    if (Ext.isArray(h)) {
                        d = h.length;
                        for (v = 0; v < d; v++) {
                            f(p, h[v])
                        }
                    } else {
                        f(p, h)
                    }
                }
            }
        }
        Ext.fly(s).on("load", Ext.Function.bind(this.onUploadComplete, this, [s, r]), null, {
            single: !Ext.isOpera
        });
        e.submit();
        Ext.fly(e).set(a);
        m = o.length;
        for (g = 0; g < m; g++) {
            Ext.removeNode(o[g])
        }
    },
    onUploadComplete: function(e, t) {
        var n = this,
        r = {
            responseText: "",
            responseXML: null
        },
        i,
        s,
        o,
        u;
        try {
            o = e.contentWindow.document || e.contentDocument || window.frames[e.id].document;
            if (o) {
                if (Ext.isOpera && o.location == "about:blank") {
                    return
                }
                if (o.body) {
                    if ((u = o.body.firstChild) && /pre/i.test(u.tagName)) {
                        r.responseText = u.textContent || u.innerText
                    } else {
                        if (u = o.getElementsByTagName("textarea")[0]) {
                            r.responseText = u.value
                        } else {
                            r.responseText = o.body.textContent || o.body.innerText
                        }
                    }
                }
                r.responseXML = o.XMLDocument || o;
                i = t.success;
                s = true
            }
        } catch(a) {
            r.responseText = '{success:false,message:"' + Ext.String.trim(a.message || a.description) + '"}';
            i = t.failure;
            s = false
        }
        n.fireEvent("requestcomplete", n, r, t);
        Ext.callback(i, t.scope, [r, t]);
        Ext.callback(t.callback, t.scope, [t, s, r]);
        setTimeout(function() {
            Ext.removeNode(e)
        },
        100)
    },
    isFormUpload: function(e) {
        var t = this.getForm(e);
        if (t) {
            return e.isUpload || /multipart\/form-data/i.test(t.getAttribute("enctype"))
        }
        return false
    },
    getForm: function(e) {
        return Ext.getDom(e.form) || null
    },
    setOptions: function(e, t) {
        var n = this,
        r = e.params || {},
        i = n.extraParams,
        s = e.urlParams,
        o = e.url || n.url,
        u = e.jsonData,
        a, f, l, c, h;
        if (Ext.isFunction(r)) {
            r = r.call(t, e)
        }
        if (Ext.isFunction(o)) {
            o = o.call(t, e)
        }
        o = this.setupUrl(e, o);
        h = e.rawData || e.binaryData || e.xmlData || u || null;
        if (u && !Ext.isPrimitive(u)) {
            h = Ext.encode(h)
        }
        if (e.binaryData) {
            if (n.nativeBinaryPostSupport()) {
                h = new Uint8Array(e.binaryData);
                if (Ext.isChrome && Ext.chromeVersion < 22 || Ext.isSafari || Ext.isGecko) {
                    h = h.buffer
                }
            }
        }
        if (Ext.isObject(r)) {
            for (f in r) {
                if (r.hasOwnProperty(f)) {
                    l = r[f];
                    if (Ext.isObject(l) || Ext.isArray(l)) {
                        r[f] = Ext.encode(l)
                    }
                }
            }
            r = Ext.Object.toQueryString(r)
        }
        if (Ext.isObject(i)) {
            for (f in i) {
                if (i.hasOwnProperty(f)) {
                    l = i[f];
                    if (Ext.isObject(l) || Ext.isArray(l)) {
                        i[f] = Ext.encode(l)
                    }
                }
            }
            i = Ext.Object.toQueryString(i)
        }
        r = r + (i ? (r ? "&": "") + i: "");
        s = Ext.isObject(s) ? Ext.Object.toQueryString(s) : s;
        r = this.setupParams(e, r);
        a = (e.method || n.method || "POST").toUpperCase();
        this.setupMethod(e, a);
        c = e.disableCaching !== false ? e.disableCaching || n.disableCaching: false;
        if (a === "GET" && c) {
            o = Ext.urlAppend(o, (e.disableCachingParam || n.disableCachingParam) + "=" + (new Date).getTime())
        }
        if ((a == "GET" || h) && r) {
            o = Ext.urlAppend(o, r);
            r = null
        }
        if (s) {
            o = Ext.urlAppend(o, s)
        }
        return {
            url: o,
            method: a,
            data: h || r || null
        }
    },
    setupUrl: function(e, t) {
        var n = this.getForm(e);
        if (n) {
            t = t || n.action
        }
        return t
    },
    setupParams: function(e, t) {
        var n = this.getForm(e),
        r;
        if (n && !this.isFormUpload(e)) {
            r = Ext.Element.serializeForm(n);
            t = t ? t + "&" + r: r
        }
        return t
    },
    setupMethod: function(e, t) {
        if (this.isFormUpload(e)) {
            return "POST"
        }
        return t
    },
    setupHeaders: function(e, t, n, r) {
        var i = this,
        s = Ext.apply({},
        t.headers || {},
        i.defaultHeaders || {}),
        o = i.defaultPostHeader,
        u = t.jsonData,
        a = t.xmlData,
        f = "Content-Type",
        l,
        c;
        if (!s.hasOwnProperty(f) && (n || r)) {
            if (n) {
                if (t.rawData) {
                    o = "text/plain"
                } else {
                    if (a && Ext.isDefined(a)) {
                        o = "text/xml"
                    } else {
                        if (u && Ext.isDefined(u)) {
                            o = "application/json"
                        }
                    }
                }
            }
            s[f] = o
        }
        if (i.useDefaultXhrHeader && !s["X-Requested-With"]) {
            s["X-Requested-With"] = i.defaultXhrHeader
        }
        if (s[f] === undefined || s[f] === null) {
            delete s[f]
        }
        try {
            for (l in s) {
                if (s.hasOwnProperty(l)) {
                    c = s[l];
                    e.setRequestHeader(l, c)
                }
            }
        } catch(h) {
            i.fireEvent("exception", l, c)
        }
        return s
    },
    newRequest: function(e) {
        var t = this,
        n;
        if (e.binaryData) {
            if (t.nativeBinaryPostSupport()) {
                n = this.getXhrInstance()
            } else {
                n = new Ext.data.flash.BinaryXhr
            }
        } else {
            if ((e.cors || t.cors) && Ext.isIE && Ext.ieVersion <= 9) {
                n = t.getXdrInstance();
                t.isXdr = true
            } else {
                n = t.getXhrInstance()
            }
        }
        return n
    },
    openRequest: function(e, t, n, r, i) {
        var s = this,
        o = s.newRequest(e);
        if (r) {
            o.open(t.method, t.url, n, r, i)
        } else {
            if (s.isXdr) {
                o.open(t.method, t.url)
            } else {
                o.open(t.method, t.url, n)
            }
        }
        if (e.binary || s.binary) {
            if (window.Uint8Array) {
                o.responseType = "arraybuffer"
            } else {
                if (o.overrideMimeType) {
                    o.overrideMimeType("text/plain; charset=x-user-defined")
                }
            }
        }
        if (e.withCredentials || s.withCredentials) {
            o.withCredentials = true
        }
        return o
    },
    getXdrInstance: function() {
        var e;
        if (Ext.ieVersion >= 8) {
            e = new XDomainRequest
        } else {
            Ext.Error.raise({
                msg: "Your browser does not support CORS"
            })
        }
        return e
    },
    getXhrInstance: function() {
        var e = [function() {
            return new XMLHttpRequest
        },
        function() {
            return new ActiveXObject("MSXML2.XMLHTTP.3.0")
        },
        function() {
            return new ActiveXObject("MSXML2.XMLHTTP")
        },
        function() {
            return new ActiveXObject("Microsoft.XMLHTTP")
        }],
        t = 0,
        n = e.length,
        r;
        for (; t < n; ++t) {
            try {
                r = e[t];
                r();
                break
            } catch(i) {}
        }
        return r
    } (),
    isLoading: function(e) {
        if (!e) {
            e = this.getLatest()
        }
        if (! (e && e.xhr)) {
            return false
        }
        var t = e.xhr.readyState;
        return e.xhr instanceof Ext.data.flash.BinaryXhr && t != 4 || !(t === 0 || t == 4)
    },
    abort: function(e) {
        var t = this,
        n;
        if (!e) {
            e = t.getLatest()
        }
        if (e && t.isLoading(e)) {
            n = e.xhr;
            try {
                n.onreadystatechange = null
            } catch(r) {
                n.onreadystatechange = Ext.emptyFn
            }
            n.abort();
            t.clearTimeout(e);
            if (!e.timedout) {
                e.aborted = true
            }
            t.onComplete(e);
            t.cleanup(e)
        }
    },
    abortAll: function() {
        var e = this.requests,
        t;
        for (t in e) {
            if (e.hasOwnProperty(t)) {
                this.abort(e[t])
            }
        }
    },
    getLatest: function() {
        var e = this.latestId,
        t;
        if (e) {
            t = this.requests[e]
        }
        return t || null
    },
    onStateChange: function(e, t) {
        var n = this;
        if (e.xhr && e.xhr.readyState == 4 || n.isXdr) {
            n.clearTimeout(e);
            n.onComplete(e, t);
            n.cleanup(e);
            Ext.EventManager.idleEvent.fire()
        }
    },
    clearTimeout: function(e) {
        clearTimeout(e.timeout);
        delete e.timeout
    },
    cleanup: function(e) {
        e.xhr = null;
        delete e.xhr
    },
    onComplete: function(e, t) {
        var n = this,
        r = e.options,
        i, s, o, u;
        try {
            i = e.xhr;
            s = n.parseStatus(i.status);
            if (s.success) {
                s.success = i.readyState === 4
            }
        } catch(a) {
            s = {
                success: false,
                isException: false
            }
        }
        o = n.isXdr ? t: s.success;
        if (o) {
            u = n.createResponse(e);
            n.fireEvent("requestcomplete", n, u, r);
            Ext.callback(r.success, r.scope, [u, r])
        } else {
            if (s.isException || e.aborted || e.timedout) {
                u = n.createException(e)
            } else {
                u = n.createResponse(e)
            }
            n.fireEvent("requestexception", n, u, r);
            Ext.callback(r.failure, r.scope, [u, r])
        }
        Ext.callback(r.callback, r.scope, [r, o, u]);
        delete n.requests[e.id];
        return u
    },
    parseStatus: function(e) {
        e = e == 1223 ? 204 : e;
        var t = e >= 200 && e < 300 || e == 304,
        n = false;
        if (!t) {
            switch (e) {
            case 12002:
            case 12029:
            case 12030:
            case 12031:
            case 12152:
            case 13030:
                n = true;
                break
            }
        }
        return {
            success: t,
            isException: n
        }
    },
    createResponse: function(e) {
        var t = this,
        n = e.xhr,
        r = t.isXdr,
        i = {},
        s = r ? [] : n.getAllResponseHeaders().replace(/\r\n/g, "\n").split("\n"),
        o = s.length,
        u,
        a,
        f,
        l,
        c;
        while (o--) {
            u = s[o];
            a = u.indexOf(":");
            if (a >= 0) {
                f = u.substr(0, a).toLowerCase();
                if (u.charAt(a + 1) == " ") {++a
                }
                i[f] = u.substr(a + 1)
            }
        }
        e.xhr = null;
        delete e.xhr;
        l = {
            request: e,
            requestId: e.id,
            status: n.status,
            statusText: n.statusText,
            getResponseHeader: function(e) {
                return i[e.toLowerCase()]
            },
            getAllResponseHeaders: function() {
                return i
            }
        };
        if (r) {
            t.processXdrResponse(l, n)
        }
        if (e.binary) {
            l.responseBytes = t.getByteArray(n)
        } else {
            l.responseText = n.responseText;
            l.responseXML = n.responseXML
        }
        n = null;
        return l
    },
    createException: function(e) {
        return {
            request: e,
            requestId: e.id,
            status: e.aborted ? -1 : 0,
            statusText: e.aborted ? "transaction aborted": "communication failure",
            aborted: e.aborted,
            timedout: e.timedout
        }
    },
    getByteArray: function(e) {
        var t = e.response,
        n = e.responseBody,
        r, i, s, o;
        if (e instanceof Ext.data.flash.BinaryXhr) {
            r = e.responseBytes
        } else {
            if (window.Uint8Array) {
                r = t ? new Uint8Array(t) : []
            } else {
                if (Ext.isIE9p) {
                    try {
                        r = (new VBArray(n)).toArray()
                    } catch(u) {
                        r = []
                    }
                } else {
                    if (Ext.isIE) {
                        if (!this.self.vbScriptInjected) {
                            this.injectVBScript()
                        }
                        getIEByteArray(e.responseBody, r = [])
                    } else {
                        r = [];
                        i = e.responseText;
                        s = i.length;
                        for (o = 0; o < s; o++) {
                            r.push(i.charCodeAt(o) & 255)
                        }
                    }
                }
            }
        }
        return r
    },
    injectVBScript: function() {
        var e = document.createElement("script");
        e.type = "text/vbscript";
        e.text = ["Function getIEByteArray(byteArray, out)", "Dim len, i", "len = LenB(byteArray)", "For i = 1 to len", "out.push(AscB(MidB(byteArray, i, 1)))", "Next", "End Function"].join("\n");
        Ext.getHead().dom.appendChild(e);
        this.self.vbScriptInjected = true
    },
    nativeBinaryPostSupport: function() {
        return Ext.isChrome || Ext.isSafari && Ext.isDefined(window.Uint8Array) || Ext.isGecko && Ext.isDefined(window.Uint8Array)
    }
});
Ext.define("Ext.Ajax", {
    extend: Ext.data.Connection,
    singleton: true,
    autoAbort: false
});
Ext.define("Ext.util.Floating", {
    focusOnToFront: true,
    shadow: "sides",
    constrain: false,
    constructor: function(e) {
        var t = this;
        t.fixed = t.fixed && !(Ext.isIE6 || Ext.isIEQuirks);
        t.el = new Ext.dom.Layer(Ext.apply({
            preventSync: true,
            hideMode: t.hideMode,
            shadow: typeof t.shadow != "undefined" ? t.shadow: "sides",
            shadowOffset: t.shadowOffset,
            constrain: false,
            fixed: t.fixed,
            shim: t.shim === false ? false: undefined
        },
        t.floating), e);
        if (t.modal && !Ext.enableFocusManager) {
            t.mon(t.el, {
                keydown: t.onKeyDown,
                scope: t
            })
        }
        t.mon(t.el, {
            mousedown: t.onMouseDown,
            scope: t
        });
        t.floating = true;
        t.registerWithOwnerCt();
        t.initHierarchyEvents()
    },
    initFloatConstrain: function() {
        var e = this,
        t = e.floatParent;
        if ((e.constrain || e.constrainHeader) && !e.constrainTo) {
            e.constrainTo = t ? t.getTargetEl() : e.container
        }
    },
    initHierarchyEvents: function() {
        var e = this,
        t = this.syncHidden;
        if (!e.hasHierarchyEventListeners) {
            e.mon(e.hierarchyEventSource, {
                hide: t,
                collapse: t,
                show: t,
                expand: t,
                added: t,
                scope: e
            });
            e.hasHierarchyEventListeners = true
        }
    },
    registerWithOwnerCt: function() {
        var e = this,
        t = e.ownerCt,
        n = e.zIndexParent;
        if (n) {
            n.unregisterFloatingItem(e)
        }
        n = e.zIndexParent = e.up("[floating]");
        e.floatParent = t || n;
        e.initFloatConstrain();
        delete e.ownerCt;
        if (n) {
            n.registerFloatingItem(e)
        } else {
            Ext.WindowManager.register(e)
        }
    },
    onKeyDown: function(e) {
        var t = this,
        n, r, i, s;
        if (e.getKey() == Ext.EventObject.TAB) {
            n = e.shiftKey;
            r = t.el.query(":focusable");
            i = r[0];
            s = r[r.length - 1];
            if (i && s && e.target === (n ? i: s)) {
                e.stopEvent(); (n ? s: i).focus(false, true)
            }
        }
    },
    onMouseDown: function(e) {
        var t = this.focusTask;
        if (this.floating && (!t || !t.id)) {
            this.toFront( !! e.getTarget(":focusable"))
        }
    },
    syncShadow: function() {
        if (this.floating) {
            this.el.sync(true)
        }
    },
    onBeforeFloatLayout: function() {
        this.el.preventSync = true
    },
    onAfterFloatLayout: function() {
        delete this.el.preventSync;
        this.syncShadow()
    },
    syncHidden: function() {
        var e = this,
        t = e.hidden || !e.rendered,
        n = e.hierarchicallyHidden = e.isHierarchicallyHidden(),
        r = e.pendingShow;
        if (t !== n) {
            if (n) {
                e.hide();
                e.pendingShow = true
            } else {
                if (r) {
                    delete e.pendingShow;
                    if (r.length) {
                        e.show.apply(e, r)
                    } else {
                        e.show()
                    }
                }
            }
        }
    },
    setZIndex: function(e) {
        var t = this;
        t.el.setZIndex(e);
        e += 10;
        if (t.floatingDescendants) {
            e = Math.floor(t.floatingDescendants.setBase(e) / 100) * 100 + 1e4
        }
        return e
    },
    doConstrain: function(e) {
        var t = this,
        n = t.calculateConstrainedPosition(e, null, true);
        if (n) {
            t.setPosition(n)
        }
    },
    toFront: function(e) {
        var t = this,
        n = t.zIndexParent,
        r = t.preventFocusOnActivate;
        if (n && t.bringParentToFront !== false) {
            n.toFront(true)
        }
        if (!Ext.isDefined(e)) {
            e = !t.focusOnToFront
        }
        if (e) {
            t.preventFocusOnActivate = true
        }
        if (t.zIndexManager.bringToFront(t, e)) {
            if (!e) {
                t.focus(false, true)
            }
            if (t.hasListeners.tofront) {
                t.fireEvent("tofront", t, t.el.getZIndex())
            }
        }
        t.preventFocusOnActivate = r;
        return t
    },
    setActive: function(e, t) {
        var n = this;
        if (e) {
            if (n.el.shadow && !n.maximized) {
                n.el.enableShadow(true)
            }
            if (!n.preventFocusOnActivate) {
                n.focus(false, true)
            }
            n.fireEvent("activate", n)
        } else {
            if (n.isWindow && t && t.isWindow && n.hideShadowOnDeactivate) {
                n.el.disableShadow()
            }
            n.fireEvent("deactivate", n)
        }
    },
    toBack: function() {
        this.zIndexManager.sendToBack(this);
        return this
    },
    center: function() {
        var e = this,
        t;
        if (e.isVisible()) {
            t = e.getAlignToXY(e.container, "c-c");
            e.setPagePosition(t)
        } else {
            e.needsCenter = true
        }
        return e
    },
    onFloatShow: function() {
        if (this.needsCenter) {
            this.center()
        }
        delete this.needsCenter;
        if (this.toFrontOnShow) {
            this.toFront()
        }
    },
    fitContainer: function(e) {
        var t = this,
        n = t.floatParent,
        r = n ? n.getTargetEl() : t.container,
        i = r.getViewSize(false),
        s = n || r.dom !== document.body ? [0, 0] : r.getXY();
        i.x = s[0];
        i.y = s[1];
        t.setBox(i, e)
    }
});
Ext.define("Ext.Component", {
    alias: ["widget.component", "widget.box"],
    extend: Ext.AbstractComponent,
    mixins: {
        floating: Ext.util.Floating
    },
    statics: {
        DIRECTION_TOP: "top",
        DIRECTION_RIGHT: "right",
        DIRECTION_BOTTOM: "bottom",
        DIRECTION_LEFT: "left",
        VERTICAL_DIRECTION_Re: /^(?:top|bottom)$/,
        INVALID_ID_CHARS_Re: /[\.,\s]/g
    },
    resizeHandles: "all",
    floating: false,
    defaultAlign: "c-c",
    alignTarget: null,
    toFrontOnShow: true,
    hideMode: "display",
    offsetsCls: Ext.baseCSSPrefix + "hide-offsets",
    bubbleEvents: [],
    defaultComponentLayoutType: "autocomponent",
    constructor: function(e) {
        var t = this;
        e = e || {};
        if (e.initialConfig) {
            if (e.isAction) {
                t.baseAction = e
            }
            e = e.initialConfig
        } else {
            if (e.tagName || e.dom || Ext.isString(e)) {
                e = {
                    applyTo: e,
                    id: e.id || e
                }
            }
        }
        t.callParent([e]);
        if (t.baseAction) {
            t.baseAction.addComponent(t)
        }
    },
    initComponent: function() {
        var e = this;
        e.callParent();
        if (e.listeners) {
            e.on(e.listeners);
            e.listeners = null
        }
        e.enableBubble(e.bubbleEvents)
    },
    afterRender: function() {
        var e = this;
        e.callParent();
        if (! (e.x && e.y) && (e.pageX || e.pageY)) {
            e.setPagePosition(e.pageX, e.pageY)
        }
    },
    setAutoScroll: function(e) {
        var t = this;
        t.autoScroll = !!e;
        if (t.rendered) {
            t.getOverflowEl().setStyle(t.getOverflowStyle())
        }
        t.updateLayout();
        return t
    },
    setOverflowXY: function(e, t) {
        var n = this,
        r = arguments.length,
        i = n.ownerCt;
        if (r) {
            n.overflowX = e || "";
            if (r > 1) {
                n.overflowY = t || ""
            }
        }
        if (n.rendered) {
            n.getOverflowEl().setStyle(n.getOverflowStyle())
        } (i || n).updateLayout();
        return n
    },
    beforeRender: function() {
        var e = this,
        t = e.floating,
        n;
        if (t) {
            e.addCls(Ext.baseCSSPrefix + "layer");
            n = t.cls;
            if (n) {
                e.addCls(n)
            }
        }
        return e.callParent()
    },
    beforeLayout: function() {
        this.callParent(arguments);
        if (this.floating) {
            this.onBeforeFloatLayout()
        }
    },
    afterComponentLayout: function() {
        this.callParent(arguments);
        if (this.floating) {
            this.onAfterFloatLayout()
        }
    },
    makeFloating: function(e) {
        this.mixins.floating.constructor.call(this, e)
    },
    wrapPrimaryEl: function(e) {
        if (this.floating) {
            this.makeFloating(e)
        } else {
            this.callParent(arguments)
        }
    },
    initResizable: function(e) {
        var t = this;
        e = Ext.apply({
            target: t,
            dynamic: false,
            constrainTo: t.constrainTo || (t.floatParent ? t.floatParent.getTargetEl() : null),
            handles: t.resizeHandles
        },
        e);
        e.target = t;
        t.resizer = new Ext.resizer.Resizer(e)
    },
    getDragEl: function() {
        return this.el
    },
    initDraggable: function() {
        var e = this,
        t = e.resizer && e.resizer.el !== e.el ? e.resizerComponent = new Ext.Component({
            ariaRole: "presentation",
            el: e.resizer.el,
            rendered: true,
            container: e.container
        }) : e,
        n = Ext.applyIf({
            el: t.getDragEl(),
            constrainTo: e.constrain || e.draggable.constrain ? e.constrainTo || (e.floatParent ? e.floatParent.getTargetEl() : e.container) : undefined
        },
        e.draggable);
        if (e.constrain || e.constrainDelegate) {
            n.constrain = e.constrain;
            n.constrainDelegate = e.constrainDelegate
        }
        e.dd = new Ext.util.ComponentDragger(t, n)
    },
    scrollBy: function(e, t, n) {
        var r;
        if ((r = this.getTargetEl()) && r.dom) {
            r.scrollBy.apply(r, arguments)
        }
    },
    setLoading: function(e, t) {
        var n = this,
        r = {
            target: n
        };
        if (n.rendered) {
            if (e !== false) {
                if (Ext.isString(e)) {
                    r.msg = e
                } else {
                    Ext.apply(r, e)
                }
                if (!n.loadMask || !n.loadMask.isLoadMask) {
                    if (t && r.useTargetEl == null) {
                        r.useTargetEl = true
                    }
                    n.loadMask = new Ext.LoadMask(r)
                } else {
                    Ext.apply(n.loadMask, r)
                }
                if (n.loadMask.isVisible()) {
                    n.loadMask.afterShow()
                } else {
                    n.loadMask.show()
                }
            } else {
                if (n.loadMask && n.loadMask.isLoadMask) {
                    n.loadMask.hide()
                }
            }
        }
        return n.loadMask
    },
    beforeSetPosition: function() {
        var e = this,
        t = e.callParent(arguments),
        n;
        if (t) {
            n = e.adjustPosition(t.x, t.y);
            t.x = n.x;
            t.y = n.y
        }
        return t || null
    },
    afterSetPosition: function(e, t) {
        this.onPosition(e, t);
        this.fireEvent("move", this, e, t)
    },
    showAt: function(e, t, n) {
        var r = this;
        if (!r.rendered && (r.autoRender || r.floating)) {
            r.x = e;
            r.y = t;
            return r.show()
        }
        if (r.floating) {
            r.setPosition(e, t, n)
        } else {
            r.setPagePosition(e, t, n)
        }
        r.show()
    },
    showBy: function(e, t, n) {
        var r = this;
        if (r.floating && e) {
            r.alignTarget = e;
            if (t) {
                r.defaultAlign = t
            }
            if (n) {
                r.alignOffset = n
            }
            r.show();
            if (!r.hidden) {
                r.alignTo(e, t || r.defaultAlign, n || r.alignOffset)
            }
        }
        return r
    },
    setPagePosition: function(e, t, n) {
        var r = this,
        i, s;
        if (Ext.isArray(e)) {
            t = e[1];
            e = e[0]
        }
        r.pageX = e;
        r.pageY = t;
        if (r.floating) {
            if (r.isContainedFloater()) {
                s = r.floatParent.getTargetEl().getViewRegion();
                if (Ext.isNumber(e) && Ext.isNumber(s.left)) {
                    e -= s.left
                }
                if (Ext.isNumber(t) && Ext.isNumber(s.top)) {
                    t -= s.top
                }
            } else {
                i = r.el.translateXY(e, t);
                e = i.x;
                t = i.y
            }
            r.setPosition(e, t, n)
        } else {
            i = r.el.translateXY(e, t);
            r.setPosition(i.x, i.y, n)
        }
        return r
    },
    isContainedFloater: function() {
        return this.floating && this.floatParent
    },
    updateBox: function(e) {
        this.setSize(e.width, e.height);
        this.setPagePosition(e.x, e.y);
        return this
    },
    getOuterSize: function() {
        var e = this.el;
        return {
            width: e.getWidth() + e.getMargin("lr"),
            height: e.getHeight() + e.getMargin("tb")
        }
    },
    adjustPosition: function(e, t) {
        var n = this,
        r;
        if (n.isContainedFloater()) {
            r = n.floatParent.getTargetEl().getViewRegion();
            e += r.left;
            t += r.top
        }
        return {
            x: e,
            y: t
        }
    },
    getPosition: function(e) {
        var t = this,
        n, r = t.isContainedFloater(),
        i;
        if (e === true && !r) {
            return [t.getLocalX(), t.getLocalY()]
        }
        n = t.getXY();
        if (e === true && r) {
            i = t.floatParent.getTargetEl().getViewRegion();
            n[0] -= i.left;
            n[1] -= i.top
        }
        return n
    },
    getId: function() {
        var e = this,
        t;
        if (!e.id) {
            t = e.getXType();
            if (t) {
                t = t.replace(Ext.Component.INVALID_ID_CHARS_Re, "-")
            } else {
                t = Ext.name.toLowerCase() + "-comp"
            }
            e.id = t + "-" + e.getAutoId()
        }
        return e.id
    },
    show: function(e, t, n) {
        var r = this,
        i = r.rendered;
        if (r.hierarchicallyHidden || r.floating && !i && r.isHierarchicallyHidden()) {
            if (!i) {
                r.initHierarchyEvents()
            }
            if (arguments.length > 1) {
                arguments[0] = null;
                r.pendingShow = arguments
            } else {
                r.pendingShow = true
            }
        } else {
            if (i && r.isVisible()) {
                if (r.floating) {
                    r.onFloatShow()
                }
            } else {
                if (r.fireEvent("beforeshow", r) !== false) {
                    r.hidden = false;
                    delete this.getHierarchyState().hidden;
                    Ext.suspendLayouts();
                    if (!i && (r.autoRender || r.floating)) {
                        r.doAutoRender();
                        i = r.rendered
                    }
                    if (i) {
                        r.beforeShow();
                        Ext.resumeLayouts();
                        r.onShow.apply(r, arguments);
                        r.afterShow.apply(r, arguments)
                    } else {
                        Ext.resumeLayouts(true)
                    }
                } else {
                    r.onShowVeto()
                }
            }
        }
        return r
    },
    onShowVeto: Ext.emptyFn,
    beforeShow: Ext.emptyFn,
    onShow: function() {
        var e = this;
        e.el.show();
        e.callParent(arguments);
        if (e.floating) {
            if (e.maximized) {
                e.fitContainer()
            } else {
                if (e.constrain) {
                    e.doConstrain()
                }
            }
        }
    },
    getAnimateTarget: function(e) {
        e = e || this.animateTarget;
        if (e) {
            e = e.isComponent ? e.getEl() : Ext.get(e)
        }
        return e || null
    },
    afterShow: function(e, t, n) {
        var r = this,
        i = r.el,
        s, o, u;
        e = r.getAnimateTarget(e);
        if (!r.ghost) {
            e = null
        }
        if (e) {
            o = {
                x: i.getX(),
                y: i.getY(),
                width: i.dom.offsetWidth,
                height: i.dom.offsetHeight
            };
            s = {
                x: e.getX(),
                y: e.getY(),
                width: e.dom.offsetWidth,
                height: e.dom.offsetHeight
            };
            i.addCls(r.offsetsCls);
            u = r.ghost();
            u.el.stopAnimation();
            u.setX( - 1e4);
            r.ghostBox = o;
            u.el.animate({
                from: s,
                to: o,
                listeners: {
                    afteranimate: function() {
                        delete u.componentLayout.lastComponentSize;
                        r.unghost();
                        delete r.ghostBox;
                        i.removeCls(r.offsetsCls);
                        r.onShowComplete(t, n)
                    }
                }
            })
        } else {
            r.onShowComplete(t, n)
        }
        r.fireHierarchyEvent("show")
    },
    onShowComplete: function(e, t) {
        var n = this;
        if (n.floating) {
            n.onFloatShow()
        }
        Ext.callback(e, t || n);
        n.fireEvent("show", n);
        delete n.hiddenByLayout
    },
    hide: function(e, t, n) {
        var r = this,
        i;
        if (r.pendingShow) {
            delete r.pendingShow
        }
        if (! (r.rendered && !r.isVisible())) {
            i = r.fireEvent("beforehide", r) !== false;
            if (r.hierarchicallyHidden || i) {
                r.hidden = true;
                r.getHierarchyState().hidden = true;
                if (r.rendered) {
                    r.onHide.apply(r, arguments)
                }
            }
        }
        return r
    },
    onHide: function(e, t, n) {
        var r = this,
        i, s, o, u = Ext.Element.getActiveElement();
        if (u === r.el || r.el.contains(u)) {
            Ext.fly(u).blur()
        }
        e = r.getAnimateTarget(e);
        if (!r.ghost) {
            e = null
        }
        if (e) {
            o = {
                x: e.getX(),
                y: e.getY(),
                width: e.dom.offsetWidth,
                height: e.dom.offsetHeight
            };
            i = r.ghost();
            i.el.stopAnimation();
            s = r.getSize();
            i.el.animate({
                to: o,
                listeners: {
                    afteranimate: function() {
                        delete i.componentLayout.lastComponentSize;
                        i.el.hide();
                        i.setHiddenState(true);
                        i.el.setSize(s);
                        r.afterHide(t, n)
                    }
                }
            })
        }
        r.el.hide();
        if (!e) {
            r.afterHide(t, n)
        }
    },
    afterHide: function(e, t) {
        var n = this;
        n.hiddenByLayout = null;
        Ext.AbstractComponent.prototype.onHide.call(n);
        Ext.callback(e, t || n);
        n.fireEvent("hide", n);
        n.fireHierarchyEvent("hide")
    },
    onDestroy: function() {
        var e = this;
        if (e.rendered) {
            Ext.destroy(e.dd, e.resizer, e.proxy, e.proxyWrap, e.resizerComponent, e.loadMask)
        }
        delete e.focusTask;
        e.callParent()
    },
    deleteMembers: function() {
        var e = arguments,
        t = e.length,
        n = 0;
        for (; n < t; ++n) {
            delete this[e[n]]
        }
    },
    focus: function(e, t, n, r) {
        var i = this,
        s, o, u;
        if (t) {
            i.getFocusTask().delay(Ext.isNumber(t) ? t: 10, i.focus, i, [e, false, n, r]);
            return i
        }
        if (i.focusTask) {
            i.focusTask.cancel()
        }
        if (i.rendered && !i.isDestroyed && i.isVisible(true) && (s = i.getFocusEl())) {
            if (s.isComponent) {
                return s.focus(e, t)
            }
            if (o = s.dom) {
                if (s.needsTabIndex()) {
                    o.tabIndex = -1
                }
                if (i.floating) {
                    u = i.container.dom.scrollTop
                }
                s.focus();
                if (e) {
                    if (Ext.isArray(e)) {
                        if (i.selectText) {
                            i.selectText.apply(i, e)
                        }
                    } else {
                        o.select()
                    }
                }
                Ext.callback(n, r)
            }
            if (i.floating) {
                if (i !== i.zIndexManager.getActive()) {
                    i.toFront(true)
                }
                if (u !== undefined) {
                    i.container.dom.scrollTop = u
                }
            }
        }
        return i
    },
    getFocusTask: function() {
        if (!this.focusTask) {
            Ext.Component.prototype.focusTask = new Ext.util.DelayedTask
        }
        return this.focusTask
    },
    cancelFocus: function() {
        var e = this.focusTask;
        if (e) {
            e.cancel()
        }
    },
    blur: function() {
        var e = this,
        t;
        if (e.rendered && (t = e.getFocusEl())) {
            e.blurring = true;
            t.blur();
            delete e.blurring
        }
        return e
    },
    getEl: function() {
        return this.el
    },
    getResizeEl: function() {
        return this.el
    },
    getPositionEl: function() {
        return this.el
    },
    getActionEl: function() {
        return this.el
    },
    getVisibilityEl: function() {
        return this.el
    },
    getRefOwner: function() {
        return this.ownerCt || this.ownerCmp || this.floatParent
    },
    getBubbleTarget: function() {
        return this.getRefOwner()
    },
    getContentTarget: function() {
        return this.el
    },
    cloneConfig: function(e) {
        e = e || {};
        var t = e.id || Ext.id(),
        n = Ext.applyIf(e, this.initialConfig),
        r;
        n.id = t;
        r = Ext.getClass(this);
        return new r(n)
    },
    getXType: function() {
        return this.self.xtype
    },
    findParentBy: function(e) {
        var t;
        for (t = this.getBubbleTarget(); t && !e(t, this); t = t.getBubbleTarget()) {}
        return t || null
    },
    findParentByType: function(e) {
        return Ext.isFunction(e) ? this.findParentBy(function(t) {
            return t.constructor === e
        }) : this.up(e)
    },
    bubble: function(e, t, n) {
        var r = this;
        while (r) {
            if (e.apply(t || r, n || [r]) === false) {
                break
            }
            r = r.getBubbleTarget()
        }
        return this
    },
    getProxy: function() {
        var e = this,
        t;
        if (!e.proxy) {
            t = Ext.getBody();
            e.proxy = e.el.createProxy(Ext.baseCSSPrefix + "proxy-el", t, true)
        }
        return e.proxy
    },
    fireHierarchyEvent: function(e) {
        this.hierarchyEventSource.fireEvent(e, this)
    },
    onAdded: function() {
        this.callParent(arguments);
        if (this.hierarchyEventSource.hasListeners.added) {
            this.fireHierarchyEvent("added")
        }
    }
},
function() {
    this.hierarchyEventSource = this.prototype.hierarchyEventSource = new Ext.util.Observable({
        events: {
            hide: true,
            show: true,
            collapse: true,
            expand: true,
            added: true
        }
    })
});
Ext.define("Ext.layout.container.border.Region", {
    override: "Ext.Component",
    initBorderRegion: function() {
        var e = this;
        if (!e._borderRegionInited) {
            e._borderRegionInited = true;
            e.addStateEvents(["changeregion", "changeweight"]);
            Ext.override(e, {
                getState: function() {
                    var t = e.callParent();
                    t = e.addPropertyToState(t, "region");
                    t = e.addPropertyToState(t, "weight");
                    return t
                }
            })
        }
    },
    getOwningBorderContainer: function() {
        var e = this.getOwningBorderLayout();
        return e && e.owner
    },
    getOwningBorderLayout: function() {
        var e = this.ownerLayout;
        return e && e.isBorderLayout ? e: null
    },
    setBorderRegion: function(e) {
        var t = this,
        n, r = t.region;
        if (e !== r) {
            n = t.getOwningBorderLayout();
            if (n) {
                var i = n.regionFlags[e],
                s = t.placeholder,
                o = t.splitter,
                u = n.owner,
                a = n.regionMeta,
                f = t.collapsed || t.floated,
                l,
                c,
                h;
                if (t.fireEventArgs("beforechangeregion", [t, e]) === false) {
                    return r
                }
                Ext.suspendLayouts();
                t.region = e;
                Ext.apply(t, i);
                if (t.updateCollapseTool) {
                    t.updateCollapseTool()
                }
                if (o) {
                    Ext.apply(o, i);
                    o.updateOrientation();
                    c = u.items;
                    h = c.indexOf(t);
                    if (h >= 0) {
                        l = a[e].splitterDelta;
                        if (c.getAt(h + l) !== o) {
                            c.remove(o);
                            h = c.indexOf(t);
                            if (l > 0) {++h
                            }
                            c.insert(h, o)
                        }
                    }
                }
                if (s) {
                    if (f) {
                        t.expand(false)
                    }
                    u.remove(s);
                    t.placeholder = null;
                    if (f) {
                        t.collapse(null, false)
                    }
                }
                u.updateLayout();
                Ext.resumeLayouts(true);
                t.fireEventArgs("changeregion", [t, r])
            } else {
                t.region = e
            }
        }
        return r
    },
    setRegionWeight: function(e) {
        var t = this,
        n = t.getOwningBorderContainer(),
        r = t.placeholder,
        i = t.weight;
        if (e !== i) {
            if (t.fireEventArgs("beforechangeweight", [t, e]) !== false) {
                t.weight = e;
                if (r) {
                    r.weight = e
                }
                if (n) {
                    n.updateLayout()
                }
                t.fireEventArgs("changeweight", [t, i])
            }
        }
        return i
    }
});
Ext.define("Ext.ElementLoader", {
    mixins: {
        observable: Ext.util.Observable
    },
    statics: {
        Renderer: {
            Html: function(e, t, n) {
                e.getTarget().update(t.responseText, n.scripts === true);
                return true
            }
        }
    },
    url: null,
    params: null,
    baseParams: null,
    autoLoad: false,
    target: null,
    loadMask: false,
    ajaxOptions: null,
    scripts: false,
    isLoader: true,
    constructor: function(e) {
        var t = this,
        n;
        e = e || {};
        Ext.apply(t, e);
        t.setTarget(t.target);
        t.addEvents("beforeload", "exception", "load");
        t.mixins.observable.constructor.call(t);
        if (t.autoLoad) {
            n = t.autoLoad;
            if (n === true) {
                n = {}
            }
            t.load(n)
        }
    },
    setTarget: function(e) {
        var t = this;
        e = Ext.get(e);
        if (t.target && t.target != e) {
            t.abort()
        }
        t.target = e
    },
    getTarget: function() {
        return this.target || null
    },
    abort: function() {
        var e = this.active;
        if (e !== undefined) {
            Ext.Ajax.abort(e.request);
            if (e.mask) {
                this.removeMask()
            }
            delete this.active
        }
    },
    removeMask: function() {
        this.target.unmask()
    },
    addMask: function(e) {
        this.target.mask(e === true ? null: e)
    },
    load: function(e) {
        e = Ext.apply({},
        e);
        var t = this,
        n = Ext.isDefined(e.loadMask) ? e.loadMask: t.loadMask,
        r = Ext.apply({},
        e.params),
        i = Ext.apply({},
        e.ajaxOptions),
        s = e.callback || t.callback,
        o = e.scope || t.scope || t;
        Ext.applyIf(i, t.ajaxOptions);
        Ext.applyIf(e, i);
        Ext.applyIf(r, t.params);
        Ext.apply(r, t.baseParams);
        Ext.applyIf(e, {
            url: t.url
        });
        Ext.apply(e, {
            scope: t,
            params: r,
            callback: t.onComplete
        });
        if (t.fireEvent("beforeload", t, e) === false) {
            return
        }
        if (n) {
            t.addMask(n)
        }
        t.active = {
            options: e,
            mask: n,
            scope: o,
            callback: s,
            success: e.success || t.success,
            failure: e.failure || t.failure,
            renderer: e.renderer || t.renderer,
            scripts: Ext.isDefined(e.scripts) ? e.scripts: t.scripts
        };
        t.active.request = Ext.Ajax.request(e);
        t.setOptions(t.active, e)
    },
    setOptions: Ext.emptyFn,
    onComplete: function(e, t, n) {
        var r = this,
        i = r.active,
        s;
        if (i) {
            s = i.scope;
            if (t) {
                t = r.getRenderer(i.renderer).call(r, r, n, i) !== false
            }
            if (t) {
                Ext.callback(i.success, s, [r, n, e]);
                r.fireEvent("load", r, n, e)
            } else {
                Ext.callback(i.failure, s, [r, n, e]);
                r.fireEvent("exception", r, n, e)
            }
            Ext.callback(i.callback, s, [r, t, n, e]);
            if (i.mask) {
                r.removeMask()
            }
        }
        delete r.active
    },
    getRenderer: function(e) {
        if (Ext.isFunction(e)) {
            return e
        }
        return this.statics().Renderer.Html
    },
    startAutoRefresh: function(e, t) {
        var n = this;
        n.stopAutoRefresh();
        n.autoRefresh = setInterval(function() {
            n.load(t)
        },
        e)
    },
    stopAutoRefresh: function() {
        clearInterval(this.autoRefresh);
        delete this.autoRefresh
    },
    isAutoRefreshing: function() {
        return Ext.isDefined(this.autoRefresh)
    },
    destroy: function() {
        var e = this;
        e.stopAutoRefresh();
        delete e.target;
        e.abort();
        e.clearListeners()
    }
});
Ext.define("Ext.ComponentLoader", {
    extend: Ext.ElementLoader,
    statics: {
        Renderer: {
            Data: function(e, t, n) {
                var r = true;
                try {
                    e.getTarget().update(Ext.decode(t.responseText))
                } catch(i) {
                    r = false
                }
                return r
            },
            Component: function(e, t, n) {
                var r = true,
                i = e.getTarget(),
                s = [];
                try {
                    s = Ext.decode(t.responseText)
                } catch(o) {
                    r = false
                }
                if (r) {
                    i.suspendLayouts();
                    if (n.removeAll) {
                        i.removeAll()
                    }
                    i.add(s);
                    i.resumeLayouts(true)
                }
                return r
            }
        }
    },
    target: null,
    loadMask: false,
    renderer: "html",
    setTarget: function(e) {
        var t = this;
        if (Ext.isString(e)) {
            e = Ext.getCmp(e)
        }
        if (t.target && t.target != e) {
            t.abort()
        }
        t.target = e
    },
    removeMask: function() {
        this.target.setLoading(false)
    },
    addMask: function(e) {
        this.target.setLoading(e)
    },
    setOptions: function(e, t) {
        e.removeAll = Ext.isDefined(t.removeAll) ? t.removeAll: this.removeAll
    },
    getRenderer: function(e) {
        if (Ext.isFunction(e)) {
            return e
        }
        var t = this.statics().Renderer;
        switch (e) {
        case "component":
            return t.Component;
        case "data":
            return t.Data;
        default:
            return Ext.ElementLoader.Renderer.Html
        }
    }
});
Ext.define("Ext.layout.SizeModel", {
    constructor: function(e) {
        var t = this,
        n = t.self,
        r = n.sizeModelsArray,
        i;
        Ext.apply(t, e);
        t[i = t.name] = true;
        t.fixed = !(t.auto = t.natural || t.shrinkWrap);
        r[t.ordinal = r.length] = n[i] = n.sizeModels[i] = t
    },
    statics: {
        sizeModelsArray: [],
        sizeModels: {}
    },
    calculated: false,
    configured: false,
    constrainedMax: false,
    constrainedMin: false,
    natural: false,
    shrinkWrap: false,
    calculatedFromConfigured: false,
    calculatedFromNatural: false,
    calculatedFromShrinkWrap: false,
    names: null
},
function() {
    var e = this,
    t = e.sizeModelsArray,
    n, r, i, s, o;
    new e({
        name: "calculated"
    });
    new e({
        name: "configured",
        names: {
            width: "width",
            height: "height"
        }
    });
    new e({
        name: "natural"
    });
    new e({
        name: "shrinkWrap"
    });
    new e({
        name: "calculatedFromConfigured",
        configured: true,
        names: {
            width: "width",
            height: "height"
        }
    });
    new e({
        name: "calculatedFromNatural",
        natural: true
    });
    new e({
        name: "calculatedFromShrinkWrap",
        shrinkWrap: true
    });
    new e({
        name: "constrainedMax",
        configured: true,
        constrained: true,
        names: {
            width: "maxWidth",
            height: "maxHeight"
        }
    });
    new e({
        name: "constrainedMin",
        configured: true,
        constrained: true,
        names: {
            width: "minWidth",
            height: "minHeight"
        }
    });
    new e({
        name: "constrainedDock",
        configured: true,
        constrained: true,
        constrainedByMin: true,
        names: {
            width: "dockConstrainedWidth",
            height: "dockConstrainedHeight"
        }
    });
    for (n = 0, i = t.length; n < i; ++n) {
        o = t[n];
        o.pairsByHeightOrdinal = s = [];
        for (r = 0; r < i; ++r) {
            s.push({
                width: o,
                height: t[r]
            })
        }
    }
});
Ext.define("Ext.layout.Layout", {
    isLayout: true,
    initialized: false,
    running: false,
    autoSizePolicy: {
        readsWidth: 1,
        readsHeight: 1,
        setsWidth: 0,
        setsHeight: 0
    },
    statics: {
        layoutsByType: {},
        create: function(e, t) {
            var n = Ext.ClassManager,
            r = this.layoutsByType,
            i, s, o, u, a, f;
            if (!e || typeof e === "string") {
                a = e || t;
                o = {}
            } else {
                if (e.isLayout) {
                    return e
                } else {
                    o = e;
                    a = e.type || t
                }
            }
            if (! (u = r[a])) {
                i = "layout." + a;
                s = n.getNameByAlias(i);
                if (!s) {
                    f = true
                }
                u = n.get(s);
                if (f || !u) {
                    return n.instantiateByAlias(i, o || {})
                }
                r[a] = u
            }
            return new u(o)
        }
    },
    constructor: function(e) {
        var t = this;
        t.id = Ext.id(null, t.type + "-");
        Ext.apply(t, e);
        t.layoutCount = 0
    },
    beginLayout: Ext.emptyFn,
    beginLayoutCycle: function(e) {
        var t = this,
        n = t.context,
        r;
        if (t.lastWidthModel != e.widthModel) {
            if (t.lastWidthModel) {
                r = true
            }
            t.lastWidthModel = e.widthModel
        }
        if (t.lastHeightModel != e.heightModel) {
            if (t.lastWidthModel) {
                r = true
            }
            t.lastHeightModel = e.heightModel
        }
        if (r) { (n = e.context).clearTriggers(t, false);
            n.clearTriggers(t, true);
            t.triggerCount = 0
        }
    },
    finishedLayout: function(e) {
        this.lastWidthModel = e.widthModel;
        this.lastHeightModel = e.heightModel;
        this.ownerContext = null
    },
    redoLayout: Ext.emptyFn,
    undoLayout: Ext.emptyFn,
    getAnimatePolicy: function() {
        return this.animatePolicy
    },
    getItemSizePolicy: function(e) {
        return this.autoSizePolicy
    },
    isItemBoxParent: function(e) {
        return false
    },
    isItemLayoutRoot: function(e) {
        var t = e.getSizeModel(),
        n = t.width,
        r = t.height;
        if (!e.componentLayout.lastComponentSize && (n.calculated || r.calculated)) {
            return false
        }
        return ! n.shrinkWrap && !r.shrinkWrap
    },
    isItemShrinkWrap: function(e) {
        return e.shrinkWrap
    },
    isRunning: function() {
        return !! this.ownerContext
    },
    getItemsRenderTree: function(e, t) {
        var n = e.length,
        r, i, s, o;
        if (n) {
            o = [];
            for (r = 0; r < n; ++r) {
                i = e[r];
                if (!i.rendered) {
                    if (t && t[i.id] !== undefined) {
                        s = t[i.id]
                    } else {
                        this.configureItem(i);
                        s = i.getRenderTree();
                        if (t) {
                            t[i.id] = s
                        }
                    }
                    if (s) {
                        o.push(s)
                    }
                }
            }
        }
        return o
    },
    finishRender: Ext.emptyFn,
    finishRenderItems: function(e, t) {
        var n = t.length,
        r, i;
        for (r = 0; r < n; r++) {
            i = t[r];
            if (i.rendering) {
                i.finishRender(r);
                this.afterRenderItem(i)
            }
        }
    },
    renderChildren: function() {
        var e = this,
        t = e.getLayoutItems(),
        n = e.getRenderTarget();
        e.renderItems(t, n)
    },
    renderItems: function(e, t) {
        var n = this,
        r = e.length,
        i = 0,
        s;
        if (r) {
            Ext.suspendLayouts();
            for (; i < r; i++) {
                s = e[i];
                if (s && !s.rendered) {
                    n.renderItem(s, t, i)
                } else {
                    if (!n.isValidParent(s, t, i)) {
                        n.moveItem(s, t, i)
                    } else {
                        n.configureItem(s)
                    }
                }
            }
            Ext.resumeLayouts(true)
        }
    },
    isValidParent: function(e, t, n) {
        var r = e.el ? e.el.dom: Ext.getDom(e),
        i = t && t.dom || t,
        s = r.parentNode,
        o;
        if (s) {
            o = s.className;
            if (o && o.indexOf(Ext.baseCSSPrefix + "resizable-wrap") !== -1) {
                r = r.parentNode
            }
        }
        if (r && i) {
            if (typeof n == "number") {
                n = this.getPositionOffset(n);
                return r === i.childNodes[n]
            }
            return r.parentNode === i
        }
        return false
    },
    getPositionOffset: function(e) {
        return e
    },
    configureItem: function(e) {
        e.ownerLayout = this
    },
    renderItem: function(e, t, n) {
        var r = this;
        if (!e.rendered) {
            r.configureItem(e);
            e.render(t, n);
            r.afterRenderItem(e)
        }
    },
    moveItem: function(e, t, n) {
        t = t.dom || t;
        if (typeof n == "number") {
            n = t.childNodes[n]
        }
        t.insertBefore(e.el.dom, n || null);
        e.container = Ext.get(t);
        this.configureItem(e)
    },
    onContentChange: function() {
        this.owner.updateLayout();
        return true
    },
    initLayout: function() {
        this.initialized = true
    },
    setOwner: function(e) {
        this.owner = e
    },
    getLayoutItems: function() {
        return []
    },
    onAdd: function(e) {
        e.ownerLayout = this
    },
    afterRenderItem: Ext.emptyFn,
    onRemove: Ext.emptyFn,
    onDestroy: Ext.emptyFn,
    afterRemove: function(e) {
        var t = this,
        n = e.el,
        r = t.owner,
        i;
        if (e.rendered) {
            i = [].concat(t.itemCls || []);
            if (r.itemCls) {
                i = Ext.Array.push(i, r.itemCls)
            }
            if (i.length) {
                n.removeCls(i)
            }
        }
        delete e.ownerLayout
    },
    destroy: function() {
        var e = this,
        t;
        if (e.targetCls) {
            t = e.getTarget();
            if (t) {
                t.removeCls(e.targetCls)
            }
        }
        e.onDestroy()
    },
    sortWeightedItems: function(e, t) {
        for (var n = 0,
        r = e.length; n < r; ++n) {
            e[n].$i = n
        }
        Ext.Array.sort(e,
        function(e, n) {
            var r = n.weight - e.weight;
            if (!r) {
                r = e.$i - n.$i;
                if (e[t]) {
                    r = -r
                }
            }
            return r
        });
        for (n = 0; n < r; ++n) {
            delete e[n].$i
        }
    }
},
function() {
    var e = this;
    e.prototype.sizeModels = e.sizeModels = Ext.layout.SizeModel.sizeModels
});
Ext.define("Ext.layout.container.Container", {
    alias: ["layout.container"],
    extend: Ext.layout.Layout,
    alternateClassName: "Ext.layout.ContainerLayout",
    mixins: {
        elementCt: Ext.util.ElementContainer
    },
    type: "container",
    beginCollapse: Ext.emptyFn,
    beginExpand: Ext.emptyFn,
    animatePolicy: null,
    childEls: ["overflowPadderEl"],
    renderTpl: ["{%this.renderBody(out,values)%}"],
    usesContainerHeight: true,
    usesContainerWidth: true,
    usesHeight: true,
    usesWidth: true,
    constructor: function() {
        this.callParent(arguments);
        this.mixins.elementCt.constructor.call(this)
    },
    destroy: function() {
        this.callParent();
        this.mixins.elementCt.destroy.call(this)
    },
    beginLayout: function(e) {
        this.callParent(arguments);
        e.targetContext = e.paddingContext = e.getEl("getTarget", this);
        this.cacheChildItems(e)
    },
    beginLayoutCycle: function(e, t) {
        var n = this;
        n.callParent(arguments);
        if (t) {
            if (n.usesContainerHeight) {++e.consumersContainerHeight
            }
            if (n.usesContainerWidth) {++e.consumersContainerWidth
            }
        }
    },
    cacheChildItems: function(e) {
        var t = e.context,
        n = [],
        r = this.getVisibleItems(),
        i = r.length,
        s;
        e.childItems = n;
        e.visibleItems = r;
        for (s = 0; s < i; ++s) {
            n.push(t.getCmp(r[s]))
        }
    },
    cacheElements: function() {
        var e = this.owner;
        this.applyChildEls(e.el, e.id)
    },
    configureItem: function(e) {
        var t = this,
        n = t.itemCls,
        r = t.owner.itemCls,
        i, s;
        e.ownerLayout = t;
        if (n) {
            if (typeof n === "string") {
                s = [n]
            } else {
                s = n;
                i = !!s
            }
        }
        if (r) {
            if (i) {
                s = Ext.Array.clone(s)
            }
            s = Ext.Array.push(s || [], r)
        }
        if (s) {
            e.addCls(s)
        }
    },
    doRenderBody: function(e, t) {
        this.renderItems(e, t);
        this.renderContent(e, t)
    },
    doRenderContainer: function(e, t) {
        var n = t.$comp.layout,
        r = n.getRenderTpl(),
        i = n.getRenderData();
        r.applyOut(i, e)
    },
    doRenderItems: function(e, t) {
        var n = t.$layout,
        r = n.getRenderTree();
        if (r) {
            Ext.DomHelper.generateMarkup(r, e)
        }
    },
    finishRender: function() {
        var e = this,
        t, n;
        e.callParent();
        e.cacheElements();
        t = e.getRenderTarget();
        n = e.getLayoutItems();
        e.finishRenderItems(t, n)
    },
    notifyOwner: function() {
        this.owner.afterLayout(this)
    },
    getContainerSize: function(e, t) {
        var n = e.targetContext,
        r = n.getFrameInfo(),
        i = e.paddingContext.getPaddingInfo(),
        s = 0,
        o = 0,
        u,
        a,
        f,
        l;
        if (!e.widthModel.shrinkWrap) {++o;
            f = t ? n.getDomProp("width") : n.getProp("width");
            u = typeof f == "number";
            if (u) {++s;
                f -= r.width + i.width;
                if (f < 0) {
                    f = 0
                }
            }
        }
        if (!e.heightModel.shrinkWrap) {++o;
            l = t ? n.getDomProp("height") : n.getProp("height");
            a = typeof l == "number";
            if (a) {++s;
                l -= r.height + i.height;
                if (l < 0) {
                    l = 0
                }
            }
        }
        return {
            width: f,
            height: l,
            needed: o,
            got: s,
            gotAll: s == o,
            gotWidth: u,
            gotHeight: a
        }
    },
    getPositionOffset: function(e) {
        if (!this.createsInnerCt) {
            var t = this.owner.itemNodeOffset;
            if (t) {
                e += t
            }
        }
        return e
    },
    getLayoutItems: function() {
        var e = this.owner,
        t = e && e.items;
        return t && t.items || []
    },
    getRenderData: function() {
        var e = this.owner;
        return {
            $comp: e,
            $layout: this,
            ownerId: e.id
        }
    },
    getRenderedItems: function() {
        var e = this,
        t = e.getRenderTarget(),
        n = e.getLayoutItems(),
        r = n.length,
        i = [],
        s,
        o;
        for (s = 0; s < r; s++) {
            o = n[s];
            if (o.rendered && e.isValidParent(o, t, s)) {
                i.push(o)
            }
        }
        return i
    },
    getRenderTarget: function() {
        return this.owner.getTargetEl()
    },
    getElementTarget: function() {
        return this.getRenderTarget()
    },
    getRenderTpl: function() {
        var e = this,
        t = Ext.XTemplate.getTpl(this, "renderTpl");
        if (!t.renderContent) {
            e.owner.setupRenderTpl(t)
        }
        return t
    },
    getRenderTree: function() {
        var e, t = this.owner.items,
        n, r = {};
        do {
            n = t.generation;
            e = this.getItemsRenderTree(this.getLayoutItems(), r)
        } while ( t . generation !== n );
        return e
    },
    renderChildren: function() {
        var e = this,
        t = e.owner.items,
        n = e.getRenderTarget(),
        r,
        i;
        do {
            r = t.generation;
            i = e.getLayoutItems();
            e.renderItems(i, n)
        } while ( t . generation !== r )
    },
    getScrollbarsNeeded: function(e, t, n, r) {
        var i = Ext.getScrollbarSize(),
        s = typeof e == "number",
        o = typeof t == "number",
        u = 0,
        a = 0;
        if (!i.width) {
            return 0
        }
        if (o && t < r) {
            a = 2;
            e -= i.width
        }
        if (s && e < n) {
            u = 1;
            if (!a && o) {
                t -= i.height;
                if (t < r) {
                    a = 2
                }
            }
        }
        return a + u
    },
    getTarget: function() {
        return this.owner.getTargetEl()
    },
    getVisibleItems: function() {
        var e = this.getRenderTarget(),
        t = this.getLayoutItems(),
        n = t.length,
        r = [],
        i,
        s;
        for (i = 0; i < n; i++) {
            s = t[i];
            if (s.rendered && this.isValidParent(s, e, i) && s.hidden !== true) {
                r.push(s)
            }
        }
        return r
    },
    setupRenderTpl: function(e) {
        var t = this;
        e.renderBody = t.doRenderBody;
        e.renderContainer = t.doRenderContainer;
        e.renderItems = t.doRenderItems
    },
    getContentTarget: function() {
        return this.owner.getDefaultContentTarget()
    }
});
Ext.define("Ext.layout.container.Auto", {
    alias: ["layout.auto", "layout.autocontainer"],
    extend: Ext.layout.container.Container,
    type: "autocontainer",
    childEls: ["outerCt", "innerCt", "clearEl"],
    reserveScrollbar: false,
    managePadding: true,
    manageOverflow: false,
    lastOverflowAdjust: {
        width: 0,
        height: 0
    },
    renderTpl: ["{% if (!(Ext.isIEQuirks || Ext.isIE7m)) { %}", '<span id="{ownerId}-outerCt" style="display:table;" role="presentation">', '<div id="{ownerId}-innerCt" style="display:table-cell;height:100%;', 'vertical-align:top;{%this.renderPadding(out, values)%}" class="{innerCtCls}" role="presentation">', "{%this.renderBody(out,values)%}", "</div>", "</span>", "{% } else if (values.shrinkWrapWidth) { %}", '<table id="{ownerId}-outerCt" class="' + Ext.plainTableCls + '" role="presentation">', '<tbody role="presentation">', '<tr role="presentation">', '<td id="{ownerId}-innerCt" style="vertical-align:top;padding:0;', '{%this.renderPadding(out, values)%}" class="{innerCtCls}" role="presentation">', "{%this.renderBody(out,values)%}", '<div id="{ownerId}-clearEl" class="', Ext.baseCSSPrefix, 'clear"', 'role="presentation"></div>', "</td>", "</tr>", "</tbody>", "</table>", "{% } else { %}", '<div id="{ownerId}-outerCt" style="zoom:1;{%this.renderPadding(out, values)%}" role="presentation">', '<div id="{ownerId}-innerCt" style="zoom:1;height:100%;" class="{innerCtCls}" role="presentation">', "{%this.renderBody(out,values)%}", '<div id="{ownerId}-clearEl" class="', Ext.baseCSSPrefix, 'clear"', 'role="presentation"></div>', "</div>", "</div>", "{% values.$layout.isShrinkWrapTpl = false %}", "{% } %}"],
    tableTpl: ['<table id="{ownerId}-outerCt" class="' + Ext.plainTableCls + '" role="presentation">', '<tbody role="presentation">', '<tr role="presentation">', '<td id="{ownerId}-innerCt" style="vertical-align:top;padding:0;', '{%this.renderPadding(out, values)%}" class="{innerCtCls}" role="presentation">', "</td>", "</tr>", "</tbody>", "</table>"],
    isShrinkWrapTpl: true,
    beginLayout: function(e) {
        var t = this,
        n, r, i, s;
        t.callParent(arguments);
        t.initContextItems(e);
        if (!t.isShrinkWrapTpl) {
            if (e.widthModel.shrinkWrap) {
                s = true
            }
            if (Ext.isStrict && Ext.isIE7) {
                i = t.getOverflowXStyle(e);
                if ((i === "auto" || i === "scroll") && e.paddingContext.getPaddingInfo().right) {
                    s = true
                }
            }
            if (s) {
                t.insertTableCt(e)
            }
        }
        if (!t.isShrinkWrapTpl && Ext.isIE7 && Ext.isStrict && !t.clearElHasPadding) {
            n = e.paddingContext.getPaddingInfo().bottom;
            r = t.getOverflowYStyle(e);
            if (n && (r === "auto" || r === "scroll")) {
                t.clearEl.setStyle("height", n);
                t.clearElHasPadding = true
            }
        }
    },
    beforeLayoutCycle: function(e) {
        var t = this.owner,
        n = t.hierarchyState,
        r = t.hierarchyStateInner;
        if (!n || n.invalid) {
            n = t.getHierarchyState();
            r = t.hierarchyStateInner
        }
        if (e.widthModel.shrinkWrap && this.isShrinkWrapTpl) {
            r.inShrinkWrapTable = true
        } else {
            delete r.inShrinkWrapTable
        }
    },
    beginLayoutCycle: function(e) {
        var t = this,
        n = t.outerCt,
        r = t.lastOuterCtWidth || "",
        i = t.lastOuterCtHeight || "",
        s = t.lastOuterCtTableLayout || "",
        o = e.state,
        u, a, f, l, c, h, p;
        t.callParent(arguments);
        f = l = c = "";
        if (!e.widthModel.shrinkWrap && t.isShrinkWrapTpl) {
            if (Ext.isIE7m && Ext.isStrict) {
                a = t.getOverflowYStyle(e);
                if (a === "auto" || a === "scroll") {
                    h = true
                }
            }
            if (!h) {
                f = "100%"
            }
            p = t.owner.hierarchyStateInner;
            u = t.getOverflowXStyle(e);
            c = p.inShrinkWrapTable || u === "auto" || u === "scroll" ? "": "fixed"
        }
        if (!e.heightModel.shrinkWrap && !Ext.supports.PercentageHeightOverflowBug) {
            l = "100%"
        }
        if (f !== r || t.hasOuterCtPxWidth) {
            n.setStyle("width", f);
            t.lastOuterCtWidth = f;
            t.hasOuterCtPxWidth = false
        }
        if (c !== s) {
            n.setStyle("table-layout", c);
            t.lastOuterCtTableLayout = c
        }
        if (l !== i || t.hasOuterCtPxHeight) {
            n.setStyle("height", l);
            t.lastOuterCtHeight = l;
            t.hasOuterCtPxHeight = false
        }
        if (t.hasInnerCtPxHeight) {
            t.innerCt.setStyle("height", "");
            t.hasInnerCtPxHeight = false
        }
        o.overflowAdjust = o.overflowAdjust || t.lastOverflowAdjust
    },
    calculate: function(e) {
        var t = this,
        n = e.state,
        r = t.getContainerSize(e, true),
        i = n.calculatedItems || (n.calculatedItems = t.calculateItems ? t.calculateItems(e, r) : true);
        t.setCtSizeIfNeeded(e, r);
        if (i && e.hasDomProp("containerChildrenSizeDone")) {
            t.calculateContentSize(e);
            if (r.gotAll) {
                if (t.manageOverflow && !e.state.secondPass && !t.reserveScrollbar) {
                    t.calculateOverflow(e, r)
                }
                return
            }
        }
        t.done = false
    },
    calculateContentSize: function(e) {
        var t = this,
        n = (e.widthModel.shrinkWrap ? 1 : 0) | (e.heightModel.shrinkWrap ? 2 : 0),
        r = n & 1 || undefined,
        i = n & 2 || undefined,
        s = 0,
        o = e.props;
        if (r) {
            if (isNaN(o.contentWidth)) {++s
            } else {
                r = undefined
            }
        }
        if (i) {
            if (isNaN(o.contentHeight)) {++s
            } else {
                i = undefined
            }
        }
        if (s) {
            if (r && !e.setContentWidth(t.measureContentWidth(e))) {
                t.done = false
            }
            if (i && !e.setContentHeight(t.measureContentHeight(e))) {
                t.done = false
            }
        }
    },
    calculateOverflow: function(e) {
        var t = this,
        n, r, i, s, o, u, a;
        o = t.getOverflowXStyle(e) === "auto";
        u = t.getOverflowYStyle(e) === "auto";
        if (o || u) {
            i = Ext.getScrollbarSize();
            a = e.overflowContext.el.dom;
            s = 0;
            if (a.scrollWidth > a.clientWidth) {
                s |= 1
            }
            if (a.scrollHeight > a.clientHeight) {
                s |= 2
            }
            n = u && s & 2 ? i.width: 0;
            r = o && s & 1 ? i.height: 0;
            if (n !== t.lastOverflowAdjust.width || r !== t.lastOverflowAdjust.height) {
                t.done = false;
                e.invalidate({
                    state: {
                        overflowAdjust: {
                            width: n,
                            height: r
                        },
                        overflowState: s,
                        secondPass: true
                    }
                })
            }
        }
    },
    completeLayout: function(e) {
        this.lastOverflowAdjust = e.state.overflowAdjust
    },
    doRenderPadding: function(e, t) {
        var n = t.$layout,
        r = t.$layout.owner,
        i = r[r.contentPaddingProperty];
        if (n.managePadding && i) {
            e.push("padding:", r.unitizeBox(i))
        }
    },
    finishedLayout: function(e) {
        var t = this.innerCt;
        this.callParent(arguments);
        if (Ext.isIEQuirks || Ext.isIE8m) {
            t.repaint()
        }
        if (Ext.isOpera) {
            t.setStyle("position", "relative");
            t.dom.scrollWidth;
            t.setStyle("position", "")
        }
    },
    getContainerSize: function(e, t) {
        var n = this.callParent(arguments),
        r = e.state.overflowAdjust;
        if (r) {
            n.width -= r.width;
            n.height -= r.height
        }
        return n
    },
    getRenderData: function() {
        var e = this.owner,
        t = this.callParent();
        if ((Ext.isIEQuirks || Ext.isIE7m) && (e.shrinkWrap & 1 || e.floating && !e.width)) {
            t.shrinkWrapWidth = true
        }
        return t
    },
    getRenderTarget: function() {
        return this.innerCt
    },
    getElementTarget: function() {
        return this.innerCt
    },
    getOverflowXStyle: function(e) {
        return e.overflowXStyle || (e.overflowXStyle = this.owner.scrollFlags.overflowX || e.overflowContext.getStyle("overflow-x"))
    },
    getOverflowYStyle: function(e) {
        return e.overflowYStyle || (e.overflowYStyle = this.owner.scrollFlags.overflowY || e.overflowContext.getStyle("overflow-y"))
    },
    initContextItems: function(e) {
        var t = this,
        n = e.target,
        r = t.owner.customOverflowEl;
        e.outerCtContext = e.getEl("outerCt", t);
        e.innerCtContext = e.getEl("innerCt", t);
        if (r) {
            e.overflowContext = e.getEl(r)
        } else {
            e.overflowContext = e.targetContext
        }
        if (n[n.contentPaddingProperty] !== undefined) {
            e.paddingContext = t.isShrinkWrapTpl ? e.innerCtContext: e.outerCtContext
        }
    },
    initLayout: function() {
        var e = this,
        t = Ext.getScrollbarSize().width,
        n = e.owner;
        e.callParent();
        if (t && e.manageOverflow && !e.hasOwnProperty("lastOverflowAdjust")) {
            if (n.autoScroll || e.reserveScrollbar) {
                e.lastOverflowAdjust = {
                    width: t,
                    height: 0
                }
            }
        }
    },
    insertTableCt: function(e) {
        var t = this,
        n = t.owner,
        r = 0,
        i, s, o, u, a;
        i = Ext.XTemplate.getTpl(this, "tableTpl");
        i.renderPadding = t.doRenderPadding;
        t.outerCt.dom.removeChild(t.innerCt.dom);
        s = document.createDocumentFragment();
        o = t.innerCt.dom.childNodes;
        u = o.length;
        for (; r < u; r++) {
            s.appendChild(o[0])
        }
        a = t.getTarget();
        a.dom.innerHTML = i.apply({
            $layout: t,
            ownerId: t.owner.id
        });
        a.down("td").dom.appendChild(s);
        t.applyChildEls(n.el, n.id);
        t.isShrinkWrapTpl = true;
        e.removeEl(t.outerCt);
        e.removeEl(t.innerCt);
        t.initContextItems(e)
    },
    measureContentHeight: function(e) {
        var t = this.outerCt.getHeight(),
        n = e.target;
        if (this.managePadding && n[n.contentPaddingProperty] === undefined) {
            t += e.targetContext.getPaddingInfo().height
        }
        return t
    },
    measureContentWidth: function(e) {
        var t, n, r, i, s;
        if (this.chromeCellMeasureBug) {
            t = this.innerCt.dom;
            n = t.style;
            r = n.display;
            if (r == "table-cell") {
                n.display = "";
                t.offsetWidth;
                n.display = r
            }
        }
        if (Ext.isSafari) {
            t = this.outerCt.dom;
            n = t.style;
            n.display = "table-cell";
            t.offsetWidth;
            t.style.display = "table"
        }
        i = this.outerCt.getWidth();
        s = e.target;
        if (this.managePadding && s[s.contentPaddingProperty] === undefined) {
            i += e.targetContext.getPaddingInfo().width
        }
        return i
    },
    setCtSizeIfNeeded: function(e, t) {
        var n = this,
        r = t.width,
        i = t.height,
        s = e.paddingContext.getPaddingInfo(),
        o = n.getTarget(),
        u = n.getOverflowXStyle(e),
        a = n.getOverflowYStyle(e),
        f = u === "auto" || u === "scroll",
        l = a === "auto" || a === "scroll",
        c = Ext.getScrollbarSize(),
        h = n.isShrinkWrapTpl,
        p = n.manageOverflow,
        d,
        v,
        m,
        g;
        if (r && !e.widthModel.shrinkWrap && (Ext.isIE7m && Ext.isStrict && h && l || Ext.isIEQuirks && !h && !f)) {
            if (!p) {
                if (l && o.dom.scrollHeight > o.dom.clientHeight) {
                    r -= c.width
                }
            }
            e.outerCtContext.setProp("width", r + s.width);
            n.hasOuterCtPxWidth = true
        }
        if (i && !e.heightModel.shrinkWrap) {
            if (Ext.supports.PercentageHeightOverflowBug) {
                v = true
            }
            if (Ext.isIE8 && Ext.isStrict || Ext.isIE7m && Ext.isStrict && h) {
                m = true;
                g = !Ext.isIE8
            }
            if ((v || m) && f && o.dom.scrollWidth > o.dom.clientWidth) {
                i = Math.max(i - c.height, 0)
            }
            if (v) {
                e.outerCtContext.setProp("height", i + s.height);
                n.hasOuterCtPxHeight = true
            }
            if (m) {
                if (g) {
                    i += s.height
                }
                e.innerCtContext.setProp("height", i);
                n.hasInnerCtPxHeight = true
            }
        }
        if (Ext.isIE7 && Ext.isStrict && !h && a === "auto") {
            d = u === "auto" ? "overflow-x": "overflow-y";
            o.setStyle(d, "hidden");
            o.setStyle(d, "auto")
        }
    },
    setupRenderTpl: function(e) {
        this.callParent(arguments);
        e.renderPadding = this.doRenderPadding
    },
    getContentTarget: function() {
        return this.innerCt
    }
},
function() {
    this.prototype.chromeCellMeasureBug = Ext.isChrome && Ext.chromeVersion >= 26
});
Ext.define("Ext.ZIndexManager", {
    alternateClassName: "Ext.WindowGroup",
    statics: {
        zBase: 9e3
    },
    constructor: function(e) {
        var t = this;
        t.map = {};
        t.zIndexStack = [];
        t.front = null;
        if (e) {
            if (e.isContainer) {
                e.on("resize", t._onContainerResize, t);
                t.zseed = Ext.Number.from(t.rendered ? e.getEl().getStyle("zIndex") : undefined, t.getNextZSeed());
                t.targetEl = e.getTargetEl();
                t.container = e
            } else {
                Ext.EventManager.onWindowResize(t._onContainerResize, t);
                t.zseed = t.getNextZSeed();
                t.targetEl = Ext.get(e)
            }
        } else {
            Ext.EventManager.onWindowResize(t._onContainerResize, t);
            t.zseed = t.getNextZSeed();
            Ext.onDocumentReady(function() {
                t.targetEl = Ext.getBody()
            })
        }
    },
    getNextZSeed: function() {
        return Ext.ZIndexManager.zBase += 1e4
    },
    setBase: function(e) {
        this.zseed = e;
        var t = this.assignZIndices();
        this._activateLast();
        return t
    },
    assignZIndices: function() {
        var e = this.zIndexStack,
        t = e.length,
        n = 0,
        r = this.zseed,
        i, s;
        for (; n < t; n++) {
            i = e[n];
            if (i && !i.hidden) {
                r = i.setZIndex(r);
                if (i.modal) {
                    s = i
                }
            }
        }
        if (s) {
            this._showModalMask(s)
        }
        return r
    },
    _setActiveChild: function(e, t) {
        var n = this.front,
        r = e.preventFocusOnActivate;
        if (e !== n) {
            if (n && !n.destroying) {
                n.setActive(false, e)
            }
            this.front = e;
            if (e && e != t) {
                e.preventFocusOnActivate = e.preventFocusOnActivate || t && (t.preventFocusOnActivate || !t.focusOnToFront);
                e.setActive(true);
                if (e.modal) {
                    this._showModalMask(e)
                }
                e.preventFocusOnActivate = r
            }
        }
    },
    onComponentHide: function(e) {
        this._activateLast()
    },
    _activateLast: function() {
        var e = this,
        t = e.zIndexStack,
        n = t.length - 1,
        r;
        for (; n >= 0 && t[n].hidden; --n) {}
        if (r = t[n]) {
            e._setActiveChild(r, e.front);
            if (r.modal) {
                return
            }
        } else {
            if (e.front && !e.front.destroying) {
                e.front.setActive(false)
            }
            e.front = null
        }
        for (; n >= 0; --n) {
            r = t[n];
            if (r.isVisible() && r.modal) {
                e._showModalMask(r);
                return
            }
        }
        e._hideModalMask()
    },
    _showModalMask: function(e) {
        var t = this,
        n = e.el.getStyle("zIndex") - 4,
        r = e.floatParent ? e.floatParent.getTargetEl() : e.container,
        i = t.mask,
        s = t.maskShim,
        o;
        if (!i) {
            if (Ext.isIE6) {
                s = t.maskShim = Ext.getBody().createChild({
                    tag: "iframe",
                    role: "presentation",
                    cls: Ext.baseCSSPrefix + "shim " + Ext.baseCSSPrefix + "mask-shim"
                });
                s.setVisibilityMode(Ext.Element.DISPLAY)
            }
            i = t.mask = Ext.getBody().createChild({
                role: "presentation",
                cls: Ext.baseCSSPrefix + "mask",
                style: "height:0;width:0"
            });
            i.setVisibilityMode(Ext.Element.DISPLAY);
            i.on("click", t._onMaskClick, t)
        }
        i.maskTarget = r;
        o = t.getMaskBox();
        if (s) {
            s.setStyle("zIndex", n);
            s.show();
            s.setBox(o)
        }
        i.setStyle("zIndex", n);
        i.show();
        i.setBox(o)
    },
    _hideModalMask: function() {
        var e = this.mask,
        t = this.maskShim;
        if (e && e.isVisible()) {
            e.maskTarget = undefined;
            e.hide();
            if (t) {
                t.hide()
            }
        }
    },
    _onMaskClick: function() {
        if (this.front) {
            this.front.focus()
        }
    },
    getMaskBox: function() {
        var e = this.mask.maskTarget;
        if (e.dom === document.body) {
            return {
                height: Math.max(document.body.scrollHeight, Ext.dom.Element.getDocumentHeight()),
                width: Math.max(document.body.scrollWidth, document.documentElement.clientWidth),
                x: 0,
                y: 0
            }
        } else {
            return e.getBox()
        }
    },
    _onContainerResize: function() {
        var e = this,
        t = e.mask,
        n = e.maskShim,
        r;
        if (t && t.isVisible()) {
            t.hide();
            if (n) {
                n.hide()
            }
            r = e.getMaskBox();
            if (n) {
                n.setSize(r);
                n.show()
            }
            t.setSize(r);
            t.show()
        }
    },
    register: function(e) {
        var t = this,
        n = e.afterHide;
        if (e.zIndexManager) {
            e.zIndexManager.unregister(e)
        }
        e.zIndexManager = t;
        t.map[e.id] = e;
        t.zIndexStack.push(e);
        e.afterHide = function() {
            n.apply(e, arguments);
            t.onComponentHide(e)
        }
    },
    unregister: function(e) {
        var t = this,
        n = t.map;
        delete e.zIndexManager;
        if (n && n[e.id]) {
            delete n[e.id];
            delete e.afterHide;
            Ext.Array.remove(t.zIndexStack, e);
            t._activateLast()
        }
    },
    get: function(e) {
        return e.isComponent ? e: this.map[e]
    },
    bringToFront: function(e, t) {
        var n = this,
        r = false,
        i = n.zIndexStack;
        e = n.get(e);
        if (e !== n.front) {
            Ext.Array.remove(i, e);
            if (e.preventBringToFront) {
                i.unshift(e)
            } else {
                i.push(e)
            }
            n.assignZIndices();
            if (!t) {
                n._activateLast()
            }
            r = true;
            n.front = e;
            if (e.modal) {
                n._showModalMask(e)
            }
        }
        return r
    },
    sendToBack: function(e) {
        var t = this;
        e = t.get(e);
        Ext.Array.remove(t.zIndexStack, e);
        t.zIndexStack.unshift(e);
        t.assignZIndices();
        this._activateLast();
        return e
    },
    hideAll: function() {
        var e = this.map,
        t, n;
        for (n in e) {
            if (e.hasOwnProperty(n)) {
                t = e[n];
                if (t.isComponent && t.isVisible()) {
                    t.hide()
                }
            }
        }
    },
    hide: function() {
        var e = 0,
        t = this.zIndexStack,
        n = t.length,
        r;
        this.tempHidden = [];
        for (; e < n; e++) {
            r = t[e];
            if (r.isVisible()) {
                this.tempHidden.push(r);
                r.el.hide();
                r.hidden = true
            }
        }
    },
    show: function() {
        var e = 0,
        t = this.tempHidden,
        n = t ? t.length: 0,
        r;
        for (; e < n; e++) {
            r = t[e];
            r.el.show();
            r.hidden = false;
            r.setPosition(r.x, r.y)
        }
        delete this.tempHidden
    },
    getActive: function() {
        return this.front
    },
    getBy: function(e, t) {
        var n = [],
        r = 0,
        i = this.zIndexStack,
        s = i.length,
        o;
        for (; r < s; r++) {
            o = i[r];
            if (e.call(t || o, o) !== false) {
                n.push(o)
            }
        }
        return n
    },
    each: function(e, t) {
        var n = this.map,
        r, i;
        for (r in n) {
            if (n.hasOwnProperty(r)) {
                i = n[r];
                if (i.isComponent && e.call(t || i, i) === false) {
                    return
                }
            }
        }
    },
    eachBottomUp: function(e, t) {
        var n = this.zIndexStack,
        r = 0,
        i = n.length,
        s;
        for (; r < i; r++) {
            s = n[r];
            if (s.isComponent && e.call(t || s, s) === false) {
                return
            }
        }
    },
    eachTopDown: function(e, t) {
        var n = this.zIndexStack,
        r = n.length,
        i;
        for (; r-->0;) {
            i = n[r];
            if (i.isComponent && e.call(t || i, i) === false) {
                return
            }
        }
    },
    destroy: function() {
        var e = this,
        t = e.map,
        n, r;
        for (r in t) {
            if (t.hasOwnProperty(r)) {
                n = t[r];
                if (n.isComponent) {
                    n.destroy()
                }
            }
        }
        Ext.destroy(e.mask);
        Ext.destroy(e.maskShim);
        delete e.zIndexStack;
        delete e.map;
        delete e.container;
        delete e.targetEl
    }
},
function() {
    Ext.WindowManager = Ext.WindowMgr = new this
});
Ext.define("Ext.Queryable", {
    isQueryable: true,
    query: function(e) {
        e = e || "*";
        return Ext.ComponentQuery.query(e, this)
    },
    queryBy: function(e, t) {
        var n = [],
        r = this.getRefItems(true),
        i = 0,
        s = r.length,
        o;
        for (; i < s; ++i) {
            o = r[i];
            if (e.call(t || o, o) !== false) {
                n.push(o)
            }
        }
        return n
    },
    queryById: function(e) {
        var t = this.getRefItems(true),
        n,
        r = t.length,
        i;
        for (n = 0; n < r; n++) {
            i = t[n];
            if (i.id === i || i.itemId === e) {
                return i
            }
        }
        return null
    },
    child: function(e) {
        var t = this.getRefItems();
        if (e && e.isComponent) {
            e = "#" + Ext.escapeId(e.getItemId())
        }
        if (e) {
            t = Ext.ComponentQuery.query(e, t)
        }
        if (t.length) {
            return t[0]
        }
        return null
    },
    down: function(e) {
        if (e && e.isComponent) {
            e = "#" + Ext.escapeId(e.getItemId())
        }
        e = e || "";
        return this.query(e)[0] || null
    },
    visitPreOrder: function(e, t, n, r) {
        Ext.ComponentQuery._visit(true, e, this, t, n, r)
    },
    visitPostOrder: function(e, t, n, r) {
        Ext.ComponentQuery._visit(false, e, this, t, n, r)
    },
    getRefItems: function() {
        return []
    }
});
Ext.define("Ext.container.AbstractContainer", {
    extend: Ext.Component,
    mixins: {
        queryable: Ext.Queryable
    },
    renderTpl: "{%this.renderContainer(out,values)%}",
    suspendLayout: false,
    autoDestroy: true,
    defaultType: "panel",
    detachOnRemove: true,
    isContainer: true,
    layoutCounter: 0,
    baseCls: Ext.baseCSSPrefix + "container",
    defaultLayoutType: "auto",
    ariaRole: "presentation",
    initComponent: function() {
        var e = this;
        e.addEvents("afterlayout", "beforeadd", "beforeremove", "add", "remove");
        e.callParent();
        e.getLayout();
        e.initItems()
    },
    initItems: function() {
        var e = this,
        t = e.items;
        e.items = new Ext.util.AbstractMixedCollection(false, e.getComponentId);
        e.floatingItems = new Ext.util.MixedCollection(false, e.getComponentId);
        if (t) {
            if (!Ext.isArray(t)) {
                t = [t]
            }
            e.add(t)
        }
    },
    getFocusEl: function() {
        return this.getTargetEl()
    },
    finishRenderChildren: function() {
        this.callParent();
        var e = this.getLayout();
        if (e) {
            e.finishRender()
        }
    },
    beforeRender: function() {
        var e = this,
        t = e.getLayout(),
        n;
        e.callParent();
        if (!t.initialized) {
            t.initLayout()
        }
        n = t.targetCls;
        if (n) {
            e.applyTargetCls(n)
        }
    },
    applyTargetCls: function(e) {
        this.addCls(e)
    },
    afterComponentLayout: function() {
        var e = this.floatingItems.items,
        t = e.length,
        n, r;
        this.callParent(arguments);
        for (n = 0; n < t; n++) {
            r = e[n];
            if (!r.rendered && r.autoShow) {
                r.show()
            }
        }
    },
    onPosition: function() {
        this.callParent(arguments);
        this.repositionFloatingItems()
    },
    onResize: function() {
        this.callParent(arguments);
        this.repositionFloatingItems()
    },
    repositionFloatingItems: function() {
        var e = this.floatingItems.items,
        t = e.length,
        n, r;
        for (n = 0; n < t; n++) {
            r = e[n];
            if (r.el && !r.hidden && !r.noReposition) {
                r.setPosition(r.x, r.y)
            }
        }
    },
    setupRenderTpl: function(e) {
        this.callParent(arguments);
        this.getLayout().setupRenderTpl(e)
    },
    getDefaultContentTarget: function() {
        return this.el
    },
    getContentTarget: function() {
        return this.getLayout().getContentTarget()
    },
    setLayout: function(e) {
        var t = this.layout;
        if (t && t.isLayout && t != e) {
            t.setOwner(null)
        }
        this.layout = e;
        e.setOwner(this)
    },
    getLayout: function() {
        var e = this;
        if (!e.layout || !e.layout.isLayout) {
            e.setLayout(Ext.layout.Layout.create(e.layout, e.self.prototype.layout || e.defaultLayoutType))
        }
        return e.layout
    },
    doLayout: function() {
        this.updateLayout();
        return this
    },
    afterLayout: function(e) {
        var t = this; ++t.layoutCounter;
        if (t.hasListeners.afterlayout) {
            t.fireEvent("afterlayout", t, e)
        }
    },
    prepareItems: function(e, t) {
        if (Ext.isArray(e)) {
            e = e.slice()
        } else {
            e = [e]
        }
        var n = this,
        r = 0,
        i = e.length,
        s;
        for (; r < i; r++) {
            s = e[r];
            if (s == null) {
                Ext.Array.erase(e, r, 1); --r; --i
            } else {
                if (t) {
                    s = this.applyDefaults(s)
                }
                s.isContained = n;
                e[r] = n.lookupComponent(s);
                delete s.isContained;
                delete e[r].isContained
            }
        }
        return e
    },
    applyDefaults: function(e) {
        var t = this.defaults;
        if (t) {
            if (Ext.isFunction(t)) {
                t = t.call(this, e)
            }
            if (Ext.isString(e)) {
                e = Ext.ComponentManager.get(e)
            }
            Ext.applyIf(e, t)
        }
        return e
    },
    lookupComponent: function(e) {
        return typeof e == "string" ? Ext.ComponentManager.get(e) : Ext.ComponentManager.create(e, this.defaultType)
    },
    getComponentId: function(e) {
        return e.getItemId && e.getItemId()
    },
    add: function() {
        var e = this,
        t = Ext.Array.slice(arguments),
        n = typeof t[0] == "number" ? t.shift() : -1,
        r = e.getLayout(),
        i,
        s,
        o,
        u,
        a,
        f,
        l,
        c = false;
        if (t.length == 1 && Ext.isArray(t[0])) {
            s = t[0];
            i = true
        } else {
            s = t
        }
        if (e.rendered) {
            Ext.suspendLayouts()
        }
        l = s = e.prepareItems(s, true);
        u = s.length;
        if (!i && u == 1) {
            l = s[0]
        }
        for (o = 0; o < u; o++) {
            a = s[o];
            f = n < 0 ? e.items.length: n + o;
            if (a.floating) {
                e.floatingItems.add(a);
                a.onAdded(e, f);
                if (e.hasListeners.add) {
                    e.fireEvent("add", e, a, f)
                }
            } else {
                if ((!e.hasListeners.beforeadd || e.fireEvent("beforeadd", e, a, f) !== false) && e.onBeforeAdd(a) !== false) {
                    e.items.insert(f, a);
                    a.onAdded(e, f);
                    e.onAdd(a, f);
                    r.onAdd(a, f);
                    c = true;
                    if (e.hasListeners.add) {
                        e.fireEvent("add", e, a, f)
                    }
                }
            }
        }
        if (c) {
            e.updateLayout()
        }
        if (e.rendered) {
            Ext.resumeLayouts(true)
        }
        return l
    },
    onAdd: Ext.emptyFn,
    onRemove: Ext.emptyFn,
    insert: function(e, t) {
        var n;
        if (t && t.isComponent) {
            n = this.items.indexOf(t);
            if (n !== -1) {
                return this.move(n, e)
            }
        }
        return this.add(e, t)
    },
    move: function(e, t) {
        var n = this.items,
        r;
        if (e.isComponent) {
            e = n.indexOf(e)
        }
        r = n.getAt(e);
        if (e !== t) {
            r = n.removeAt(e);
            if (r === false) {
                return false
            }
            n.insert(t, r);
            this.onMove(r, e, t);
            this.updateLayout()
        }
        return r
    },
    onMove: Ext.emptyFn,
    onBeforeAdd: function(e) {
        var t = e.ownerCt;
        if (t && t !== this) {
            t.remove(e, false)
        }
    },
    remove: function(e, t) {
        var n = this,
        r = n.getComponent(e);
        if (r && (!n.hasListeners.beforeremove || n.fireEvent("beforeremove", n, r) !== false)) {
            n.doRemove(r, t);
            if (n.hasListeners.remove) {
                n.fireEvent("remove", n, r)
            }
            if (!n.destroying && !r.floating) {
                n.updateLayout()
            }
        }
        return r
    },
    doRemove: function(e, t) {
        t = t === true || t !== false && this.autoDestroy;
        var n = this,
        r = n.layout,
        i = r && n.rendered,
        s = e.destroying || t,
        o = e.floating;
        if (o) {
            n.floatingItems.remove(e)
        } else {
            n.items.remove(e)
        }
        if (i && !o) {
            if (r.running) {
                Ext.AbstractComponent.cancelLayout(e, s)
            }
            r.onRemove(e, s)
        }
        e.onRemoved(s);
        n.onRemove(e, s);
        if (t) {
            e.destroy()
        } else {
            if (i && !o) {
                r.afterRemove(e)
            }
            if (n.detachOnRemove && e.rendered) {
                n.detachComponent(e)
            }
        }
    },
    detachComponent: function(e) {
        Ext.getDetachedBody().appendChild(e.getEl())
    },
    removeAll: function(e) {
        var t = this,
        n = t.items.items.slice().concat(t.floatingItems.items),
        r = [],
        i = 0,
        s = n.length,
        o;
        t.suspendLayouts();
        for (; i < s; i++) {
            o = n[i];
            t.remove(o, e);
            if (o.ownerCt !== t) {
                r.push(o)
            }
        }
        t.resumeLayouts( !! s);
        return r
    },
    getRefItems: function(e) {
        var t = this,
        n = t.items.items,
        r = n.length,
        i = 0,
        s, o = [];
        for (; i < r; i++) {
            s = n[i];
            o[o.length] = s;
            if (e && s.getRefItems) {
                o.push.apply(o, s.getRefItems(true))
            }
        }
        n = t.floatingItems.items;
        r = n.length;
        for (i = 0; i < r; i++) {
            s = n[i];
            o[o.length] = s;
            if (e && s.getRefItems) {
                o.push.apply(o, s.getRefItems(true))
            }
        }
        return o
    },
    cascade: function(e, t, n) {
        var r = this,
        i = r.items ? r.items.items: [],
        s = i.length,
        o = 0,
        u,
        a = n ? n.concat(r) : [r],
        f = a.length - 1;
        if (e.apply(t || r, a) !== false) {
            for (; o < s; o++) {
                u = i[o];
                if (u.cascade) {
                    u.cascade(e, t, n)
                } else {
                    a[f] = u;
                    e.apply(t || u, a)
                }
            }
        }
        return this
    },
    isAncestor: function(e) {
        while (e) {
            if (e.ownerCt === this) {
                return true
            }
            e = e.ownerCt
        }
    },
    getComponent: function(e) {
        if (Ext.isObject(e)) {
            e = e.getItemId()
        }
        var t = this.items.get(e);
        if (!t && typeof e != "number") {
            t = this.floatingItems.get(e)
        }
        return t
    },
    contains: function(e, t) {
        var n = false;
        if (t) {
            this.cascade(function(t) {
                if (t.contains && t.contains(e)) {
                    n = true;
                    return false
                }
            });
            return n
        } else {
            return this.items.contains(e) || this.floatingItems.contains(e)
        }
    },
    nextChild: function(e, t) {
        var n = this,
        r = n.items,
        i = r.indexOf(e),
        s = 0,
        o = r.length,
        u;
        if (i !== -1) {
            if (t) {
                for (; s < o; s++) {
                    u = r.getAt(i + s);
                    if (!u || Ext.ComponentQuery.is(u, t)) {
                        break
                    }
                }
            } else {
                u = r.getAt(i + 1)
            }
            if (!u && n.ownerCt) {
                u = n.ownerCt.nextChild(n, t)
            }
        }
        return u
    },
    prevChild: function(e, t) {
        var n = this,
        r = n.items,
        i = r.indexOf(e),
        s = 0,
        o = r.length,
        u;
        if (i !== -1) {
            if (t) {
                for (; s < o; s++) {
                    u = r.getAt(i - s);
                    if (!u || Ext.ComponentQuery.is(u, t)) {
                        break
                    }
                }
            } else {
                u = r.getAt(i - 1)
            }
            if (!u && n.ownerCt) {
                u = n.ownerCt.nextChild(n, t)
            }
        }
        return u
    },
    enable: function() {
        this.callParent(arguments);
        var e = this.getChildItemsToDisable(),
        t = e.length,
        n,
        r;
        for (r = 0; r < t; r++) {
            n = e[r];
            if (n.resetDisable) {
                n.enable()
            }
        }
        return this
    },
    disable: function() {
        this.callParent(arguments);
        var e = this.getChildItemsToDisable(),
        t = e.length,
        n,
        r;
        for (r = 0; r < t; r++) {
            n = e[r];
            if (n.resetDisable !== false && !n.disabled) {
                n.disable();
                n.resetDisable = true
            }
        }
        return this
    },
    getChildItemsToDisable: function() {
        return this.query("[isFormField],button")
    },
    beforeDestroy: function() {
        var e = this,
        t = e.items,
        n = e.floatingItems,
        r;
        if (t) {
            while (r = t.first()) {
                e.doRemove(r, true)
            }
        }
        if (n) {
            while (r = n.first()) {
                e.doRemove(r, true)
            }
        }
        Ext.destroy(e.layout);
        e.callParent()
    }
});
Ext.define("Ext.container.Container", {
    extend: Ext.container.AbstractContainer,
    alias: "widget.container",
    alternateClassName: "Ext.Container",
    getChildByElement: function(e, t) {
        var n, r, i = 0,
        s = this.getRefItems(),
        o = s.length;
        e = Ext.getDom(e);
        for (; i < o; i++) {
            n = s[i];
            r = n.getEl();
            if (r && (r.dom === e || r.contains(e))) {
                return t && n.getChildByElement ? n.getChildByElement(e, t) : n
            }
        }
        return null
    }
});
Ext.define("Ext.layout.container.Editor", {
    alias: "layout.editor",
    extend: Ext.layout.container.Container,
    autoSizeDefault: {
        width: "field",
        height: "field"
    },
    sizePolicies: {
        $: {
            $: {
                readsWidth: 1,
                readsHeight: 1,
                setsWidth: 0,
                setsHeight: 0
            },
            boundEl: {
                readsWidth: 1,
                readsHeight: 0,
                setsWidth: 0,
                setsHeight: 1
            }
        },
        boundEl: {
            $: {
                readsWidth: 0,
                readsHeight: 1,
                setsWidth: 1,
                setsHeight: 0
            },
            boundEl: {
                readsWidth: 0,
                readsHeight: 0,
                setsWidth: 1,
                setsHeight: 1
            }
        }
    },
    getItemSizePolicy: function(e) {
        var t = this,
        n = t.owner.autoSize,
        r = n && n.width,
        i = t.sizePolicies;
        i = i[r] || i.$;
        r = n && n.height;
        i = i[r] || i.$;
        return i
    },
    calculate: function(e) {
        var t = this,
        n = t.owner,
        r = n.autoSize,
        i, s;
        if (r === true) {
            r = t.autoSizeDefault
        }
        if (r) {
            i = t.getDimension(n, r.width, "getWidth", n.width);
            s = t.getDimension(n, r.height, "getHeight", n.height)
        }
        e.childItems[0].setSize(i, s);
        e.setWidth(i);
        e.setHeight(s);
        e.setContentSize(i || n.field.getWidth(), s || n.field.getHeight())
    },
    getDimension: function(e, t, n, r) {
        switch (t) {
        case "boundEl":
            return e.boundEl[n]();
        case "field":
            return undefined;
        default:
            return r
        }
    }
});
Ext.define("Ext.Editor", {
    extend: Ext.container.Container,
    alias: "widget.editor",
    layout: "editor",
    allowBlur: true,
    constrainToBottom: true,
    revertInvalid: true,
    value: "",
    alignment: "c-c?",
    offsets: [0, 0],
    shadow: "frame",
    constrain: false,
    swallowKeys: true,
    completeOnEnter: true,
    cancelOnEsc: true,
    updateEl: false,
    focusOnToFront: false,
    hidden: true,
    baseCls: Ext.baseCSSPrefix + "editor",
    initComponent: function() {
        var e = this,
        t = e.field = Ext.ComponentManager.create(e.field, "textfield");
        t.inEditor = true;
        t.msgTarget = t.msgTarget || "qtip";
        e.mon(t, {
            scope: e,
            blur: e.onFieldBlur,
            specialkey: e.onSpecialKey
        });
        if (t.grow) {
            e.mon(t, "autosize", e.onFieldAutosize, e, {
                delay: 1
            })
        }
        e.floating = {
            constrain: e.constrain
        };
        e.items = t;
        e.callParent(arguments);
        e.addEvents("beforestartedit", "startedit", "beforecomplete", "complete", "canceledit", "specialkey")
    },
    onFieldAutosize: function() {
        this.updateLayout()
    },
    afterRender: function(e, t) {
        var n = this,
        r = n.field,
        i = r.inputEl;
        n.callParent(arguments);
        if (i) {
            i.dom.name = "";
            if (n.swallowKeys) {
                i.swallowEvent(["keypress", "keydown"])
            }
        }
    },
    onSpecialKey: function(e, t) {
        var n = this,
        r = t.getKey(),
        i = n.completeOnEnter && r == t.ENTER,
        s = n.cancelOnEsc && r == t.ESC;
        if (i || s) {
            t.stopEvent();
            Ext.defer(function() {
                if (i) {
                    n.completeEdit()
                } else {
                    n.cancelEdit()
                }
            },
            1)
        }
        n.fireEvent("specialkey", n, e, t)
    },
    startEdit: function(e, t) {
        var n = this,
        r = n.field,
        i;
        n.completeEdit();
        n.boundEl = Ext.get(e);
        i = n.boundEl.dom;
        t = Ext.isDefined(t) ? t: Ext.String.trim(i.textContent || i.innerText || i.innerHTML);
        if (!n.rendered && !n.renderTo && n.ownerCt) { (n.renderTo = n.ownerCt.el).position()
        }
        if (n.fireEvent("beforestartedit", n, n.boundEl, t) !== false) {
            n.startValue = t;
            n.show();
            r.suspendEvents();
            r.reset();
            r.setValue(t);
            r.resumeEvents();
            n.realign(true);
            r.focus([r.getRawValue().length]);
            if (r.autoSize) {
                r.autoSize()
            }
            n.editing = true
        }
    },
    realign: function(e) {
        var t = this;
        if (e === true) {
            t.updateLayout()
        }
        t.alignTo(t.boundEl, t.alignment, t.offsets)
    },
    completeEdit: function(e) {
        var t = this,
        n = t.field,
        r;
        if (!t.editing) {
            return
        }
        if (n.assertValue) {
            n.assertValue()
        }
        r = t.getValue();
        if (!n.isValid()) {
            if (t.revertInvalid !== false) {
                t.cancelEdit(e)
            }
            return
        }
        if (String(r) === String(t.startValue) && t.ignoreNoChange) {
            t.hideEdit(e);
            return
        }
        if (t.fireEvent("beforecomplete", t, r, t.startValue) !== false) {
            r = t.getValue();
            if (t.updateEl && t.boundEl) {
                t.boundEl.update(r)
            }
            t.hideEdit(e);
            t.fireEvent("complete", t, r, t.startValue)
        }
    },
    onShow: function() {
        var e = this;
        e.callParent(arguments);
        if (e.hideEl !== false) {
            e.boundEl.hide()
        }
        e.fireEvent("startedit", e, e.boundEl, e.startValue)
    },
    cancelEdit: function(e) {
        var t = this,
        n = t.startValue,
        r = t.field,
        i;
        if (t.editing) {
            if (r) {
                i = t.editedValue = t.getValue();
                r.suspendEvents();
                t.setValue(n);
                r.resumeEvents()
            }
            t.hideEdit(e);
            t.fireEvent("canceledit", t, i, n);
            delete t.editedValue
        }
    },
    hideEdit: function(e) {
        if (e !== true) {
            this.editing = false;
            this.hide()
        }
    },
    onFieldBlur: function(e, t) {
        var n = this,
        r = Ext.Element.getActiveElement();
        if (n.allowBlur === true && n.editing && n.selectSameEditor !== true) {
            n.completeEdit()
        }
        if (Ext.fly(r).isFocusable() || r.getAttribute("tabIndex")) {
            r.focus()
        }
    },
    onHide: function() {
        var e = this,
        t = e.field;
        if (e.editing) {
            e.completeEdit();
            return
        }
        if (t.hasFocus && t.triggerBlur) {
            t.triggerBlur()
        }
        if (t.collapse) {
            t.collapse()
        }
        if (e.hideEl !== false) {
            e.boundEl.show()
        }
        e.callParent(arguments)
    },
    setValue: function(e) {
        this.field.setValue(e)
    },
    getValue: function() {
        return this.field.getValue()
    },
    beforeDestroy: function() {
        var e = this;
        Ext.destroy(e.field);
        delete e.field;
        delete e.boundEl;
        e.callParent(arguments)
    }
});
Ext.define("Ext.util.KeyMap", {
    alternateClassName: "Ext.KeyMap",
    eventName: "keydown",
    constructor: function(e) {
        var t = this;
        if (arguments.length !== 1 || typeof e === "string" || e.dom || e.tagName || e === document || e.isComponent) {
            t.legacyConstructor.apply(t, arguments);
            return
        }
        Ext.apply(t, e);
        t.bindings = [];
        if (!t.target.isComponent) {
            t.target = Ext.get(t.target)
        }
        if (t.binding) {
            t.addBinding(t.binding)
        } else {
            if (e.key) {
                t.addBinding(e)
            }
        }
        t.enable()
    },
    legacyConstructor: function(e, t, n) {
        var r = this;
        Ext.apply(r, {
            target: Ext.get(e),
            eventName: n || r.eventName,
            bindings: []
        });
        if (t) {
            r.addBinding(t)
        }
        r.enable()
    },
    addBinding: function(e) {
        var t = this,
        n = e.key,
        r, i;
        if (t.processing) {
            t.bindings = bindings.slice(0)
        }
        if (Ext.isArray(e)) {
            for (r = 0, i = e.length; r < i; r++) {
                t.addBinding(e[r])
            }
            return
        }
        t.bindings.push(Ext.apply({
            keyCode: t.processKeys(n)
        },
        e))
    },
    removeBinding: function(e) {
        var t = this,
        n = t.bindings,
        r = n.length,
        i, s, o;
        if (t.processing) {
            t.bindings = n.slice(0)
        }
        o = t.processKeys(e.key);
        for (i = 0; i < r; ++i) {
            s = n[i];
            if ((s.fn || s.handler) === (e.fn || e.handler) && s.scope === e.scope) {
                if (e.alt === s.alt && e.crtl === s.crtl && e.shift === s.shift) {
                    if (Ext.Array.equals(s.keyCode, o)) {
                        Ext.Array.erase(t.bindings, i, 1);
                        return
                    }
                }
            }
        }
    },
    processKeys: function(e) {
        var t = false,
        n, r, i, s, o;
        if (Ext.isString(e)) {
            r = [];
            i = e.toUpperCase();
            for (o = 0, s = i.length; o < s; ++o) {
                r.push(i.charCodeAt(o))
            }
            e = r;
            t = true
        }
        if (!Ext.isArray(e)) {
            e = [e]
        }
        if (!t) {
            for (o = 0, s = e.length; o < s; ++o) {
                n = e[o];
                if (Ext.isString(n)) {
                    e[o] = n.toUpperCase().charCodeAt(0)
                }
            }
        }
        return e
    },
    handleTargetEvent: function() {
        var e = /input|textarea/i;
        return function(t) {
            var n = this,
            r, i, s, o, u;
            if (n.enabled) {
                r = n.bindings;
                i = 0;
                s = r.length;
                t = n.processEvent.apply(n || n.processEventScope, arguments);
                if (n.ignoreInputFields) {
                    o = t.target;
                    u = o.contentEditable;
                    if (e.test(o.tagName) || u === "" || u === "true") {
                        return
                    }
                }
                if (!t.getKey) {
                    return t
                }
                n.processing = true;
                for (; i < s; ++i) {
                    n.processBinding(r[i], t)
                }
                n.processing = false
            }
        }
    } (),
    processEvent: Ext.identityFn,
    processBinding: function(e, t) {
        if (this.checkModifiers(e, t)) {
            var n = t.getKey(),
            r = e.fn || e.handler,
            i = e.scope || this,
            s = e.keyCode,
            o = e.defaultEventAction,
            u,
            a,
            f = new Ext.EventObjectImpl(t);
            for (u = 0, a = s.length; u < a; ++u) {
                if (n === s[u]) {
                    if (r.call(i, n, t) !== true && o) {
                        f[o]()
                    }
                    break
                }
            }
        }
    },
    checkModifiers: function(e, t) {
        var n = ["shift", "ctrl", "alt"],
        r = 0,
        i = n.length,
        s,
        o;
        for (; r < i; ++r) {
            o = n[r];
            s = e[o];
            if (! (s === undefined || s === t[o + "Key"])) {
                return false
            }
        }
        return true
    },
    on: function(e, t, n) {
        var r, i, s, o;
        if (Ext.isObject(e) && !Ext.isArray(e)) {
            r = e.key;
            i = e.shift;
            s = e.ctrl;
            o = e.alt
        } else {
            r = e
        }
        this.addBinding({
            key: r,
            shift: i,
            ctrl: s,
            alt: o,
            fn: t,
            scope: n
        })
    },
    un: function(e, t, n) {
        var r, i, s, o;
        if (Ext.isObject(e) && !Ext.isArray(e)) {
            r = e.key;
            i = e.shift;
            s = e.ctrl;
            o = e.alt
        } else {
            r = e
        }
        this.removeBinding({
            key: r,
            shift: i,
            ctrl: s,
            alt: o,
            fn: t,
            scope: n
        })
    },
    isEnabled: function() {
        return this.enabled
    },
    enable: function() {
        var e = this;
        if (!e.enabled) {
            e.target.on(e.eventName, e.handleTargetEvent, e);
            e.enabled = true
        }
    },
    disable: function() {
        var e = this;
        if (e.enabled) {
            e.target.removeListener(e.eventName, e.handleTargetEvent, e);
            e.enabled = false
        }
    },
    setDisabled: function(e) {
        if (e) {
            this.disable()
        } else {
            this.enable()
        }
    },
    destroy: function(e) {
        var t = this,
        n = t.target;
        t.bindings = [];
        t.disable();
        if (e === true) {
            if (n.isComponent) {
                n.destroy()
            } else {
                n.remove()
            }
        }
        delete t.target
    }
});
Ext.define("Ext.util.KeyNav", {
    alternateClassName: "Ext.KeyNav",
    statics: {
        keyOptions: {
            left: 37,
            right: 39,
            up: 38,
            down: 40,
            space: 32,
            pageUp: 33,
            pageDown: 34,
            del: 46,
            backspace: 8,
            home: 36,
            end: 35,
            enter: 13,
            esc: 27,
            tab: 9
        }
    },
    constructor: function(e) {
        var t = this;
        if (e.beforeCall) {
            t.beforeCall = e.beforeCall
        }
        if (arguments.length === 2) {
            t.legacyConstructor.apply(t, arguments);
            return
        }
        t.setConfig(e)
    },
    legacyConstructor: function(e, t) {
        this.setConfig(Ext.apply({
            target: e
        },
        t))
    },
    setConfig: function(e) {
        var t = this,
        n = {
            target: e.target,
            ignoreInputFields: e.ignoreInputFields,
            eventName: t.getKeyEvent("forceKeyDown" in e ? e.forceKeyDown: t.forceKeyDown, e.eventName)
        },
        r,
        i,
        s,
        o,
        u;
        if (t.map) {
            t.map.destroy()
        }
        if (e.processEvent) {
            n.processEvent = e.processEvent;
            n.processEventScope = e.processEventScope || t
        }
        if (e.keyMap) {
            r = t.map = e.keyMap
        } else {
            r = t.map = new Ext.util.KeyMap(n);
            t.destroyKeyMap = true
        }
        i = Ext.util.KeyNav.keyOptions;
        s = e.scope || t;
        for (o in e) {
            u = e[o];
            if (u && (o.length === 1 || (o = i[o]) || !isNaN(o = parseInt(o, 10)))) {
                if (typeof u === "function") {
                    u = {
                        handler: u,
                        defaultEventAction: e.defaultEventAction !== undefined ? e.defaultEventAction: t.defaultEventAction
                    }
                }
                r.addBinding({
                    key: o,
                    ctrl: u.ctrl,
                    shift: u.shift,
                    alt: u.alt,
                    handler: Ext.Function.bind(t.handleEvent, u.scope || s, u.handler || u.fn, true),
                    defaultEventAction: u.defaultEventAction !== undefined ? u.defaultEventAction: t.defaultEventAction
                })
            }
        }
        r.disable();
        if (!e.disabled) {
            r.enable()
        }
    },
    handleEvent: function(e, t, n) {
        var r = this;
        if (r.beforeCall && r.beforeCall(t) === false) {
            return true
        }
        return n.call(r, t)
    },
    disabled: false,
    defaultEventAction: "stopEvent",
    forceKeyDown: false,
    eventName: "keypress",
    destroy: function(e) {
        if (this.destroyKeyMap) {
            this.map.destroy(e)
        }
        delete this.map
    },
    enable: function() {
        if (this.map) {
            this.map.enable();
            this.disabled = false
        }
    },
    disable: function() {
        if (this.map) {
            this.map.disable()
        }
        this.disabled = true
    },
    setDisabled: function(e) {
        this.map.setDisabled(e);
        this.disabled = e
    },
    getKeyEvent: function(e, t) {
        if (e || Ext.EventManager.useKeyDown && !t) {
            return "keydown"
        } else {
            return t || this.eventName
        }
    }
});
Ext.define("Ext.FocusManager", {
    singleton: true,
    alternateClassName: ["Ext.FocusMgr"],
    mixins: {
        observable: Ext.util.Observable
    },
    enabled: false,
    focusElementCls: Ext.baseCSSPrefix + "focus-element",
    focusFrameCls: Ext.baseCSSPrefix + "focus-frame",
    whitelist: ["textfield"],
    constructor: function(e) {
        var t = this,
        n = Ext.ComponentQuery;
        t.mixins.observable.constructor.call(t, e);
        t.addEvents("beforecomponentfocus", "componentfocus", "disable", "enable");
        t.focusTask = new Ext.util.DelayedTask(t.handleComponentFocus, t);
        Ext.override(Ext.AbstractComponent, {
            onFocus: function() {
                this.callParent(arguments);
                if (t.enabled && this.hasFocus) {
                    Array.prototype.unshift.call(arguments, this);
                    t.onComponentFocus.apply(t, arguments)
                }
            },
            onBlur: function() {
                this.callParent(arguments);
                if (t.enabled && !this.hasFocus) {
                    Array.prototype.unshift.call(arguments, this);
                    t.onComponentBlur.apply(t, arguments)
                }
            },
            onDestroy: function() {
                this.callParent(arguments);
                if (t.enabled) {
                    Array.prototype.unshift.call(arguments, this);
                    t.onComponentDestroy.apply(t, arguments)
                }
            }
        });
        Ext.override(Ext.Component, {
            afterHide: function() {
                this.callParent(arguments);
                if (t.enabled) {
                    Array.prototype.unshift.call(arguments, this);
                    t.onComponentHide.apply(t, arguments)
                }
            }
        });
        t.keyNav = new Ext.util.KeyNav(Ext.getDoc(), {
            disabled: true,
            scope: t,
            backspace: t.focusLast,
            enter: t.navigateIn,
            esc: t.navigateOut,
            tab: t.navigateSiblings,
            space: t.navigateIn,
            del: t.focusLast,
            left: t.navigateSiblings,
            right: t.navigateSiblings,
            down: t.navigateSiblings,
            up: t.navigateSiblings
        });
        t.focusData = {};
        t.subscribers = new Ext.util.HashMap;
        t.focusChain = {};
        Ext.apply(n.pseudos, {
            nextFocus: function(e, t, n) {
                n = n || 1;
                t = parseInt(t, 10);
                var r = e.length,
                i = t,
                s;
                for (;;) {
                    if ((i += n) >= r) {
                        i = 0
                    } else {
                        if (i < 0) {
                            i = r - 1
                        }
                    }
                    if (i === t) {
                        return []
                    }
                    if ((s = e[i]).isFocusable()) {
                        return [s]
                    }
                }
                return []
            },
            prevFocus: function(e, t) {
                return this.nextFocus(e, t, -1)
            },
            root: function(e) {
                var t = e.length,
                n = [],
                r = 0,
                i;
                for (; r < t; r++) {
                    i = e[r];
                    if (!i.ownerCt) {
                        n.push(i)
                    }
                }
                return n
            }
        })
    },
    addXTypeToWhitelist: function(e) {
        var t = this;
        if (Ext.isArray(e)) {
            Ext.Array.forEach(e, t.addXTypeToWhitelist, t);
            return
        }
        if (!Ext.Array.contains(t.whitelist, e)) {
            t.whitelist.push(e)
        }
    },
    clearComponent: function(e) {
        clearTimeout(this.cmpFocusDelay);
        if (!e.isDestroyed) {
            e.blur()
        }
    },
    disable: function() {
        var e = this;
        if (!e.enabled) {
            return
        }
        delete e.options;
        e.enabled = false;
        e.removeDOM();
        e.keyNav.disable();
        e.fireEvent("disable", e)
    },
    enable: function(e) {
        var t = this;
        if (e === true) {
            e = {
                focusFrame: true
            }
        }
        t.options = e = e || {};
        if (t.enabled) {
            return
        }
        t.enabled = Ext.enableFocusManager = true;
        t.initDOM(e);
        t.keyNav.enable();
        t.focusEl.focus();
        delete t.focusedCmp;
        t.fireEvent("enable", t)
    },
    focusLast: function(e) {
        var t = this;
        if (t.isWhitelisted(t.focusedCmp)) {
            return true
        }
        if (t.previousFocusedCmp) {
            t.previousFocusedCmp.focus()
        }
    },
    getRootComponents: function() {
        var e = Ext.ComponentQuery,
        t = e.query(":focusable:root:not([floating])"),
        n = e.query(":focusable:root[floating]");
        n.sort(function(e, t) {
            return e.el.getZIndex() > t.el.getZIndex()
        });
        return n.concat(t)
    },
    initDOM: function(e) {
        var t = this,
        n = t.focusFrameCls,
        r = Ext.ComponentQuery.query("{getFocusEl()}:not([focusListenerAdded])"),
        i = 0,
        s = r.length;
        if (!Ext.isReady) {
            return Ext.onReady(t.initDOM, t)
        }
        for (; i < s; i++) {
            r[i].addFocusListener()
        }
        if (!t.focusEl) {
            t.focusEl = Ext.getBody();
            t.focusEl.dom.tabIndex = -1
        }
        if (!t.focusFrame && e.focusFrame) {
            t.focusFrame = Ext.getBody().createChild({
                cls: n,
                children: [{
                    cls: n + "-top"
                },
                {
                    cls: n + "-bottom"
                },
                {
                    cls: n + "-left"
                },
                {
                    cls: n + "-right"
                }],
                style: "top: -100px; left: -100px;"
            });
            t.focusFrame.setVisibilityMode(Ext.Element.DISPLAY);
            t.focusFrame.hide().setLocalXY(0, 0)
        }
    },
    isWhitelisted: function(e) {
        return e && Ext.Array.some(this.whitelist,
        function(t) {
            return e.isXType(t)
        })
    },
    navigateIn: function(e) {
        var t = this,
        n = t.focusedCmp,
        r, i;
        if (t.isWhitelisted(n)) {
            return true
        }
        if (!n) {
            r = t.getRootComponents()[0];
            if (r) {
                if (r.getFocusEl() === t.focusEl) {
                    t.focusEl.blur()
                }
                r.focus()
            }
        } else {
            i = n.hasFocus ? Ext.ComponentQuery.query(">:focusable", n)[0] : n;
            if (i) {
                i.focus()
            } else {
                if (Ext.isFunction(n.onClick)) {
                    e.button = 0;
                    n.onClick(e);
                    if (n.isVisible(true)) {
                        n.focus()
                    } else {
                        t.navigateOut()
                    }
                }
            }
        }
    },
    navigateOut: function(e) {
        var t = this,
        n;
        if (!t.focusedCmp || !(n = t.focusedCmp.up(":focusable"))) {
            t.focusEl.focus()
        } else {
            n.focus()
        }
        return true
    },
    navigateSiblings: function(e, t, n) {
        var r = this,
        i = t || r,
        s = e.getKey(),
        o = Ext.EventObject,
        u = e.shiftKey || s == o.LEFT || s == o.UP,
        a = s == o.LEFT || s == o.RIGHT || s == o.UP || s == o.DOWN,
        f = u ? "prev": "next",
        l,
        c,
        h,
        p;
        h = i.focusedCmp && i.focusedCmp.comp || i.focusedCmp;
        if (!h && !n) {
            return true
        }
        if (a && r.isWhitelisted(h)) {
            return true
        }
        if (!h || h.is(":root")) {
            p = r.getRootComponents()
        } else {
            n = n || h.up();
            if (n) {
                p = n.getRefItems()
            }
        }
        if (p) {
            l = h ? Ext.Array.indexOf(p, h) : -1;
            c = Ext.ComponentQuery.query(":" + f + "Focus(" + l + ")", p)[0];
            if (c && h !== c) {
                c.focus();
                return c
            }
        }
    },
    onComponentBlur: function(e, t) {
        var n = this;
        if (n.focusedCmp === e) {
            n.previousFocusedCmp = e;
            delete n.focusedCmp
        }
        if (n.focusFrame) {
            n.focusFrame.hide()
        }
    },
    onComponentFocus: function(e, t) {
        var n = this,
        r = n.focusChain,
        i;
        if (!e.isFocusable()) {
            n.clearComponent(e);
            if (r[e.id]) {
                return
            }
            i = e.up();
            if (i) {
                r[e.id] = true;
                i.focus()
            }
            return
        }
        n.focusChain = {};
        n.focusTask.delay(10, null, null, [e, e.getFocusEl()])
    },
    handleComponentFocus: function(e, t) {
        var n = this,
        r, i, s, o, u, a, f, l, c, h, p;
        if (n.fireEvent("beforecomponentfocus", n, e, n.previousFocusedCmp) === false) {
            n.clearComponent(e);
            return
        }
        n.focusedCmp = e;
        if (n.shouldShowFocusFrame(e)) {
            r = "." + n.focusFrameCls + "-";
            i = n.focusFrame;
            s = (t.dom ? t: t.el).getBox();
            o = s.top;
            u = s.left;
            a = s.width;
            f = s.height;
            l = i.child(r + "top");
            c = i.child(r + "bottom");
            h = i.child(r + "left");
            p = i.child(r + "right");
            l.setWidth(a).setLocalXY(u, o);
            c.setWidth(a).setLocalXY(u, o + f - 2);
            h.setHeight(f - 2).setLocalXY(u, o + 2);
            p.setHeight(f - 2).setLocalXY(u + a - 2, o + 2);
            i.show()
        }
        n.fireEvent("componentfocus", n, e, n.previousFocusedCmp)
    },
    onComponentHide: function(e) {
        var t = this,
        n = false,
        r = t.focusedCmp,
        i;
        if (r) {
            n = e.hasFocus || e.isContainer && e.isAncestor(t.focusedCmp)
        }
        t.clearComponent(e);
        if (n && (i = e.up(":focusable"))) {
            i.focus()
        } else {
            t.focusEl.focus()
        }
    },
    onComponentDestroy: function() {},
    removeDOM: function() {
        var e = this;
        if (e.enabled || e.subscribers.length) {
            return
        }
        Ext.destroy(e.focusFrame);
        delete e.focusEl;
        delete e.focusFrame
    },
    removeXTypeFromWhitelist: function(e) {
        var t = this;
        if (Ext.isArray(e)) {
            Ext.Array.forEach(e, t.removeXTypeFromWhitelist, t);
            return
        }
        Ext.Array.remove(t.whitelist, e)
    },
    setupSubscriberKeys: function(e, t) {
        var n = this,
        r = e.getFocusEl(),
        i = t.scope,
        s = {
            backspace: n.focusLast,
            enter: n.navigateIn,
            esc: n.navigateOut,
            scope: n
        },
        o = function(t) {
            if (n.focusedCmp === e) {
                return n.navigateSiblings(t, n, e)
            } else {
                return n.navigateSiblings(t)
            }
        };
        Ext.iterate(t,
        function(t, n) {
            s[t] = function(t) {
                var r = o(t);
                if (Ext.isFunction(n) && n.call(i || e, t, r) === true) {
                    return true
                }
                return r
            }
        },
        n);
        return new Ext.util.KeyNav(r, s)
    },
    shouldShowFocusFrame: function(e) {
        var t = this,
        n = t.options || {};
        if (!t.focusFrame || !e) {
            return false
        }
        if (n.focusFrame) {
            return true
        }
        if (t.focusData[e.id].focusFrame) {
            return true
        }
        return false
    }
});
Ext.define("Ext.Img", {
    extend: Ext.Component,
    alias: ["widget.image", "widget.imagecomponent"],
    autoEl: "img",
    baseCls: Ext.baseCSSPrefix + "img",
    src: "",
    alt: "",
    title: "",
    imgCls: "",
    stretch: true,
    ariaRole: "img",
    maskOnDisable: false,
    initComponent: function() {
        if (this.glyph) {
            this.autoEl = "div"
        }
        this.callParent()
    },
    getElConfig: function() {
        var e = this,
        t = e.autoEl,
        n = e.callParent(),
        r = Ext._glyphFontFamily,
        i = e.glyph,
        s,
        o;
        if (t === "img" || Ext.isObject(t) && t.tag === "img") {
            s = n
        } else {
            if (e.glyph) {
                if (typeof i === "string") {
                    o = i.split("@");
                    i = o[0];
                    r = o[1]
                }
                n.html = "&#" + i + ";";
                if (r) {
                    n.style = "font-family:" + r
                }
            } else {
                n.cn = [s = {
                    tag: "img",
                    role: e.ariaRole,
                    id: e.id + "-img"
                }]
            }
        }
        if (s) {
            if (e.imgCls) {
                s.cls = (s.cls ? s.cls + " ": "") + e.imgCls
            }
            if (e.stretch) {
                s.src = e.src || Ext.BLANK_IMAGE_URL
            } else {
                s.src = Ext.BLANK_IMAGE_URL;
                if (!s.style) {
                    s.style = {}
                }
                s.style["background-image"] = "url(" + e.src + ")";
                s.style["background-repeat"] = "no-repeat"
            }
        }
        if (e.alt) { (s || n).alt = e.alt
        }
        if (e.title) { (s || n).title = e.title
        }
        return n
    },
    onRender: function() {
        var e = this,
        t = e.autoEl,
        n;
        e.callParent(arguments);
        n = e.el;
        if (t === "img" || Ext.isObject(t) && t.tag === "img") {
            e.imgEl = n
        } else {
            e.imgEl = n.getById(e.id + "-img")
        }
    },
    onDestroy: function() {
        Ext.destroy(this.imgEl);
        this.imgEl = null;
        this.callParent()
    },
    setStretch: function(e) {
        var t = this;
        t.stretch = e;
        t.setSrc(t.src)
    },
    setSrc: function(e) {
        var t = this,
        n = t.imgEl;
        t.src = e;
        if (n) {
            if (t.stretch) {
                n.dom.src = e || Ext.BLANK_IMAGE_URL;
                n.setStyle("background-image", "")
            } else {
                n.dom.src = Ext.BLANK_IMAGE_URL;
                n.setStyle("background-image", "url(" + e + ")");
                n.setStyle("background-repeat", "no-repeat")
            }
        }
    },
    setGlyph: function(e) {
        var t = this,
        n = Ext._glyphFontFamily,
        r, i;
        if (e != t.glyph) {
            if (typeof e === "string") {
                r = e.split("@");
                e = r[0];
                n = r[1]
            }
            i = t.el.dom;
            i.innerHTML = "&#" + e + ";";
            if (n) {
                i.style = "font-family:" + n
            }
        }
    }
});
Ext.define("Ext.util.Bindable", {
    bindStore: function(e, t, n) {
        n = n || "store";
        var r = this,
        i = r[n];
        if (!t && i) {
            r.onUnbindStore(i, t, n);
            if (e !== i && i.autoDestroy !== false) {
                if (i.treeStore) {
                    i.treeStore.destroyStore()
                }
                i.destroyStore()
            } else {
                r.unbindStoreListeners(i)
            }
        }
        if (e) {
            e = Ext.data.StoreManager.lookup(e);
            r.bindStoreListeners(e);
            r.onBindStore(e, t, n)
        }
        r[n] = e || null;
        return r
    },
    getStore: function() {
        return this.store
    },
    unbindStoreListeners: function(e) {
        var t = this.storeListeners;
        if (t) {
            e.un(t)
        }
    },
    bindStoreListeners: function(e) {
        var t = this,
        n = Ext.apply({},
        t.getStoreListeners(e));
        if (!n.scope) {
            n.scope = t
        }
        t.storeListeners = n;
        e.on(n)
    },
    getStoreListeners: Ext.emptyFn,
    onUnbindStore: Ext.emptyFn,
    onBindStore: Ext.emptyFn
});
Ext.define("Ext.LoadMask", {
    extend: Ext.Component,
    alias: "widget.loadmask",
    mixins: {
        bindable: Ext.util.Bindable
    },
    isLoadMask: true,
    msg: "Loading...",
    msgCls: Ext.baseCSSPrefix + "mask-loading",
    maskCls: Ext.baseCSSPrefix + "mask",
    cls: Ext.baseCSSPrefix + "mask-msg",
    useMsg: true,
    useTargetEl: false,
    ariaRole: "presentation",
    childEls: ["msgEl", "msgTextEl"],
    renderTpl: ['<div id="{id}-msgEl" role="{role}"', '<tpl if="ariaAttr"> {ariaAttr}</tpl>', ' class="{[values.$comp.msgCls]} ', Ext.baseCSSPrefix, 'mask-msg-inner {childElCls}">', '<div id="{id}-msgTextEl" class="', Ext.baseCSSPrefix, "mask-msg-text", '{childElCls}">{msg}</div>', "</div>"],
    constructor: function(e) {
        var t = this,
        n;
        if (arguments.length === 2) {
            n = t.target = e;
            e = arguments[1]
        } else {
            n = e.target
        }
        t.callParent([e]);
        if (n.isComponent) {
            t.ownerCt = n;
            t.hidden = true;
            t.renderTo = t.getMaskTarget();
            t.external = t.renderTo === Ext.getBody();
            t.bindComponent(n)
        } else {
            n = Ext.get(n);
            t.isElement = true;
            t.renderTo = t.target
        }
        t.render(t.renderTo);
        if (t.store) {
            t.bindStore(t.store, true)
        }
    },
    getRenderTree: function() {
        return [{
            cls: this.maskCls,
            style: "display:none"
        },
        this.callParent()]
    },
    onRender: function() {
        this.callParent(arguments);
        this.maskEl = this.el.prev()
    },
    initRenderData: function() {
        var e = this.callParent(arguments);
        e.msg = this.msg || "";
        return e
    },
    bindComponent: function(e) {
        var t = this,
        n = {
            scope: this,
            resize: t.sizeMask
        };
        if (t.external) {
            n.added = t.onComponentAdded;
            n.removed = t.onComponentRemoved;
            if (e.floating) {
                n.move = t.sizeMask;
                t.activeOwner = e
            } else {
                if (e.ownerCt) {
                    t.onComponentAdded(e.ownerCt)
                }
            }
        }
        t.mon(e, n);
        if (t.external) {
            t.mon(t.hierarchyEventSource, {
                show: t.onContainerShow,
                hide: t.onContainerHide,
                expand: t.onContainerExpand,
                collapse: t.onContainerCollapse,
                scope: t
            })
        }
    },
    onComponentAdded: function(e) {
        var t = this;
        delete t.activeOwner;
        t.floatParent = e;
        if (!e.floating) {
            e = e.up("[floating]")
        }
        if (e) {
            t.activeOwner = e;
            t.mon(e, "move", t.sizeMask, t);
            t.mon(e, "tofront", t.onOwnerToFront, t)
        } else {
            t.preventBringToFront = true
        }
        e = t.floatParent.ownerCt;
        if (t.rendered && t.isVisible() && e) {
            t.floatOwner = e;
            t.mon(e, "afterlayout", t.sizeMask, t, {
                single: true
            })
        }
    },
    onComponentRemoved: function(e) {
        var t = this,
        n = t.activeOwner,
        r = t.floatOwner;
        if (n) {
            t.mun(n, "move", t.sizeMask, t);
            t.mun(n, "tofront", t.onOwnerToFront, t)
        }
        if (r) {
            t.mun(r, "afterlayout", t.sizeMask, t)
        }
        delete t.activeOwner;
        delete t.floatOwner
    },
    afterRender: function() {
        this.callParent(arguments);
        this.el.$cache.skipGarbageCollection = true;
        this.maskEl.$cache.skipGarbageCollection = true
    },
    onOwnerToFront: function(e, t) {
        this.maskEl.setStyle("zIndex", t + 1);
        this.el.setStyle("zIndex", t + 2)
    },
    onContainerShow: function(e) {
        this.onComponentShow()
    },
    onContainerHide: function(e) {
        this.onComponentHide()
    },
    onContainerExpand: function(e) {
        this.onComponentShow()
    },
    onContainerCollapse: function(e) {
        this.onComponentHide()
    },
    onComponentHide: function() {
        var e = this;
        if (e.rendered && e.isVisible()) {
            e.hide();
            e.showNext = true
        }
    },
    onComponentShow: function() {
        if (this.showNext) {
            this.show()
        }
        delete this.showNext
    },
    sizeMask: function() {
        var e = this,
        t = e.target,
        n = e.external ? e.getOwner().el: e.getMaskTarget();
        if (e.rendered && e.isVisible()) {
            if (e.external) {
                if (!e.isElement && t.floating) {
                    e.onOwnerToFront(t, t.el.getZIndex())
                }
                e.maskEl.setSize(n.getSize()).alignTo(n, "tl-tl")
            }
            e.el.center(e.maskEl)
        }
    },
    bindStore: function(e, t) {
        var n = this;
        n.mixins.bindable.bindStore.apply(n, arguments);
        e = n.store;
        if (e && e.isLoading()) {
            n.onBeforeLoad()
        }
    },
    getStoreListeners: function(e) {
        var t = this.onLoad,
        n = this.onBeforeLoad,
        r = {
            cachemiss: n,
            cachefilled: t
        };
        if (!e.proxy.isSynchronous) {
            r.beforeLoad = n;
            r.load = t
        }
        return r
    },
    onDisable: function() {
        this.callParent(arguments);
        if (this.loading) {
            this.onLoad()
        }
    },
    getOwner: function() {
        return this.ownerCt || this.floatParent
    },
    getMaskTarget: function() {
        var e = this.getOwner();
        if (this.isElement) {
            return this.target
        }
        return this.useTargetEl ? e.getTargetEl() : e.getMaskTarget() || Ext.getBody()
    },
    onBeforeLoad: function() {
        var e = this,
        t = e.getOwner(),
        n;
        if (!e.disabled) {
            e.loading = true;
            if (t.componentLayoutCounter) {
                e.maybeShow()
            } else {
                n = t.afterComponentLayout;
                t.afterComponentLayout = function() {
                    t.afterComponentLayout = n;
                    n.apply(t, arguments);
                    e.maybeShow()
                }
            }
        }
    },
    maybeShow: function() {
        var e = this,
        t = e.getOwner();
        if (!t.isVisible(true)) {
            e.showNext = true
        } else {
            if (e.loading && t.rendered) {
                e.show()
            }
        }
    },
    hide: function() {
        if (this.isElement) {
            this.ownerCt.unmask();
            this.fireEvent("hide", this);
            return
        }
        delete this.showNext;
        this.maskEl.setDisplayed(false);
        return this.callParent(arguments)
    },
    show: function() {
        if (this.isElement) {
            this.ownerCt.mask(this.useMsg ? this.msg: "", this.msgCls);
            this.fireEvent("show", this);
            return
        }
        this.maskEl.setDisplayed(true);
        return this.callParent(arguments)
    },
    afterShow: function() {
        var e = this;
        e.loading = true;
        e.callParent(arguments);
        if (e.hasOwnProperty("maskCls")) {
            e.maskEl.dom.className = e.maskCls
        }
        if (e.useMsg) {
            e.msgTextEl.update(e.msg)
        } else {
            e.el.hide()
        }
        e.sizeMask()
    },
    onLoad: function() {
        this.loading = false;
        this.hide()
    },
    beforeDestroy: function() {
        this.ownerCt = null;
        this.callParent()
    },
    onDestroy: function() {
        var e = this;
        if (e.isElement) {
            e.ownerCt.unmask()
        }
        Ext.destroy(e.maskEl);
        e.callParent()
    }
});
Ext.define("Ext.data.association.Association", {
    alternateClassName: "Ext.data.Association",
    primaryKey: "id",
    associationKeyFunction: null,
    defaultReaderType: "json",
    isAssociation: true,
    initialConfig: null,
    statics: {
        AUTO_ID: 1e3,
        create: function(e) {
            if (Ext.isString(e)) {
                e = {
                    type: e
                }
            }
            switch (e.type) {
            case "belongsTo":
                return new Ext.data.association.BelongsTo(e);
            case "hasMany":
                return new Ext.data.association.HasMany(e);
            case "hasOne":
                return new Ext.data.association.HasOne(e);
            default:
            }
            return e
        }
    },
    constructor: function(e) {
        Ext.apply(this, e);
        var t = this,
        n = Ext.ModelManager.types,
        r = e.ownerModel,
        i = e.associatedModel,
        s = n[r],
        o = n[i],
        u = e.associationKey,
        a;
        if (u) {
            a = String(u).search(/[\[\.]/);
            if (a >= 0) {
                t.associationKeyFunction = Ext.functionFactory("obj", "return obj" + (a > 0 ? ".": "") + u)
            }
        }
        t.initialConfig = e;
        t.ownerModel = s;
        t.associatedModel = o;
        Ext.applyIf(t, {
            ownerName: r,
            associatedName: i
        });
        t.associationId = "association" + ++t.statics().AUTO_ID
    },
    getReader: function() {
        var e = this,
        t = e.reader,
        n = e.associatedModel;
        if (t) {
            if (Ext.isString(t)) {
                t = {
                    type: t
                }
            }
            if (t.isReader) {
                t.setModel(n)
            } else {
                Ext.applyIf(t, {
                    model: n,
                    type: e.defaultReaderType
                })
            }
            e.reader = Ext.createByAlias("reader." + t.type, t)
        }
        return e.reader || null
    }
});
Ext.define("Ext.ModelManager", {
    extend: Ext.AbstractManager,
    alternateClassName: "Ext.ModelMgr",
    singleton: true,
    typeName: "mtype",
    associationStack: [],
    registerType: function(e, t) {
        var n = t.prototype,
        r;
        if (n && n.isModel) {
            r = t
        } else {
            if (!t.extend) {
                t.extend = "Ext.data.Model"
            }
            r = Ext.define(e, t)
        }
        this.types[e] = r;
        return r
    },
    unregisterType: function(e) {
        delete this.types[e]
    },
    onModelDefined: function(e) {
        var t = this.associationStack,
        n = t.length,
        r = [],
        i,
        s,
        o;
        for (s = 0; s < n; s++) {
            i = t[s];
            if (i.associatedModel == e.modelName) {
                r.push(i)
            }
        }
        for (s = 0, n = r.length; s < n; s++) {
            o = r[s];
            this.types[o.ownerModel].prototype.associations.add(Ext.data.association.Association.create(o));
            Ext.Array.remove(t, o)
        }
    },
    registerDeferredAssociation: function(e) {
        this.associationStack.push(e)
    },
    getModel: function(e) {
        var t = e;
        if (typeof t == "string") {
            t = this.types[t]
        }
        return t
    },
    create: function(e, t, n) {
        var r = typeof t == "function" ? t: this.types[t || e.name];
        return new r(e, n)
    }
},
function() {
    Ext.regModel = function() {
        return this.ModelManager.registerType.apply(this.ModelManager, arguments)
    }
});
Ext.define("Ext.layout.component.Component", {
    extend: Ext.layout.Layout,
    type: "component",
    isComponentLayout: true,
    nullBox: {},
    usesContentHeight: true,
    usesContentWidth: true,
    usesHeight: true,
    usesWidth: true,
    beginLayoutCycle: function(e, t) {
        var n = this,
        r = n.owner,
        i = e.ownerCtContext,
        s = e.heightModel,
        o = e.widthModel,
        u = r.el.dom === document.body,
        a = r.lastBox || n.nullBox,
        f = r.el.lastBox || n.nullBox,
        l = !u,
        c, h, p, d;
        n.callParent(arguments);
        if (t) {
            if (n.usesContentWidth) {++e.consumersContentWidth
            }
            if (n.usesContentHeight) {++e.consumersContentHeight
            }
            if (n.usesWidth) {++e.consumersWidth
            }
            if (n.usesHeight) {++e.consumersHeight
            }
            if (i && !i.hasRawContent) {
                c = r.ownerLayout;
                if (c.usesWidth) {++e.consumersWidth
                }
                if (c.usesHeight) {++e.consumersHeight
                }
            }
        }
        if (o.configured) {
            p = o.names.width;
            if (!u) {
                l = n.setWidthInDom || (t ? r[p] !== f.width: o.constrained)
            }
            e.setWidth(r[p], l)
        } else {
            if (e.isTopLevel) {
                if (o.calculated) {
                    h = a.width;
                    e.setWidth(h, h != f.width)
                }
                h = a.x;
                e.setProp("x", h, h != f.x)
            }
        }
        if (s.configured) {
            d = s.names.height;
            if (!u) {
                l = t ? r[d] !== f.height: s.constrained
            }
            e.setHeight(r[d], l)
        } else {
            if (e.isTopLevel) {
                if (s.calculated) {
                    h = a.height;
                    e.setHeight(h, h != f.height)
                }
                h = a.y;
                e.setProp("y", h, h != f.y)
            }
        }
    },
    finishedLayout: function(e) {
        var t = this,
        n = e.children,
        r = t.owner,
        i, s, o, u, a;
        if (n) {
            i = n.length;
            for (s = 0; s < i; s++) {
                o = n[s];
                o.el.lastBox = o.props
            }
        }
        e.previousSize = t.lastComponentSize;
        t.lastComponentSize = r.el.lastBox = a = e.props;
        u = r.lastBox || (r.lastBox = {});
        u.x = a.x;
        u.y = a.y;
        u.width = a.width;
        u.height = a.height;
        u.invalid = false;
        t.callParent(arguments)
    },
    notifyOwner: function(e) {
        var t = this,
        n = t.lastComponentSize,
        r = e.previousSize,
        i = [n.width, n.height];
        if (r) {
            i.push(r.width, r.height)
        }
        t.owner.afterComponentLayout.apply(t.owner, i)
    },
    getTarget: function() {
        return this.owner.el
    },
    getRenderTarget: function() {
        return this.owner.el
    },
    cacheTargetInfo: function(e) {
        var t = this,
        n = t.targetInfo,
        r;
        if (!n) {
            r = e.getEl("getTarget", t);
            t.targetInfo = n = {
                padding: r.getPaddingInfo(),
                border: r.getBorderInfo()
            }
        }
        return n
    },
    measureAutoDimensions: function(e, t) {
        var n = this,
        r = n.owner,
        i = r.layout,
        s = e.heightModel,
        o = e.widthModel,
        u = e.boxParent,
        a = e.isBoxParent,
        f = e.props,
        l, c = {
            gotWidth: false,
            gotHeight: false,
            isContainer: l = !e.hasRawContent
        },
        h = t || 3,
        p,
        d,
        v = 0,
        m = 0,
        g,
        y,
        b;
        if (o.shrinkWrap && e.consumersContentWidth) {++v;
            p = !(h & 1);
            if (l) {
                if (p) {
                    c.contentWidth = 0;
                    c.gotWidth = true; ++m
                } else {
                    if ((c.contentWidth = e.getProp("contentWidth")) !== undefined) {
                        c.gotWidth = true; ++m
                    }
                }
            } else {
                y = f.contentWidth;
                if (typeof y == "number") {
                    c.contentWidth = y;
                    c.gotWidth = true; ++m
                } else {
                    if (p) {
                        g = true
                    } else {
                        if (!e.hasDomProp("containerChildrenSizeDone")) {
                            g = false
                        } else {
                            if (a || !u || u.widthModel.shrinkWrap) {
                                g = true
                            } else {
                                g = u.hasDomProp("width")
                            }
                        }
                    }
                    if (g) {
                        if (p) {
                            b = 0
                        } else {
                            if (i && i.measureContentWidth) {
                                b = i.measureContentWidth(e)
                            } else {
                                b = n.measureContentWidth(e)
                            }
                        }
                        if (!isNaN(c.contentWidth = b)) {
                            e.setContentWidth(b, true);
                            c.gotWidth = true; ++m
                        }
                    }
                }
            }
        } else {
            if (o.natural && e.consumersWidth) {++v;
                y = f.width;
                if (typeof y == "number") {
                    c.width = y;
                    c.gotWidth = true; ++m
                } else {
                    if (a || !u) {
                        g = true
                    } else {
                        g = u.hasDomProp("width")
                    }
                    if (g) {
                        if (!isNaN(c.width = n.measureOwnerWidth(e))) {
                            e.setWidth(c.width, false);
                            c.gotWidth = true; ++m
                        }
                    }
                }
            }
        }
        if (s.shrinkWrap && e.consumersContentHeight) {++v;
            d = !(h & 2);
            if (l) {
                if (d) {
                    c.contentHeight = 0;
                    c.gotHeight = true; ++m
                } else {
                    if ((c.contentHeight = e.getProp("contentHeight")) !== undefined) {
                        c.gotHeight = true; ++m
                    }
                }
            } else {
                y = f.contentHeight;
                if (typeof y == "number") {
                    c.contentHeight = y;
                    c.gotHeight = true; ++m
                } else {
                    if (d) {
                        g = true
                    } else {
                        if (!e.hasDomProp("containerChildrenSizeDone")) {
                            g = false
                        } else {
                            if (r.noWrap) {
                                g = true
                            } else {
                                if (!o.shrinkWrap) {
                                    g = (e.bodyContext || e).hasDomProp("width")
                                } else {
                                    if (a || !u || u.widthModel.shrinkWrap) {
                                        g = true
                                    } else {
                                        g = u.hasDomProp("width")
                                    }
                                }
                            }
                        }
                    }
                    if (g) {
                        if (d) {
                            b = 0
                        } else {
                            if (i && i.measureContentHeight) {
                                b = i.measureContentHeight(e)
                            } else {
                                b = n.measureContentHeight(e)
                            }
                        }
                        if (!isNaN(c.contentHeight = b)) {
                            e.setContentHeight(b, true);
                            c.gotHeight = true; ++m
                        }
                    }
                }
            }
        } else {
            if (s.natural && e.consumersHeight) {++v;
                y = f.height;
                if (typeof y == "number") {
                    c.height = y;
                    c.gotHeight = true; ++m
                } else {
                    if (a || !u) {
                        g = true
                    } else {
                        g = u.hasDomProp("width")
                    }
                    if (g) {
                        if (!isNaN(c.height = n.measureOwnerHeight(e))) {
                            e.setHeight(c.height, false);
                            c.gotHeight = true; ++m
                        }
                    }
                }
            }
        }
        if (u) {
            e.onBoxMeasured()
        }
        c.gotAll = m == v;
        return c
    },
    measureContentWidth: function(e) {
        return e.el.getWidth() - e.getFrameInfo().width
    },
    measureContentHeight: function(e) {
        return e.el.getHeight() - e.getFrameInfo().height
    },
    measureOwnerHeight: function(e) {
        return e.el.getHeight()
    },
    measureOwnerWidth: function(e) {
        return e.el.getWidth()
    }
});
Ext.define("Ext.layout.component.Auto", {
    alias: "layout.autocomponent",
    extend: Ext.layout.component.Component,
    type: "autocomponent",
    setHeightInDom: false,
    setWidthInDom: false,
    waitForOuterHeightInDom: false,
    waitForOuterWidthInDom: false,
    beginLayoutCycle: function(e, t) {
        var n = this,
        r = n.lastWidthModel,
        i = n.lastHeightModel,
        s = n.owner.el;
        n.callParent(arguments);
        if (r && r.fixed && e.widthModel.shrinkWrap) {
            s.setWidth(null)
        }
        if (i && i.fixed && e.heightModel.shrinkWrap) {
            s.setHeight(null)
        }
    },
    calculate: function(e) {
        var t = this,
        n = t.measureAutoDimensions(e),
        r = e.heightModel,
        i = e.widthModel,
        s,
        o;
        if (n.gotWidth) {
            if (i.shrinkWrap) {
                t.publishOwnerWidth(e, n.contentWidth)
            } else {
                if (t.publishInnerWidth) {
                    t.publishInnerWidth(e, n.width)
                }
            }
        } else {
            if (!i.auto && t.publishInnerWidth) {
                s = t.waitForOuterWidthInDom ? e.getDomProp("width") : e.getProp("width");
                if (s === undefined) {
                    t.done = false
                } else {
                    t.publishInnerWidth(e, s)
                }
            }
        }
        if (n.gotHeight) {
            if (r.shrinkWrap) {
                t.publishOwnerHeight(e, n.contentHeight)
            } else {
                if (t.publishInnerHeight) {
                    t.publishInnerHeight(e, n.height)
                }
            }
        } else {
            if (!r.auto && t.publishInnerHeight) {
                o = t.waitForOuterHeightInDom ? e.getDomProp("height") : e.getProp("height");
                if (o === undefined) {
                    t.done = false
                } else {
                    t.publishInnerHeight(e, o)
                }
            }
        }
        if (!n.gotAll) {
            t.done = false
        }
    },
    calculateOwnerHeightFromContentHeight: function(e, t) {
        return t + e.getFrameInfo().height
    },
    calculateOwnerWidthFromContentWidth: function(e, t) {
        return t + e.getFrameInfo().width
    },
    publishOwnerHeight: function(e, t) {
        var n = this,
        r = n.owner,
        i = n.calculateOwnerHeightFromContentHeight(e, t),
        s,
        o,
        u;
        if (isNaN(i)) {
            n.done = false
        } else {
            s = Ext.Number.constrain(i, r.minHeight, r.maxHeight);
            if (s == i) {
                o = n.setHeightInDom
            } else {
                u = n.sizeModels[s < i ? "constrainedMax": "constrainedMin"];
                i = s;
                if (e.heightModel.calculatedFromShrinkWrap) {
                    e.heightModel = u
                } else {
                    e.invalidate({
                        heightModel: u
                    })
                }
            }
            e.setHeight(i, o)
        }
    },
    publishOwnerWidth: function(e, t) {
        var n = this,
        r = n.owner,
        i = n.calculateOwnerWidthFromContentWidth(e, t),
        s,
        o,
        u;
        if (isNaN(i)) {
            n.done = false
        } else {
            s = Ext.Number.constrain(i, r.minWidth, r.maxWidth);
            if (s == i) {
                o = n.setWidthInDom
            } else {
                u = n.sizeModels[s < i ? "constrainedMax": "constrainedMin"];
                i = s;
                if (e.widthModel.calculatedFromShrinkWrap) {
                    e.widthModel = u
                } else {
                    e.invalidate({
                        widthModel: u
                    })
                }
            }
            e.setWidth(i, o)
        }
    }
});
Ext.define("Ext.layout.component.ProgressBar", {
    alias: ["layout.progressbar"],
    extend: Ext.layout.component.Auto,
    type: "progressbar",
    beginLayout: function(e) {
        var t = this,
        n, r;
        t.callParent(arguments);
        if (!e.textEls) {
            r = t.owner.textEl;
            if (r.isComposite) {
                e.textEls = [];
                r = r.elements;
                for (n = r.length; n--;) {
                    e.textEls[n] = e.getEl(Ext.get(r[n]))
                }
            } else {
                e.textEls = [e.getEl("textEl")]
            }
        }
    },
    calculate: function(e) {
        var t = this,
        n, r, i;
        t.callParent(arguments);
        if (Ext.isNumber(i = e.getProp("width"))) {
            i -= e.getBorderInfo().width;
            r = e.textEls;
            for (n = r.length; n--;) {
                r[n].setWidth(i)
            }
        } else {
            t.done = false
        }
    }
});
Ext.define("Ext.ProgressBar", {
    extend: Ext.Component,
    alias: "widget.progressbar",
    baseCls: Ext.baseCSSPrefix + "progress",
    animate: false,
    text: "",
    waitTimer: null,
    childEls: ["bar"],
    renderTpl: ['<tpl if="internalText">', '<div class="{baseCls}-text {baseCls}-text-back">{text}</div>', "</tpl>", '<div id="{id}-bar" class="{baseCls}-bar {baseCls}-bar-{ui}" role="presentation" style="width:{percentage}%">', '<tpl if="internalText">', '<div class="{baseCls}-text">', "<div>{text}</div>", "</div>", "</tpl>", "</div>"],
    componentLayout: "progressbar",
    ariaRole: "progressbar",
    initComponent: function() {
        this.callParent();
        this.addEvents("update")
    },
    initRenderData: function() {
        var e = this;
        return Ext.apply(e.callParent(), {
            internalText: !e.hasOwnProperty("textEl"),
            text: e.text || "&#160;",
            percentage: e.value ? e.value * 100 : 0
        })
    },
    onRender: function() {
        var e = this;
        e.callParent(arguments);
        if (e.textEl) {
            e.textEl = Ext.get(e.textEl);
            e.updateText(e.text)
        } else {
            e.textEl = e.el.select("." + e.baseCls + "-text")
        }
    },
    updateProgress: function(e, t, n) {
        var r = this,
        i = r.value;
        r.value = e || 0;
        if (t) {
            r.updateText(t)
        }
        if (r.rendered && !r.isDestroyed) {
            if (n === true || n !== false && r.animate) {
                r.bar.stopAnimation();
                r.bar.animate(Ext.apply({
                    from: {
                        width: i * 100 + "%"
                    },
                    to: {
                        width: r.value * 100 + "%"
                    }
                },
                r.animate))
            } else {
                r.bar.setStyle("width", r.value * 100 + "%")
            }
        }
        r.fireEvent("update", r, r.value, t);
        return r
    },
    updateText: function(e) {
        var t = this;
        t.text = e;
        if (t.rendered) {
            t.textEl.update(t.text)
        }
        return t
    },
    applyText: function(e) {
        this.updateText(e)
    },
    getText: function() {
        return this.text
    },
    wait: function(e) {
        var t = this,
        n;
        if (!t.waitTimer) {
            n = t;
            e = e || {};
            t.updateText(e.text);
            t.waitTimer = Ext.TaskManager.start({
                run: function(n) {
                    var r = e.increment || 10;
                    n -= 1;
                    t.updateProgress(((n + r) % r + 1) * (100 / r) * .01, null, e.animate)
                },
                interval: e.interval || 1e3,
                duration: e.duration,
                onStop: function() {
                    if (e.fn) {
                        e.fn.apply(e.scope || t)
                    }
                    t.reset()
                },
                scope: n
            })
        }
        return t
    },
    isWaiting: function() {
        return this.waitTimer !== null
    },
    reset: function(e) {
        var t = this;
        t.updateProgress(0);
        t.clearTimer();
        if (e === true) {
            t.hide()
        }
        return t
    },
    clearTimer: function() {
        var e = this;
        if (e.waitTimer) {
            e.waitTimer.onStop = null;
            Ext.TaskManager.stop(e.waitTimer);
            e.waitTimer = null
        }
    },
    onDestroy: function() {
        var e = this,
        t = e.bar;
        e.clearTimer();
        if (e.rendered) {
            if (e.textEl.isComposite) {
                e.textEl.clear()
            }
            Ext.destroyMembers(e, "textEl", "progressBar");
            if (t && e.animate) {
                t.stopAnimation()
            }
        }
        e.callParent()
    }
});
Ext.define("Ext.ShadowPool", {
    singleton: true,
    markup: function() {
        return Ext.String.format('<div class="{0}{1}-shadow" role="presentation"></div>', Ext.baseCSSPrefix, Ext.isIE && !Ext.supports.CSS3BoxShadow ? "ie": "css")
    } (),
    shadows: [],
    pull: function() {
        var e = this.shadows.shift();
        if (!e) {
            e = Ext.get(Ext.DomHelper.insertHtml("afterBegin", document.body, this.markup));
            e.autoBoxAdjust = false
        }
        return e
    },
    push: function(e) {
        this.shadows.push(e)
    },
    reset: function() {
        var e = [].concat(this.shadows),
        t,
        n = e.length;
        for (t = 0; t < n; t++) {
            e[t].remove()
        }
        this.shadows = []
    }
});
Ext.define("Ext.Shadow", {
    localXYNames: {
        get: "getLocalXY",
        set: "setLocalXY"
    },
    constructor: function(e) {
        var t = this,
        n, r, i;
        Ext.apply(t, e);
        if (!Ext.isString(t.mode)) {
            t.mode = t.defaultMode
        }
        r = t.offset;
        i = Math.floor(r / 2);
        t.opacity = 50;
        switch (t.mode.toLowerCase()) {
        case "drop":
            if (Ext.supports.CSS3BoxShadow) {
                n = {
                    t: r,
                    l: r,
                    h: -r,
                    w: -r
                }
            } else {
                n = {
                    t: -i,
                    l: -i,
                    h: -i,
                    w: -i
                }
            }
            break;
        case "sides":
            if (Ext.supports.CSS3BoxShadow) {
                n = {
                    t: r,
                    l: 0,
                    h: -r,
                    w: 0
                }
            } else {
                n = {
                    t: -(1 + i),
                    l: 1 + i - 2 * r,
                    h: -1,
                    w: i - 1
                }
            }
            break;
        case "frame":
            if (Ext.supports.CSS3BoxShadow) {
                n = {
                    t: 0,
                    l: 0,
                    h: 0,
                    w: 0
                }
            } else {
                n = {
                    t: 1 + i - 2 * r,
                    l: 1 + i - 2 * r,
                    h: r - i - 1,
                    w: r - i - 1
                }
            }
            break;
        case "bottom":
            if (Ext.supports.CSS3BoxShadow) {
                n = {
                    t: r,
                    l: 0,
                    h: -r,
                    w: 0
                }
            } else {
                n = {
                    t: r,
                    l: 0,
                    h: 0,
                    w: 0
                }
            }
            break
        }
        t.adjusts = n
    },
    getShadowSize: function() {
        var e = this,
        t = e.el ? e.offset: 0,
        n = [t, t, t, t],
        r = e.mode.toLowerCase();
        if (e.el && r !== "frame") {
            n[0] = 0;
            if (r == "drop") {
                n[3] = 0
            }
        }
        return n
    },
    offset: 4,
    defaultMode: "drop",
    boxShadowProperty: function() {
        var e = "boxShadow",
        t = document.documentElement.style;
        if (! ("boxShadow" in t)) {
            if ("WebkitBoxShadow" in t) {
                e = "WebkitBoxShadow"
            } else {
                if ("MozBoxShadow" in t) {
                    e = "MozBoxShadow"
                }
            }
        }
        return e
    } (),
    show: function(e) {
        var t = this,
        n, r;
        e = Ext.get(e);
        n = parseInt(e.getStyle("z-index"), 10) - 1 || 0;
        r = e[t.localXYNames.get]();
        if (!t.el) {
            t.el = Ext.ShadowPool.pull();
            if (t.fixed) {
                t.el.dom.style.position = "fixed"
            } else {
                t.el.dom.style.position = ""
            }
            if (t.el.dom.nextSibling != e.dom) {
                t.el.insertBefore(e)
            }
        }
        t.el.setStyle("z-index", t.zIndex || n);
        if (Ext.isIE && !Ext.supports.CSS3BoxShadow) {
            t.el.dom.style.filter = "progid:DXImageTransform.Microsoft.alpha(opacity=" + t.opacity + ") progid:DXImageTransform.Microsoft.Blur(pixelradius=" + t.offset + ")"
        }
        t.realign(r[0], r[1], e.dom.offsetWidth, e.dom.offsetHeight);
        t.el.dom.style.display = "block"
    },
    isVisible: function() {
        return this.el ? true: false
    },
    realign: function(e, t, n, r) {
        if (!this.el) {
            return
        }
        var i = this.adjusts,
        s = this.el,
        o = s.dom.style,
        u, a, f, l;
        s[this.localXYNames.set](e + i.l, t + i.t);
        u = Math.max(n + i.w, 0);
        a = Math.max(r + i.h, 0);
        f = u + "px";
        l = a + "px";
        if (o.width != f || o.height != l) {
            o.width = f;
            o.height = l;
            if (Ext.supports.CSS3BoxShadow) {
                o[this.boxShadowProperty] = "0 0 " + (this.offset + 2) + "px #888"
            }
        }
    },
    hide: function() {
        var e = this;
        if (e.el) {
            e.el.dom.style.display = "none";
            Ext.ShadowPool.push(e.el);
            delete e.el
        }
    },
    setZIndex: function(e) {
        this.zIndex = e;
        if (this.el) {
            this.el.setStyle("z-index", e)
        }
    },
    setOpacity: function(e) {
        if (this.el) {
            if (Ext.isIE && !Ext.supports.CSS3BoxShadow) {
                e = Math.floor(e * 100 / 2) / 100
            }
            this.opacity = e;
            this.el.setOpacity(e)
        }
    }
});
Ext.define("Ext.app.EventDomain", {
    statics: {
        instances: {}
    },
    isEventDomain: true,
    constructor: function() {
        var e = this;
        Ext.app.EventDomain.instances[e.type] = e;
        e.bus = {};
        e.monitoredClasses = []
    },
    dispatch: function(e, t, n) {
        var r = this,
        i = r.bus,
        s = i[t.toLowerCase()],
        o,
        u,
        a,
        f,
        l,
        c,
        h;
        if (!s) {
            return true
        }
        for (o in s) {
            if (s.hasOwnProperty(o) && r.match(e, o)) {
                u = s[o];
                for (a in u) {
                    if (u.hasOwnProperty(a)) {
                        f = u[a];
                        for (c = 0, h = f.length; c < h; c++) {
                            l = f[c];
                            if (l.fire.apply(l, n) === false) {
                                return false
                            }
                        }
                    }
                }
            }
        }
        return true
    },
    listen: function(e, t) {
        var n = this,
        r = n.bus,
        i = n.idProperty,
        s = n.monitoredClasses,
        o = s.length,
        u, a, f, l, c, h, p, d, v, m;
        for (l in e) {
            if (e.hasOwnProperty(l) && (v = e[l])) {
                if (i) {
                    l = l === "*" ? l: l.substring(1)
                }
                for (m in v) {
                    if (v.hasOwnProperty(m)) {
                        c = null;
                        h = v[m];
                        p = t;
                        m = m.toLowerCase();
                        d = new Ext.util.Event(t, m);
                        if (Ext.isObject(h)) {
                            c = h;
                            h = c.fn;
                            p = c.scope || t;
                            delete c.fn;
                            delete c.scope
                        }
                        if (typeof h === "string") {
                            h = p[h]
                        }
                        d.addListener(h, p, c);
                        for (u = o; u-->0;) {
                            s[u].hasListeners._incr_(m)
                        }
                        a = r[m] || (r[m] = {});
                        a = a[l] || (a[l] = {});
                        f = a[t.id] || (a[t.id] = []);
                        f.push(d)
                    }
                }
            }
        }
    },
    match: function(e, t) {
        var n = this.idProperty;
        if (n) {
            return t === "*" || e[n] === t
        }
        return false
    },
    monitor: function(e) {
        var t = this,
        n = e.isInstance ? e: e.prototype,
        r = n.fireEventArgs;
        t.monitoredClasses.push(e);
        n.fireEventArgs = function(e, n) {
            var i = r.apply(this, arguments);
            if (i !== false) {
                i = t.dispatch(this, e, n)
            }
            return i
        }
    },
    unlisten: function(e) {
        var t = this.bus,
        n, r, i, s;
        for (r in t) {
            r = r.toLowerCase();
            if (t.hasOwnProperty(r) && (s = t[r])) {
                for (i in s) {
                    n = s[i];
                    delete n[e]
                }
            }
        }
    }
});
Ext.define("Ext.app.domain.Component", {
    extend: Ext.app.EventDomain,
    singleton: true,
    type: "component",
    constructor: function() {
        var e = this;
        e.callParent();
        e.monitor(Ext.Component)
    },
    match: function(e, t) {
        return e.is(t)
    }
});
Ext.define("Ext.app.EventBus", {
    singleton: true,
    constructor: function() {
        var e = this,
        t = Ext.app.EventDomain.instances;
        e.callParent();
        e.domains = t;
        e.bus = t.component.bus
    },
    control: function(e, t) {
        return this.domains.component.listen(e, t)
    },
    listen: function(e, t) {
        var n = this.domains,
        r;
        for (r in e) {
            if (e.hasOwnProperty(r)) {
                n[r].listen(e[r], t)
            }
        }
    },
    unlisten: function(e) {
        var t = Ext.app.EventDomain.instances,
        n;
        for (n in t) {
            t[n].unlisten(e)
        }
    }
});
Ext.define("Ext.data.ResultSet", {
    loaded: true,
    count: 0,
    total: 0,
    success: false,
    constructor: function(e) {
        Ext.apply(this, e);
        this.totalRecords = this.total;
        if (e.count === undefined) {
            this.count = this.records.length
        }
    }
});
Ext.define("Ext.data.reader.Reader", {
    alternateClassName: ["Ext.data.Reader", "Ext.data.DataReader"],
    mixins: {
        observable: Ext.util.Observable
    },
    totalProperty: "total",
    successProperty: "success",
    root: "",
    implicitIncludes: true,
    readRecordsOnFailure: true,
    isReader: true,
    applyDefaults: true,
    lastFieldGeneration: null,
    constructor: function(e) {
        var t = this;
        t.mixins.observable.constructor.call(t, e);
        t.model = Ext.ModelManager.getModel(t.model);
        if (t.model && t.model.prototype.fields) {
            t.buildExtractors()
        }
        this.addEvents("exception")
    },
    setModel: function(e, t) {
        var n = this,
        r = n.model,
        i = true;
        e = n.model = Ext.ModelManager.getModel(e);
        if (e && r === e) {
            i = n.lastFieldGeneration !== e.prototype.fields.generation
        }
        if (e) {
            n.buildExtractors(i)
        }
        if (t && n.proxy) {
            n.proxy.setModel(e, true)
        }
    },
    read: function(e) {
        var t;
        if (e) {
            t = e.responseText ? this.getResponseData(e) : this.readRecords(e)
        }
        return t || this.nullResultSet
    },
    readRecords: function(e) {
        var t = this,
        n, r, i, s, o, u, a;
        if (t.lastFieldGeneration !== t.model.prototype.fields.generation) {
            t.buildExtractors(true)
        }
        t.rawData = e;
        e = t.getData(e);
        n = true;
        r = 0;
        i = [];
        if (t.successProperty) {
            u = t.getSuccess(e);
            if (u === false || u === "false") {
                n = false
            }
        }
        if (t.messageProperty) {
            a = t.getMessage(e)
        }
        if (t.readRecordsOnFailure || n) {
            s = Ext.isArray(e) ? e: t.getRoot(e);
            if (s) {
                o = s.length
            }
            if (t.totalProperty) {
                u = parseInt(t.getTotal(e), 10);
                if (!isNaN(u)) {
                    o = u
                }
            }
            if (s) {
                i = t.extractData(s);
                r = i.length
            }
        }
        return new Ext.data.ResultSet({
            total: o || r,
            count: r,
            records: i,
            success: n,
            message: a
        })
    },
    extractData: function(e) {
        var t = this,
        n = t.model,
        r = e.length,
        i = new Array(r),
        s,
        o,
        u,
        a,
        f;
        if (!e.length && Ext.isObject(e)) {
            e = [e];
            r = 1
        }
        for (f = 0; f < r; f++) {
            u = e[f];
            if (u.isModel) {
                i[f] = u
            } else {
                i[f] = a = new n(undefined, t.getId(u), u, o = {});
                a.phantom = false;
                t.convertRecordData(o, u, a);
                if (t.implicitIncludes && a.associations.length) {
                    t.readAssociated(a, u)
                }
            }
        }
        return i
    },
    readAssociated: function(e, t) {
        var n = e.associations.items,
        r = 0,
        i = n.length,
        s, o, u, a;
        for (; r < i; r++) {
            s = n[r];
            o = this.getAssociatedDataRoot(t, s.associationKeyFunction || s.associationKey || s.name);
            if (o) {
                a = s.getReader();
                if (!a) {
                    u = s.associatedModel.getProxy();
                    if (u) {
                        a = u.getReader()
                    } else {
                        a = new this.constructor({
                            model: s.associatedName
                        })
                    }
                }
                s.read(e, a, o)
            }
        }
    },
    getAssociatedDataRoot: function(e, t) {
        if (Ext.isFunction(t)) {
            return t(e)
        }
        return e[t]
    },
    getFields: function() {
        return this.model.prototype.fields.items
    },
    getData: Ext.identityFn,
    getRoot: Ext.identityFn,
    getResponseData: function(e) {},
    onMetaChange: function(e) {
        var t = this,
        n = e.fields || t.getFields(),
        r,
        i;
        t.metaData = e;
        t.root = e.root || t.root;
        t.idProperty = e.idProperty || t.idProperty;
        t.totalProperty = e.totalProperty || t.totalProperty;
        t.successProperty = e.successProperty || t.successProperty;
        t.messageProperty = e.messageProperty || t.messageProperty;
        i = e.clientIdProperty;
        if (t.model) {
            t.model.setFields(n, t.idProperty, i);
            t.setModel(t.model, true)
        } else {
            r = Ext.define("Ext.data.reader.Json-Model" + Ext.id(), {
                extend: "Ext.data.Model",
                fields: n,
                clientIdProperty: i
            });
            if (t.idProperty) {
                r.idProperty = t.idProperty
            }
            t.setModel(r, true)
        }
    },
    getIdProperty: function() {
        var e = this.model.prototype.idField,
        t = this.idProperty;
        if (!t && e && (t = e.mapping) == null) {
            t = e.name
        }
        return t
    },
    buildExtractors: function(e) {
        var t = this,
        n = t.getIdProperty(),
        r = t.totalProperty,
        i = t.successProperty,
        s = t.messageProperty,
        o;
        if (e === true) {
            delete t.convertRecordData
        }
        if (t.convertRecordData) {
            return
        }
        if (r) {
            t.getTotal = t.createAccessor(r)
        }
        if (i) {
            t.getSuccess = t.createAccessor(i)
        }
        if (s) {
            t.getMessage = t.createAccessor(s)
        }
        if (n) {
            o = t.createAccessor(n);
            t.getId = function(e) {
                var n = o.call(t, e);
                return n === undefined || n === "" ? null: n
            }
        } else {
            t.getId = function() {
                return null
            }
        }
        t.convertRecordData = t.buildRecordDataExtractor();
        t.lastFieldGeneration = t.model.prototype.fields.generation
    },
    recordDataExtractorTemplate: ["var me = this\n", "    ,value\n", "    ,internalId\n", '<tpl for="fields">', '    ,__field{#} = fields.map["{name}"]\n', "</tpl>", ";\n", "return function(dest, source, record) {\n", '<tpl for="fields">', '{% var fieldAccessExpression =  this.createFieldAccessExpression(values, "__field" + xindex, "source");', "   if (fieldAccessExpression) { %}", '    value = {[ this.createFieldAccessExpression(values, "__field" + xindex, "source") ]};\n', '<tpl if="hasCustomConvert">', '    dest["{name}"] = value === undefined ? __field{#}.convert(__field{#}.defaultValue, record) : __field{#}.convert(value, record);\n', '<tpl elseif="defaultValue !== undefined">', "    if (value === undefined) {\n", "        if (me.applyDefaults) {\n", '<tpl if="convert">', '            dest["{name}"] = __field{#}.convert(__field{#}.defaultValue, record);\n', "<tpl else>", '            dest["{name}"] = __field{#}.defaultValue\n', "</tpl>", "        };\n", "    } else {\n", '<tpl if="convert">', '        dest["{name}"] = __field{#}.convert(value, record);\n', "<tpl else>", '        dest["{name}"] = value;\n', "</tpl>", "    };\n", "<tpl else>", "    if (value !== undefined) {\n", '<tpl if="convert">', '        dest["{name}"] = __field{#}.convert(value, record);\n', "<tpl else>", '        dest["{name}"] = value;\n', "</tpl>", "    }\n", "</tpl>", "{% } else { %}", '<tpl if="defaultValue !== undefined">', '<tpl if="convert">', '    dest["{name}"] = __field{#}.convert(__field{#}.defaultValue, record);\n', "<tpl else>", '    dest["{name}"] = __field{#}.defaultValue\n', "</tpl>", "</tpl>", "{% } %}", "</tpl>", '<tpl if="clientIdProp">', '    if (record && (internalId = {[ this.createFieldAccessExpression({mapping: values.clientIdProp}, null, "source") ]})) {\n', '        record.{["internalId"]} = internalId;\n', "    }\n", "</tpl>", "};"],
    buildRecordDataExtractor: function() {
        var e = this,
        t = e.model.prototype,
        n = {
            clientIdProp: t.clientIdProperty,
            fields: t.fields.items
        };
        e.recordDataExtractorTemplate.createFieldAccessExpression = function() {
            return e.createFieldAccessExpression.apply(e, arguments)
        };
        return Ext.functionFactory("fields", e.recordDataExtractorTemplate.apply(n)).call(e, e.model.prototype.fields)
    },
    destroyReader: function() {
        var e = this;
        delete e.proxy;
        delete e.model;
        delete e.convertRecordData;
        delete e.getId;
        delete e.getTotal;
        delete e.getSuccess;
        delete e.getMessage
    }
},
function() {
    var e = this.prototype;
    Ext.apply(e, {
        nullResultSet: new Ext.data.ResultSet({
            total: 0,
            count: 0,
            records: [],
            success: true,
            message: ""
        }),
        recordDataExtractorTemplate: new Ext.XTemplate(e.recordDataExtractorTemplate)
    })
});
Ext.define("Ext.data.reader.Json", {
    extend: Ext.data.reader.Reader,
    alternateClassName: "Ext.data.JsonReader",
    alias: "reader.json",
    root: "",
    metaProperty: "metaData",
    useSimpleAccessors: false,
    readRecords: function(e) {
        var t = this,
        n;
        if (t.getMeta) {
            n = t.getMeta(e);
            if (n) {
                t.onMetaChange(n)
            }
        } else {
            if (e.metaData) {
                t.onMetaChange(e.metaData)
            }
        }
        t.jsonData = e;
        return t.callParent([e])
    },
    getResponseData: function(e) {
        var t, n;
        try {
            t = Ext.decode(e.responseText);
            return this.readRecords(t)
        } catch(r) {
            n = new Ext.data.ResultSet({
                total: 0,
                count: 0,
                records: [],
                success: false,
                message: r.message
            });
            this.fireEvent("exception", this, e, n);
            Ext.Logger.warn("Unable to parse the JSON returned by the server");
            return n
        }
    },
    buildExtractors: function() {
        var e = this,
        t = e.metaProperty;
        e.callParent(arguments);
        if (e.root) {
            e.getRoot = e.createAccessor(e.root)
        } else {
            e.getRoot = Ext.identityFn
        }
        if (t) {
            e.getMeta = e.createAccessor(t)
        }
    },
    extractData: function(e) {
        var t = this.record,
        n = [],
        r,
        i;
        if (t) {
            r = e.length;
            if (!r && Ext.isObject(e)) {
                r = 1;
                e = [e]
            }
            for (i = 0; i < r; i++) {
                n[i] = e[i][t]
            }
        } else {
            n = e
        }
        return this.callParent([n])
    },
    createAccessor: function() {
        var e = /[\[\.]/;
        return function(t) {
            if (Ext.isEmpty(t)) {
                return Ext.emptyFn
            }
            if (Ext.isFunction(t)) {
                return t
            }
            if (this.useSimpleAccessors !== true) {
                var n = String(t).search(e);
                if (n >= 0) {
                    return Ext.functionFactory("obj", "return obj" + (n > 0 ? ".": "") + t)
                }
            }
            return function(e) {
                return e[t]
            }
        }
    } (),
    createFieldAccessExpression: function() {
        var e = /[\[\.]/;
        return function(t, n, r) {
            var i = t.mapping,
            s = i || i === 0,
            o = s ? i: t.name,
            u,
            f;
            if (i === false) {
                return
            }
            if (typeof o === "function") {
                u = n + ".mapping(" + r + ", this)"
            } else {
                if (this.useSimpleAccessors === true || (f = String(o).search(e)) < 0) {
                    if (!s || isNaN(o)) {
                        o = '"' + o + '"'
                    }
                    u = r + "[" + o + "]"
                } else {
                    if (f === 0) {
                        u = r + o
                    } else {
                        var l = o.split("."),
                        c = l.length,
                        h = 1,
                        p = r + "." + l[0],
                        d = [p];
                        for (; h < c; h++) {
                            p += "." + l[h];
                            d.push(p)
                        }
                        u = d.join(" && ")
                    }
                }
            }
            return u
        }
    } ()
});
Ext.define("Ext.data.writer.Writer", {
    alias: "writer.base",
    alternateClassName: ["Ext.data.DataWriter", "Ext.data.Writer"],
    writeAllFields: true,
    nameProperty: "name",
    writeRecordId: true,
    isWriter: true,
    constructor: function(e) {
        Ext.apply(this, e)
    },
    write: function(e) {
        var t = e.operation,
        n = t.records || [],
        r = n.length,
        i = 0,
        s = [];
        for (; i < r; i++) {
            s.push(this.getRecordData(n[i], t))
        }
        return this.writeRecords(e, s)
    },
    getRecordData: function(e, t) {
        var n = e.phantom === true,
        r = this.writeAllFields || n,
        i = e.fields,
        s = i.items,
        o = {},
        u = e.clientIdProperty,
        a, f, l, c, h, p;
        if (r) {
            p = s.length;
            for (h = 0; h < p; h++) {
                f = s[h];
                if (f.persist) {
                    this.writeValue(o, f, e)
                }
            }
        } else {
            if (t && t.action === "destroy") {
                this.writeValue(o, e.idField, e)
            } else {
                a = e.getChanges();
                for (l in a) {
                    if (a.hasOwnProperty(l)) {
                        f = i.get(l);
                        if (f.persist) {
                            this.writeValue(o, f, e)
                        }
                    }
                }
            }
        }
        if (n) {
            if (u && t && t.records.length > 1) {
                o[u] = e.internalId
            }
        } else {
            if (this.writeRecordId) {
                c = i.get(e.idProperty)[this.nameProperty] || e.idProperty;
                o[c] = e.getId()
            }
        }
        return o
    },
    writeValue: function(e, t, n) {
        var r = t[this.nameProperty],
        i = this.dateFormat || t.dateWriteFormat || t.dateFormat,
        s = n.get(t.name);
        if (r == null) {
            r = t.name
        }
        if (t.serialize) {
            e[r] = t.serialize(s, n)
        } else {
            if (t.type === Ext.data.Types.DATE && i && Ext.isDate(s)) {
                e[r] = Ext.Date.format(s, i)
            } else {
                e[r] = s
            }
        }
    }
});
Ext.define("Ext.data.writer.Json", {
    extend: Ext.data.writer.Writer,
    alternateClassName: "Ext.data.JsonWriter",
    alias: "writer.json",
    root: undefined,
    encode: false,
    allowSingle: true,
    expandData: false,
    getExpandedData: function(e) {
        var t = e.length,
        n = 0,
        r, i, s, o, u, a = function(e, t) {
            var n = {};
            n[e] = t;
            return n
        };
        for (; n < t; n++) {
            r = e[n];
            for (i in r) {
                if (r.hasOwnProperty(i)) {
                    s = i.split(".");
                    o = s.length - 1;
                    if (o > 0) {
                        u = r[i];
                        for (; o > 0; o--) {
                            u = a(s[o], u)
                        }
                        r[s[0]] = r[s[0]] || {};
                        Ext.Object.merge(r[s[0]], u);
                        delete r[i]
                    }
                }
            }
        }
        return e
    },
    writeRecords: function(e, t) {
        var n = this.root;
        if (this.expandData) {
            t = this.getExpandedData(t)
        }
        if (this.allowSingle && t.length === 1) {
            t = t[0]
        }
        if (this.encode) {
            if (n) {
                e.params[n] = Ext.encode(t)
            } else {}
        } else {
            e.jsonData = e.jsonData || {};
            if (n) {
                e.jsonData[n] = t
            } else {
                e.jsonData = t
            }
        }
        return e
    }
});
Ext.define("Ext.data.proxy.Proxy", {
    alias: "proxy.proxy",
    alternateClassName: ["Ext.data.DataProxy", "Ext.data.Proxy"],
    mixins: {
        observable: Ext.util.Observable
    },
    batchOrder: "create,update,destroy",
    batchActions: true,
    defaultReaderType: "json",
    defaultWriterType: "json",
    isProxy: true,
    isSynchronous: false,
    constructor: function(e) {
        var t = this;
        e = e || {};
        t.proxyConfig = e;
        t.mixins.observable.constructor.call(t, e);
        if (t.model !== undefined && !(t.model instanceof Ext.data.Model)) {
            t.setModel(t.model)
        } else {
            if (t.reader) {
                t.setReader(t.reader)
            }
            if (t.writer) {
                t.setWriter(t.writer)
            }
        }
    },
    setModel: function(e, t) {
        var n = this;
        n.model = Ext.ModelManager.getModel(e);
        n.setReader(this.reader);
        n.setWriter(this.writer);
        if (t && n.store) {
            n.store.model = n.model
        }
    },
    getModel: function() {
        return this.model
    },
    setReader: function(e) {
        var t = this,
        n = true,
        r = t.reader;
        if (e === undefined || typeof e == "string") {
            e = {
                type: e
            };
            n = false
        }
        if (e.isReader) {
            e.setModel(t.model)
        } else {
            if (n) {
                e = Ext.apply({},
                e)
            }
            Ext.applyIf(e, {
                proxy: t,
                model: t.model,
                type: t.defaultReaderType
            });
            e = Ext.createByAlias("reader." + e.type, e)
        }
        if (e !== r && e.onMetaChange) {
            e.onMetaChange = Ext.Function.createSequence(e.onMetaChange, this.onMetaChange, this)
        }
        t.reader = e;
        return t.reader
    },
    getReader: function() {
        return this.reader
    },
    onMetaChange: function(e) {
        this.fireEvent("metachange", this, e)
    },
    setWriter: function(e) {
        var t = this,
        n = true;
        if (e === undefined || typeof e == "string") {
            e = {
                type: e
            };
            n = false
        }
        if (!e.isWriter) {
            if (n) {
                e = Ext.apply({},
                e)
            }
            Ext.applyIf(e, {
                model: t.model,
                type: t.defaultWriterType
            });
            e = Ext.createByAlias("writer." + e.type, e)
        }
        t.writer = e;
        return t.writer
    },
    getWriter: function() {
        return this.writer
    },
    create: Ext.emptyFn,
    read: Ext.emptyFn,
    update: Ext.emptyFn,
    destroy: Ext.emptyFn,
    batch: function(e, t) {
        var n = this,
        r = n.batchActions,
        i, s, o, u, a, f, l, c, h;
        if (e.operations === undefined) {
            e = {
                operations: e,
                listeners: t
            }
        }
        if (e.batch) {
            if (Ext.isDefined(e.batch.runOperation)) {
                i = Ext.applyIf(e.batch, {
                    proxy: n,
                    listeners: {}
                })
            }
        } else {
            e.batch = {
                proxy: n,
                listeners: e.listeners || {}
            }
        }
        if (!i) {
            i = new Ext.data.Batch(e.batch)
        }
        i.on("complete", Ext.bind(n.onBatchComplete, n, [e], 0));
        o = n.batchOrder.split(",");
        u = o.length;
        for (f = 0; f < u; f++) {
            a = o[f];
            s = e.operations[a];
            if (s) {
                if (r) {
                    i.add(new Ext.data.Operation({
                        action: a,
                        records: s
                    }))
                } else {
                    c = s.length;
                    for (l = 0; l < c; l++) {
                        h = s[l];
                        i.add(new Ext.data.Operation({
                            action: a,
                            records: [h]
                        }))
                    }
                }
            }
        }
        i.start();
        return i
    },
    onBatchComplete: function(e, t) {
        var n = e.scope || this;
        if (t.hasException) {
            if (Ext.isFunction(e.failure)) {
                Ext.callback(e.failure, n, [t, e])
            }
        } else {
            if (Ext.isFunction(e.success)) {
                Ext.callback(e.success, n, [t, e])
            }
        }
        if (Ext.isFunction(e.callback)) {
            Ext.callback(e.callback, n, [t, e])
        }
    },
    clone: function() {
        return new this.self(this.proxyConfig)
    }
});
Ext.define("Ext.data.proxy.Client", {
    extend: Ext.data.proxy.Proxy,
    alternateClassName: "Ext.data.ClientProxy",
    isSynchronous: true,
    clear: function() {}
});
Ext.define("Ext.data.proxy.Memory", {
    extend: Ext.data.proxy.Client,
    alias: "proxy.memory",
    alternateClassName: "Ext.data.MemoryProxy",
    constructor: function(e) {
        this.callParent([e]);
        this.setReader(this.reader)
    },
    updateOperation: function(e, t, n) {
        var r = 0,
        i = e.getRecords(),
        s = i.length;
        for (r; r < s; r++) {
            i[r].commit()
        }
        e.setCompleted();
        e.setSuccessful();
        Ext.callback(t, n || this, [e])
    },
    create: function() {
        this.updateOperation.apply(this, arguments)
    },
    update: function() {
        this.updateOperation.apply(this, arguments)
    },
    destroy: function() {
        this.updateOperation.apply(this, arguments)
    },
    read: function(e, t, n) {
        var r = this,
        i = e.resultSet = r.getReader().read(r.data),
        s = i.records,
        o = e.sorters,
        u = e.groupers,
        a = e.filters;
        e.setCompleted();
        if (i.success) {
            if (a && a.length) {
                s = i.records = Ext.Array.filter(s, Ext.util.Filter.createFilterFn(a));
                i.total = s.length
            }
            if (u && u.length) {
                o = o ? o.concat(u) : o
            }
            if (o && o.length) {
                i.records = Ext.Array.sort(s, Ext.util.Sortable.createComparator(o))
            }
            if (r.enablePaging && e.start !== undefined && e.limit !== undefined) {
                if (e.start >= i.total) {
                    i.success = false;
                    i.count = 0;
                    i.records = []
                } else {
                    i.records = Ext.Array.slice(i.records, e.start, e.start + e.limit);
                    i.count = i.records.length
                }
            }
        }
        if (i.success) {
            e.setSuccessful()
        } else {
            r.fireEvent("exception", r, null, e)
        }
        Ext.callback(t, n || r, [e])
    },
    clear: Ext.emptyFn
});
Ext.define("Ext.data.Operation", {
    synchronous: true,
    action: undefined,
    filters: undefined,
    sorters: undefined,
    groupers: undefined,
    start: undefined,
    limit: undefined,
    batch: undefined,
    callback: undefined,
    scope: undefined,
    started: false,
    running: false,
    complete: false,
    success: undefined,
    exception: false,
    error: undefined,
    actionCommitRecordsRe: /^(?:create|update)$/i,
    actionSkipSyncRe: /^destroy$/i,
    constructor: function(e) {
        Ext.apply(this, e || {})
    },
    commitRecords: function(e) {
        var t = this,
        n = t.actionCommitRecordsRe.test(t.action),
        r,
        i,
        s,
        o,
        u,
        a,
        f,
        l,
        c;
        if (!t.actionSkipSyncRe.test(t.action)) {
            s = t.records;
            if (s && s.length) {
                if (n) {
                    c = []
                }
                if (s.length > 1) {
                    if (t.action == "update" || s[0].clientIdProperty) {
                        r = new Ext.util.MixedCollection;
                        r.addAll(e);
                        for (i = s.length; i--;) {
                            u = s[i];
                            o = r.findBy(t.matchClientRec, u);
                            l = u.copyFrom(o);
                            if (n) {
                                c.push(l)
                            }
                        }
                    } else {
                        for (a = 0, f = s.length; a < f; ++a) {
                            u = s[a];
                            o = e[a];
                            if (u && o) {
                                l = t.updateRecord(u, o);
                                if (n) {
                                    c.push(l)
                                }
                            }
                        }
                    }
                } else {
                    l = t.updateRecord(s[0], e[0]);
                    if (n) {
                        c[0] = l
                    }
                }
                if (n) {
                    for (i = s.length; i--;) {
                        s[i].commit(false, c[i])
                    }
                }
            }
        }
    },
    updateRecord: function(e, t) {
        if (t && (e.phantom || e.getId() === t.getId())) {
            return e.copyFrom(t)
        }
        return []
    },
    matchClientRec: function(e) {
        var t = this,
        n = t.getId();
        if (n && e.getId() === n) {
            return true
        }
        return e.internalId === t.internalId
    },
    setStarted: function() {
        this.started = true;
        this.running = true
    },
    setCompleted: function() {
        this.complete = true;
        this.running = false
    },
    setSuccessful: function() {
        this.success = true
    },
    setException: function(e) {
        this.exception = true;
        this.success = false;
        this.running = false;
        this.error = e
    },
    hasException: function() {
        return this.exception === true
    },
    getError: function() {
        return this.error
    },
    getRecords: function() {
        var e = this.getResultSet();
        return this.records || (e ? e.records: null)
    },
    getResultSet: function() {
        return this.resultSet
    },
    isStarted: function() {
        return this.started === true
    },
    isRunning: function() {
        return this.running === true
    },
    isComplete: function() {
        return this.complete === true
    },
    wasSuccessful: function() {
        return this.isComplete() && this.success === true
    },
    setBatch: function(e) {
        this.batch = e
    },
    allowWrite: function() {
        return this.action != "read"
    }
});
Ext.define("Ext.data.AbstractStore", {
    mixins: {
        observable: Ext.util.Observable,
        sortable: Ext.util.Sortable
    },
    statics: {
        create: function(e) {
            if (!e.isStore) {
                if (!e.type) {
                    e.type = "store"
                }
                e = Ext.createByAlias("store." + e.type, e)
            }
            return e
        }
    },
    onClassExtended: function(e, t, n) {
        var r = t.model,
        i;
        if (typeof r == "string") {
            i = n.onBeforeCreated;
            n.onBeforeCreated = function() {
                var e = this,
                t = arguments;
                Ext.require(r,
                function() {
                    i.apply(e, t)
                })
            }
        }
    },
    remoteSort: false,
    remoteFilter: false,
    autoLoad: undefined,
    showError: true,
    autoSync: false,
    batchUpdateMode: "operation",
    filterOnLoad: true,
    sortOnLoad: true,
    implicitModel: false,
    defaultProxyType: "memory",
    isDestroyed: false,
    isStore: true,
    sortRoot: "data",
    constructor: function(e) {
        var t = this,
        n;
        if (e.appScope && e.storeName) {
            e.appScope[e.storeName] = t
        }
        Ext.apply(t, e);
        t.removed = [];
        t.mixins.observable.constructor.apply(t, arguments);
        t.model = Ext.ModelManager.getModel(t.model);
        Ext.applyIf(t, {
            modelDefaults: null
        });
        if (e.url && !t.proxy) {
            t.proxy = {
                type: "ajax",
                url: e.url
            };
            if (e.timeout) {
                t.proxy.timeout = e.timeout
            }
            if (t instanceof Ext.data.Store) {
                t.proxy.reader = {
                    type: "json",
                    root: "rows"
                }
            }
        }
        if (!t.proxy && !t.model && !t.fields) {
            t.fields = []
        }
        if (!t.model && t.fields) {
            t.model = Ext.define(null, {
                extend: "Ext.data.Model",
                fields: t.fields,
                proxy: t.proxy || t.defaultProxyType
            });
            delete t.fields;
            t.implicitModel = true
        }
        t.setProxy(t.proxy || t.model.getProxy());
        if (t.id && !t.storeId) {
            t.storeId = t.id;
            delete t.id
        }
        if (t.storeId) {
            Ext.data.StoreManager.register(t)
        }
        t.mixins.sortable.initSortable.call(t);
        n = t.decodeFilters(t.filters);
        t.filters = new Ext.util.MixedCollection;
        t.filters.addAll(n)
    },
    setProxy: function(e) {
        var t = this,
        n = t.model;
        e.store = t;
        if (e instanceof Ext.data.proxy.Proxy) {
            e.setModel(n)
        } else {
            if (Ext.isString(e)) {
                e = {
                    type: e,
                    model: n
                }
            } else {
                if (!e.model) {
                    e = Ext.apply({
                        model: n
                    },
                    e)
                }
            }
            e = Ext.createByAlias("proxy." + e.type, e)
        }
        if (!t.disableMetaChangeEvent) {
            e.on("metachange", t.onMetaChange, t)
        }
        t.proxy = e;
        return t.proxy
    },
    getProxy: function() {
        return this.proxy
    },
    onMetaChange: function(e, t) {
        this.fireEvent("metachange", this, t)
    },
    create: function(e, t) {
        var n = this,
        r = Ext.ModelManager.create(Ext.applyIf(e, n.modelDefaults), n.model.modelName),
        i;
        t = t || {};
        Ext.applyIf(t, {
            action: "create",
            records: [r]
        });
        i = new Ext.data.Operation(t);
        n.proxy.create(i, n.onProxyWrite, n);
        return r
    },
    read: function() {
        return this.load.apply(this, arguments)
    },
    update: function(e) {
        var t = this,
        n;
        e = e || {};
        Ext.applyIf(e, {
            action: "update",
            records: t.getUpdatedRecords()
        });
        n = new Ext.data.Operation(e);
        return t.proxy.update(n, t.onProxyWrite, t)
    },
    onProxyWrite: function(e) {
        var t = this,
        n = e.wasSuccessful(),
        r = e.getRecords();
        switch (e.action) {
        case "create":
            t.onCreateRecords(r, e, n);
            break;
        case "update":
            t.onUpdateRecords(r, e, n);
            break;
        case "destroy":
            t.onDestroyRecords(r, e, n);
            break
        }
        if (n) {
            t.fireEvent("write", t, e);
            t.fireEvent("datachanged", t);
            t.fireEvent("refresh", t)
        }
        Ext.callback(e.callback, e.scope || t, [r, e, n])
    },
    onCreateRecords: Ext.emptyFn,
    onUpdateRecords: Ext.emptyFn,
    onDestroyRecords: function(e, t, n) {
        if (n) {
            this.removed = []
        }
    },
    destroy: function(e) {
        var t = this,
        n;
        e = e || {};
        Ext.applyIf(e, {
            action: "destroy",
            records: t.getRemovedRecords()
        });
        n = new Ext.data.Operation(e);
        return t.proxy.destroy(n, t.onProxyWrite, t)
    },
    onBatchOperationComplete: function(e, t) {
        return this.onProxyWrite(t)
    },
    onBatchComplete: function(e, t) {
        var n = this,
        r = e.operations,
        i = r.length,
        s;
        n.suspendEvents();
        for (s = 0; s < i; s++) {
            n.onProxyWrite(r[s])
        }
        n.resumeEvents();
        n.fireEvent("datachanged", n);
        n.fireEvent("refresh", n)
    },
    onBatchException: function(e, t) {},
    filterNew: function(e) {
        return e.phantom === true && e.isValid()
    },
    getNewRecords: function() {
        return []
    },
    getUpdatedRecords: function() {
        return []
    },
    getModifiedRecords: function() {
        return [].concat(this.getNewRecords(), this.getUpdatedRecords())
    },
    filterUpdated: function(e) {
        return e.dirty === true && e.phantom !== true && e.isValid()
    },
    getRemovedRecords: function() {
        return this.removed
    },
    filter: function(e, t) {},
    decodeFilters: function(e) {
        if (!Ext.isArray(e)) {
            if (e === undefined) {
                e = []
            } else {
                e = [e]
            }
        }
        var t = e.length,
        n = Ext.util.Filter,
        r, i;
        for (i = 0; i < t; i++) {
            r = e[i];
            if (! (r instanceof n)) {
                Ext.apply(r, {
                    root: "data"
                });
                if (r.fn) {
                    r.filterFn = r.fn
                }
                if (typeof r == "function") {
                    r = {
                        filterFn: r
                    }
                }
                e[i] = new n(r)
            }
        }
        return e
    },
    clearFilter: function(e) {},
    isFiltered: function() {},
    filterBy: function(e, t) {},
    sync: function(e) {
        var t = this,
        n = {},
        r = t.getNewRecords(),
        i = t.getUpdatedRecords(),
        s = t.getRemovedRecords(),
        o = false;
        if (r.length > 0) {
            n.create = r;
            o = true
        }
        if (i.length > 0) {
            n.update = i;
            o = true
        }
        if (s.length > 0) {
            n.destroy = s;
            o = true
        }
        if (o && t.fireEvent("beforesync", n) !== false) {
            e = e || {};
            t.proxy.batch(Ext.apply(e, {
                operations: n,
                listeners: t.getBatchListeners()
            }))
        }
        return t
    },
    getBatchListeners: function() {
        var e = this,
        t = {
            scope: e,
            exception: e.onBatchException
        };
        if (e.batchUpdateMode == "operation") {
            t.operationcomplete = e.onBatchOperationComplete
        } else {
            t.complete = e.onBatchComplete
        }
        return t
    },
    save: function() {
        return this.sync.apply(this, arguments)
    },
    load: function(e) {
        var t = this,
        n = {
            action: "read"
        };
        if (t.remoteFilter) {
            n.filters = t.filters.items
        }
        if (t.remoteSort) {
            n.sorters = t.getSorters()
        }
        if (e.out) {
            e.params = Wb.apply(Wb.getValue(e.out), e.params)
        }
        Ext.apply(n, e);
        t.lastOptions = n;
        n = new Ext.data.Operation(n);
        if (t.fireEvent("beforeload", t, n) !== false) {
            t.loading = true;
            t.proxy.read(n, t.onProxyLoad, t)
        }
        return t
    },
    reload: function(e) {
        var t = Ext.apply({},
        e, this.lastOptions);
        return this.load(t)
    },
    afterEdit: function(e, t) {
        var n = this,
        r, i;
        if (n.autoSync && !n.autoSyncSuspended) {
            for (r = t.length; r--;) {
                if (e.fields.get(t[r]).persist) {
                    i = true;
                    break
                }
            }
            if (i) {
                n.sync()
            }
        }
        n.onUpdate(e, Ext.data.Model.EDIT, t);
        n.fireEvent("update", n, e, Ext.data.Model.EDIT, t)
    },
    afterReject: function(e) {
        this.onUpdate(e, Ext.data.Model.REJECT, null);
        this.fireEvent("update", this, e, Ext.data.Model.REJECT, null)
    },
    afterCommit: function(e, t) {
        if (!t) {
            t = null
        }
        this.onUpdate(e, Ext.data.Model.COMMIT, t);
        this.fireEvent("update", this, e, Ext.data.Model.COMMIT, t)
    },
    onUpdate: Ext.emptyFn,
    onIdChanged: function(e, t, n, r) {
        this.fireEvent("idchanged", this, e, t, n, r)
    },
    destroyStore: function() {
        var e = this;
        if (!e.isDestroyed) {
            e.clearListeners();
            if (e.storeId) {
                Ext.data.StoreManager.unregister(e)
            }
            e.destroyClear();
            if (e.reader) {
                e.reader.destroyReader()
            }
            e.data = e.tree = e.sorters = e.filters = e.groupers = e.proxy = e.reader = e.writer = e.model = null;
            e.isDestroyed = true
        }
    },
    destroyClear: function() {
        this.clearData()
    },
    getState: function() {
        var e = this,
        t, n, r = !!e.groupers,
        i = [],
        s = [],
        o = [];
        if (r) {
            e.groupers.each(function(e) {
                i[i.length] = e.serialize();
                t = true
            })
        }
        if (e.sorters) {
            e.sorters.each(function(n) {
                if (r && !e.groupers.contains(n)) {
                    s[s.length] = n.serialize();
                    t = true
                }
            })
        }
        if (e.filters && e.statefulFilters) {
            e.filters.each(function(e) {
                o[o.length] = e.serialize();
                t = true
            })
        }
        if (t) {
            n = {};
            if (i.length) {
                n.groupers = i
            }
            if (s.length) {
                n.sorters = s
            }
            if (o.length) {
                n.filters = o
            }
            return n
        }
    },
    applyState: function(e) {
        var t = this,
        n = !!t.sorters,
        r = !!t.groupers,
        i = !!t.filters,
        s;
        if (r && e.groupers) {
            t.groupers.clear();
            t.groupers.addAll(t.decodeGroupers(e.groupers))
        }
        if (n && e.sorters) {
            t.sorters.clear();
            t.sorters.addAll(t.decodeSorters(e.sorters))
        }
        if (i && e.filters) {
            t.filters.clear();
            t.filters.addAll(t.decodeFilters(e.filters))
        }
        if (n && r) {
            t.sorters.insert(0, t.groupers.getRange())
        }
        if (t.autoLoad && (t.remoteSort || t.remoteGroup || t.remoteFilter)) {
            if (t.autoLoadTask) {
                t.autoLoadTask.cancel();
                delete t.autoLoadTask
            }
            if (t.autoLoad === true) {
                t.reload()
            } else {
                t.reload(t.autoLoad)
            }
        }
        if (i && t.filters.length && !t.remoteFilter) {
            t.filter();
            s = t.sortOnFilter
        }
        if (n && t.sorters.length && !t.remoteSort && !s) {
            t.sort()
        }
    },
    doSort: function(e) {
        var t = this;
        if (t.remoteSort) {
            t.load()
        } else {
            t.data.sortBy(e);
            t.fireEvent("datachanged", t);
            t.fireEvent("refresh", t)
        }
        t.fireEvent("sort", t, t.sorters.getRange())
    },
    clearData: Ext.emptyFn,
    getCount: Ext.emptyFn,
    getById: Ext.emptyFn,
    removeAll: Ext.emptyFn,
    isLoading: function() {
        return !! this.loading
    },
    suspendAutoSync: function() {
        this.autoSyncSuspended = true
    },
    resumeAutoSync: function() {
        this.autoSyncSuspended = false
    }
});
Ext.define("Ext.data.StoreManager", {
    extend: Ext.util.MixedCollection,
    alternateClassName: ["Ext.StoreMgr", "Ext.data.StoreMgr", "Ext.StoreManager"],
    singleton: true,
    register: function() {
        for (var e = 0,
        t; t = arguments[e]; e++) {
            this.add(t)
        }
    },
    unregister: function() {
        for (var e = 0,
        t; t = arguments[e]; e++) {
            this.remove(this.lookup(t))
        }
    },
    lookup: function(e) {
        if (Ext.isArray(e)) {
            var t = ["field1"],
            n = !Ext.isArray(e[0]),
            r = e,
            i,
            s;
            if (n) {
                r = [];
                for (i = 0, s = e.length; i < s; ++i) {
                    r.push([e[i]])
                }
            } else {
                for (i = 2, s = e[0].length; i <= s; ++i) {
                    t.push("field" + i)
                }
            }
            return new Ext.data.ArrayStore({
                data: r,
                fields: t,
                autoDestroy: true,
                autoCreated: true,
                expanded: n
            })
        }
        if (Ext.isString(e)) {
            return this.get(e)
        } else {
            return Ext.data.AbstractStore.create(e)
        }
    },
    getKey: function(e) {
        return e.storeId
    }
},
function() {
    Ext.regStore = function(e, t) {
        var n;
        if (Ext.isObject(e)) {
            t = e
        } else {
            t.storeId = e
        }
        if (t instanceof Ext.data.Store) {
            n = t
        } else {
            n = new Ext.data.Store(t)
        }
        return Ext.data.StoreManager.register(n)
    };
    Ext.getStore = function(e) {
        return Ext.data.StoreManager.lookup(e)
    }
});
Ext.define("Ext.app.domain.Global", {
    extend: Ext.app.EventDomain,
    singleton: true,
    type: "global",
    constructor: function() {
        var e = this;
        e.callParent();
        e.monitor(Ext.globalEvents)
    },
    listen: function(e, t) {
        this.callParent([{
            global: e
        },
        t])
    },
    match: function() {
        return true
    }
});
Ext.define("Ext.app.domain.Store", {
    extend: Ext.app.EventDomain,
    singleton: true,
    type: "store",
    idProperty: "storeId",
    constructor: function() {
        var e = this;
        e.callParent();
        e.monitor(Ext.data.AbstractStore)
    }
});
Ext.define("Ext.app.Controller", {
    mixins: {
        observable: Ext.util.Observable
    },
    statics: {
        strings: {
            model: {
                getter: "getModel",
                upper: "Model"
            },
            view: {
                getter: "getView",
                upper: "View"
            },
            controller: {
                getter: "getController",
                upper: "Controller"
            },
            store: {
                getter: "getStore",
                upper: "Store"
            }
        },
        controllerRegex: /^(.*)\.controller\./,
        createGetter: function(e, t) {
            return function() {
                return this[e](t)
            }
        },
        getGetterName: function(e, t) {
            var n = "get",
            r = e.split("."),
            i = r.length,
            s;
            for (s = 0; s < i; s++) {
                n += Ext.String.capitalize(r[s])
            }
            n += t;
            return n
        },
        processDependencies: function(e, t, n, r, i) {
            if (!i || !i.length) {
                return
            }
            var s = this,
            o = s.strings[r],
            u,
            a,
            f,
            l,
            c,
            h,
            p,
            d;
            if (!Ext.isArray(i)) {
                i = [i]
            }
            for (c = 0, h = i.length; c < h; c++) {
                l = i[c];
                u = s.getFullName(l, r, n);
                a = u.absoluteName;
                f = u.shortName;
                t.push(a);
                p = s.getGetterName(f, o.upper);
                e[p] = d = s.createGetter(o.getter, l);
                if (r !== "controller") {
                    d["Ext.app.getter"] = true
                }
            }
        },
        getFullName: function(e, t, n) {
            var r = e,
            i, s;
            if ((i = e.indexOf("@")) > 0) {
                r = e.substring(0, i);
                s = e.substring(i + 1) + "." + r
            } else {
                if (e.indexOf(".") > 0 && (Ext.ClassManager.isCreated(e) || Ext.Loader.isAClassNameWithAKnownPrefix(e))) {
                    s = e
                } else {
                    if (n) {
                        s = n + "." + t + "." + e;
                        r = e
                    } else {
                        s = e
                    }
                }
            }
            return {
                absoluteName: s,
                shortName: r
            }
        }
    },
    application: null,
    onClassExtended: function(e, t, n) {
        var r = n.onBeforeCreated;
        n.onBeforeCreated = function(e, t) {
            var n = Ext.app.Controller,
            i = n.controllerRegex,
            s = [],
            o,
            u,
            s,
            a,
            f;
            a = e.prototype;
            o = Ext.getClassName(e);
            u = t.$namespace || Ext.app.getNamespace(o) || (f = i.exec(o)) && f[1];
            if (u) {
                a.$namespace = u
            }
            n.processDependencies(a, s, u, "model", t.models);
            n.processDependencies(a, s, u, "view", t.views);
            n.processDependencies(a, s, u, "store", t.stores);
            n.processDependencies(a, s, u, "controller", t.controllers);
            Ext.require(s, Ext.Function.pass(r, arguments, this))
        }
    },
    constructor: function(e) {
        var t = this;
        t.mixins.observable.constructor.call(t, e);
        if (t.refs) {
            t.ref(t.refs)
        }
        t.eventbus = Ext.app.EventBus;
        t.initAutoGetters()
    },
    initAutoGetters: function() {
        var e = this.self.prototype,
        t, n;
        for (t in e) {
            n = e[t];
            if (n && n["Ext.app.getter"]) {
                n.call(this)
            }
        }
    },
    doInit: function(e) {
        var t = this;
        if (!t._initialized) {
            t.init(e);
            t._initialized = true
        }
    },
    finishInit: function(e) {
        var t = this,
        n = t.controllers,
        r, i, s;
        if (t._initialized && n && n.length) {
            for (i = 0, s = n.length; i < s; i++) {
                r = t.getController(n[i]);
                r.finishInit(e)
            }
        }
    },
    init: Ext.emptyFn,
    onLaunch: Ext.emptyFn,
    ref: function(e) {
        var t = this,
        n = 0,
        r = e.length,
        i, s, o;
        e = Ext.Array.from(e);
        t.references = t.references || [];
        for (; n < r; n++) {
            i = e[n];
            s = i.ref;
            o = "get" + Ext.String.capitalize(s);
            if (!t[o]) {
                t[o] = Ext.Function.pass(t.getRef, [s, i], t)
            }
            t.references.push(s.toLowerCase())
        }
    },
    addRef: function(e) {
        this.ref(e)
    },
    getRef: function(e, t, n) {
        var r = this,
        i = r.refCache || (r.refCache = {}),
        s = i[e];
        t = t || {};
        n = n || {};
        Ext.apply(t, n);
        if (t.forceCreate) {
            return Ext.ComponentManager.create(t, "component")
        }
        if (!s) {
            if (t.selector) {
                i[e] = s = Ext.ComponentQuery.query(t.selector)[0]
            }
            if (!s && t.autoCreate) {
                i[e] = s = Ext.ComponentManager.create(t, "component")
            }
            if (s) {
                s.on("beforedestroy",
                function() {
                    i[e] = null
                })
            }
        }
        return s
    },
    hasRef: function(e) {
        var t = this.references;
        return t && Ext.Array.indexOf(t, e.toLowerCase()) !== -1
    },
    control: function(e, t, n) {
        var r = this,
        i = n,
        s;
        if (Ext.isString(e)) {
            s = {};
            s[e] = t
        } else {
            s = e;
            i = t
        }
        r.eventbus.control(s, i || r)
    },
    listen: function(e, t) {
        this.eventbus.listen(e, t || this)
    },
    getController: function(e) {
        var t = this,
        n = t.application;
        if (e === t.id) {
            return t
        }
        return n && n.getController(e)
    },
    getStore: function(e) {
        var t, n;
        t = e.indexOf("@") == -1 ? e: e.split("@")[0];
        n = Ext.StoreManager.get(t);
        if (!n) {
            e = Ext.app.Controller.getFullName(e, "store", this.$namespace);
            if (e) {
                n = Ext.create(e.absoluteName, {
                    storeId: t
                })
            }
        }
        return n
    },
    getModel: function(e) {
        var t = Ext.app.Controller.getFullName(e, "model", this.$namespace);
        return t && Ext.ModelManager.getModel(t.absoluteName)
    },
    getView: function(e) {
        var t = Ext.app.Controller.getFullName(e, "view", this.$namespace);
        return t && Ext.ClassManager.get(t.absoluteName)
    },
    getApplication: function() {
        return this.application
    }
});
Ext.define("Ext.container.DockingContainer", {
    isDockingContainer: true,
    defaultDockWeights: {
        top: {
            render: 1,
            visual: 1
        },
        left: {
            render: 3,
            visual: 5
        },
        right: {
            render: 5,
            visual: 7
        },
        bottom: {
            render: 7,
            visual: 3
        }
    },
    dockOrder: {
        top: -1,
        left: -1,
        right: 1,
        bottom: 1
    },
    horizontalDocks: 0,
    addDocked: function(e, t) {
        var n = this,
        r = 0,
        i, s;
        e = n.prepareItems(e);
        s = e.length;
        for (; r < s; r++) {
            i = e[r];
            i.dock = i.dock || "top";
            if (i.dock === "left" || i.dock === "right") {
                n.horizontalDocks++
            }
            if (t !== undefined) {
                r += t;
                n.dockedItems.insert(r, i)
            } else {
                n.dockedItems.add(i)
            }
            i.onAdded(n, r);
            if (n.hasListeners.dockedadd) {
                n.fireEvent("dockedadd", n, i, r)
            }
            if (n.onDockedAdd !== Ext.emptyFn) {
                n.onDockedAdd(i)
            }
        }
        if (n.rendered && !n.suspendLayout) {
            n.updateLayout()
        }
        return e
    },
    destroyDockedItems: function() {
        var e = this.dockedItems,
        t;
        if (e) {
            while (t = e.first()) {
                this.removeDocked(t, true)
            }
        }
    },
    doRenderDockedItems: function(e, t, n) {
        var r = t.$comp,
        i = r.componentLayout,
        s, o;
        if (i.getDockedItems && !t.$skipDockedItems) {
            s = i.getDockedItems("render", !n);
            o = s && i.getItemsRenderTree(s);
            if (o) {
                Ext.DomHelper.generateMarkup(o, e)
            }
        }
    },
    getDockedComponent: function(e) {
        if (Ext.isObject(e)) {
            e = e.getItemId()
        }
        return this.dockedItems.get(e)
    },
    getDockedItems: function(e, t) {
        var n = this.getComponentLayout().getDockedItems("render", t);
        if (e && n.length) {
            n = Ext.ComponentQuery.query(e, n)
        }
        return n
    },
    getDockingRefItems: function(e, t) {
        var n = e && "*,* *",
        r = this.getDockedItems(n, true),
        i;
        r.push.apply(r, t);
        i = this.getDockedItems(n, false);
        r.push.apply(r, i);
        return r
    },
    initDockingItems: function() {
        var e = this,
        t = e.dockedItems;
        e.dockedItems = new Ext.util.AbstractMixedCollection(false, e.getComponentId);
        if (t) {
            e.addDocked(t)
        }
    },
    insertDocked: function(e, t) {
        this.addDocked(t, e)
    },
    onDockedAdd: Ext.emptyFn,
    onDockedRemove: Ext.emptyFn,
    removeDocked: function(e, t) {
        var n = this,
        r, i;
        t = t === true || t !== false && n.autoDestroy;
        if (!n.dockedItems.contains(e)) {
            return e
        }
        if (e.dock === "left" || e.dock === "right") {
            n.horizontalDocks--
        }
        r = n.componentLayout;
        i = r && n.rendered;
        if (i) {
            r.onRemove(e)
        }
        n.dockedItems.remove(e);
        e.onRemoved(e.destroying || t);
        n.onDockedRemove(e);
        if (t) {
            e.destroy()
        } else {
            if (i) {
                r.afterRemove(e)
            }
        }
        if (n.hasListeners.dockedremove) {
            n.fireEvent("dockedremove", n, e)
        }
        if (!n.destroying && !n.suspendLayout) {
            n.updateLayout()
        }
        return e
    },
    setupDockingRenderTpl: function(e) {
        e.renderDockedItems = this.doRenderDockedItems
    }
});
Ext.define("Ext.toolbar.Fill", {
    extend: Ext.Component,
    alias: "widget.tbfill",
    alternateClassName: "Ext.Toolbar.Fill",
    ariaRole: "presentation",
    isFill: true,
    flex: 1
});
Ext.define("Ext.layout.container.boxOverflow.None", {
    alternateClassName: "Ext.layout.boxOverflow.None",
    constructor: function(e, t) {
        this.layout = e;
        Ext.apply(this, t)
    },
    handleOverflow: Ext.emptyFn,
    clearOverflow: Ext.emptyFn,
    beginLayout: Ext.emptyFn,
    beginLayoutCycle: Ext.emptyFn,
    calculate: function(e) {
        var t = this,
        n = e.state.boxPlan,
        r;
        if (n && n.tooNarrow) {
            r = t.handleOverflow(e);
            if (r) {
                if (r.reservedSpace) {
                    t.layout.publishInnerCtSize(e, r.reservedSpace)
                }
            }
        } else {
            t.clearOverflow()
        }
    },
    completeLayout: Ext.emptyFn,
    finishedLayout: function(e) {
        var t = this,
        n = t.layout.owner,
        r, i;
        if (n.hasListeners.overflowchange) {
            r = n.query(">[hidden]");
            i = r.length;
            if (i !== t.lastHiddenCount) {
                n.fireEvent("overflowchange", t.lastHiddenCount, i, r);
                t.lastHiddenCount = i
            }
        }
    },
    onRemove: Ext.emptyFn,
    getItem: function(e) {
        return this.layout.owner.getComponent(e)
    },
    getOwnerType: function(e) {
        var t;
        if (e.isToolbar) {
            t = "toolbar"
        } else {
            if (e.isTabBar) {
                t = "tabbar"
            } else {
                if (e.isMenu) {
                    t = "menu"
                } else {
                    t = e.getXType()
                }
            }
        }
        return t
    },
    getPrefixConfig: Ext.emptyFn,
    getSuffixConfig: Ext.emptyFn,
    getOverflowCls: function() {
        return ""
    }
});
Ext.define("Ext.toolbar.Item", {
    extend: Ext.Component,
    alias: "widget.tbitem",
    alternateClassName: "Ext.Toolbar.Item",
    enable: Ext.emptyFn,
    disable: Ext.emptyFn,
    focus: Ext.emptyFn
});
Ext.define("Ext.toolbar.Separator", {
    extend: Ext.toolbar.Item,
    alias: "widget.tbseparator",
    alternateClassName: "Ext.Toolbar.Separator",
    baseCls: Ext.baseCSSPrefix + "toolbar-separator",
    focusable: false,
    ariaRole: "separator"
});
Ext.define("Ext.button.Manager", {
    singleton: true,
    alternateClassName: "Ext.ButtonToggleManager",
    groups: {},
    pressedButton: null,
    buttonSelector: "." + Ext.baseCSSPrefix + "btn",
    init: function() {
        var e = this;
        if (!e.initialized) {
            Ext.getDoc().on({
                keydown: e.onDocumentKeyDown,
                mouseup: e.onDocumentMouseUp,
                scope: e
            });
            e.initialized = true
        }
    },
    onDocumentKeyDown: function(e) {
        var t = e.getKey(),
        n;
        if (t === e.SPACE || t === e.ENTER) {
            n = e.getTarget(this.buttonSelector);
            if (n) {
                Ext.getCmp(n.id).onClick(e)
            }
        }
    },
    onButtonMousedown: function(e, t) {
        var n = this.pressedButton;
        if (n) {
            n.onMouseUp(t)
        }
        this.pressedButton = e
    },
    onDocumentMouseUp: function(e) {
        var t = this.pressedButton;
        if (t) {
            t.onMouseUp(e);
            this.pressedButton = null
        }
    },
    toggleGroup: function(e, t) {
        if (t) {
            var n = this.groups[e.toggleGroup],
            r = n.length,
            i;
            for (i = 0; i < r; i++) {
                if (n[i] !== e) {
                    n[i].toggle(false)
                }
            }
        }
    },
    register: function(e) {
        var t = this,
        n = this.groups,
        r = n[e.toggleGroup];
        t.init();
        if (!e.toggleGroup) {
            return
        }
        if (!r) {
            r = n[e.toggleGroup] = []
        }
        r.push(e);
        e.on("toggle", t.toggleGroup, t)
    },
    unregister: function(e) {
        if (!e.toggleGroup) {
            return
        }
        var t = this,
        n = t.groups[e.toggleGroup];
        if (n) {
            Ext.Array.remove(n, e);
            e.un("toggle", t.toggleGroup, t)
        }
    },
    getPressed: function(e) {
        var t = this.groups[e],
        n = 0,
        r;
        if (t) {
            for (r = t.length; n < r; n++) {
                if (t[n].pressed === true) {
                    return t[n]
                }
            }
        }
        return null
    }
});
Ext.define("Ext.layout.component.Dock", {
    extend: Ext.layout.component.Component,
    alias: "layout.dock",
    alternateClassName: "Ext.layout.component.AbstractDock",
    type: "dock",
    horzAxisProps: {
        name: "horz",
        oppositeName: "vert",
        dockBegin: "left",
        dockEnd: "right",
        horizontal: true,
        marginBegin: "margin-left",
        maxSize: "maxWidth",
        minSize: "minWidth",
        pos: "x",
        setSize: "setWidth",
        shrinkWrapDock: "shrinkWrapDockWidth",
        size: "width",
        sizeModel: "widthModel"
    },
    vertAxisProps: {
        name: "vert",
        oppositeName: "horz",
        dockBegin: "top",
        dockEnd: "bottom",
        horizontal: false,
        marginBegin: "margin-top",
        maxSize: "maxHeight",
        minSize: "minHeight",
        pos: "y",
        setSize: "setHeight",
        shrinkWrapDock: "shrinkWrapDockHeight",
        size: "height",
        sizeModel: "heightModel"
    },
    initializedBorders: -1,
    horizontalCollapsePolicy: {
        width: true,
        x: true
    },
    verticalCollapsePolicy: {
        height: true,
        y: true
    },
    finishRender: function() {
        var e = this,
        t, n;
        e.callParent();
        t = e.getRenderTarget();
        n = e.getDockedItems();
        e.finishRenderItems(t, n)
    },
    isItemBoxParent: function(e) {
        return true
    },
    isItemShrinkWrap: function(e) {
        return true
    },
    noBorderClasses: [Ext.baseCSSPrefix + "docked-noborder-top", Ext.baseCSSPrefix + "docked-noborder-right", Ext.baseCSSPrefix + "docked-noborder-bottom", Ext.baseCSSPrefix + "docked-noborder-left"],
    noBorderClassesSides: {
        top: Ext.baseCSSPrefix + "docked-noborder-top",
        right: Ext.baseCSSPrefix + "docked-noborder-right",
        bottom: Ext.baseCSSPrefix + "docked-noborder-bottom",
        left: Ext.baseCSSPrefix + "docked-noborder-left"
    },
    borderWidthProps: {
        top: "border-top-width",
        right: "border-right-width",
        bottom: "border-bottom-width",
        left: "border-left-width"
    },
    handleItemBorders: function() {
        var e = this,
        t = e.owner,
        n, r, i = e.lastDockedItems,
        s = e.borders,
        o = t.dockedItems.generation,
        u = e.noBorderClassesSides,
        a = e.borderWidthProps,
        f, l, c, h, p, d = e.collapsed;
        if (e.initializedBorders == o || t.border && !t.manageBodyBorders) {
            return
        }
        e.initializedBorders = o;
        e.collapsed = false;
        e.lastDockedItems = r = e.getLayoutItems();
        e.collapsed = d;
        n = {
            top: [],
            right: [],
            bottom: [],
            left: []
        };
        for (f = 0, l = r.length; f < l; f++) {
            c = r[f];
            h = c.dock;
            if (c.ignoreBorderManagement) {
                continue
            }
            if (!n[h].satisfied) {
                n[h].push(c);
                n[h].satisfied = true
            }
            if (!n.top.satisfied && h !== "bottom") {
                n.top.push(c)
            }
            if (!n.right.satisfied && h !== "left") {
                n.right.push(c)
            }
            if (!n.bottom.satisfied && h !== "top") {
                n.bottom.push(c)
            }
            if (!n.left.satisfied && h !== "right") {
                n.left.push(c)
            }
        }
        if (i) {
            for (f = 0, l = i.length; f < l; f++) {
                c = i[f];
                if (!c.isDestroyed && !c.ignoreBorderManagement && !t.manageBodyBorders) {
                    c.removeCls(e.noBorderClasses)
                }
            }
        }
        if (s) {
            for (p in s) {
                if (t.manageBodyBorders && s[p].satisfied) {
                    t.setBodyStyle(a[p], "")
                }
            }
        }
        for (p in n) {
            l = n[p].length;
            if (!t.manageBodyBorders) {
                for (f = 0; f < l; f++) {
                    n[p][f].addCls(u[p])
                }
                if (!n[p].satisfied && !t.bodyBorder || t.bodyBorder === false) {
                    t.addBodyCls(u[p])
                }
            } else {
                if (n[p].satisfied) {
                    t.setBodyStyle(a[p], "1px")
                }
            }
        }
        e.borders = n
    },
    beforeLayoutCycle: function(e) {
        var t = this,
        n = t.owner,
        r = t.sizeModels.shrinkWrap,
        i = n.shrinkWrapDock,
        s, o;
        if (n.collapsed) {
            if (n.collapsedVertical()) {
                o = true;
                e.measureDimensions = 1
            } else {
                s = true;
                e.measureDimensions = 2
            }
        }
        e.collapsedVert = o;
        e.collapsedHorz = s;
        if (o) {
            e.heightModel = r
        } else {
            if (s) {
                e.widthModel = r
            }
        }
        i = i === true ? 3 : i || 0;
        e.shrinkWrapDockHeight = i & 1 && e.heightModel.shrinkWrap;
        e.shrinkWrapDockWidth = i & 2 && e.widthModel.shrinkWrap
    },
    beginLayout: function(e) {
        var t = this,
        n = t.owner,
        r = t.getLayoutItems(),
        i = e.context,
        s = r.length,
        o,
        u,
        a,
        f,
        l,
        c,
        h;
        t.callParent(arguments);
        c = n.getCollapsed();
        if (c !== t.lastCollapsedState && Ext.isDefined(t.lastCollapsedState)) {
            if (t.owner.collapsed) {
                e.isCollapsingOrExpanding = 1;
                n.addClsWithUI(n.collapsedCls)
            } else {
                e.isCollapsingOrExpanding = 2;
                n.removeClsWithUI(n.collapsedCls);
                e.lastCollapsedState = t.lastCollapsedState
            }
        }
        t.lastCollapsedState = c;
        e.dockedItems = o = [];
        for (u = 0; u < s; u++) {
            a = r[u];
            if (a.rendered) {
                h = a.dock;
                f = i.getCmp(a);
                f.dockedAt = {
                    x: 0,
                    y: 0
                };
                f.offsets = l = Ext.Element.parseBox(a.offsets || 0);
                f.horizontal = h == "top" || h == "bottom";
                l.width = l.left + l.right;
                l.height = l.top + l.bottom;
                o.push(f)
            }
        }
        e.bodyContext = e.getEl("body")
    },
    beginLayoutCycle: function(e) {
        var t = this,
        n = e.dockedItems,
        r = n.length,
        i = t.owner,
        s = i.frameBody,
        o = t.lastHeightModel,
        u, a, f;
        t.callParent(arguments);
        if (t.owner.manageHeight) {
            if (t.lastBodyDisplay) {
                i.body.dom.style.display = t.lastBodyDisplay = ""
            }
        } else {
            if (t.lastBodyDisplay !== "inline-block") {
                i.body.dom.style.display = t.lastBodyDisplay = "inline-block"
            }
            if (o && o.shrinkWrap && !e.heightModel.shrinkWrap) {
                i.body.dom.style.marginBottom = ""
            }
        }
        if (e.widthModel.auto) {
            if (e.widthModel.shrinkWrap) {
                i.el.setWidth(null)
            }
            i.body.setWidth(null);
            if (s) {
                s.setWidth(null)
            }
        }
        if (e.heightModel.auto) {
            i.body.setHeight(null);
            if (s) {
                s.setHeight(null)
            }
        }
        if (e.collapsedVert) {
            e.setContentHeight(0)
        } else {
            if (e.collapsedHorz) {
                e.setContentWidth(0)
            }
        }
        for (u = 0; u < r; u++) {
            a = n[u].target;
            f = a.dock;
            if (f == "right") {
                a.setLocalX(0)
            } else {
                if (f != "left") {
                    continue
                }
            }
        }
    },
    calculate: function(e) {
        var t = this,
        n = t.measureAutoDimensions(e, e.measureDimensions),
        r = e.state,
        i = r.horzDone,
        s = r.vertDone,
        o = e.bodyContext,
        u,
        a,
        f,
        l,
        c;
        e.borderInfo || e.getBorderInfo();
        e.paddingInfo || e.getPaddingInfo();
        e.frameInfo || e.getFrameInfo();
        o.borderInfo || o.getBorderInfo();
        o.paddingInfo || o.getPaddingInfo();
        if (!e.frameBorder) {
            if (! (u = e.framing)) {
                e.frameBorder = e.borderInfo;
                e.framePadding = e.paddingInfo
            } else {
                e.frameBorder = u.border;
                e.framePadding = u.padding
            }
        }
        a = !i && t.createAxis(e, n.contentWidth, e.widthModel, t.horzAxisProps, e.collapsedHorz);
        f = !s && t.createAxis(e, n.contentHeight, e.heightModel, t.vertAxisProps, e.collapsedVert);
        for (l = 0, c = e.dockedItems.length; c--; ++l) {
            if (a) {
                t.dockChild(e, a, c, l)
            }
            if (f) {
                t.dockChild(e, f, c, l)
            }
        }
        if (a && t.finishAxis(e, a)) {
            r.horzDone = i = a
        }
        if (f && t.finishAxis(e, f)) {
            r.vertDone = s = f
        }
        if (i && s && t.finishConstraints(e, i, s)) {
            t.finishPositions(e, i, s)
        } else {
            t.done = false
        }
    },
    createAxis: function(e, t, n, r, i) {
        var s = this,
        o = 0,
        u = s.owner,
        a = u[r.maxSize],
        f = u[r.minSize] || 0,
        l = r.dockBegin,
        c = r.dockEnd,
        h = r.pos,
        p = r.size,
        d = a != null,
        v = n.shrinkWrap,
        m,
        g,
        y,
        b;
        if (v) {
            if (i) {
                b = 0
            } else {
                m = e.bodyContext;
                b = t + m.borderInfo[p]
            }
        } else {
            g = e.frameBorder;
            y = e.framePadding;
            o = g[l] + y[l];
            b = e.getProp(p) - (g[c] + y[c])
        }
        return {
            shrinkWrap: n.shrinkWrap,
            sizeModel: n,
            initialBegin: o,
            begin: o,
            end: b,
            collapsed: i,
            horizontal: r.horizontal,
            ignoreFrameBegin: null,
            ignoreFrameEnd: null,
            initialSize: b - o,
            maxChildSize: 0,
            hasMinMaxConstraints: (f || d) && n.shrinkWrap,
            minSize: f,
            maxSize: d ? a: 1e9,
            bodyPosProp: s.owner.manageHeight ? h: r.marginBegin,
            dockBegin: l,
            dockEnd: c,
            posProp: h,
            sizeProp: p,
            setSize: r.setSize,
            shrinkWrapDock: e[r.shrinkWrapDock],
            sizeModelName: r.sizeModel,
            dockedPixelsEnd: 0
        }
    },
    dockChild: function(e, t, n, r) {
        var i = this,
        s = e.dockedItems[t.shrinkWrap ? n: r],
        o = s.target,
        u = o.dock,
        a = t.sizeProp,
        f,
        l;
        if (o.ignoreParentFrame && e.isCollapsingOrExpanding) {
            s.clearMarginCache()
        }
        s.marginInfo || s.getMarginInfo();
        if (u == t.dockBegin) {
            if (t.shrinkWrap) {
                f = i.dockOutwardBegin(e, s, o, t)
            } else {
                f = i.dockInwardBegin(e, s, o, t)
            }
        } else {
            if (u == t.dockEnd) {
                if (t.shrinkWrap) {
                    f = i.dockOutwardEnd(e, s, o, t)
                } else {
                    f = i.dockInwardEnd(e, s, o, t)
                }
            } else {
                if (t.shrinkWrapDock) {
                    l = s.getProp(a) + s.marginInfo[a];
                    t.maxChildSize = Math.max(t.maxChildSize, l);
                    f = 0
                } else {
                    f = i.dockStretch(e, s, o, t)
                }
            }
        }
        s.dockedAt[t.posProp] = f
    },
    dockInwardBegin: function(e, t, n, r) {
        var i = r.begin,
        s = r.sizeProp,
        o = n.ignoreParentFrame,
        u, a, f;
        if (o) {
            r.ignoreFrameBegin = t;
            f = n.dock;
            u = e.frameBorder[f];
            i -= u + e.framePadding[f]
        }
        if (!n.overlay) {
            a = t.getProp(s) + t.marginInfo[s];
            r.begin += a;
            if (o) {
                r.begin -= u
            }
        }
        return i
    },
    dockInwardEnd: function(e, t, n, r) {
        var i = r.sizeProp,
        s = t.getProp(i) + t.marginInfo[i],
        o = r.end - s,
        u;
        if (!n.overlay) {
            r.end = o
        }
        if (n.ignoreParentFrame) {
            r.ignoreFrameEnd = t;
            u = e.frameBorder[n.dock];
            o += u + e.framePadding[n.dock];
            r.end += u
        }
        return o
    },
    dockOutwardBegin: function(e, t, n, r) {
        var i = r.begin,
        s = r.sizeProp,
        o;
        if (r.collapsed) {
            r.ignoreFrameBegin = r.ignoreFrameEnd = t
        } else {
            if (n.ignoreParentFrame) {
                r.ignoreFrameBegin = t
            }
        }
        if (!n.overlay) {
            o = t.getProp(s) + t.marginInfo[s];
            i -= o;
            r.begin = i
        }
        return i
    },
    dockOutwardEnd: function(e, t, n, r) {
        var i = r.end,
        s = r.sizeProp,
        o;
        o = t.getProp(s) + t.marginInfo[s];
        if (r.collapsed) {
            r.ignoreFrameBegin = r.ignoreFrameEnd = t
        } else {
            if (n.ignoreParentFrame) {
                r.ignoreFrameEnd = t
            }
        }
        if (!n.overlay) {
            r.end = i + o;
            r.dockedPixelsEnd += o
        }
        return i
    },
    dockStretch: function(e, t, n, r) {
        var i = n.dock,
        s = r.sizeProp,
        o = i == "top" || i == "bottom",
        u = e.frameBorder,
        a = t.offsets,
        f = e.framePadding,
        l = o ? "right": "bottom",
        c = o ? "left": "top",
        h = r.begin + a[c],
        p,
        d;
        if (n.stretch !== false) {
            d = r.end - h - a[l];
            if (n.ignoreParentFrame) {
                h -= f[c] + u[c];
                d += f[s] + u[s]
            }
            p = t.marginInfo;
            d -= p[s];
            t[r.setSize](d)
        }
        return h
    },
    finishAxis: function(e, t) {
        if (isNaN(t.maxChildSize)) {
            return false
        }
        var n = t.begin,
        r = t.end - n,
        i = t.collapsed,
        s = t.setSize,
        o = t.dockBegin,
        u = t.dockEnd,
        a = e.framePadding,
        f = e.frameBorder,
        l = f[o],
        c = e.framing,
        h = c && c[o],
        p = i ? 0 : a[o],
        d = t.sizeProp,
        v = t.ignoreFrameBegin,
        m = t.ignoreFrameEnd,
        g = e.bodyContext,
        y = Math.max(l + p - h, 0),
        b,
        w,
        E,
        S;
        if (t.shrinkWrap) {
            w = t.initialSize;
            if (c) {
                E = -n + l + p;
                b = E - h - y
            } else {
                b = -n;
                E = b + p
            }
            if (!i) {
                r += a[d]
            }
            if (v) {
                E -= l;
                b -= l;
                v.dockedAt[t.posProp] -= p
            } else {
                r += l
            }
            if (i) {} else {
                if (m) {
                    m.dockedAt[t.posProp] += a[u]
                } else {
                    r += f[u]
                }
            }
            t.size = r;
            if (!t.horizontal && !this.owner.manageHeight) {
                S = false
            }
        } else {
            if (c) {
                E = 0;
                b = n - h - y
            } else {
                E = -l;
                b = n - p - l
            }
            w = r
        }
        t.delta = E;
        g[s](w, S);
        g.setProp(t.bodyPosProp, b);
        return ! isNaN(r)
    },
    beforeInvalidateShrinkWrapDock: function(e, t) {
        var n = t.axis.sizeModelName;
        if (!e[n].constrainedMin) {
            e[n] = Ext.layout.SizeModel.calculated
        }
    },
    afterInvalidateShrinkWrapDock: function(e, t) {
        var n = t.axis,
        r = t.layout,
        i;
        if (e[n.sizeModelName].calculated) {
            i = r.dockStretch(t.ownerContext, e, e.target, n);
            e.setProp(n.posProp, n.delta + i)
        }
    },
    finishConstraints: function(e, t, n) {
        var r = this,
        i = r.sizeModels,
        s = t.shrinkWrap,
        o = n.shrinkWrap,
        u = r.owner,
        a, f, l, c, h, p, d, v, m, g;
        if (s) {
            p = t.size;
            d = t.collapsed ? 0 : t.minSize;
            v = t.maxSize;
            m = t.maxChildSize;
            g = Math.max(p, m);
            if (g > v) {
                h = i.constrainedMax;
                l = v
            } else {
                if (g < d) {
                    h = i.constrainedMin;
                    l = d
                } else {
                    if (p < m) {
                        h = i.constrainedDock;
                        u.dockConstrainedWidth = l = m
                    } else {
                        l = p
                    }
                }
            }
        }
        if (o) {
            p = n.size;
            d = n.collapsed ? 0 : n.minSize;
            v = n.maxSize;
            m = n.maxChildSize;
            g = Math.max(p, m + p - n.initialSize);
            if (g > v) {
                c = i.constrainedMax;
                f = v
            } else {
                if (g < d) {
                    c = i.constrainedMin;
                    f = d
                } else {
                    if (p < m) {
                        c = i.constrainedDock;
                        u.dockConstrainedHeight = f = m
                    } else {
                        if (!e.collapsedVert && !u.manageHeight) {
                            a = false;
                            e.bodyContext.setProp("margin-bottom", n.dockedPixelsEnd)
                        }
                        f = p
                    }
                }
            }
        }
        if (h || c) {
            if (h && c && h.constrainedMax && c.constrainedByMin) {
                e.invalidate({
                    widthModel: h
                });
                return false
            }
            if (!e.widthModel.calculatedFromShrinkWrap && !e.heightModel.calculatedFromShrinkWrap) {
                e.invalidate({
                    widthModel: h,
                    heightModel: c
                });
                return false
            }
        } else {
            r.invalidateAxes(e, t, n)
        }
        if (s) {
            e.setWidth(l);
            if (h) {
                e.widthModel = h
            }
        }
        if (o) {
            e.setHeight(f, a);
            if (c) {
                e.heightModel = c
            }
        }
        return true
    },
    invalidateAxes: function(e, t, n) {
        var r = this.beforeInvalidateShrinkWrapDock,
        i = this.afterInvalidateShrinkWrapDock,
        s = t.end - t.begin,
        o = n.initialSize,
        u = t.shrinkWrapDock && t.maxChildSize <= s,
        a = n.shrinkWrapDock && n.maxChildSize <= o,
        f, l, c, h, p, d, v, m;
        if (u || a) {
            if (a) {
                n.begin = n.initialBegin;
                n.end = n.begin + n.initialSize
            }
            f = e.dockedItems;
            for (c = 0, l = f.length; c < l; ++c) {
                h = f[c];
                d = h.horizontal;
                v = null;
                if (u && d) {
                    m = t.sizeProp;
                    p = s;
                    v = t
                } else {
                    if (a && !d) {
                        m = n.sizeProp;
                        p = o;
                        v = n
                    }
                }
                if (v) {
                    p -= h.getMarginInfo()[m];
                    if (p !== h.props[m]) {
                        h.invalidate({
                            before: r,
                            after: i,
                            axis: v,
                            ownerContext: e,
                            layout: this
                        })
                    }
                }
            }
        }
    },
    finishPositions: function(e, t, n) {
        var r = e.dockedItems,
        i = r.length,
        s = t.delta,
        o = n.delta,
        u, a;
        for (u = 0; u < i; ++u) {
            a = r[u];
            a.setProp("x", s + a.dockedAt.x);
            a.setProp("y", o + a.dockedAt.y)
        }
    },
    finishedLayout: function(e) {
        var t = this,
        n = e.target;
        t.callParent(arguments);
        if (!e.animatePolicy) {
            if (e.isCollapsingOrExpanding === 1) {
                n.afterCollapse(false)
            } else {
                if (e.isCollapsingOrExpanding === 2) {
                    n.afterExpand(false)
                }
            }
        }
    },
    getAnimatePolicy: function(e) {
        var t = this,
        n, r;
        if (e.isCollapsingOrExpanding == 1) {
            n = t.lastCollapsedState
        } else {
            if (e.isCollapsingOrExpanding == 2) {
                n = e.lastCollapsedState
            }
        }
        if (n == "left" || n == "right") {
            r = t.horizontalCollapsePolicy
        } else {
            if (n == "top" || n == "bottom") {
                r = t.verticalCollapsePolicy
            }
        }
        return r
    },
    getDockedItems: function(e, t) {
        var n = this,
        r = e === "visual",
        i = r ? Ext.ComponentQuery.query("[rendered]", n.owner.dockedItems.items) : n.owner.dockedItems.items,
        s = i && i.length && e !== false,
        o,
        u,
        a,
        f,
        l,
        c;
        if (t == null) {
            a = s && !r ? i.slice() : i
        } else {
            a = [];
            for (f = 0, c = i.length; f < c; ++f) {
                u = i[f].dock;
                l = u == "top" || u == "left";
                if (t ? l: !l) {
                    a.push(i[f])
                }
            }
            s = s && a.length
        }
        if (s) {
            o = (e = e || "render") == "render";
            Ext.Array.sort(a,
            function(t, r) {
                var i, s;
                if (o && (i = n.owner.dockOrder[t.dock]) !== (s = n.owner.dockOrder[r.dock])) {
                    if (! (i + s)) {
                        return i - s
                    }
                }
                i = n.getItemWeight(t, e);
                s = n.getItemWeight(r, e);
                if (i !== undefined && s !== undefined) {
                    return i - s
                }
                return 0
            })
        }
        return a || []
    },
    getItemWeight: function(e, t) {
        var n = e.weight || this.owner.defaultDockWeights[e.dock];
        return n[t] || n
    },
    getLayoutItems: function() {
        var e = this,
        t, n, r, i, s;
        if (e.owner.collapsed) {
            s = e.owner.getCollapsedDockedItems()
        } else {
            t = e.getDockedItems("visual");
            n = t.length;
            s = [];
            for (i = 0; i < n; i++) {
                r = t[i];
                if (!r.hidden) {
                    s.push(r)
                }
            }
        }
        return s
    },
    measureContentWidth: function(e) {
        var t = e.bodyContext;
        return t.el.getWidth() - t.getBorderInfo().width
    },
    measureContentHeight: function(e) {
        var t = e.bodyContext;
        return t.el.getHeight() - t.getBorderInfo().height
    },
    redoLayout: function(e) {
        var t = this,
        n = t.owner;
        if (e.isCollapsingOrExpanding == 1) {
            if (n.reExpander) {
                n.reExpander.el.show()
            }
            n.addClsWithUI(n.collapsedCls);
            e.redo(true)
        } else {
            if (e.isCollapsingOrExpanding == 2) {
                n.removeClsWithUI(n.collapsedCls);
                e.bodyContext.redo()
            }
        }
    },
    renderChildren: function() {
        var e = this,
        t = e.getDockedItems(),
        n = e.getRenderTarget();
        e.handleItemBorders();
        e.renderItems(t, n)
    },
    renderItems: function(e, t) {
        var n = this,
        r = e.length,
        i = 0,
        s = 0,
        o = 0,
        u = n.getRenderTarget().dom.childNodes,
        a = u.length,
        f,
        l,
        c,
        h;
        for (f = 0, l = 0; f < a; f++) {
            c = u[f];
            if (Ext.fly(c).hasCls(Ext.baseCSSPrefix + "resizable-handle")) {
                break
            }
            for (l = 0; l < r; l++) {
                h = e[l];
                if (h.rendered && h.el.dom === c) {
                    break
                }
            }
            if (l === r) {
                o++
            }
        }
        for (; i < r; i++, s++) {
            h = e[i];
            if (i === s && (h.dock === "right" || h.dock === "bottom")) {
                s += o
            }
            if (h && !h.rendered) {
                n.renderItem(h, t, s)
            } else {
                if (!n.isValidParent(h, t, s)) {
                    n.moveItem(h, t, s)
                }
            }
        }
    },
    undoLayout: function(e) {
        var t = this,
        n = t.owner;
        if (e.isCollapsingOrExpanding == 1) {
            if (n.reExpander) {
                n.reExpander.el.hide()
            }
            n.removeClsWithUI(n.collapsedCls);
            e.undo(true)
        } else {
            if (e.isCollapsingOrExpanding == 2) {
                n.addClsWithUI(n.collapsedCls);
                e.bodyContext.undo()
            }
        }
    },
    sizePolicy: {
        nostretch: {
            setsWidth: 0,
            setsHeight: 0
        },
        horz: {
            shrinkWrap: {
                setsWidth: 1,
                setsHeight: 0,
                readsWidth: 1
            },
            stretch: {
                setsWidth: 1,
                setsHeight: 0
            }
        },
        vert: {
            shrinkWrap: {
                setsWidth: 0,
                setsHeight: 1,
                readsHeight: 1
            },
            stretch: {
                setsWidth: 0,
                setsHeight: 1
            }
        },
        stretchV: {
            setsWidth: 0,
            setsHeight: 1
        },
        autoStretchH: {
            readsWidth: 1,
            setsWidth: 1,
            setsHeight: 0
        },
        autoStretchV: {
            readsHeight: 1,
            setsWidth: 0,
            setsHeight: 1
        }
    },
    getItemSizePolicy: function(e, t) {
        var n = this,
        r = n.sizePolicy,
        i = n.owner.shrinkWrapDock,
        s, o;
        if (e.stretch === false) {
            return r.nostretch
        }
        s = e.dock;
        o = s == "left" || s == "right";
        i = i === true ? 3 : i || 0;
        if (o) {
            r = r.vert;
            i = i & 1
        } else {
            r = r.horz;
            i = i & 2
        }
        if (i) {
            if (!t) {
                t = n.owner.getSizeModel()
            }
            if (t[o ? "height": "width"].shrinkWrap) {
                return r.shrinkWrap
            }
        }
        return r.stretch
    },
    configureItem: function(e, t) {
        this.callParent(arguments);
        e.addCls(Ext.baseCSSPrefix + "docked");
        e.addClsWithUI(this.getDockCls(e.dock))
    },
    getDockCls: function(e) {
        return "docked-" + e
    },
    afterRemove: function(e) {
        this.callParent(arguments);
        if (this.itemCls) {
            e.el.removeCls(this.itemCls + "-" + e.dock)
        }
        var t = e.el.dom;
        if (!e.destroying && t) {
            t.parentNode.removeChild(t)
        }
        this.childrenChanged = true
    },
    borderCollapseMap: {},
    getBorderCollapseTable: function() {
        var e = this,
        t = e.borderCollapseMap,
        n = e.owner,
        r = n.baseCls,
        i = n.ui,
        s;
        t = t[r] || (t[r] = {});
        s = t[i];
        if (!s) {
            r += "-" + i + "-outer-border-";
            t[i] = s = [0, r + "l", r + "b", r + "bl", r + "r", r + "rl", r + "rb", r + "rbl", r + "t", r + "tl", r + "tb", r + "tbl", r + "tr", r + "trl", r + "trb", r + "trbl"]
        }
        return s
    }
});
Ext.define("Ext.menu.Manager", {
    singleton: true,
    alternateClassName: "Ext.menu.MenuMgr",
    menuSelector: "." + Ext.baseCSSPrefix + "menu",
    menus: {},
    groups: {},
    attached: false,
    lastShow: new Date,
    init: function() {
        var e = this;
        e.active = new Ext.util.MixedCollection;
        Ext.getDoc().addKeyListener(27,
        function() {
            if (e.active.length > 0) {
                e.hideAll()
            }
        },
        e)
    },
    hideAll: function() {
        var e = this.active,
        t, n, r;
        if (e && e.length > 0) {
            t = Ext.Array.slice(e.items);
            r = t.length;
            for (n = 0; n < r; n++) {
                t[n].hide()
            }
            return true
        }
        return false
    },
    onHide: function(e) {
        var t = this,
        n = t.active;
        n.remove(e);
        if (n.length < 1) {
            Ext.getDoc().un("mousedown", t.onMouseDown, t);
            t.attached = false
        }
    },
    onShow: function(e) {
        var t = this,
        n = t.active,
        r = t.attached;
        t.lastShow = new Date;
        n.add(e);
        if (!r) {
            Ext.getDoc().on("mousedown", t.onMouseDown, t, {
                buffer: Ext.isIE9m ? 10 : undefined
            });
            t.attached = true
        }
        e.toFront()
    },
    onBeforeHide: function(e) {
        if (e.activeChild) {
            e.activeChild.hide()
        }
        if (e.autoHideTimer) {
            clearTimeout(e.autoHideTimer);
            delete e.autoHideTimer
        }
    },
    onBeforeShow: function(e) {
        var t = this.active,
        n = e.parentMenu;
        t.remove(e);
        if (!n && !e.allowOtherMenus) {
            this.hideAll()
        } else {
            if (n && n.activeChild && e != n.activeChild) {
                n.activeChild.hide()
            }
        }
    },
    onMouseDown: function(e) {
        var t = this,
        n = t.active,
        r = n.length,
        i = t.lastShow,
        s;
        if (Ext.Date.getElapsed(i) > 50 && r) {
            if (Ext.isIE9m && !Ext.getDoc().contains(e.target)) {
                return
            } else {
                for (s = 0; s < r; s++) {
                    if (n.items[s].owns(e.target)) {
                        return
                    }
                }
            }
            t.hideAll()
        }
    },
    register: function(e) {
        var t = this;
        if (!t.active) {
            t.init()
        }
        if (e.floating) {
            t.menus[e.id] = e;
            e.on({
                beforehide: t.onBeforeHide,
                hide: t.onHide,
                beforeshow: t.onBeforeShow,
                show: t.onShow,
                scope: t
            })
        }
    },
    get: function(e) {
        var t = this.menus;
        if (typeof e == "string") {
            if (!t) {
                return null
            }
            return t[e]
        } else {
            if (e.isMenu) {
                return e
            } else {
                if (Ext.isArray(e)) {
                    return new Ext.menu.Menu({
                        items: e
                    })
                } else {
                    return Ext.ComponentManager.create(e, "menu")
                }
            }
        }
    },
    unregister: function(e) {
        var t = this,
        n = t.menus,
        r = t.active;
        delete n[e.id];
        r.remove(e);
        e.un({
            beforehide: t.onBeforeHide,
            hide: t.onHide,
            beforeshow: t.onBeforeShow,
            show: t.onShow,
            scope: t
        })
    },
    registerCheckable: function(e) {
        var t = this.groups,
        n = e.group;
        if (n) {
            if (!t[n]) {
                t[n] = []
            }
            t[n].push(e)
        }
    },
    unregisterCheckable: function(e) {
        var t = this.groups,
        n = e.group;
        if (n) {
            Ext.Array.remove(t[n], e)
        }
    },
    onCheckChange: function(e, t) {
        var n = this.groups,
        r = e.group,
        i = 0,
        s, o, u;
        if (r && t) {
            s = n[r];
            o = s.length;
            for (; i < o; i++) {
                u = s[i];
                if (u != e) {
                    u.setChecked(false)
                }
            }
        }
    }
});
Ext.define("Ext.util.ClickRepeater", {
    extend: Ext.util.Observable,
    constructor: function(e, t) {
        var n = this;
        n.el = Ext.get(e);
        n.el.unselectable();
        Ext.apply(n, t);
        n.callParent();
        n.addEvents("mousedown", "click", "mouseup");
        if (!n.disabled) {
            n.disabled = true;
            n.enable()
        }
        if (n.handler) {
            n.on("click", n.handler, n.scope || n)
        }
    },
    interval: 20,
    delay: 250,
    preventDefault: true,
    stopDefault: false,
    timer: 0,
    enable: function() {
        if (this.disabled) {
            this.el.on("mousedown", this.handleMouseDown, this);
            if (Ext.isIE && !(Ext.isIE10p || Ext.isStrict && Ext.isIE9)) {
                this.el.on("dblclick", this.handleDblClick, this)
            }
            if (this.preventDefault || this.stopDefault) {
                this.el.on("click", this.eventOptions, this)
            }
        }
        this.disabled = false
    },
    disable: function(e) {
        if (e || !this.disabled) {
            clearTimeout(this.timer);
            if (this.pressedCls) {
                this.el.removeCls(this.pressedCls)
            }
            Ext.getDoc().un("mouseup", this.handleMouseUp, this);
            this.el.removeAllListeners()
        }
        this.disabled = true
    },
    setDisabled: function(e) {
        this[e ? "disable": "enable"]()
    },
    eventOptions: function(e) {
        if (this.preventDefault) {
            e.preventDefault()
        }
        if (this.stopDefault) {
            e.stopEvent()
        }
    },
    destroy: function() {
        this.disable(true);
        Ext.destroy(this.el);
        this.clearListeners()
    },
    handleDblClick: function(e) {
        clearTimeout(this.timer);
        this.el.blur();
        this.fireEvent("mousedown", this, e);
        this.fireEvent("click", this, e)
    },
    handleMouseDown: function(e) {
        clearTimeout(this.timer);
        this.el.blur();
        if (this.pressedCls) {
            this.el.addCls(this.pressedCls)
        }
        this.mousedownTime = new Date;
        Ext.getDoc().on("mouseup", this.handleMouseUp, this);
        this.el.on("mouseout", this.handleMouseOut, this);
        this.fireEvent("mousedown", this, e);
        this.fireEvent("click", this, e);
        if (this.accelerate) {
            this.delay = 400
        }
        e = new Ext.EventObjectImpl(e);
        this.timer = Ext.defer(this.click, this.delay || this.interval, this, [e])
    },
    click: function(e) {
        this.fireEvent("click", this, e);
        this.timer = Ext.defer(this.click, this.accelerate ? this.easeOutExpo(Ext.Date.getElapsed(this.mousedownTime), 400, -390, 12e3) : this.interval, this, [e])
    },
    easeOutExpo: function(e, t, n, r) {
        return e == r ? t + n: n * ( - Math.pow(2, -10 * e / r) + 1) + t
    },
    handleMouseOut: function() {
        clearTimeout(this.timer);
        if (this.pressedCls) {
            this.el.removeCls(this.pressedCls)
        }
        this.el.on("mouseover", this.handleMouseReturn, this)
    },
    handleMouseReturn: function() {
        this.el.un("mouseover", this.handleMouseReturn, this);
        if (this.pressedCls) {
            this.el.addCls(this.pressedCls)
        }
        this.click()
    },
    handleMouseUp: function(e) {
        clearTimeout(this.timer);
        this.el.un("mouseover", this.handleMouseReturn, this);
        this.el.un("mouseout", this.handleMouseOut, this);
        Ext.getDoc().un("mouseup", this.handleMouseUp, this);
        if (this.pressedCls) {
            this.el.removeCls(this.pressedCls)
        }
        this.fireEvent("mouseup", this, e)
    }
});
Ext.define("Ext.layout.component.Button", {
    alias: ["layout.button"],
    extend: Ext.layout.component.Auto,
    type: "button",
    htmlRE: /<.*>/,
    beginLayout: function(e) {
        var t = this,
        n = t.owner,
        r = n.text;
        t.callParent(arguments);
        e.btnWrapContext = e.getEl("btnWrap");
        e.btnElContext = e.getEl("btnEl");
        e.btnInnerElContext = e.getEl("btnInnerEl");
        e.btnIconElContext = e.getEl("btnIconEl");
        if (r && t.htmlRE.test(r)) {
            e.isHtmlText = true;
            n.btnInnerEl.setStyle("line-height", "normal");
            n.btnInnerEl.setStyle("padding-top", "")
        }
    },
    beginLayoutCycle: function(e) {
        var t = this.owner,
        n = this.lastWidthModel,
        r = this.lastHeightModel,
        i = t.btnInnerEl,
        s = t.getFrameInfo().table;
        this.callParent(arguments);
        if (n && !n.shrinkWrap && e.widthModel.shrinkWrap) {
            t.btnWrap.setStyle("height", "");
            t.btnEl.setStyle("height", "");
            i.setStyle("line-height", "");
            if (s) {
                i.setStyle("width", "")
            }
        }
        if (s && r && !r.shrinkWrap && e.heightModel.shrinkWrap) {
            i.setStyle("height", "")
        }
    },
    calculate: function(e) {
        var t = this,
        n = t.owner,
        r = e.btnElContext,
        i = e.btnInnerElContext,
        s = e.btnWrapContext,
        o = Math.max,
        u, a, f, l;
        t.callParent(arguments);
        if (e.heightModel.shrinkWrap) {
            f = n.btnEl.getHeight();
            if (e.isHtmlText) {
                t.centerInnerEl(e, f);
                t.ieCenterIcon(e, f)
            }
        } else {
            u = e.getProp("height");
            if (u) {
                a = u - e.getFrameInfo().height - e.getPaddingInfo().height;
                f = a;
                if ((n.menu || n.split) && n.arrowAlign === "bottom") {
                    f -= s.getPaddingInfo().bottom
                }
                l = f;
                if ((n.icon || n.iconCls || n.glyph) && (n.iconAlign === "top" || n.iconAlign === "bottom")) {
                    l -= i.getPaddingInfo().height
                }
                s.setProp("height", o(0, a));
                r.setProp("height", o(0, f));
                if (e.isHtmlText) {
                    t.centerInnerEl(e, f)
                } else {
                    i.setProp("line-height", o(0, l) + "px")
                }
                t.ieCenterIcon(e, f)
            } else {
                if (u !== 0) {
                    t.done = false
                }
            }
        }
    },
    centerInnerEl: function(e, t) {
        var n = this,
        r = e.btnInnerElContext,
        i = n.owner.btnInnerEl.getHeight();
        if (e.heightModel.shrinkWrap && t < i) {
            e.btnElContext.setHeight(i)
        } else {
            if (t > i) {
                r.setProp("padding-top", Math.round((t - i) / 2) + r.getPaddingInfo().top)
            }
        }
    },
    ieCenterIcon: function(e, t) {
        var n = this.owner.iconAlign;
        if ((Ext.isIEQuirks || Ext.isIE6) && (n === "left" || n === "right")) {
            e.btnIconElContext.setHeight(t)
        }
    },
    publishInnerWidth: function(e, t) {
        if (this.owner.getFrameInfo().table) {
            e.btnInnerElContext.setWidth(t - e.getFrameInfo().width - e.getPaddingInfo().width - e.btnWrapContext.getPaddingInfo().width)
        }
    }
});
Ext.define("Ext.util.TextMetrics", {
    statics: {
        shared: null,
        measure: function(e, t, n) {
            var r = this,
            i = r.shared;
            if (!i) {
                i = r.shared = new r(e, n)
            }
            i.bind(e);
            i.setFixedWidth(n || "auto");
            return i.getSize(t)
        },
        destroy: function() {
            var e = this;
            Ext.destroy(e.shared);
            e.shared = null
        }
    },
    constructor: function(e, t) {
        var n = this,
        r = Ext.getBody().createChild({
            role: "presentation",
            cls: Ext.baseCSSPrefix + "textmetrics"
        });
        n.measure = r;
        if (e) {
            n.bind(e)
        }
        r.position("absolute");
        r.setLocalXY( - 1e3, -1e3);
        r.hide();
        if (t) {
            r.setWidth(t)
        }
    },
    getSize: function(e) {
        var t = this.measure,
        n;
        t.update(e);
        n = t.getSize();
        t.update("");
        return n
    },
    bind: function(e) {
        var t = this;
        t.el = Ext.get(e);
        t.measure.setStyle(t.el.getStyles("font-size", "font-style", "font-weight", "font-family", "line-height", "text-transform", "letter-spacing", "word-break"))
    },
    setFixedWidth: function(e) {
        this.measure.setWidth(e)
    },
    getWidth: function(e) {
        this.measure.dom.style.width = "auto";
        return this.getSize(e).width
    },
    getHeight: function(e) {
        return this.getSize(e).height
    },
    destroy: function() {
        var e = this;
        e.measure.remove();
        delete e.el;
        delete e.measure
    }
},
function() {
    Ext.Element.addMethods({
        getTextWidth: function(e, t, n) {
            return Ext.Number.constrain(Ext.util.TextMetrics.measure(this.dom, Ext.value(e, this.dom.innerHTML, true)).width, t || 0, n || 1e6)
        }
    })
});
Ext.define("Ext.button.Button", {
    alias: "widget.button",
    extend: Ext.Component,
    mixins: {
        queryable: Ext.Queryable
    },
    alternateClassName: "Ext.Button",
    isButton: true,
    componentLayout: "button",
    hidden: false,
    disabled: false,
    pressed: false,
    tabIndex: 0,
    enableToggle: false,
    menuAlign: "tl-bl?",
    showEmptyMenu: false,
    textAlign: "center",
    clickEvent: "click",
    preventDefault: true,
    handleMouseEvents: true,
    tooltipType: "qtip",
    baseCls: Ext.baseCSSPrefix + "btn",
    pressedCls: "pressed",
    overCls: "over",
    focusCls: "focus",
    menuActiveCls: "menu-active",
    hrefTarget: "_blank",
    destroyMenu: true,
    ariaRole: "button",
    childEls: ["btnEl", "btnWrap", "btnInnerEl", "btnIconEl"],
    renderTpl: ['<span id="{id}-btnWrap" role="presentation" class="{baseCls}-wrap', '<tpl if="splitCls"> {splitCls}</tpl>', '{childElCls}" unselectable="on">', '<span id="{id}-btnEl" class="{baseCls}-button" role="presentation">', '<span id="{id}-btnInnerEl" class="{baseCls}-inner {innerCls}', '{childElCls}" unselectable="on">', "{text}", "</span>", '<span role="presentation" id="{id}-btnIconEl" class="{baseCls}-icon-el {iconCls}', '{childElCls} {glyphCls}" unselectable="on" style="', '<tpl if="iconUrl">background-image:url({iconUrl});</tpl>', '<tpl if="glyph && glyphFontFamily">font-family:{glyphFontFamily};</tpl>">', '<tpl if="glyph">&#{glyph};</tpl><tpl if="iconCls || iconUrl">&#160;</tpl>', "</span>", "</span>", "</span>", '<tpl if="closable">', '<span id="{id}-closeEl" role="presentation"', ' class="{baseCls}-close-btn"', '<tpl if="closeText">', ' title="{closeText}" aria-label="{closeText}"', "</tpl>", ">", "</span>", "</tpl>"],
    scale: "small",
    allowedScales: ["small", "medium", "large"],
    iconAlign: "left",
    arrowAlign: "right",
    arrowCls: "arrow",
    maskOnDisable: false,
    shrinkWrap: 3,
    frame: true,
    autoEl: {
        tag: "a",
        hidefocus: "on",
        unselectable: "on"
    },
    hasFrameTable: function() {
        return this.href && this.frameTable
    },
    frameTableListener: function() {
        if (!this.disabled) {
            this.doNavigate()
        }
    },
    doNavigate: function() {
        if (this.hrefTarget === "_blank") {
            window.open(this.getHref(), this.hrefTarget)
        } else {
            location.href = this.getHref()
        }
    },
    _triggerRegion: {},
    initComponent: function() {
        var e = this;
        e.addCls(Ext.baseCSSPrefix + "unselectable");
        e.callParent(arguments);
        e.addEvents("click", "toggle", "mouseover", "mouseout", "menushow", "menuhide", "menutriggerover", "menutriggerout", "textchange", "iconchange", "glyphchange");
        if (e.menu) {
            e.split = true;
            e.setMenu(e.menu, false)
        }
        if (e.url) {
            e.href = e.url
        }
        if (e.href && !e.hasOwnProperty("preventDefault")) {
            e.preventDefault = false
        }
        if (Ext.isString(e.toggleGroup) && e.toggleGroup !== "") {
            e.enableToggle = true
        }
        if (e.html && !e.text) {
            e.text = e.html;
            delete e.html
        }
        e.glyphCls = e.baseCls + "-glyph"
    },
    getActionEl: function() {
        return this.el
    },
    getFocusEl: function() {
        return this.el
    },
    setComponentCls: function() {
        var e = this,
        t = e.getComponentCls();
        if (!Ext.isEmpty(e.oldCls)) {
            e.removeClsWithUI(e.oldCls);
            e.removeClsWithUI(e.pressedCls)
        }
        e.oldCls = t;
        e.addClsWithUI(t)
    },
    getComponentCls: function() {
        var e = this,
        t;
        if (e.iconCls || e.icon || e.glyph) {
            t = [e.text ? "icon-text-" + e.iconAlign: "icon"]
        } else {
            if (e.text) {
                t = ["noicon"]
            } else {
                t = []
            }
        }
        if (e.pressed) {
            t[t.length] = e.pressedCls
        }
        return t
    },
    getElConfig: function() {
        var e = this,
        t = e.callParent(),
        n = e.getHref(),
        r = e.hrefTarget;
        if (t.tag === "a") {
            if (!e.disabled) {
                t.tabIndex = e.tabIndex
            }
            if (n) {
                t.href = n;
                if (r) {
                    t.target = r
                }
            }
        }
        return t
    },
    beforeRender: function() {
        var e = this;
        e.callParent();
        e.oldCls = e.getComponentCls();
        e.addClsWithUI(e.oldCls);
        Ext.applyIf(e.renderData, e.getTemplateArgs())
    },
    setMenu: function(e, t) {
        var n = this,
        r = n.menu;
        if (r && t !== false && n.destroyMenu) {
            r.destroy()
        }
        if (r) {
            r.ownerCmp = r.ownerButton = null
        }
        if (e) {
            e = Ext.menu.Manager.get(e);
            e.ownerCmp = e.ownerButton = n;
            n.mon(e, {
                scope: n,
                show: n.onMenuShow,
                hide: n.onMenuHide
            });
            if (!r) {
                n.split = true;
                if (n.rendered) {
                    n.btnWrap.addCls(n.getSplitCls());
                    n.updateLayout()
                }
            }
            n.menu = e
        } else {
            if (n.rendered) {
                n.btnWrap.removeCls(n.getSplitCls());
                n.updateLayout()
            }
            n.split = false;
            n.menu = null
        }
    },
    onRender: function() {
        var e = this,
        t, n, r;
        e.doc = Ext.getDoc();
        e.callParent(arguments);
        n = e.el;
        if (e.tooltip) {
            e.setTooltip(e.tooltip, true)
        }
        if (e.handleMouseEvents) {
            r = {
                scope: e,
                mouseover: e.onMouseOver,
                mouseout: e.onMouseOut,
                mousedown: e.onMouseDown
            };
            if (e.split) {
                r.mousemove = e.onMouseMove
            }
        } else {
            r = {
                scope: e
            }
        }
        if (e.menu) {
            e.keyMap = new Ext.util.KeyMap({
                target: e.el,
                key: Ext.EventObject.DOWN,
                handler: e.onDownKey,
                scope: e
            })
        }
        if (e.repeat) {
            e.mon(new Ext.util.ClickRepeater(n, Ext.isObject(e.repeat) ? e.repeat: {}), "click", e.onRepeatClick, e)
        } else {
            if (r[e.clickEvent]) {
                t = true
            } else {
                r[e.clickEvent] = e.onClick
            }
        }
        e.mon(n, r);
        if (e.hasFrameTable()) {
            e.mon(e.frameTable, "click", e.frameTableListener, e)
        }
        if (t) {
            e.mon(n, e.clickEvent, e.onClick, e)
        }
        Ext.button.Manager.register(e)
    },
    getTemplateArgs: function() {
        var e = this,
        t = e.glyph,
        n = Ext._glyphFontFamily,
        r;
        if (typeof t === "string") {
            r = t.split("@");
            t = r[0];
            n = r[1]
        }
        return {
            innerCls: e.getInnerCls(),
            splitCls: e.getSplitCls(),
            iconUrl: e.icon,
            iconCls: e.iconCls,
            glyph: t,
            glyphCls: t ? e.glyphCls: "",
            glyphFontFamily: n,
            text: e.text || "&#160;",
            closeText: e.closeText
        }
    },
    setHref: function(e) {
        this.href = e;
        this.el.dom.href = this.getHref()
    },
    getHref: function() {
        var e = this,
        t = e.href;
        return t ? Ext.urlAppend(t, Ext.Object.toQueryString(Ext.apply({},
        e.params, e.baseParams))) : false
    },
    setParams: function(e) {
        this.params = e;
        this.el.dom.href = this.getHref()
    },
    getSplitCls: function() {
        var e = this;
        return e.split ? e.baseCls + "-" + e.arrowCls + " " + (e.baseCls + "-" + e.arrowCls + "-" + e.arrowAlign) : ""
    },
    getInnerCls: function() {
        return this.textAlign ? this.baseCls + "-inner-" + this.textAlign: ""
    },
    setIcon: function(e) {
        e = e || "";
        var t = this,
        n = t.btnIconEl,
        r = t.icon || "";
        t.icon = e;
        if (e != r) {
            if (n) {
                n.setStyle("background-image", e ? "url(" + e + ")": "");
                t.setComponentCls();
                if (t.didIconStateChange(r, e)) {
                    t.updateLayout()
                }
            }
            t.fireEvent("iconchange", t, r, e)
        }
        return t
    },
    setIconCls: function(e) {
        e = e || "";
        var t = this,
        n = t.btnIconEl,
        r = t.iconCls || "";
        t.iconCls = e;
        if (r != e) {
            if (n) {
                n.removeCls(r);
                n.addCls(e);
                t.setComponentCls();
                if (t.didIconStateChange(r, e)) {
                    t.updateLayout()
                }
            }
            t.fireEvent("iconchange", t, r, e)
        }
        return t
    },
    setGlyph: function(e) {
        e = e || 0;
        var t = this,
        n = t.btnIconEl,
        r = t.glyph,
        i, s;
        t.glyph = e;
        if (n) {
            if (typeof e === "string") {
                s = e.split("@");
                e = s[0];
                i = s[1] || Ext._glyphFontFamily
            }
            if (!e) {
                n.dom.innerHTML = ""
            } else {
                if (r != e) {
                    n.dom.innerHTML = "&#" + e + ";"
                }
            }
            if (i) {
                n.setStyle("font-family", i)
            }
        }
        t.fireEvent("glyphchange", t, t.glyph, r);
        return t
    },
    setTooltip: function(e, t) {
        var n = this;
        if (n.rendered) {
            if (!t || !e) {
                n.clearTip()
            }
            if (e) {
                if (Ext.quickTipsActive && Ext.isObject(e)) {
                    Ext.tip.QuickTipManager.register(Ext.apply({
                        target: n.el.id
                    },
                    e));
                    n.tooltip = e
                } else {
                    n.el.dom.setAttribute(n.getTipAttr(), e)
                }
            }
        } else {
            n.tooltip = e
        }
        return n
    },
    setTextAlign: function(e) {
        var t = this,
        n = t.btnEl;
        if (n) {
            n.removeCls(t.baseCls + "-inner-" + t.textAlign);
            n.addCls(t.baseCls + "-inner-" + e)
        }
        t.textAlign = e;
        return t
    },
    getTipAttr: function() {
        return this.tooltipType == "qtip" ? "data-qtip": "title"
    },
    getRefItems: function(e) {
        var t = this.menu,
        n;
        if (t) {
            n = t.getRefItems(e);
            n.unshift(t)
        }
        return n || []
    },
    clearTip: function() {
        var e = this,
        t = e.el;
        if (Ext.quickTipsActive && Ext.isObject(e.tooltip)) {
            Ext.tip.QuickTipManager.unregister(t)
        } else {
            t.dom.removeAttribute(e.getTipAttr())
        }
    },
    beforeDestroy: function() {
        var e = this;
        if (e.rendered) {
            e.clearTip()
        }
        if (e.menu && e.destroyMenu) {
            e.menu.destroy()
        }
        Ext.destroy(e.btnInnerEl, e.repeater);
        e.callParent()
    },
    onDestroy: function() {
        var e = this;
        if (e.rendered) {
            e.doc.un("mouseover", e.monitorMouseOver, e);
            delete e.doc;
            Ext.destroy(e.keyMap);
            delete e.keyMap
        }
        Ext.button.Manager.unregister(e);
        e.callParent()
    },
    setHandler: function(e, t) {
        this.handler = e;
        this.scope = t;
        return this
    },
    setText: function(e) {
        e = e || "";
        var t = this,
        n = t.text || "";
        if (e != n) {
            t.text = e;
            if (t.rendered) {
                t.btnInnerEl.update(e || "&#160;");
                t.setComponentCls();
                if (Ext.isStrict && Ext.isIE8) {
                    t.el.repaint()
                }
                t.updateLayout()
            }
            t.fireEvent("textchange", t, n, e)
        }
        return t
    },
    didIconStateChange: function(e, t) {
        var n = Ext.isEmpty(t);
        return Ext.isEmpty(e) ? !n: n
    },
    getText: function() {
        return this.text
    },
    toggle: function(e, t) {
        var n = this;
        e = e === undefined ? !n.pressed: !!e;
        if (e !== n.pressed) {
            if (n.rendered) {
                n[e ? "addClsWithUI": "removeClsWithUI"](n.pressedCls)
            }
            n.pressed = e;
            if (!t) {
                n.fireEvent("toggle", n, e);
                Ext.callback(n.toggleHandler, n.scope || n, [n, e])
            }
        }
        return n
    },
    maybeShowMenu: function() {
        var e = this;
        if (e.menu && !e.hasVisibleMenu() && !e.ignoreNextClick) {
            e.showMenu(true)
        }
    },
    showMenu: function(e) {
        var t = this,
        n = t.menu;
        if (t.rendered) {
            if (t.tooltip && Ext.quickTipsActive && t.getTipAttr() != "title") {
                Ext.tip.QuickTipManager.getQuickTip().cancelShow(t.el)
            }
            if (n.isVisible()) {
                n.hide()
            }
            if (!e || t.showEmptyMenu || n.items.getCount() > 0) {
                n.showBy(t.el, t.menuAlign)
            }
        }
        return t
    },
    hideMenu: function() {
        if (this.hasVisibleMenu()) {
            this.menu.hide()
        }
        return this
    },
    hasVisibleMenu: function() {
        var e = this.menu;
        return e && e.rendered && e.isVisible()
    },
    onRepeatClick: function(e, t) {
        this.onClick(t)
    },
    onClick: function(e) {
        var t = this;
        t.doPreventDefault(e);
        if (e.type !== "keydown" && e.button !== 0) {
            return
        }
        if (!t.disabled) {
            t.doToggle();
            t.maybeShowMenu();
            t.fireHandler(e)
        }
    },
    doPreventDefault: function(e) {
        if (this.preventDefault || this.disabled && this.getHref() && e) {
            e.preventDefault()
        }
    },
    fireHandler: function(e) {
        var t = this,
        n = t.handler;
        if (t.fireEvent("click", t, e) !== false) {
            if (n) {
                n.call(t.scope || t, t, e)
            }
            t.blur()
        }
    },
    doToggle: function() {
        var e = this;
        if (e.enableToggle && (e.allowDepress !== false || !e.pressed)) {
            e.toggle()
        }
    },
    onMouseOver: function(e) {
        var t = this;
        if (!t.disabled && !e.within(t.el, true, true)) {
            t.onMouseEnter(e)
        }
    },
    onMouseOut: function(e) {
        var t = this;
        if (!e.within(t.el, true, true)) {
            if (t.overMenuTrigger) {
                t.onMenuTriggerOut(e)
            }
            t.onMouseLeave(e)
        }
    },
    onMouseMove: function(e) {
        var t = this,
        n = t.el,
        r = t.overMenuTrigger,
        i, s;
        if (t.split) {
            i = t.arrowAlign === "right" ? e.getX() - t.getX() : e.getY() - n.getY();
            s = t.getTriggerRegion();
            if (i > s.begin && i < s.end) {
                if (!r) {
                    t.onMenuTriggerOver(e)
                }
            } else {
                if (r) {
                    t.onMenuTriggerOut(e)
                }
            }
        }
    },
    getTriggerRegion: function() {
        var e = this,
        t = e._triggerRegion,
        n = e.getTriggerSize(),
        r = e.arrowAlign === "right" ? e.getWidth() : e.getHeight();
        t.begin = r - n;
        t.end = r;
        return t
    },
    getTriggerSize: function() {
        var e = this,
        t = e.triggerSize,
        n, r;
        if (t == null) {
            n = e.arrowAlign;
            r = n.charAt(0);
            t = e.triggerSize = e.el.getFrameWidth(r) + e.getBtnWrapFrameWidth(r);
            if (e.frameSize) {
                t = e.triggerSize += e.frameSize[n]
            }
        }
        return t
    },
    getBtnWrapFrameWidth: function(e) {
        return this.btnWrap.getFrameWidth(e)
    },
    addOverCls: function() {
        if (!this.disabled) {
            this.addClsWithUI(this.overCls)
        }
    },
    removeOverCls: function() {
        this.removeClsWithUI(this.overCls)
    },
    onMouseEnter: function(e) {
        this.fireEvent("mouseover", this, e)
    },
    onMouseLeave: function(e) {
        this.fireEvent("mouseout", this, e)
    },
    onMenuTriggerOver: function(e) {
        var t = this,
        n = t.arrowTooltip;
        t.overMenuTrigger = true;
        if (t.split && n) {
            t.btnWrap.dom.setAttribute(t.getTipAttr(), n)
        }
        t.fireEvent("menutriggerover", t, t.menu, e)
    },
    onMenuTriggerOut: function(e) {
        var t = this;
        delete t.overMenuTrigger;
        if (t.split && t.arrowTooltip) {
            t.btnWrap.dom.setAttribute(t.getTipAttr(), "")
        }
        t.fireEvent("menutriggerout", t, t.menu, e)
    },
    enable: function(e) {
        var t = this;
        t.callParent(arguments);
        t.removeClsWithUI("disabled");
        if (t.rendered) {
            t.el.dom.setAttribute("tabIndex", t.tabIndex)
        }
        return t
    },
    disable: function(e) {
        var t = this;
        t.callParent(arguments);
        t.addClsWithUI("disabled");
        t.removeClsWithUI(t.overCls);
        if (t.rendered) {
            t.el.dom.removeAttribute("tabIndex")
        }
        if (t.btnInnerEl && Ext.isIE7m) {
            t.btnInnerEl.repaint()
        }
        return t
    },
    setScale: function(e) {
        var t = this,
        n = t.ui.replace("-" + t.scale, "");
        if (!Ext.Array.contains(t.allowedScales, e)) {
            throw "#setScale: scale must be an allowed scale (" + t.allowedScales.join(", ") + ")"
        }
        t.scale = e;
        t.setUI(n)
    },
    setUI: function(e) {
        var t = this;
        if (t.scale && !e.match(t.scale)) {
            e = e + "-" + t.scale
        }
        t.callParent([e])
    },
    onMouseDown: function(e) {
        var t = this;
        if (Ext.isIE) {
            t.getFocusEl().focus()
        }
        if (!t.disabled && e.button === 0) {
            Ext.button.Manager.onButtonMousedown(t, e);
            t.addClsWithUI(t.pressedCls)
        }
    },
    onMouseUp: function(e) {
        var t = this;
        if (!t.isDestroyed && e.button === 0) {
            if (!t.pressed) {
                t.removeClsWithUI(t.pressedCls)
            }
        }
    },
    onMenuShow: function(e) {
        var t = this;
        t.ignoreNextClick = 0;
        t.addClsWithUI(t.menuActiveCls);
        t.fireEvent("menushow", t, t.menu)
    },
    onMenuHide: function(e) {
        var t = this;
        t.removeClsWithUI(t.menuActiveCls);
        t.ignoreNextClick = Ext.defer(t.restoreClick, 250, t);
        t.fireEvent("menuhide", t, t.menu);
        t.focus()
    },
    restoreClick: function() {
        this.ignoreNextClick = 0
    },
    onDownKey: function(e, t) {
        var n = this;
        if (n.menu && !n.disabled) {
            n.showMenu();
            t.stopEvent();
            return false
        }
    }
});
Ext.define("Ext.layout.container.boxOverflow.Menu", {
    extend: Ext.layout.container.boxOverflow.None,
    alternateClassName: "Ext.layout.boxOverflow.Menu",
    noItemsMenuText: '<div class="' + Ext.baseCSSPrefix + 'toolbar-no-items" role="menuitem">(None)</div>',
    constructor: function(e) {
        var t = this;
        t.callParent(arguments);
        t.triggerButtonCls = t.triggerButtonCls || Ext.baseCSSPrefix + "box-menu-after";
        t.menuItems = []
    },
    beginLayout: function(e) {
        this.callParent(arguments);
        this.clearOverflow(e)
    },
    beginLayoutCycle: function(e, t) {
        this.callParent(arguments);
        if (!t) {
            this.clearOverflow(e);
            this.layout.cacheChildItems(e)
        }
    },
    onRemove: function(e) {
        Ext.Array.remove(this.menuItems, e)
    },
    getSuffixConfig: function() {
        var e = this,
        t = e.layout,
        n = t.owner,
        r = n.id;
        e.menu = new Ext.menu.Menu({
            listeners: {
                scope: e,
                beforeshow: e.beforeMenuShow
            }
        });
        e.menuTrigger = new Ext.button.Button({
            id: r + "-menu-trigger",
            cls: Ext.layout.container.Box.prototype.innerCls + " " + e.triggerButtonCls + " " + Ext.baseCSSPrefix + "toolbar-item",
            plain: n.usePlainButtons,
            ownerCt: n,
            ownerLayout: t,
            iconCls: Ext.baseCSSPrefix + e.getOwnerType(n) + "-more-icon",
            ui: n instanceof Ext.toolbar.Toolbar ? "default-toolbar": "default",
            menu: e.menu,
            showEmptyMenu: true,
            getSplitCls: function() {
                return ""
            }
        });
        return e.menuTrigger.getRenderTree()
    },
    getOverflowCls: function() {
        return Ext.baseCSSPrefix + this.layout.direction + "-box-overflow-body"
    },
    handleOverflow: function(e) {
        var t = this,
        n = t.layout,
        r = n.names,
        i = e.state.boxPlan,
        s = [null, null];
        t.showTrigger(e);
        if (t.layout.direction !== "vertical") {
            s[r.heightIndex] = (i.maxSize - t.menuTrigger[r.getHeight]()) / 2;
            t.menuTrigger.setPosition.apply(t.menuTrigger, s)
        }
        return {
            reservedSpace: t.triggerTotalWidth
        }
    },
    captureChildElements: function() {
        var e = this,
        t = e.menuTrigger,
        n = e.layout.names;
        if (t.rendering) {
            t.finishRender();
            e.triggerTotalWidth = t[n.getWidth]() + t.el.getMargin(n.parallelMargins)
        }
    },
    _asLayoutRoot: {
        isRoot: true
    },
    clearOverflow: function(e) {
        var t = this,
        n = t.menuItems,
        r, i = 0,
        s = n.length,
        o = t.layout.owner,
        u = t._asLayoutRoot;
        o.suspendLayouts();
        t.captureChildElements();
        t.hideTrigger();
        o.resumeLayouts();
        for (; i < s; i++) {
            r = n[i];
            r.suspendLayouts();
            r.show();
            r.resumeLayouts(u)
        }
        n.length = 0
    },
    showTrigger: function(e) {
        var t = this,
        n = t.layout,
        r = n.owner,
        i = n.names,
        s = i.x,
        o = i.width,
        u = e.state.boxPlan,
        a = u.targetSize[o],
        f = e.childItems,
        l = f.length,
        c = t.menuTrigger,
        h,
        p,
        d,
        v;
        c.suspendLayouts();
        c.show();
        c.resumeLayouts(t._asLayoutRoot);
        a -= t.triggerTotalWidth;
        r.suspendLayouts();
        t.menuItems.length = 0;
        for (d = 0; d < l; d++) {
            h = f[d];
            v = h.props;
            if (v[s] + v[o] > a) {
                p = h.target;
                t.menuItems.push(p);
                p.hide()
            }
        }
        r.resumeLayouts()
    },
    hideTrigger: function() {
        var e = this.menuTrigger;
        if (e) {
            e.hide()
        }
    },
    beforeMenuShow: function(e) {
        var t = this,
        n = t.menuItems,
        r = 0,
        i = n.length,
        s, o, u = function(e, t) {
            return e.isXType("buttongroup") && !(t instanceof Ext.toolbar.Separator)
        };
        e.suspendLayouts();
        t.clearMenu();
        e.removeAll();
        for (; r < i; r++) {
            s = n[r];
            if (!r && s instanceof Ext.toolbar.Separator) {
                continue
            }
            if (o && (u(s, o) || u(o, s))) {
                e.add("-")
            }
            t.addComponentToMenu(e, s);
            o = s
        }
        if (e.items.length < 1) {
            e.add(t.noItemsMenuText)
        }
        e.resumeLayouts()
    },
    createMenuConfig: function(e, t) {
        var n = Ext.apply({},
        e.initialConfig),
        r = e.toggleGroup;
        Ext.copyTo(n, e, ["iconCls", "icon", "itemId", "disabled", "handler", "scope", "menu", "tabIndex"]);
        Ext.applyIf(n, {
            text: e.overflowText || e.text,
            hideOnClick: t,
            destroyMenu: false,
            listeners: {}
        });
        if (e.isFormField) {
            n.value = e.getValue();
            n.listeners.change = function(t, n, r) {
                e.setValue(n)
            }
        } else {
            if (r || e.enableToggle) {
                Ext.apply(n, {
                    hideOnClick: false,
                    group: r,
                    checked: e.pressed,
                    handler: function(t, n) {
                        e.onClick(n)
                    }
                })
            }
        }
        if (e.isButton && !e.changeListenersAdded) {
            e.on({
                textchange: this.onButtonAttrChange,
                iconchange: this.onButtonAttrChange,
                toggle: this.onButtonToggle
            });
            e.changeListenersAdded = true
        }
        delete n.margin;
        delete n.ownerCt;
        delete n.xtype;
        delete n.id;
        delete n.itemId;
        return n
    },
    onButtonAttrChange: function(e) {
        var t = e.overflowClone;
        t.suspendLayouts();
        t.setText(e.text);
        t.setIcon(e.icon);
        t.setIconCls(e.iconCls);
        t.resumeLayouts(true)
    },
    onButtonToggle: function(e, t) {
        if (e.overflowClone.checked !== t) {
            e.overflowClone.setChecked(t)
        }
    },
    addComponentToMenu: function(e, t) {
        var n = this,
        r, i, s;
        if (t instanceof Ext.toolbar.Fill) {
            return
        } else {
            if (t instanceof Ext.toolbar.Separator) {
                e.add("-")
            } else {
                if (t.isComponent) {
                    if (t.isXType("splitbutton")) {
                        t.overflowClone = e.add(n.createMenuConfig(t, true))
                    } else {
                        if (t.isXType("button")) {
                            t.overflowClone = e.add(n.createMenuConfig(t, !t.menu))
                        } else {
                            if (t.isXType("buttongroup")) {
                                i = t.items.items;
                                s = i.length;
                                for (r = 0; r < s; r++) {
                                    n.addComponentToMenu(e, i[r])
                                }
                            } else {
                                t.overflowClone = e.add(Ext.create(Ext.getClassName(t), n.createMenuConfig(t)))
                            }
                        }
                    }
                }
            }
        }
    },
    clearMenu: function() {
        var e = this.menu,
        t, n, r, i;
        if (e && e.items) {
            t = e.items.items;
            r = t.length;
            for (n = 0; n < r; n++) {
                i = t[n];
                if (i.setMenu) {
                    i.setMenu(null)
                }
            }
        }
    },
    destroy: function() {
        var e = this.menuTrigger;
        if (e && !this.layout.owner.items.contains(e)) {
            delete e.ownerCt
        }
        Ext.destroy(this.menu, e)
    }
});
Ext.define("Ext.layout.container.boxOverflow.Scroller", {
    extend: Ext.layout.container.boxOverflow.None,
    alternateClassName: "Ext.layout.boxOverflow.Scroller",
    mixins: {
        observable: Ext.util.Observable
    },
    animateScroll: false,
    scrollIncrement: 20,
    wheelIncrement: 10,
    scrollRepeatInterval: 60,
    scrollDuration: 400,
    scrollerCls: Ext.baseCSSPrefix + "box-scroller",
    constructor: function(e, t) {
        var n = this;
        n.layout = e;
        Ext.apply(n, t || {});
        n.mixins.observable.constructor.call(n);
        n.addEvents("scroll");
        n.scrollPosition = 0;
        n.scrollSize = 0
    },
    getPrefixConfig: function() {
        var e = this,
        t = e.layout,
        n = t.owner,
        r;
        e.initCSSClasses();
        r = Ext.layout.container.Box.prototype.innerCls + " " + e.beforeCtCls;
        if (n.plain) {
            r += " " + e.scrollerCls + "-plain"
        }
        return {
            role: "presentation",
            cls: r,
            cn: {
                role: "presentation",
                id: n.id + t.names.beforeScrollerSuffix,
                cls: e.scrollerCls + " " + e.beforeScrollerCls,
                style: "display:none"
            }
        }
    },
    getSuffixConfig: function() {
        var e = this,
        t = e.layout,
        n = t.owner,
        r = Ext.layout.container.Box.prototype.innerCls + " " + e.afterCtCls;
        if (n.plain) {
            r += " " + e.scrollerCls + "-plain"
        }
        return {
            role: "presentation",
            cls: r,
            cn: {
                role: "presentation",
                id: n.id + t.names.afterScrollerSuffix,
                cls: e.scrollerCls + " " + e.afterScrollerCls,
                style: "display:none"
            }
        }
    },
    getOverflowCls: function() {
        return Ext.baseCSSPrefix + this.layout.direction + "-box-overflow-body"
    },
    initCSSClasses: function() {
        var e = this,
        t = Ext.baseCSSPrefix,
        n = e.layout,
        r = n.names,
        i = r.beforeX,
        s = r.afterX,
        o = e.getOwnerType(n.owner);
        e.beforeCtCls = e.beforeCtCls || t + "box-scroller-" + i;
        e.afterCtCls = e.afterCtCls || t + "box-scroller-" + s;
        e.beforeScrollerCls = e.beforeScrollerCls || t + o + "-scroll-" + i;
        e.afterScrollerCls = e.afterScrollerCls || t + o + "-scroll-" + s
    },
    beginLayout: function(e) {
        var t = this.layout;
        e.innerCtScrollPos = this.getScrollPosition();
        this.callParent(arguments)
    },
    completeLayout: function(e) {
        var t = this,
        n = e.state.boxPlan,
        r = t.layout.names,
        i;
        if (n && n.tooNarrow) {
            i = e.childItems[e.childItems.length - 1];
            t.scrollSize = i.props[r.x] + i.props[r.width];
            t.updateScrollButtons()
        }
        this.callParent(arguments)
    },
    finishedLayout: function(e) {
        var t = this,
        n = t.layout,
        r = Math.min(t.getMaxScrollPosition(), e.innerCtScrollPos);
        n.innerCt[n.names.setScrollLeft](r)
    },
    handleOverflow: function(e) {
        var t = this,
        n = t.layout.names.getWidth;
        t.showScrollers();
        return {
            reservedSpace: t.beforeCt[n]() + t.afterCt[n]()
        }
    },
    captureChildElements: function() {
        var e = this,
        t = e.layout.owner.el,
        n, r, i, s, o, u;
        if (!e.beforeCt) {
            u = "-hover";
            s = "-pressed";
            i = e.scrollerCls + u;
            o = e.scrollerCls + s;
            n = e.beforeScroller = t.getById(e.layout.owner.id + "-before-scroller");
            r = e.afterScroller = t.getById(e.layout.owner.id + "-after-scroller");
            e.beforeCt = n.up("");
            e.afterCt = r.up("");
            e.createWheelListener();
            n.addClsOnOver(i);
            n.addClsOnOver(e.beforeScrollerCls + u);
            n.addClsOnClick(o);
            n.addClsOnClick(e.beforeScrollerCls + s);
            r.addClsOnOver(i);
            r.addClsOnOver(e.afterScrollerCls + u);
            r.addClsOnClick(o);
            r.addClsOnClick(e.afterScrollerCls + s);
            n.setVisibilityMode(Ext.Element.DISPLAY);
            r.setVisibilityMode(Ext.Element.DISPLAY);
            e.beforeRepeater = new Ext.util.ClickRepeater(n, {
                interval: e.scrollRepeatInterval,
                handler: e.scrollLeft,
                scope: e
            });
            e.afterRepeater = new Ext.util.ClickRepeater(r, {
                interval: e.scrollRepeatInterval,
                handler: e.scrollRight,
                scope: e
            })
        }
    },
    createWheelListener: function() {
        var e = this;
        e.layout.innerCt.on({
            mousewheel: function(t) {
                e.scrollBy(e.getWheelDelta(t) * e.wheelIncrement * -1, false)
            },
            stopEvent: true
        })
    },
    getWheelDelta: function(e) {
        return e.getWheelDelta()
    },
    clearOverflow: function() {
        this.hideScrollers()
    },
    showScrollers: function() {
        var e = this;
        e.captureChildElements();
        e.beforeScroller.show();
        e.afterScroller.show();
        e.layout.owner.addClsWithUI(e.layout.direction === "vertical" ? "vertical-scroller": "scroller")
    },
    hideScrollers: function() {
        var e = this;
        if (e.beforeScroller !== undefined) {
            e.beforeScroller.hide();
            e.afterScroller.hide();
            e.layout.owner.removeClsWithUI(e.layout.direction === "vertical" ? "vertical-scroller": "scroller")
        }
    },
    destroy: function() {
        var e = this;
        Ext.destroy(e.beforeRepeater, e.afterRepeater, e.beforeScroller, e.afterScroller, e.beforeCt, e.afterCt)
    },
    scrollBy: function(e, t) {
        this.scrollTo(this.getScrollPosition() + e, t)
    },
    getScrollAnim: function() {
        return {
            duration: this.scrollDuration,
            callback: this.updateScrollButtons,
            scope: this
        }
    },
    updateScrollButtons: function() {
        var e = this,
        t, n, r, i, s, o = "-disabled";
        if (e.beforeScroller == null || e.afterScroller == null) {
            return
        }
        t = e.atExtremeBefore() ? "addCls": "removeCls";
        n = e.atExtremeAfter() ? "addCls": "removeCls";
        s = e.scrollerCls + o;
        r = [s, e.beforeScrollerCls + o];
        i = [s, e.afterScrollerCls + o];
        e.beforeScroller[t](r);
        e.afterScroller[n](i);
        e.scrolling = false
    },
    scrollLeft: function() {
        this.scrollBy( - this.scrollIncrement, false)
    },
    scrollRight: function() {
        this.scrollBy(this.scrollIncrement, false)
    },
    getScrollPosition: function() {
        var e = this,
        t = e.layout,
        n;
        if (isNaN(e.scrollPosition)) {
            n = t.innerCt[t.names.getScrollLeft]()
        } else {
            n = e.scrollPosition
        }
        return n
    },
    getMaxScrollPosition: function() {
        var e = this,
        t = e.layout,
        n = e.scrollSize - t.innerCt[t.names.getWidth]();
        return n < 0 ? 0 : n
    },
    atExtremeBefore: function() {
        return ! this.getScrollPosition()
    },
    atExtremeAfter: function() {
        return this.getScrollPosition() >= this.getMaxScrollPosition()
    },
    scrollTo: function(e, t) {
        var n = this,
        r = n.layout,
        i = r.names,
        s = n.getScrollPosition(),
        o = Ext.Number.constrain(e, 0, n.getMaxScrollPosition());
        if (o != s && !n.scrolling) {
            n.scrollPosition = NaN;
            if (t === undefined) {
                t = n.animateScroll
            }
            r.innerCt[i.scrollTo](i.beforeScrollX, o, t ? n.getScrollAnim() : false);
            if (t) {
                n.scrolling = true
            } else {
                n.updateScrollButtons()
            }
            n.fireEvent("scroll", n, o, t ? n.getScrollAnim() : false)
        }
    },
    scrollToItem: function(e, t) {
        var n = this,
        r = n.layout,
        i = r.owner,
        s = r.names,
        o, u, a;
        e = n.getItem(e);
        if (e !== undefined) {
            if (e == i.items.first()) {
                a = 0
            } else {
                if (e === i.items.last()) {
                    a = n.getMaxScrollPosition()
                } else {
                    o = n.getItemVisibility(e);
                    if (!o.fullyVisible) {
                        u = e.getBox(false, true);
                        a = u[s.x];
                        if (o.hiddenEnd) {
                            a -= n.layout.innerCt[s.getWidth]() - u[s.width]
                        }
                    }
                }
            }
            if (a !== undefined) {
                n.scrollTo(a, t)
            }
        }
    },
    getItemVisibility: function(e) {
        var t = this,
        n = t.getItem(e).getBox(true, true),
        r = t.layout,
        i = r.names,
        s = n[i.x],
        o = s + n[i.width],
        u = t.getScrollPosition(),
        a = u + r.innerCt[i.getWidth]();
        return {
            hiddenStart: s < u,
            hiddenEnd: o > a,
            fullyVisible: s > u && o < a
        }
    }
});
Ext.define("Ext.util.Offset", {
    statics: {
        fromObject: function(e) {
            return new this(e.x, e.y)
        }
    },
    constructor: function(e, t) {
        this.x = e != null && !isNaN(e) ? e: 0;
        this.y = t != null && !isNaN(t) ? t: 0;
        return this
    },
    copy: function() {
        return new Ext.util.Offset(this.x, this.y)
    },
    copyFrom: function(e) {
        this.x = e.x;
        this.y = e.y
    },
    toString: function() {
        return "Offset[" + this.x + "," + this.y + "]"
    },
    equals: function(e) {
        return this.x == e.x && this.y == e.y
    },
    round: function(e) {
        if (!isNaN(e)) {
            var t = Math.pow(10, e);
            this.x = Math.round(this.x * t) / t;
            this.y = Math.round(this.y * t) / t
        } else {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y)
        }
    },
    isZero: function() {
        return this.x == 0 && this.y == 0
    }
});
Ext.define("Ext.util.Region", {
    statics: {
        getRegion: function(e) {
            return Ext.fly(e).getRegion()
        },
        from: function(e) {
            return new this(e.top, e.right, e.bottom, e.left)
        }
    },
    constructor: function(e, t, n, r) {
        var i = this;
        i.y = i.top = i[1] = e;
        i.right = t;
        i.bottom = n;
        i.x = i.left = i[0] = r
    },
    contains: function(e) {
        var t = this;
        return e.x >= t.x && e.right <= t.right && e.y >= t.y && e.bottom <= t.bottom
    },
    intersect: function(e) {
        var t = this,
        n = Math.max(t.y, e.y),
        r = Math.min(t.right, e.right),
        i = Math.min(t.bottom, e.bottom),
        s = Math.max(t.x, e.x);
        if (i > n && r > s) {
            return new this.self(n, r, i, s)
        } else {
            return false
        }
    },
    union: function(e) {
        var t = this,
        n = Math.min(t.y, e.y),
        r = Math.max(t.right, e.right),
        i = Math.max(t.bottom, e.bottom),
        s = Math.min(t.x, e.x);
        return new this.self(n, r, i, s)
    },
    constrainTo: function(e) {
        var t = this,
        n = Ext.Number.constrain;
        t.top = t.y = n(t.top, e.y, e.bottom);
        t.bottom = n(t.bottom, e.y, e.bottom);
        t.left = t.x = n(t.left, e.x, e.right);
        t.right = n(t.right, e.x, e.right);
        return t
    },
    adjust: function(e, t, n, r) {
        var i = this;
        i.top = i.y += e;
        i.left = i.x += r;
        i.right += t;
        i.bottom += n;
        return i
    },
    getOutOfBoundOffset: function(e, t) {
        if (!Ext.isObject(e)) {
            if (e == "x") {
                return this.getOutOfBoundOffsetX(t)
            } else {
                return this.getOutOfBoundOffsetY(t)
            }
        } else {
            t = e;
            var n = new Ext.util.Offset;
            n.x = this.getOutOfBoundOffsetX(t.x);
            n.y = this.getOutOfBoundOffsetY(t.y);
            return n
        }
    },
    getOutOfBoundOffsetX: function(e) {
        if (e <= this.x) {
            return this.x - e
        } else {
            if (e >= this.right) {
                return this.right - e
            }
        }
        return 0
    },
    getOutOfBoundOffsetY: function(e) {
        if (e <= this.y) {
            return this.y - e
        } else {
            if (e >= this.bottom) {
                return this.bottom - e
            }
        }
        return 0
    },
    isOutOfBound: function(e, t) {
        if (!Ext.isObject(e)) {
            if (e == "x") {
                return this.isOutOfBoundX(t)
            } else {
                return this.isOutOfBoundY(t)
            }
        } else {
            t = e;
            return this.isOutOfBoundX(t.x) || this.isOutOfBoundY(t.y)
        }
    },
    isOutOfBoundX: function(e) {
        return e < this.x || e > this.right
    },
    isOutOfBoundY: function(e) {
        return e < this.y || e > this.bottom
    },
    restrict: function(e, t, n) {
        if (Ext.isObject(e)) {
            var r;
            n = t;
            t = e;
            if (t.copy) {
                r = t.copy()
            } else {
                r = {
                    x: t.x,
                    y: t.y
                }
            }
            r.x = this.restrictX(t.x, n);
            r.y = this.restrictY(t.y, n);
            return r
        } else {
            if (e == "x") {
                return this.restrictX(t, n)
            } else {
                return this.restrictY(t, n)
            }
        }
    },
    restrictX: function(e, t) {
        if (!t) {
            t = 1
        }
        if (e <= this.x) {
            e -= (e - this.x) * t
        } else {
            if (e >= this.right) {
                e -= (e - this.right) * t
            }
        }
        return e
    },
    restrictY: function(e, t) {
        if (!t) {
            t = 1
        }
        if (e <= this.y) {
            e -= (e - this.y) * t
        } else {
            if (e >= this.bottom) {
                e -= (e - this.bottom) * t
            }
        }
        return e
    },
    getSize: function() {
        return {
            width: this.right - this.x,
            height: this.bottom - this.y
        }
    },
    copy: function() {
        return new this.self(this.y, this.right, this.bottom, this.x)
    },
    copyFrom: function(e) {
        var t = this;
        t.top = t.y = t[1] = e.y;
        t.right = e.right;
        t.bottom = e.bottom;
        t.left = t.x = t[0] = e.x;
        return this
    },
    toString: function() {
        return "Region[" + this.top + "," + this.right + "," + this.bottom + "," + this.left + "]"
    },
    translateBy: function(e, t) {
        if (arguments.length == 1) {
            t = e.y;
            e = e.x
        }
        var n = this;
        n.top = n.y += t;
        n.right += e;
        n.bottom += t;
        n.left = n.x += e;
        return n
    },
    round: function() {
        var e = this;
        e.top = e.y = Math.round(e.y);
        e.right = Math.round(e.right);
        e.bottom = Math.round(e.bottom);
        e.left = e.x = Math.round(e.x);
        return e
    },
    equals: function(e) {
        return this.top == e.top && this.right == e.right && this.bottom == e.bottom && this.left == e.left
    }
});
Ext.define("Ext.dd.DragDropManager", {
    singleton: true,
    alternateClassName: ["Ext.dd.DragDropMgr", "Ext.dd.DDM"],
    ids: {},
    handleIds: {},
    dragCurrent: null,
    dragOvers: {},
    deltaX: 0,
    deltaY: 0,
    preventDefault: true,
    stopPropagation: true,
    initialized: false,
    locked: false,
    init: function() {
        this.initialized = true
    },
    POINT: 0,
    INTERSECT: 1,
    mode: 0,
    notifyOccluded: false,
    dragCls: Ext.baseCSSPrefix + "dd-drag-current",
    _execOnAll: function(e, t) {
        var n = this.ids,
        r, i, s, o;
        for (r in n) {
            if (n.hasOwnProperty(r)) {
                o = n[r];
                for (i in o) {
                    if (o.hasOwnProperty(i)) {
                        s = o[i];
                        if (!this.isTypeOfDD(s)) {
                            continue
                        }
                        s[e].apply(s, t)
                    }
                }
            }
        }
    },
    _onLoad: function() {
        this.init();
        var e = Ext.EventManager;
        e.on(document, "mouseup", this.handleMouseUp, this, true);
        e.on(document, "mousemove", this.handleMouseMove, this, true);
        e.on(window, "unload", this._onUnload, this, true);
        e.on(window, "resize", this._onResize, this, true)
    },
    _onResize: function(e) {
        this._execOnAll("resetConstraints", [])
    },
    lock: function() {
        this.locked = true
    },
    unlock: function() {
        this.locked = false
    },
    isLocked: function() {
        return this.locked
    },
    locationCache: {},
    useCache: true,
    clickPixelThresh: 3,
    clickTimeThresh: 350,
    dragThreshMet: false,
    clickTimeout: null,
    startX: 0,
    startY: 0,
    regDragDrop: function(e, t) {
        if (!this.initialized) {
            this.init()
        }
        if (!this.ids[t]) {
            this.ids[t] = {}
        }
        this.ids[t][e.id] = e
    },
    removeDDFromGroup: function(e, t) {
        if (!this.ids[t]) {
            this.ids[t] = {}
        }
        var n = this.ids[t];
        if (n && n[e.id]) {
            delete n[e.id]
        }
    },
    _remove: function(e, t) {
        var n = this,
        r = n.ids,
        i = e.groups,
        s;
        if (n.clearingAll) {
            return
        }
        if (n.dragCurrent === e) {
            n.dragCurrent = null
        }
        for (s in i) {
            if (i.hasOwnProperty(s)) {
                if (t) {
                    delete r[s]
                } else {
                    if (r[s]) {
                        delete r[s][e.id]
                    }
                }
            }
        }
        delete n.handleIds[e.id]
    },
    regHandle: function(e, t) {
        if (!this.handleIds[e]) {
            this.handleIds[e] = {}
        }
        this.handleIds[e][t] = t
    },
    isDragDrop: function(e) {
        return this.getDDById(e) ? true: false
    },
    getRelated: function(e, t) {
        var n = [],
        r,
        i,
        s;
        for (r in e.groups) {
            for (i in this.ids[r]) {
                s = this.ids[r][i];
                if (!this.isTypeOfDD(s)) {
                    continue
                }
                if (!t || s.isTarget) {
                    n[n.length] = s
                }
            }
        }
        return n
    },
    isLegalTarget: function(e, t) {
        var n = this.getRelated(e, true),
        r,
        i;
        for (r = 0, i = n.length; r < i; ++r) {
            if (n[r].id == t.id) {
                return true
            }
        }
        return false
    },
    isTypeOfDD: function(e) {
        return e && e.__ygDragDrop
    },
    isHandle: function(e, t) {
        return this.handleIds[e] && this.handleIds[e][t]
    },
    getDDById: function(e) {
        var t, n;
        for (t in this.ids) {
            n = this.ids[t][e];
            if (n instanceof Ext.dd.DDTarget) {
                return n
            }
        }
        return null
    },
    handleMouseDown: function(e, t) {
        var n = this,
        r;
        if (Ext.quickTipsActive) {
            Ext.tip.QuickTipManager.ddDisable()
        }
        if (n.dragCurrent) {
            n.handleMouseUp(e)
        }
        n.mousedownEvent = e.clone();
        n.currentTarget = e.getTarget();
        n.dragCurrent = t;
        r = t.getEl();
        if (Ext.isIE9m && r.setCapture) {
            r.setCapture()
        }
        n.startX = e.getPageX();
        n.startY = e.getPageY();
        n.deltaX = n.startX - r.offsetLeft;
        n.deltaY = n.startY - r.offsetTop;
        n.dragThreshMet = false;
        n.clickTimeout = setTimeout(function() {
            n.startDrag(n.startX, n.startY)
        },
        n.clickTimeThresh)
    },
    startDrag: function(e, t) {
        var n = this,
        r = n.dragCurrent,
        i;
        clearTimeout(n.clickTimeout);
        if (r) {
            r.b4StartDrag(e, t);
            r.startDrag(e, t);
            i = r.getDragEl();
            if (i) {
                Ext.fly(i).addCls(n.dragCls)
            }
        }
        n.dragThreshMet = true
    },
    handleMouseUp: function(e) {
        var t = this;
        if (Ext.quickTipsActive) {
            Ext.tip.QuickTipManager.ddEnable()
        }
        if (!t.dragCurrent) {
            return
        }
        if (Ext.isIE && document.releaseCapture) {
            document.releaseCapture()
        }
        clearTimeout(t.clickTimeout);
        if (t.dragThreshMet) {
            t.fireEvents(e, true)
        }
        t.stopDrag(e);
        t.stopEvent(e)
    },
    stopEvent: function(e) {
        if (this.stopPropagation) {
            e.stopPropagation()
        }
        if (this.preventDefault) {
            e.preventDefault()
        }
    },
    stopDrag: function(e) {
        var t = this,
        n = t.dragCurrent,
        r;
        if (n) {
            if (t.dragThreshMet) {
                r = n.getDragEl();
                if (r) {
                    Ext.fly(r).removeCls(t.dragCls)
                }
                n.b4EndDrag(e);
                n.endDrag(e)
            }
            t.dragCurrent.onMouseUp(e)
        }
        t.dragCurrent = null;
        t.dragOvers = {}
    },
    handleMouseMove: function(e) {
        var t = this,
        n = t.dragCurrent,
        r, i;
        if (!n) {
            return true
        }
        if (!t.dragThreshMet) {
            r = Math.abs(t.startX - e.getPageX());
            i = Math.abs(t.startY - e.getPageY());
            if (r > t.clickPixelThresh || i > t.clickPixelThresh) {
                t.startDrag(t.startX, t.startY)
            }
        }
        if (t.dragThreshMet) {
            n.b4Drag(e);
            n.onDrag(e);
            if (!n.moveOnly) {
                t.fireEvents(e, false)
            }
        }
        t.stopEvent(e);
        return true
    },
    fireEvents: function(e, t) {
        var n = this,
        r = n.dragCurrent,
        i, s, o = e.getPoint(),
        u,
        a,
        f = [],
        l = [],
        c = [],
        h = [],
        p = [],
        d = [],
        v,
        m,
        g,
        y,
        b;
        if (!r || r.isLocked()) {
            return
        }
        if (!n.notifyOccluded && (!Ext.supports.PointerEvents || Ext.isIE10m || Ext.isOpera) && !(r.deltaX < 0 || r.deltaY < 0)) {
            i = r.getDragEl();
            s = i.style.top;
            i.style.visibility = "hidden";
            v = e.getXY();
            e.target = document.elementFromPoint(v[0], v[1]);
            i.style.visibility = "visible";
            i.style.top = s
        }
        for (g in n.dragOvers) {
            u = n.dragOvers[g];
            delete n.dragOvers[g];
            if (!n.isTypeOfDD(u) || u.isDestroyed) {
                continue
            }
            if (n.notifyOccluded) {
                if (!this.isOverTarget(o, u, n.mode)) {
                    c.push(u)
                }
            } else {
                if (!e.within(u.getEl())) {
                    c.push(u)
                }
            }
            l[g] = true
        }
        for (b in r.groups) {
            if ("string" != typeof b) {
                continue
            }
            for (g in n.ids[b]) {
                u = n.ids[b][g];
                if (n.isTypeOfDD(u) && (a = u.getEl()) && u.isTarget && !u.isLocked() && Ext.fly(a).isVisible(true) && (u != r || r.ignoreSelf === false)) {
                    if (n.notifyOccluded) {
                        if ((u.zIndex = n.getZIndex(a)) !== -1) {
                            m = true
                        }
                        f.push(u)
                    } else {
                        if (e.within(u.getEl())) {
                            f.push(u);
                            break
                        }
                    }
                }
            }
        }
        if (m) {
            Ext.Array.sort(f, n.byZIndex)
        }
        for (g = 0, y = f.length; g < y; g++) {
            u = f[g];
            if (n.isOverTarget(o, u, n.mode)) {
                if (t) {
                    p.push(u)
                } else {
                    if (!l[u.id]) {
                        d.push(u)
                    } else {
                        h.push(u)
                    }
                    n.dragOvers[u.id] = u
                }
                if (!n.notifyOccluded) {
                    break
                }
            }
        }
        if (n.mode) {
            if (c.length) {
                r.b4DragOut(e, c);
                r.onDragOut(e, c)
            }
            if (d.length) {
                r.onDragEnter(e, d)
            }
            if (h.length) {
                r.b4DragOver(e, h);
                r.onDragOver(e, h)
            }
            if (p.length) {
                r.b4DragDrop(e, p);
                r.onDragDrop(e, p)
            }
        } else {
            for (g = 0, y = c.length; g < y; ++g) {
                r.b4DragOut(e, c[g].id);
                r.onDragOut(e, c[g].id)
            }
            for (g = 0, y = d.length; g < y; ++g) {
                r.onDragEnter(e, d[g].id)
            }
            for (g = 0, y = h.length; g < y; ++g) {
                r.b4DragOver(e, h[g].id);
                r.onDragOver(e, h[g].id)
            }
            for (g = 0, y = p.length; g < y; ++g) {
                r.b4DragDrop(e, p[g].id);
                r.onDragDrop(e, p[g].id)
            }
        }
        if (t && !p.length) {
            r.onInvalidDrop(e)
        }
    },
    getZIndex: function(e) {
        var t = document.body,
        n, r = -1;
        e = Ext.getDom(e);
        while (e !== t) {
            if (!isNaN(n = Number(Ext.fly(e).getStyle("zIndex")))) {
                r = n
            }
            e = e.parentNode
        }
        return r
    },
    byZIndex: function(e, t) {
        return e.zIndex < t.zIndex
    },
    getBestMatch: function(e) {
        var t = null,
        n = e.length,
        r, i;
        if (n == 1) {
            t = e[0]
        } else {
            for (r = 0; r < n; ++r) {
                i = e[r];
                if (i.cursorIsOver) {
                    t = i;
                    break
                } else {
                    if (!t || t.overlap.getArea() < i.overlap.getArea()) {
                        t = i
                    }
                }
            }
        }
        return t
    },
    refreshCache: function(e) {
        var t, n, r, i;
        for (t in e) {
            if ("string" != typeof t) {
                continue
            }
            for (n in this.ids[t]) {
                r = this.ids[t][n];
                if (this.isTypeOfDD(r)) {
                    i = this.getLocation(r);
                    if (i) {
                        this.locationCache[r.id] = i
                    } else {
                        delete this.locationCache[r.id]
                    }
                }
            }
        }
    },
    verifyEl: function(e) {
        if (e) {
            var t;
            if (Ext.isIE) {
                try {
                    t = e.offsetParent
                } catch(n) {}
            } else {
                t = e.offsetParent
            }
            if (t) {
                return true
            }
        }
        return false
    },
    getLocation: function(e) {
        if (!this.isTypeOfDD(e)) {
            return null
        }
        if (e.getRegion) {
            return e.getRegion()
        }
        var t = e.getEl(),
        n,
        r,
        i,
        s,
        o,
        u,
        a,
        f,
        l;
        if (!t) {
            return null
        }
        try {
            n = Ext.Element.getXY(t)
        } catch(c) {}
        if (!n) {
            return null
        }
        r = n[0];
        i = r + t.offsetWidth;
        s = n[1];
        o = s + t.offsetHeight;
        u = s - e.padding[0];
        a = i + e.padding[1];
        f = o + e.padding[2];
        l = r - e.padding[3];
        return new Ext.util.Region(u, a, f, l)
    },
    isOverTarget: function(e, t, n) {
        var r = this.locationCache[t.id],
        i,
        s,
        o,
        u,
        a;
        if (!r || !this.useCache) {
            r = this.getLocation(t);
            this.locationCache[t.id] = r
        }
        if (!r) {
            return false
        }
        t.cursorIsOver = r.contains(e);
        i = this.dragCurrent;
        if (!i || !i.getTargetCoord || !n && !i.constrainX && !i.constrainY) {
            return t.cursorIsOver
        }
        t.overlap = null;
        s = i.getTargetCoord(e.x, e.y);
        o = i.getDragEl();
        u = new Ext.util.Region(s.y, s.x + o.offsetWidth, s.y + o.offsetHeight, s.x);
        a = u.intersect(r);
        if (a) {
            t.overlap = a;
            return n ? true: t.cursorIsOver
        } else {
            return false
        }
    },
    _onUnload: function(e, t) {
        Ext.dd.DragDropManager.unregAll()
    },
    unregAll: function() {
        var e = this,
        t = e.elementCache,
        n;
        if (e.dragCurrent) {
            e.stopDrag();
            e.dragCurrent = null
        }
        e.clearingAll = true;
        e._execOnAll("unreg", []);
        delete e.clearingAll;
        for (n in t) {
            delete t[n]
        }
        e.elementCache = {};
        e.ids = {};
        e.handleIds = {}
    },
    elementCache: {},
    getElWrapper: function(e) {
        var t = this.elementCache[e];
        if (!t || !t.el) {
            t = this.elementCache[e] = new this.ElementWrapper(Ext.getDom(e))
        }
        return t
    },
    getElement: function(e) {
        return Ext.getDom(e)
    },
    getCss: function(e) {
        var t = Ext.getDom(e);
        return t ? t.style: null
    },
    ElementWrapper: function(e) {
        this.el = e || null;
        this.id = this.el && e.id;
        this.css = this.el && e.style
    },
    getPosX: function(e) {
        return Ext.Element.getX(e)
    },
    getPosY: function(e) {
        return Ext.Element.getY(e)
    },
    swapNode: function(e, t) {
        if (e.swapNode) {
            e.swapNode(t)
        } else {
            var n = t.parentNode,
            r = t.nextSibling;
            if (r == e) {
                n.insertBefore(e, t)
            } else {
                if (t == e.nextSibling) {
                    n.insertBefore(t, e)
                } else {
                    e.parentNode.replaceChild(t, e);
                    n.insertBefore(e, r)
                }
            }
        }
    },
    getScroll: function() {
        var e = window.document,
        t = e.documentElement,
        n = e.body,
        r = 0,
        i = 0;
        if (Ext.isGecko4) {
            r = window.scrollYOffset;
            i = window.scrollXOffset
        } else {
            if (t && (t.scrollTop || t.scrollLeft)) {
                r = t.scrollTop;
                i = t.scrollLeft
            } else {
                if (n) {
                    r = n.scrollTop;
                    i = n.scrollLeft
                }
            }
        }
        return {
            top: r,
            left: i
        }
    },
    getStyle: function(e, t) {
        return Ext.fly(e).getStyle(t)
    },
    getScrollTop: function() {
        return this.getScroll().top
    },
    getScrollLeft: function() {
        return this.getScroll().left
    },
    moveToEl: function(e, t) {
        var n = Ext.Element.getXY(t);
        Ext.Element.setXY(e, n)
    },
    numericSort: function(e, t) {
        return e - t
    },
    _timeoutCount: 0,
    _addListeners: function() {
        if (document) {
            this._onLoad()
        } else {
            if (this._timeoutCount <= 2e3) {
                setTimeout(this._addListeners, 10);
                if (document && document.body) {
                    this._timeoutCount += 1
                }
            }
        }
    },
    handleWasClicked: function(e, t) {
        if (this.isHandle(t, e.id)) {
            return true
        } else {
            var n = e.parentNode;
            while (n) {
                if (this.isHandle(t, n.id)) {
                    return true
                } else {
                    n = n.parentNode
                }
            }
        }
        return false
    }
},
function() {
    this._addListeners()
});
Ext.define("Ext.layout.container.Box", {
    alias: ["layout.box"],
    extend: Ext.layout.container.Container,
    alternateClassName: "Ext.layout.BoxLayout",
    defaultMargins: {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
    },
    padding: 0,
    pack: "start",
    flex: undefined,
    stretchMaxPartner: undefined,
    alignRoundingMethod: "round",
    type: "box",
    scrollOffset: 0,
    itemCls: Ext.baseCSSPrefix + "box-item",
    targetCls: Ext.baseCSSPrefix + "box-layout-ct",
    targetElCls: Ext.baseCSSPrefix + "box-target",
    innerCls: Ext.baseCSSPrefix + "box-inner",
    availableSpaceOffset: 0,
    reserveOffset: true,
    manageMargins: true,
    createsInnerCt: true,
    childEls: ["innerCt", "targetEl"],
    renderTpl: ["{%var oc,l=values.$comp.layout,oh=l.overflowHandler;", "if (oh.getPrefixConfig!==Ext.emptyFn) {", "if(oc=oh.getPrefixConfig())dh.generateMarkup(oc, out)", "}%}", '<div id="{ownerId}-innerCt" class="{[l.innerCls]} {[oh.getOverflowCls()]}" role="presentation">', '<div id="{ownerId}-targetEl" class="{targetElCls}" role="presentation">', "{%this.renderBody(out, values)%}", "</div>", "</div>", "{%if (oh.getSuffixConfig!==Ext.emptyFn) {", "if(oc=oh.getSuffixConfig())dh.generateMarkup(oc, out)", "}%}", {
        disableFormats: true,
        definitions: "var dh=Ext.DomHelper;"
    }],
    constructor: function(e) {
        var t = this,
        n;
        t.callParent(arguments);
        t.flexSortFn = Ext.Function.bind(t.flexSort, t);
        t.initOverflowHandler();
        n = typeof t.padding;
        if (n == "string" || n == "number") {
            t.padding = Ext.util.Format.parseBox(t.padding);
            t.padding.height = t.padding.top + t.padding.bottom;
            t.padding.width = t.padding.left + t.padding.right
        }
    },
    _percentageRe: /^\s*(\d+(?:\.\d*)?)\s*[%]\s*$/,
    getItemSizePolicy: function(e, t) {
        var n = this,
        r = n.sizePolicy,
        i = n.align,
        s = e.flex,
        o = i,
        u = n.names,
        a = e[u.width],
        f = e[u.height],
        l = n._percentageRe,
        c = l.test(a),
        h = i == "stretch",
        p = i == "stretchmax",
        d = n.constrainAlign;
        if (!t && (h || s || c || d && !p)) {
            t = n.owner.getSizeModel()
        }
        if (h) {
            if (!l.test(f) && t[u.height].shrinkWrap) {
                o = "stretchmax"
            }
        } else {
            if (!p) {
                if (l.test(f)) {
                    o = "stretch"
                } else {
                    if (d && !t[u.height].shrinkWrap) {
                        o = "stretchmax"
                    } else {
                        o = ""
                    }
                }
            }
        }
        if (s || c) {
            if (!t[u.width].shrinkWrap) {
                r = r.flex
            }
        }
        return r[o]
    },
    flexSort: function(e, t) {
        var n = this.names.maxWidth,
        r = this.names.minWidth,
        i = Infinity,
        s = e.target,
        o = t.target,
        u = s.flex,
        a = o.flex,
        f = 0,
        l, c, h, p, d, v;
        h = s[n] || i;
        p = o[n] || i;
        l = s[r] || 0;
        c = o[r] || 0;
        d = isFinite(l) || isFinite(c);
        v = isFinite(h) || isFinite(p);
        if (d || v) {
            if (v) {
                f = h - p
            }
            if (f === 0 && d) {
                f = c - l
            }
            if (f === 0) {
                if (v) {
                    f = a - u
                } else {
                    f = u - a
                }
            }
        }
        return f
    },
    isItemBoxParent: function(e) {
        return true
    },
    isItemShrinkWrap: function(e) {
        return true
    },
    roundFlex: function(e) {
        return Math.ceil(e)
    },
    beginCollapse: function(e) {
        var t = this;
        if (t.direction === "vertical" && e.collapsedVertical()) {
            e.collapseMemento.capture(["flex"]);
            delete e.flex
        } else {
            if (t.direction === "horizontal" && e.collapsedHorizontal()) {
                e.collapseMemento.capture(["flex"]);
                delete e.flex
            }
        }
    },
    beginExpand: function(e) {
        e.collapseMemento.restore(["flex"])
    },
    beginLayout: function(e) {
        var t = this,
        n = t.owner,
        r = n.stretchMaxPartner,
        i = t.innerCt.dom.style,
        s = t.names;
        e.boxNames = s;
        t.overflowHandler.beginLayout(e);
        if (typeof r === "string") {
            r = Ext.getCmp(r) || n.query(r)[0]
        }
        e.stretchMaxPartner = r && e.context.getCmp(r);
        t.callParent(arguments);
        e.innerCtContext = e.getEl("innerCt", t);
        t.scrollParallel = n.scrollFlags[s.x];
        t.scrollPerpendicular = n.scrollFlags[s.y];
        if (t.scrollParallel) {
            t.scrollPos = n.getTargetEl().dom[s.scrollLeft]
        }
        i.width = "";
        i.height = ""
    },
    beginLayoutCycle: function(e, t) {
        var n = this,
        r = n.align,
        i = e.boxNames,
        s = n.pack,
        o = i.heightModel;
        n.overflowHandler.beginLayoutCycle(e, t);
        n.callParent(arguments);
        e.parallelSizeModel = e[i.widthModel];
        e.perpendicularSizeModel = e[o];
        e.boxOptions = {
            align: r = {
                stretch: r == "stretch",
                stretchmax: r == "stretchmax",
                center: r == i.center,
                bottom: r == i.afterY
            },
            pack: s = {
                center: s == "center",
                end: s == "end"
            }
        };
        if (r.stretch && e.perpendicularSizeModel.shrinkWrap) {
            r.stretchmax = true;
            r.stretch = false
        }
        r.nostretch = !(r.stretch || r.stretchmax);
        if (e.parallelSizeModel.shrinkWrap) {
            s.center = s.end = false
        }
        n.cacheFlexes(e);
        n.targetEl.setWidth(2e4)
    },
    cacheFlexes: function(e) {
        var t = this,
        n = e.boxNames,
        r = n.widthModel,
        i = n.heightModel,
        s = e.boxOptions.align.nostretch,
        o = 0,
        u = e.childItems,
        a = u.length,
        f = [],
        l = 0,
        c = n.minWidth,
        h = t._percentageRe,
        p = 0,
        d = 0,
        v,
        m,
        g,
        y;
        while (a--) {
            m = u[a];
            v = m.target;
            if (m[r].calculated) {
                m.flex = g = v.flex;
                if (g) {
                    o += g;
                    f.push(m);
                    l += v[c] || 0
                } else {
                    y = h.exec(v[n.width]);
                    m.percentageParallel = parseFloat(y[1]) / 100; ++p
                }
            }
            if (s && m[i].calculated) {
                y = h.exec(v[n.height]);
                m.percentagePerpendicular = parseFloat(y[1]) / 100; ++d
            }
        }
        e.flexedItems = f;
        e.flexedMinSize = l;
        e.totalFlex = o;
        e.percentageWidths = p;
        e.percentageHeights = d;
        Ext.Array.sort(f, t.flexSortFn)
    },
    calculate: function(e) {
        var t = this,
        n = t.getContainerSize(e),
        r = e.boxNames,
        i = e.state,
        s = i.boxPlan || (i.boxPlan = {}),
        o = e.targetContext;
        s.targetSize = n;
        if (!i.parallelDone) {
            i.parallelDone = t.calculateParallel(e, r, s)
        }
        if (!i.perpendicularDone) {
            i.perpendicularDone = t.calculatePerpendicular(e, r, s)
        }
        if (i.parallelDone && i.perpendicularDone) {
            if (t.owner.dock && (Ext.isIE7m || Ext.isIEQuirks) && !t.owner.width && !t.horizontal) {
                s.isIEVerticalDock = true;
                s.calculatedWidth = s.maxSize + e.getPaddingInfo().width + e.getFrameInfo().width;
                if (o !== e) {
                    s.calculatedWidth += o.getPaddingInfo().width
                }
            }
            t.publishInnerCtSize(e, t.reserveOffset ? t.availableSpaceOffset: 0);
            if (t.done && e.boxOptions.align.stretchmax && !i.stretchMaxDone) {
                t.calculateStretchMax(e, r, s);
                i.stretchMaxDone = true
            }
            t.overflowHandler.calculate(e)
        } else {
            t.done = false
        }
    },
    calculateParallel: function(e, t, n) {
        var r = this,
        i = t.width,
        s = e.childItems,
        o = t.beforeX,
        u = t.afterX,
        a = t.setWidth,
        f = s.length,
        l = e.flexedItems,
        c = l.length,
        h = e.boxOptions.pack,
        p = r.padding,
        d = n.targetSize,
        v = d[i],
        m = 0,
        g = p[o],
        y = g + p[u] + r.scrollOffset + (r.reserveOffset ? r.availableSpaceOffset: 0),
        b = Ext.getScrollbarSize()[t.width],
        w,
        E,
        S,
        x,
        T,
        N,
        C,
        k,
        L,
        A,
        O;
        if (!e.parallelSizeModel.shrinkWrap && !d[t.gotWidth]) {
            return false
        }
        if (b && r.scrollPerpendicular && e.parallelSizeModel.shrinkWrap && !e.boxOptions.align.stretch && !e.perpendicularSizeModel.shrinkWrap) {
            if (!e.state.perpendicularDone) {
                return false
            }
            L = true
        }
        for (w = 0; w < f; ++w) {
            T = s[w];
            E = T.marginInfo || T.getMarginInfo();
            m += E[i];
            if (!T[t.widthModel].calculated) {
                A = T.getProp(i);
                y += A;
                if (isNaN(y)) {
                    return false
                }
            }
        }
        y += m;
        if (e.percentageWidths) {
            O = v - m;
            if (isNaN(O)) {
                return false
            }
            for (w = 0; w < f; ++w) {
                T = s[w];
                if (T.percentageParallel) {
                    A = Math.ceil(O * T.percentageParallel);
                    A = T.setWidth(A);
                    y += A
                }
            }
        }
        if (e.parallelSizeModel.shrinkWrap) {
            n.availableSpace = 0;
            n.tooNarrow = false
        } else {
            n.availableSpace = v - y;
            n.tooNarrow = n.availableSpace < e.flexedMinSize;
            if (n.tooNarrow && Ext.getScrollbarSize()[t.height] && r.scrollParallel && e.state.perpendicularDone) {
                e.state.perpendicularDone = false;
                for (w = 0; w < f; ++w) {
                    s[w].invalidate()
                }
            }
        }
        k = y;
        S = n.availableSpace;
        x = e.totalFlex;
        for (w = 0; w < c; w++) {
            T = l[w];
            N = T.flex;
            C = r.roundFlex(N / x * S);
            C = T[a](C);
            k += C;
            S = Math.max(0, S - C);
            x -= N
        }
        if (h.center) {
            g += S / 2;
            if (g < 0) {
                g = 0
            }
        } else {
            if (h.end) {
                g += S
            }
        }
        for (w = 0; w < f; ++w) {
            T = s[w];
            E = T.marginInfo;
            g += E[o];
            T.setProp(t.x, g);
            g += E[u] + T.props[i]
        }
        k += e.targetContext.getPaddingInfo()[i];
        e.state.contentWidth = k;
        if (L && e.peek(t.contentHeight) > n.targetSize[t.height]) {
            k += b;
            e[t.hasOverflowY] = true;
            e.target.componentLayout[t.setWidthInDom] = true;
            e[t.invalidateScrollY] = Ext.isStrict && Ext.isIE8
        }
        e[t.setContentWidth](k);
        return true
    },
    calculatePerpendicular: function(e, t, n) {
        var r = this,
        i = e.perpendicularSizeModel.shrinkWrap,
        s = n.targetSize,
        o = e.childItems,
        u = o.length,
        a = Math.max,
        f = t.height,
        l = t.setHeight,
        c = t.beforeY,
        h = t.y,
        p = r.padding,
        d = p[c],
        v = s[f] - d - p[t.afterY],
        m = e.boxOptions.align,
        g = m.stretch,
        y = m.stretchmax,
        b = m.center,
        w = m.bottom,
        E = r.constrainAlign,
        S = 0,
        x = 0,
        T = r.onBeforeConstrainInvalidateChild,
        N = r.onAfterConstrainInvalidateChild,
        C = Ext.getScrollbarSize().height,
        k,
        L,
        A,
        O,
        M,
        _,
        D,
        P,
        H,
        B,
        j;
        if (g || (b || w) && !i) {
            if (isNaN(v)) {
                return false
            }
        }
        if (!g && !e.parallelSizeModel.shrinkWrap && !e.state.parallelDone && r.scrollParallel) {
            return false
        }
        if (r.scrollParallel && n.tooNarrow) {
            if (i) {
                B = true
            } else {
                v -= C;
                n.targetSize[f] -= C
            }
        }
        if (g) {
            _ = v
        } else {
            for (L = 0; L < u; L++) {
                D = o[L];
                O = (D.marginInfo || D.getMarginInfo())[f];
                if (! (j = D.percentagePerpendicular)) {
                    A = D.getProp(f)
                } else {++x;
                    if (i) {
                        continue
                    } else {
                        A = j * v - O;
                        A = D[t.setHeight](A)
                    }
                }
                if (!i && E && D[t.heightModel].shrinkWrap && A > v) {
                    D.invalidate({
                        before: T,
                        after: N,
                        layout: r,
                        childHeight: v,
                        names: t
                    });
                    e.state.parallelDone = false
                }
                if (isNaN(S = a(S, A + O, D.target[t.minHeight] || 0))) {
                    return false
                }
            }
            if (B) {
                S += C;
                e[t.hasOverflowX] = true;
                e.target.componentLayout[t.setHeightInDom] = true;
                e[t.invalidateScrollX] = Ext.isStrict && Ext.isIE8
            }
            P = e.stretchMaxPartner;
            if (P) {
                e.setProp("maxChildHeight", S);
                H = P.childItems;
                if (H && H.length) {
                    S = a(S, P.getProp("maxChildHeight"));
                    if (isNaN(S)) {
                        return false
                    }
                }
            }
            e[t.setContentHeight](S + r.padding[f] + e.targetContext.getPaddingInfo()[f]);
            if (B) {
                S -= C
            }
            n.maxSize = S;
            if (y) {
                _ = S
            } else {
                if (b || w || x) {
                    if (E) {
                        _ = i ? S: v
                    } else {
                        _ = i ? S: a(v, S)
                    }
                    _ -= e.innerCtContext.getBorderInfo()[f]
                }
            }
        }
        for (L = 0; L < u; L++) {
            D = o[L];
            O = D.marginInfo || D.getMarginInfo();
            k = d + O[c];
            if (g) {
                D[l](_ - O[f])
            } else {
                j = D.percentagePerpendicular;
                if (i && j) {
                    O = D.marginInfo || D.getMarginInfo();
                    A = j * _ - O[f];
                    A = D.setHeight(A)
                }
                if (b) {
                    M = _ - D.props[f];
                    if (M > 0) {
                        k = d + Math[r.alignRoundingMethod](M / 2)
                    }
                } else {
                    if (w) {
                        k = a(0, _ - k - D.props[f])
                    }
                }
            }
            D.setProp(h, k)
        }
        return true
    },
    onBeforeConstrainInvalidateChild: function(e, t) {
        var n = t.names.heightModel;
        if (!e[n].constrainedMin) {
            e[n] = Ext.layout.SizeModel.calculated
        }
    },
    onAfterConstrainInvalidateChild: function(e, t) {
        var n = t.names;
        e.setProp(n.beforeY, 0);
        if (e[n.heightModel].calculated) {
            e[n.setHeight](t.childHeight)
        }
    },
    calculateStretchMax: function(e, t, n) {
        var r = this,
        i = t.height,
        s = t.width,
        o = e.childItems,
        u = o.length,
        a = n.maxSize,
        f = r.onBeforeStretchMaxInvalidateChild,
        l = r.onAfterStretchMaxInvalidateChild,
        c, h, p, d;
        for (p = 0; p < u; ++p) {
            c = o[p];
            h = c.props;
            d = a - c.getMarginInfo()[i];
            if (d != h[i] || c[t.heightModel].constrained) {
                c.invalidate({
                    before: f,
                    after: l,
                    layout: r,
                    childWidth: h[s],
                    childHeight: d,
                    childX: h.x,
                    childY: h.y,
                    names: t
                })
            }
        }
    },
    onBeforeStretchMaxInvalidateChild: function(e, t) {
        var n = t.names.heightModel;
        if (!e[n].constrainedMax) {
            e[n] = Ext.layout.SizeModel.calculated
        }
    },
    onAfterStretchMaxInvalidateChild: function(e, t) {
        var n = t.names,
        r = t.childHeight,
        i = t.childWidth;
        e.setProp("x", t.childX);
        e.setProp("y", t.childY);
        if (e[n.heightModel].calculated) {
            e[n.setHeight](r)
        }
        if (e[n.widthModel].calculated) {
            e[n.setWidth](i)
        }
    },
    completeLayout: function(e) {
        var t = this,
        n = e.boxNames,
        r = e.invalidateScrollX,
        i = e.invalidateScrollY,
        s, o, u, a, f;
        t.overflowHandler.completeLayout(e);
        if (r || i) {
            o = t.getTarget();
            s = o.dom;
            f = s.style;
            if (r) {
                u = o.getStyle("overflowX");
                if (u == "auto") {
                    u = f.overflowX;
                    f.overflowX = "scroll"
                } else {
                    r = false
                }
            }
            if (i) {
                a = o.getStyle("overflowY");
                if (a == "auto") {
                    a = f.overflowY;
                    f.overflowY = "scroll"
                } else {
                    i = false
                }
            }
            if (r || i) {
                s.scrollWidth;
                if (r) {
                    f.overflowX = u
                }
                if (i) {
                    f.overflowY = a
                }
            }
        }
        if (t.scrollParallel) {
            t.owner.getTargetEl().dom[n.scrollLeft] = t.scrollPos
        }
    },
    finishedLayout: function(e) {
        this.overflowHandler.finishedLayout(e);
        this.callParent(arguments);
        this.targetEl.setWidth(e.innerCtContext.props.width)
    },
    publishInnerCtSize: function(e, t) {
        var n = this,
        r = e.boxNames,
        i = r.height,
        s = r.width,
        o = e.boxOptions.align,
        u = n.owner.dock,
        a = n.padding,
        f = e.state.boxPlan,
        l = f.targetSize,
        c = l[i],
        h = e.innerCtContext,
        p = (e.parallelSizeModel.shrinkWrap || f.tooNarrow && n.scrollParallel ? e.state.contentWidth - e.targetContext.getPaddingInfo()[s] : l[s]) - (t || 0),
        d;
        if (o.stretch) {
            d = c
        } else {
            d = f.maxSize + a[r.beforeY] + a[r.afterY] + h.getBorderInfo()[i];
            if (!e.perpendicularSizeModel.shrinkWrap && (o.center || o.bottom)) {
                d = Math.max(c, d)
            }
        }
        h[r.setWidth](p);
        h[r.setHeight](d);
        if (isNaN(p + d)) {
            n.done = false
        }
        if (f.calculatedWidth && (u == "left" || u == "right")) {
            e.setWidth(f.calculatedWidth, true, true)
        }
    },
    onRemove: function(e, t) {
        var n = this,
        r = n.names,
        i;
        n.callParent(arguments);
        if (n.overflowHandler) {
            n.overflowHandler.onRemove(e)
        }
        if (e.layoutMarginCap == n.id) {
            delete e.layoutMarginCap
        }
        if (!n.owner.destroying && !t && e.rendered) {
            i = e.getEl();
            i.setStyle(r.beforeY, "");
            i.setStyle(r.beforeX, "");
            i.setStyle("margin", "")
        }
    },
    initOverflowHandler: function() {
        var e = this,
        t = e.overflowHandler,
        n, r;
        if (typeof t == "string") {
            t = {
                type: t
            }
        }
        n = "None";
        if (t && t.type !== undefined) {
            n = t.type
        }
        r = Ext.layout.container.boxOverflow[n];
        if (r[e.type]) {
            r = r[e.type]
        }
        e.overflowHandler = Ext.create("Ext.layout.container.boxOverflow." + n, e, t)
    },
    getRenderTarget: function() {
        return this.targetEl
    },
    getElementTarget: function() {
        return this.innerCt
    },
    destroy: function() {
        var e = this;
        Ext.destroy(e.innerCt, e.overflowHandler);
        e.flexSortFn = e.innerCt = null;
        e.callParent(arguments)
    },
    getRenderData: function() {
        var e = this.callParent();
        e.targetElCls = this.targetElCls;
        return e
    }
});
Ext.define("Ext.layout.container.HBox", {
    alias: ["layout.hbox"],
    extend: Ext.layout.container.Box,
    alternateClassName: "Ext.layout.HBoxLayout",
    align: "top",
    constrainAlign: false,
    type: "hbox",
    direction: "horizontal",
    horizontal: true,
    names: {
        beforeX: "left",
        beforeScrollX: "left",
        beforeScrollerSuffix: "-before-scroller",
        afterScrollerSuffix: "-after-scroller",
        leftCap: "Left",
        afterX: "right",
        width: "width",
        contentWidth: "contentWidth",
        minWidth: "minWidth",
        maxWidth: "maxWidth",
        widthCap: "Width",
        widthModel: "widthModel",
        widthIndex: 0,
        x: "x",
        scrollLeft: "scrollLeft",
        overflowX: "overflowX",
        hasOverflowX: "hasOverflowX",
        invalidateScrollX: "invalidateScrollX",
        parallelMargins: "lr",
        center: "middle",
        beforeY: "top",
        afterY: "bottom",
        height: "height",
        contentHeight: "contentHeight",
        minHeight: "minHeight",
        maxHeight: "maxHeight",
        heightCap: "Height",
        heightModel: "heightModel",
        heightIndex: 1,
        y: "y",
        overflowY: "overflowY",
        hasOverflowY: "hasOverflowY",
        invalidateScrollY: "invalidateScrollY",
        perpendicularMargins: "tb",
        getWidth: "getWidth",
        getHeight: "getHeight",
        setWidth: "setWidth",
        setHeight: "setHeight",
        gotWidth: "gotWidth",
        gotHeight: "gotHeight",
        setContentWidth: "setContentWidth",
        setContentHeight: "setContentHeight",
        setWidthInDom: "setWidthInDom",
        setHeightInDom: "setHeightInDom",
        getScrollLeft: "getScrollLeft",
        setScrollLeft: "setScrollLeft",
        scrollTo: "scrollTo"
    },
    sizePolicy: {
        flex: {
            "": {
                readsWidth: 0,
                readsHeight: 1,
                setsWidth: 1,
                setsHeight: 0
            },
            stretch: {
                readsWidth: 0,
                readsHeight: 0,
                setsWidth: 1,
                setsHeight: 1
            },
            stretchmax: {
                readsWidth: 0,
                readsHeight: 1,
                setsWidth: 1,
                setsHeight: 1
            }
        },
        "": {
            readsWidth: 1,
            readsHeight: 1,
            setsWidth: 0,
            setsHeight: 0
        },
        stretch: {
            readsWidth: 1,
            readsHeight: 0,
            setsWidth: 0,
            setsHeight: 1
        },
        stretchmax: {
            readsWidth: 1,
            readsHeight: 1,
            setsWidth: 0,
            setsHeight: 1
        }
    }
});
Ext.define("Ext.layout.container.VBox", {
    alias: ["layout.vbox"],
    extend: Ext.layout.container.Box,
    alternateClassName: "Ext.layout.VBoxLayout",
    align: "left",
    constrainAlign: false,
    type: "vbox",
    direction: "vertical",
    horizontal: false,
    names: {
        beforeX: "top",
        beforeScrollX: "top",
        beforeScrollerSuffix: "-before-scroller",
        afterScrollerSuffix: "-after-scroller",
        leftCap: "Top",
        afterX: "bottom",
        width: "height",
        contentWidth: "contentHeight",
        minWidth: "minHeight",
        maxWidth: "maxHeight",
        widthCap: "Height",
        widthModel: "heightModel",
        widthIndex: 1,
        x: "y",
        scrollLeft: "scrollTop",
        overflowX: "overflowY",
        hasOverflowX: "hasOverflowY",
        invalidateScrollX: "invalidateScrollY",
        parallelMargins: "tb",
        center: "center",
        beforeY: "left",
        afterY: "right",
        height: "width",
        contentHeight: "contentWidth",
        minHeight: "minWidth",
        maxHeight: "maxWidth",
        heightCap: "Width",
        heightModel: "widthModel",
        heightIndex: 0,
        y: "x",
        overflowY: "overflowX",
        hasOverflowY: "hasOverflowX",
        invalidateScrollY: "invalidateScrollX",
        perpendicularMargins: "lr",
        getWidth: "getHeight",
        getHeight: "getWidth",
        setWidth: "setHeight",
        setHeight: "setWidth",
        gotWidth: "gotHeight",
        gotHeight: "gotWidth",
        setContentWidth: "setContentHeight",
        setContentHeight: "setContentWidth",
        setWidthInDom: "setHeightInDom",
        setHeightInDom: "setWidthInDom",
        getScrollLeft: "getScrollTop",
        setScrollLeft: "setScrollTop",
        scrollTo: "scrollTo"
    },
    sizePolicy: {
        flex: {
            "": {
                readsWidth: 1,
                readsHeight: 0,
                setsWidth: 0,
                setsHeight: 1
            },
            stretch: {
                readsWidth: 0,
                readsHeight: 0,
                setsWidth: 1,
                setsHeight: 1
            },
            stretchmax: {
                readsWidth: 1,
                readsHeight: 0,
                setsWidth: 1,
                setsHeight: 1
            }
        },
        "": {
            readsWidth: 1,
            readsHeight: 1,
            setsWidth: 0,
            setsHeight: 0
        },
        stretch: {
            readsWidth: 0,
            readsHeight: 1,
            setsWidth: 1,
            setsHeight: 0
        },
        stretchmax: {
            readsWidth: 1,
            readsHeight: 1,
            setsWidth: 1,
            setsHeight: 0
        }
    }
});
Ext.define("Ext.toolbar.Toolbar", {
    extend: Ext.container.Container,
    alias: "widget.toolbar",
    alternateClassName: "Ext.Toolbar",
    isToolbar: true,
    baseCls: Ext.baseCSSPrefix + "toolbar",
    ariaRole: "toolbar",
    defaultType: "button",
    vertical: false,
    enableOverflow: false,
    menuTriggerCls: Ext.baseCSSPrefix + "toolbar-more-icon",
    trackMenus: true,
    itemCls: Ext.baseCSSPrefix + "toolbar-item",
    statics: {
        shortcuts: {
            "-": "tbseparator",
            " ": "tbspacer"
        },
        shortcutsHV: {
            0 : {
                "->": {
                    xtype: "tbfill",
                    height: 0
                }
            },
            1 : {
                "->": {
                    xtype: "tbfill",
                    width: 0
                }
            }
        }
    },
    initComponent: function() {
        var e = this;
        if (!e.layout && e.enableOverflow) {
            e.layout = {
                overflowHandler: "Menu"
            }
        }
        if (e.dock === "right" || e.dock === "left") {
            e.vertical = true
        }
        e.layout = Ext.applyIf(Ext.isString(e.layout) ? {
            type: e.layout
        }: e.layout || {},
        {
            type: e.vertical ? "vbox": "hbox",
            align: e.vertical ? "stretchmax": "middle"
        });
        if (e.vertical) {
            e.addClsWithUI("vertical")
        }
        if (e.ui === "footer") {
            e.ignoreBorderManagement = true
        }
        e.callParent();
        e.addEvents("overflowchange")
    },
    getRefItems: function(e) {
        var t = this,
        n = t.callParent(arguments),
        r = t.layout,
        i;
        if (e && t.enableOverflow) {
            i = r.overflowHandler;
            if (i && i.menu) {
                n = n.concat(i.menu.getRefItems(e))
            }
        }
        return n
    },
    lookupComponent: function(e) {
        var t = arguments;
        if (typeof e == "string") {
            var n = Ext.toolbar.Toolbar,
            r = n.shortcutsHV[this.vertical ? 1 : 0][e] || n.shortcuts[e];
            if (typeof r == "string") {
                e = {
                    xtype: r
                }
            } else {
                if (r) {
                    e = Ext.apply({},
                    r)
                } else {
                    e = {
                        xtype: "tbtext",
                        text: e
                    }
                }
            }
            this.applyDefaults(e);
            t = [e]
        }
        return this.callParent(t)
    },
    applyDefaults: function(e) {
        if (!Ext.isString(e)) {
            e = this.callParent(arguments)
        }
        return e
    },
    trackMenu: function(e, t) {
        if (this.trackMenus && e.menu) {
            var n = t ? "mun": "mon",
            r = this;
            r[n](e, "mouseover", r.onButtonOver, r);
            r[n](e, "menushow", r.onButtonMenuShow, r);
            r[n](e, "menuhide", r.onButtonMenuHide, r)
        }
    },
    onBeforeAdd: function(e) {
        var t = this,
        n = e.isButton;
        if (n && t.defaultButtonUI && e.ui === "default" && !e.hasOwnProperty("ui")) {
            e.ui = t.defaultButtonUI
        } else {
            if ((n || e.isFormField) && t.ui !== "footer") {
                e.ui = e.ui + "-toolbar";
                e.addCls(e.baseCls + "-toolbar")
            }
        }
        if (e instanceof Ext.toolbar.Separator) {
            e.setUI(t.vertical ? "vertical": "horizontal")
        }
        t.callParent(arguments)
    },
    onAdd: function(e) {
        this.callParent(arguments);
        this.trackMenu(e)
    },
    onRemove: function(e) {
        this.callParent(arguments);
        this.trackMenu(e, true)
    },
    getChildItemsToDisable: function() {
        return this.items.getRange()
    },
    onButtonOver: function(e) {
        if (this.activeMenuBtn && this.activeMenuBtn != e) {
            this.activeMenuBtn.hideMenu();
            e.showMenu();
            this.activeMenuBtn = e
        }
    },
    onButtonMenuShow: function(e) {
        this.activeMenuBtn = e
    },
    onButtonMenuHide: function(e) {
        delete this.activeMenuBtn
    }
});
Ext.define("Ext.panel.AbstractPanel", {
    extend: Ext.container.Container,
    mixins: {
        docking: Ext.container.DockingContainer
    },
    baseCls: Ext.baseCSSPrefix + "panel",
    isPanel: true,
    contentPaddingProperty: "bodyPadding",
    shrinkWrapDock: false,
    componentLayout: "dock",
    childEls: ["body"],
    renderTpl: ["{% this.renderDockedItems(out,values,0); %}", Ext.isIE7m || Ext.isIEQuirks ? '<div style="position:relative;font-size:0;line-height:0;" role="presentation">&nbsp;</div>': "", '<div id="{id}-body" class="{baseCls}-body<tpl if="bodyCls"> {bodyCls}</tpl>', ' {baseCls}-body-{ui}<tpl if="uiCls">', '<tpl for="uiCls"> {parent.baseCls}-body-{parent.ui}-{.}</tpl>', '</tpl>{childElCls}"', '<tpl if="bodyRole"> role="{bodyRole}"<tpl else> role="presentation"</tpl>', '<tpl if="bodyStyle"> style="{bodyStyle}"</tpl>>', "{%this.renderContainer(out,values);%}", "</div>", "{% this.renderDockedItems(out,values,1); %}"],
    bodyPosProps: {
        x: "x",
        y: "y"
    },
    border: true,
    emptyArray: [],
    initComponent: function() {
        this.initBorderProps();
        this.callParent()
    },
    initBorderProps: function() {
        var e = this;
        if (e.frame && e.border && e.bodyBorder === undefined) {
            e.bodyBorder = false
        }
        if (e.frame && e.border && (e.bodyBorder === false || e.bodyBorder === 0)) {
            e.manageBodyBorders = true
        }
    },
    beforeDestroy: function() {
        this.destroyDockedItems();
        this.callParent()
    },
    initItems: function() {
        this.callParent();
        this.initDockingItems()
    },
    initRenderData: function() {
        var e = this,
        t = e.callParent();
        e.initBodyStyles();
        e.protoBody.writeTo(t);
        delete e.protoBody;
        return t
    },
    getComponent: function(e) {
        var t = this.callParent(arguments);
        if (t === undefined && !Ext.isNumber(e)) {
            t = this.getDockedComponent(e)
        }
        return t
    },
    getProtoBody: function() {
        var e = this,
        t = e.protoBody;
        if (!t) {
            e.protoBody = t = new Ext.util.ProtoElement({
                cls: e.bodyCls,
                style: e.bodyStyle,
                clsProp: "bodyCls",
                styleProp: "bodyStyle",
                styleIsText: true
            })
        }
        return t
    },
    initBodyStyles: function() {
        var e = this,
        t = e.getProtoBody();
        if (e.bodyPadding !== undefined) {
            if (e.layout.managePadding) {
                t.setStyle("padding", 0)
            } else {
                t.setStyle("padding", this.unitizeBox(e.bodyPadding === true ? 5 : e.bodyPadding))
            }
        }
        e.initBodyBorder()
    },
    initBodyBorder: function() {
        var e = this;
        if (e.frame && e.bodyBorder) {
            if (!Ext.isNumber(e.bodyBorder)) {
                e.bodyBorder = 1
            }
            e.getProtoBody().setStyle("border-width", this.unitizeBox(e.bodyBorder))
        }
    },
    getCollapsedDockedItems: function() {
        var e = this;
        return e.header === false || e.collapseMode == "placeholder" ? e.emptyArray: [e.getReExpander()]
    },
    setBodyStyle: function(e, t) {
        var n = this,
        r = n.rendered ? n.body: n.getProtoBody();
        if (Ext.isFunction(e)) {
            e = e()
        }
        if (arguments.length == 1) {
            if (Ext.isString(e)) {
                e = Ext.Element.parseStyles(e)
            }
            r.setStyle(e)
        } else {
            r.setStyle(e, t)
        }
        return n
    },
    addBodyCls: function(e) {
        var t = this,
        n = t.rendered ? t.body: t.getProtoBody();
        n.addCls(e);
        return t
    },
    removeBodyCls: function(e) {
        var t = this,
        n = t.rendered ? t.body: t.getProtoBody();
        n.removeCls(e);
        return t
    },
    addUIClsToElement: function(e) {
        var t = this,
        n = t.callParent(arguments);
        t.addBodyCls([Ext.baseCSSPrefix + e, t.baseCls + "-body-" + e, t.baseCls + "-body-" + t.ui + "-" + e]);
        return n
    },
    removeUIClsFromElement: function(e) {
        var t = this,
        n = t.callParent(arguments);
        t.removeBodyCls([Ext.baseCSSPrefix + e, t.baseCls + "-body-" + e, t.baseCls + "-body-" + t.ui + "-" + e]);
        return n
    },
    addUIToElement: function() {
        var e = this;
        e.callParent(arguments);
        e.addBodyCls(e.baseCls + "-body-" + e.ui)
    },
    removeUIFromElement: function() {
        var e = this;
        e.callParent(arguments);
        e.removeBodyCls(e.baseCls + "-body-" + e.ui)
    },
    getTargetEl: function() {
        return this.body
    },
    applyTargetCls: function(e) {
        this.getProtoBody().addCls(e)
    },
    getRefItems: function(e) {
        var t = this.callParent(arguments);
        return this.getDockingRefItems(e, t)
    },
    setupRenderTpl: function(e) {
        this.callParent(arguments);
        this.setupDockingRenderTpl(e)
    }
});
Ext.define("Ext.panel.Header", {
    extend: Ext.container.Container,
    alias: "widget.header",
    isHeader: true,
    defaultType: "tool",
    indicateDrag: false,
    weight: -1,
    componentLayout: "body",
    childEls: ["body"],
    renderTpl: ['<div id="{id}-body" class="{headerCls}-body {baseCls}-body {bodyCls} {bodyTargetCls}', '<tpl for="uiCls"> {parent.baseCls}-body-{parent.ui}-{.}</tpl>"', '<tpl if="bodyStyle"> style="{bodyStyle}"</tpl> role="presentation">', "{%this.renderContainer(out,values)%}", "</div>"],
    headingTpl: ['<span id="{id}-textEl" class="{headerCls}-text {cls}-text {cls}-text-{ui}" unselectable="on"', '<tpl if="headerRole">', ' role="{headerRole}"', "</tpl>", ">{title}</span>"],
    shrinkWrap: 3,
    titlePosition: 0,
    headerCls: Ext.baseCSSPrefix + "header",
    initComponent: function() {
        var e = this,
        t = e.hasOwnProperty("titlePosition"),
        n = e.items,
        r = t ? e.titlePosition: n ? n.length: 0,
        i = [e.orientation, e.getDockName()],
        s = e.ownerCt;
        e.addEvents("click", "dblclick");
        e.indicateDragCls = e.headerCls + "-draggable";
        e.title = e.title || "&#160;";
        e.tools = e.tools || [];
        n = e.items = n ? Ext.Array.slice(n) : [];
        e.orientation = e.orientation || "horizontal";
        e.dock = e.dock ? e.dock: e.orientation == "horizontal" ? "top": "left";
        if (s ? s.border === false && !s.frame: e.border === false) {
            i.push(e.orientation + "-noborder")
        }
        e.addClsWithUI(i);
        e.addCls([e.headerCls, e.headerCls + "-" + e.orientation]);
        if (e.indicateDrag) {
            e.addCls(e.indicateDragCls)
        }
        if (e.iconCls || e.icon || e.glyph) {
            e.initIconCmp();
            if (!t && !n.length) {++r
            }
            n.push(e.iconCmp)
        }
        e.titleCmp = new Ext.Component({
            ariaRole: "presentation",
            focusable: false,
            noWrap: true,
            flex: 1,
            rtl: e.rtl,
            id: e.id + "_hd",
            style: e.titleAlign ? "text-align:" + e.titleAlign: "",
            cls: e.headerCls + "-text-container " + e.baseCls + "-text-container " + e.baseCls + "-text-container-" + e.ui,
            renderTpl: e.getTpl("headingTpl"),
            renderData: {
                title: e.title,
                cls: e.baseCls,
                headerCls: e.headerCls,
                headerRole: e.headerRole,
                ui: e.ui
            },
            childEls: ["textEl"],
            autoEl: {
                unselectable: "on"
            },
            listeners: {
                render: e.onTitleRender,
                scope: e
            }
        });
        e.layout = e.orientation == "vertical" ? {
            type: "vbox",
            align: "center",
            alignRoundingMethod: "ceil"
        }: {
            type: "hbox",
            align: "middle",
            alignRoundingMethod: "floor"
        };
        Ext.Array.push(n, e.tools);
        e.tools.length = 0;
        e.callParent();
        if (n.length < r) {
            r = n.length
        }
        e.titlePosition = r;
        e.insert(r, e.titleCmp);
        e.on({
            dblclick: e.onDblClick,
            click: e.onClick,
            element: "el",
            scope: e
        })
    },
    setTitlePosition: function(e) {
        var t = this;
        t.titlePosition = e = Math.min(e, t.items.length - 1);
        t.insert(e, t.titleCmp)
    },
    initIconCmp: function() {
        var e = this,
        t = [e.headerCls + "-icon", e.baseCls + "-icon", e.iconCls],
        n;
        if (e.glyph) {
            t.push(e.baseCls + "-glyph")
        }
        n = {
            focusable: false,
            src: Ext.BLANK_IMAGE_URL,
            cls: t,
            baseCls: e.baseCls + "-icon",
            id: e.id + "-iconEl",
            iconCls: e.iconCls,
            glyph: e.glyph
        };
        if (!Ext.isEmpty(e.icon)) {
            delete n.iconCls;
            n.src = e.icon
        }
        e.iconCmp = new Ext.Img(n)
    },
    beforeRender: function() {
        this.protoEl.unselectable();
        this.callParent()
    },
    afterLayout: function() {
        var e = this,
        t, n, r, i;
        if (e.orientation === "vertical") {
            e.adjustTitlePosition();
            n = e.frameTR;
            if (n) {
                t = e.frameBR;
                r = e.frameTL;
                i = e.getWidth() - n.getPadding("r") - (r ? r.getPadding("l") : e.el.getBorderWidth("l")) + "px";
                t.setStyle("background-position-x", i);
                n.setStyle("background-position-x", i)
            }
            if (Ext.isIE7 && Ext.isStrict && e.frame) {
                e.el.repaint()
            }
        }
    },
    beforeLayout: function() {
        this.callParent();
        this.syncBeforeAfterTitleClasses()
    },
    adjustTitlePosition: function() {
        var e = this.titleCmp,
        t;
        if (!Ext.isIE9m && e) {
            t = e.el;
            t.setStyle("left", t.getWidth() + "px")
        }
    },
    onTitleRender: function() {
        if (this.orientation === "vertical") {
            this.titleCmp.el.setVertical(90)
        }
    },
    addUIClsToElement: function(e) {
        var t = this,
        n = t.callParent(arguments),
        r = [t.baseCls + "-body-" + e, t.baseCls + "-body-" + t.ui + "-" + e],
        i,
        s;
        if (t.bodyCls) {
            i = t.bodyCls.split(" ");
            for (s = 0; s < r.length; s++) {
                if (!Ext.Array.contains(i, r[s])) {
                    i.push(r[s])
                }
            }
            t.bodyCls = i.join(" ")
        } else {
            t.bodyCls = r.join(" ")
        }
        return n
    },
    removeUIClsFromElement: function(e) {
        var t = this,
        n = t.callParent(arguments),
        r = [t.baseCls + "-body-" + e, t.baseCls + "-body-" + t.ui + "-" + e],
        i,
        s;
        if (t.bodyCls) {
            i = t.bodyCls.split(" ");
            for (s = 0; s < r.length; s++) {
                Ext.Array.remove(i, r[s])
            }
            t.bodyCls = i.join(" ")
        }
        return n
    },
    addUIToElement: function() {
        var e = this,
        t, n;
        e.callParent(arguments);
        n = e.baseCls + "-body-" + e.ui;
        if (e.rendered) {
            if (e.bodyCls) {
                e.body.addCls(e.bodyCls)
            } else {
                e.body.addCls(n)
            }
        } else {
            if (e.bodyCls) {
                t = e.bodyCls.split(" ");
                if (!Ext.Array.contains(t, n)) {
                    t.push(n)
                }
                e.bodyCls = t.join(" ")
            } else {
                e.bodyCls = n
            }
        }
        if (e.titleCmp && e.titleCmp.rendered) {
            e.titleCmp.addCls(e.baseCls + "-text-container-" + e.ui)
        }
    },
    removeUIFromElement: function() {
        var e = this,
        t, n;
        e.callParent(arguments);
        n = e.baseCls + "-body-" + e.ui;
        if (e.rendered) {
            if (e.bodyCls) {
                e.body.removeCls(e.bodyCls)
            } else {
                e.body.removeCls(n)
            }
        } else {
            if (e.bodyCls) {
                t = e.bodyCls.split(" ");
                Ext.Array.remove(t, n);
                e.bodyCls = t.join(" ")
            } else {
                e.bodyCls = n
            }
        }
        if (e.titleCmp && e.titleCmp.rendered) {
            e.titleCmp.removeCls(e.baseCls + "-text-container-" + e.ui)
        }
    },
    onClick: function(e) {
        this.fireClickEvent("click", e)
    },
    onDblClick: function(e) {
        this.fireClickEvent("dblclick", e)
    },
    fireClickEvent: function(e, t) {
        var n = "." + Ext.panel.Tool.prototype.baseCls;
        if (!t.getTarget(n)) {
            this.fireEvent(e, this, t)
        }
    },
    getFocusEl: function() {
        return this.el
    },
    getTargetEl: function() {
        return this.body || this.frameBody || this.el
    },
    applyTargetCls: function(e) {
        this.bodyTargetCls = e
    },
    setTitle: function(e) {
        var t = this,
        n = t.titleCmp;
        t.title = e;
        if (n.rendered) {
            n.textEl.update(t.title || "&#160;");
            n.updateLayout()
        } else {
            t.titleCmp.on({
                render: function() {
                    t.setTitle(e)
                },
                single: true
            })
        }
    },
    getMinWidth: function() {
        var e = this,
        t = e.titleCmp.textEl.dom,
        n, r = e.tools,
        i, s;
        t.style.display = "inline";
        n = t.offsetWidth;
        t.style.display = "";
        if (r && (i = r.length)) {
            for (s = 0; s < i; s++) {
                if (r[s].el) {
                    n += r[s].el.dom.offsetWidth
                }
            }
        }
        if (e.iconCmp) {
            n += e.iconCmp.el.dom.offsetWidth
        }
        return n + 10
    },
    setIconCls: function(e) {
        var t = this,
        n = !e || !e.length,
        r = t.iconCmp;
        t.iconCls = e;
        if (!t.iconCmp && !n) {
            t.initIconCmp();
            t.insert(0, t.iconCmp)
        } else {
            if (r) {
                if (n) {
                    t.iconCmp.destroy();
                    delete t.iconCmp
                } else {
                    r.removeCls(r.iconCls);
                    r.addCls(e);
                    r.iconCls = e
                }
            }
        }
    },
    setIcon: function(e) {
        var t = this,
        n = !e || !e.length,
        r = t.iconCmp;
        t.icon = e;
        if (!t.iconCmp && !n) {
            t.initIconCmp();
            t.insert(0, t.iconCmp)
        } else {
            if (r) {
                if (n) {
                    t.iconCmp.destroy();
                    delete t.iconCmp
                } else {
                    r.setSrc(t.icon)
                }
            }
        }
    },
    setGlyph: function(e) {
        var t = this,
        n = t.iconCmp;
        if (!t.iconCmp) {
            t.initIconCmp();
            t.insert(0, t.iconCmp)
        } else {
            if (n) {
                if (e) {
                    t.iconCmp.setGlyph(e)
                } else {
                    t.iconCmp.destroy();
                    delete t.iconCmp
                }
            }
        }
    },
    getTools: function() {
        return this.tools.slice()
    },
    addTool: function(e) {
        this.add(Ext.ComponentManager.create(e, "tool"))
    },
    syncBeforeAfterTitleClasses: function(e) {
        var t = this,
        n = t.items,
        r = n.items,
        i = t.titlePosition,
        s = r.length,
        o = n.generation,
        u = t.syncBeforeAfterGen,
        a, f, l, c;
        if (!e && u === o) {
            return
        }
        t.syncBeforeAfterGen = o;
        for (l = 0; l < s; ++l) {
            c = r[l];
            a = c.afterTitleCls || (c.afterTitleCls = c.baseCls + "-after-title");
            f = c.beforeTitleCls || (c.beforeTitleCls = c.baseCls + "-before-title");
            if (!t.title || l < i) {
                if (u) {
                    c.removeCls(a)
                }
                c.addCls(f)
            } else {
                if (l > i) {
                    if (u) {
                        c.removeCls(f)
                    }
                    c.addCls(a)
                }
            }
        }
    },
    onAdd: function(e, t) {
        var n = this.tools;
        this.callParent(arguments);
        if (e.isTool) {
            n.push(e);
            n[e.type] = e
        }
    },
    initRenderData: function() {
        return Ext.applyIf(this.callParent(), {
            bodyCls: this.bodyCls,
            bodyTargetCls: this.bodyTargetCls,
            headerCls: this.headerCls
        })
    },
    getDockName: function() {
        return this.dock
    },
    getFramingInfoCls: function() {
        var e = this,
        t = e.callParent(),
        n = e.ownerCt;
        if (!e.expanding && n && (n.collapsed || e.isCollapsedExpander)) {
            t += "-" + n.collapsedCls
        }
        return t + "-" + e.dock
    }
});
Ext.define("Ext.dd.DragDrop", {
    constructor: function(e, t, n) {
        if (e) {
            this.init(e, t, n)
        }
    },
    id: null,
    config: null,
    dragElId: null,
    handleElId: null,
    invalidHandleTypes: null,
    invalidHandleIds: null,
    invalidHandleClasses: null,
    startPageX: 0,
    startPageY: 0,
    groups: null,
    locked: false,
    lock: function() {
        this.locked = true
    },
    moveOnly: false,
    unlock: function() {
        this.locked = false
    },
    isTarget: true,
    padding: null,
    _domRef: null,
    __ygDragDrop: true,
    constrainX: false,
    constrainY: false,
    minX: 0,
    maxX: 0,
    minY: 0,
    maxY: 0,
    maintainOffset: false,
    xTicks: null,
    yTicks: null,
    primaryButtonOnly: true,
    available: false,
    hasOuterHandles: false,
    b4StartDrag: function(e, t) {},
    startDrag: function(e, t) {},
    b4Drag: function(e) {},
    onDrag: function(e) {},
    onDragEnter: function(e, t) {},
    b4DragOver: function(e) {},
    onDragOver: function(e, t) {},
    b4DragOut: function(e) {},
    onDragOut: function(e, t) {},
    b4DragDrop: function(e) {},
    onDragDrop: function(e, t) {},
    onInvalidDrop: function(e) {},
    b4EndDrag: function(e) {},
    endDrag: function(e) {},
    b4MouseDown: function(e) {},
    onMouseDown: function(e) {},
    onMouseUp: function(e) {},
    onAvailable: function() {},
    defaultPadding: {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
    },
    constrainTo: function(e, t, n) {
        if (Ext.isNumber(t)) {
            t = {
                left: t,
                right: t,
                top: t,
                bottom: t
            }
        }
        t = t || this.defaultPadding;
        var r = Ext.get(this.getEl()).getBox(),
        i = Ext.get(e),
        s = i.getScroll(),
        o,
        u = i.dom,
        a,
        f,
        l;
        if (u == document.body) {
            o = {
                x: s.left,
                y: s.top,
                width: Ext.Element.getViewWidth(),
                height: Ext.Element.getViewHeight()
            }
        } else {
            a = i.getXY();
            o = {
                x: a[0],
                y: a[1],
                width: u.clientWidth,
                height: u.clientHeight
            }
        }
        f = r.y - o.y;
        l = r.x - o.x;
        this.resetConstraints();
        this.setXConstraint(l - (t.left || 0), o.width - l - r.width - (t.right || 0), this.xTickSize);
        this.setYConstraint(f - (t.top || 0), o.height - f - r.height - (t.bottom || 0), this.yTickSize)
    },
    getEl: function() {
        if (!this._domRef) {
            this._domRef = Ext.getDom(this.id)
        }
        return this._domRef
    },
    getDragEl: function() {
        return Ext.getDom(this.dragElId)
    },
    init: function(e, t, n) {
        this.initTarget(e, t, n);
        Ext.EventManager.on(this.id, "mousedown", this.handleMouseDown, this)
    },
    initTarget: function(e, t, n) {
        this.config = n || {};
        this.DDMInstance = Ext.dd.DragDropManager;
        this.groups = {};
        if (typeof e !== "string") {
            e = Ext.id(e)
        }
        this.id = e;
        this.addToGroup(t ? t: "default");
        this.handleElId = e;
        this.setDragElId(e);
        this.invalidHandleTypes = {
            A: "A"
        };
        this.invalidHandleIds = {};
        this.invalidHandleClasses = [];
        this.applyConfig();
        this.handleOnAvailable()
    },
    applyConfig: function() {
        this.padding = this.config.padding || [0, 0, 0, 0];
        this.isTarget = this.config.isTarget !== false;
        this.maintainOffset = this.config.maintainOffset;
        this.primaryButtonOnly = this.config.primaryButtonOnly !== false
    },
    handleOnAvailable: function() {
        this.available = true;
        this.resetConstraints();
        this.onAvailable()
    },
    setPadding: function(e, t, n, r) {
        if (!t && 0 !== t) {
            this.padding = [e, e, e, e]
        } else {
            if (!n && 0 !== n) {
                this.padding = [e, t, e, t]
            } else {
                this.padding = [e, t, n, r]
            }
        }
    },
    setInitPosition: function(e, t) {
        var n = this.getEl(),
        r,
        i,
        s;
        if (!this.DDMInstance.verifyEl(n)) {
            return
        }
        r = e || 0;
        i = t || 0;
        s = Ext.Element.getXY(n);
        this.initPageX = s[0] - r;
        this.initPageY = s[1] - i;
        this.lastPageX = s[0];
        this.lastPageY = s[1];
        this.setStartPosition(s)
    },
    setStartPosition: function(e) {
        var t = e || Ext.Element.getXY(this.getEl());
        this.deltaSetXY = null;
        this.startPageX = t[0];
        this.startPageY = t[1]
    },
    addToGroup: function(e) {
        this.groups[e] = true;
        this.DDMInstance.regDragDrop(this, e)
    },
    removeFromGroup: function(e) {
        if (this.groups[e]) {
            delete this.groups[e]
        }
        this.DDMInstance.removeDDFromGroup(this, e)
    },
    setDragElId: function(e) {
        this.dragElId = e
    },
    setHandleElId: function(e) {
        if (typeof e !== "string") {
            e = Ext.id(e)
        }
        this.handleElId = e;
        this.DDMInstance.regHandle(this.id, e)
    },
    setOuterHandleElId: function(e) {
        if (typeof e !== "string") {
            e = Ext.id(e)
        }
        Ext.EventManager.on(e, "mousedown", this.handleMouseDown, this);
        this.setHandleElId(e);
        this.hasOuterHandles = true
    },
    unreg: function() {
        var e = this;
        Ext.EventManager.un(e.id, "mousedown", e.handleMouseDown, e);
        e._domRef = null;
        e.DDMInstance._remove(e, e.autoGroup)
    },
    destroy: function() {
        this.unreg();
        this.isDestroyed = true
    },
    isLocked: function() {
        return this.DDMInstance.isLocked() || this.locked
    },
    handleMouseDown: function(e, t) {
        var n = this;
        if (n.primaryButtonOnly && e.button != 0 || n.isLocked()) {
            return
        }
        n.DDMInstance.refreshCache(n.groups);
        if (n.hasOuterHandles || n.DDMInstance.isOverTarget(e.getPoint(), n)) {
            if (n.clickValidator(e)) {
                n.setStartPosition();
                n.b4MouseDown(e);
                n.onMouseDown(e);
                n.DDMInstance.handleMouseDown(e, n);
                n.DDMInstance.stopEvent(e)
            }
        }
    },
    clickValidator: function(e) {
        var t = e.getTarget();
        return this.isValidHandleChild(t) && (this.id == this.handleElId || this.DDMInstance.handleWasClicked(t, this.id))
    },
    addInvalidHandleType: function(e) {
        var t = e.toUpperCase();
        this.invalidHandleTypes[t] = t
    },
    addInvalidHandleId: function(e) {
        if (typeof e !== "string") {
            e = Ext.id(e)
        }
        this.invalidHandleIds[e] = e
    },
    addInvalidHandleClass: function(e) {
        this.invalidHandleClasses.push(e)
    },
    removeInvalidHandleType: function(e) {
        var t = e.toUpperCase();
        delete this.invalidHandleTypes[t]
    },
    removeInvalidHandleId: function(e) {
        if (typeof e !== "string") {
            e = Ext.id(e)
        }
        delete this.invalidHandleIds[e]
    },
    removeInvalidHandleClass: function(e) {
        for (var t = 0,
        n = this.invalidHandleClasses.length; t < n; ++t) {
            if (this.invalidHandleClasses[t] == e) {
                delete this.invalidHandleClasses[t]
            }
        }
    },
    isValidHandleChild: function(e) {
        var t = true,
        n, r, i;
        try {
            n = e.nodeName.toUpperCase()
        } catch(s) {
            n = e.nodeName
        }
        t = t && !this.invalidHandleTypes[n];
        t = t && !this.invalidHandleIds[e.id];
        for (r = 0, i = this.invalidHandleClasses.length; t && r < i; ++r) {
            t = !Ext.fly(e).hasCls(this.invalidHandleClasses[r])
        }
        return t
    },
    setXTicks: function(e, t) {
        this.xTicks = [];
        this.xTickSize = t;
        var n = {},
        r;
        for (r = this.initPageX; r >= this.minX; r = r - t) {
            if (!n[r]) {
                this.xTicks[this.xTicks.length] = r;
                n[r] = true
            }
        }
        for (r = this.initPageX; r <= this.maxX; r = r + t) {
            if (!n[r]) {
                this.xTicks[this.xTicks.length] = r;
                n[r] = true
            }
        }
        Ext.Array.sort(this.xTicks, this.DDMInstance.numericSort)
    },
    setYTicks: function(e, t) {
        this.yTicks = [];
        this.yTickSize = t;
        var n = {},
        r;
        for (r = this.initPageY; r >= this.minY; r = r - t) {
            if (!n[r]) {
                this.yTicks[this.yTicks.length] = r;
                n[r] = true
            }
        }
        for (r = this.initPageY; r <= this.maxY; r = r + t) {
            if (!n[r]) {
                this.yTicks[this.yTicks.length] = r;
                n[r] = true
            }
        }
        Ext.Array.sort(this.yTicks, this.DDMInstance.numericSort)
    },
    setXConstraint: function(e, t, n) {
        this.leftConstraint = e;
        this.rightConstraint = t;
        this.minX = this.initPageX - e;
        this.maxX = this.initPageX + t;
        if (n) {
            this.setXTicks(this.initPageX, n)
        }
        this.constrainX = true
    },
    clearConstraints: function() {
        this.constrainX = false;
        this.constrainY = false;
        this.clearTicks()
    },
    clearTicks: function() {
        this.xTicks = null;
        this.yTicks = null;
        this.xTickSize = 0;
        this.yTickSize = 0
    },
    setYConstraint: function(e, t, n) {
        this.topConstraint = e;
        this.bottomConstraint = t;
        this.minY = this.initPageY - e;
        this.maxY = this.initPageY + t;
        if (n) {
            this.setYTicks(this.initPageY, n)
        }
        this.constrainY = true
    },
    resetConstraints: function() {
        if (this.initPageX || this.initPageX === 0) {
            var e = this.maintainOffset ? this.lastPageX - this.initPageX: 0,
            t = this.maintainOffset ? this.lastPageY - this.initPageY: 0;
            this.setInitPosition(e, t)
        } else {
            this.setInitPosition()
        }
        if (this.constrainX) {
            this.setXConstraint(this.leftConstraint, this.rightConstraint, this.xTickSize)
        }
        if (this.constrainY) {
            this.setYConstraint(this.topConstraint, this.bottomConstraint, this.yTickSize)
        }
    },
    getTick: function(e, t) {
        if (!t) {
            return e
        } else {
            if (t[0] >= e) {
                return t[0]
            } else {
                var n, r, i, s, o;
                for (n = 0, r = t.length; n < r; ++n) {
                    i = n + 1;
                    if (t[i] && t[i] >= e) {
                        s = e - t[n];
                        o = t[i] - e;
                        return o > s ? t[n] : t[i]
                    }
                }
                return t[t.length - 1]
            }
        }
    },
    toString: function() {
        return "DragDrop " + this.id
    }
});
Ext.define("Ext.dd.DD", {
    extend: Ext.dd.DragDrop,
    constructor: function(e, t, n) {
        if (e) {
            this.init(e, t, n)
        }
    },
    scroll: true,
    autoOffset: function(e, t) {
        var n = e - this.startPageX,
        r = t - this.startPageY;
        this.setDelta(n, r)
    },
    setDelta: function(e, t) {
        this.deltaX = e;
        this.deltaY = t
    },
    setDragElPos: function(e, t) {
        var n = this.getDragEl();
        this.alignElWithMouse(n, e, t)
    },
    alignElWithMouse: function(e, t, n) {
        var r = this.getTargetCoord(t, n),
        i = e.dom ? e: Ext.fly(e, "_dd"),
        s = i.getSize(),
        o = Ext.Element,
        u,
        a,
        f,
        l;
        if (!this.deltaSetXY) {
            u = this.cachedViewportSize = {
                width: o.getDocumentWidth(),
                height: o.getDocumentHeight()
            };
            a = [Math.max(0, Math.min(r.x, u.width - s.width)), Math.max(0, Math.min(r.y, u.height - s.height))];
            i.setXY(a);
            f = this.getLocalX(i);
            l = i.getLocalY();
            this.deltaSetXY = [f - r.x, l - r.y]
        } else {
            u = this.cachedViewportSize;
            this.setLocalXY(i, Math.max(0, Math.min(r.x + this.deltaSetXY[0], u.width - s.width)), Math.max(0, Math.min(r.y + this.deltaSetXY[1], u.height - s.height)))
        }
        this.cachePosition(r.x, r.y);
        this.autoScroll(r.x, r.y, e.offsetHeight, e.offsetWidth);
        return r
    },
    cachePosition: function(e, t) {
        if (e) {
            this.lastPageX = e;
            this.lastPageY = t
        } else {
            var n = Ext.Element.getXY(this.getEl());
            this.lastPageX = n[0];
            this.lastPageY = n[1]
        }
    },
    autoScroll: function(e, t, n, r) {
        if (this.scroll) {
            var i = Ext.Element.getViewHeight(),
            s = Ext.Element.getViewWidth(),
            o = this.DDMInstance.getScrollTop(),
            u = this.DDMInstance.getScrollLeft(),
            a = n + t,
            f = r + e,
            l = i + o - t - this.deltaY,
            c = s + u - e - this.deltaX,
            h = 40,
            p = document.all ? 80 : 30;
            if (a > i && l < h) {
                window.scrollTo(u, o + p)
            }
            if (t < o && o > 0 && t - o < h) {
                window.scrollTo(u, o - p)
            }
            if (f > s && c < h) {
                window.scrollTo(u + p, o)
            }
            if (e < u && u > 0 && e - u < h) {
                window.scrollTo(u - p, o)
            }
        }
    },
    getTargetCoord: function(e, t) {
        var n = e - this.deltaX,
        r = t - this.deltaY;
        if (this.constrainX) {
            if (n < this.minX) {
                n = this.minX
            }
            if (n > this.maxX) {
                n = this.maxX
            }
        }
        if (this.constrainY) {
            if (r < this.minY) {
                r = this.minY
            }
            if (r > this.maxY) {
                r = this.maxY
            }
        }
        n = this.getTick(n, this.xTicks);
        r = this.getTick(r, this.yTicks);
        return {
            x: n,
            y: r
        }
    },
    applyConfig: function() {
        this.callParent();
        this.scroll = this.config.scroll !== false
    },
    b4MouseDown: function(e) {
        this.autoOffset(e.getPageX(), e.getPageY())
    },
    b4Drag: function(e) {
        this.setDragElPos(e.getPageX(), e.getPageY())
    },
    toString: function() {
        return "DD " + this.id
    },
    getLocalX: function(e) {
        return e.getLocalX()
    },
    setLocalXY: function(e, t, n) {
        e.setLocalXY(t, n)
    }
});
Ext.define("Ext.dd.DDProxy", {
    extend: Ext.dd.DD,
    statics: {
        dragElId: "ygddfdiv"
    },
    constructor: function(e, t, n) {
        if (e) {
            this.init(e, t, n);
            this.initFrame()
        }
    },
    resizeFrame: true,
    centerFrame: false,
    createFrame: function() {
        var e = this,
        t = document.body,
        n, r;
        if (!t || !t.firstChild) {
            setTimeout(function() {
                e.createFrame()
            },
            50);
            return
        }
        n = this.getDragEl();
        if (!n) {
            n = document.createElement("div");
            n.id = this.dragElId;
            n.setAttribute("role", "presentation");
            r = n.style;
            r.position = "absolute";
            r.visibility = "hidden";
            r.cursor = "move";
            r.border = "2px solid #aaa";
            r.zIndex = 999;
            t.insertBefore(n, t.firstChild)
        }
    },
    initFrame: function() {
        this.createFrame()
    },
    applyConfig: function() {
        this.callParent();
        this.resizeFrame = this.config.resizeFrame !== false;
        this.centerFrame = this.config.centerFrame;
        this.setDragElId(this.config.dragElId || Ext.dd.DDProxy.dragElId)
    },
    showFrame: function(e, t) {
        var n = this.getEl(),
        r = this.getDragEl(),
        i = r.style;
        this._resizeProxy();
        if (this.centerFrame) {
            this.setDelta(Math.round(parseInt(i.width, 10) / 2), Math.round(parseInt(i.height, 10) / 2))
        }
        this.setDragElPos(e, t);
        Ext.fly(r).show()
    },
    _resizeProxy: function() {
        if (this.resizeFrame) {
            var e = this.getEl();
            Ext.fly(this.getDragEl()).setSize(e.offsetWidth, e.offsetHeight)
        }
    },
    b4MouseDown: function(e) {
        var t = e.getPageX(),
        n = e.getPageY();
        this.autoOffset(t, n);
        this.setDragElPos(t, n)
    },
    b4StartDrag: function(e, t) {
        this.showFrame(e, t)
    },
    b4EndDrag: function(e) {
        Ext.fly(this.getDragEl()).hide()
    },
    endDrag: function(e) {
        var t = this.getEl(),
        n = this.getDragEl();
        n.style.visibility = "";
        this.beforeMove();
        t.style.visibility = "hidden";
        Ext.dd.DDM.moveToEl(t, n);
        n.style.visibility = "hidden";
        t.style.visibility = "";
        this.afterDrag()
    },
    beforeMove: function() {},
    afterDrag: function() {},
    toString: function() {
        return "DDProxy " + this.id
    }
});
Ext.define("Ext.dd.StatusProxy", {
    extend: Ext.Component,
    animRepair: false,
    childEls: ["ghost"],
    renderTpl: ['<div class="' + Ext.baseCSSPrefix + 'dd-drop-icon" role="presentation"></div><div id="{id}-ghost" class="' + Ext.baseCSSPrefix + 'dd-drag-ghost" role="presentation"></div>'],
    repairCls: Ext.baseCSSPrefix + "dd-drag-repair",
    ariaRole: "presentation",
    constructor: function(e) {
        var t = this;
        e = e || {};
        Ext.apply(t, {
            hideMode: "visibility",
            hidden: true,
            floating: true,
            id: t.id || Ext.id(),
            cls: Ext.baseCSSPrefix + "dd-drag-proxy " + this.dropNotAllowed,
            shadow: e.shadow || false,
            renderTo: Ext.getDetachedBody()
        });
        t.callParent(arguments);
        this.dropStatus = this.dropNotAllowed
    },
    dropAllowed: Ext.baseCSSPrefix + "dd-drop-ok",
    dropNotAllowed: Ext.baseCSSPrefix + "dd-drop-nodrop",
    setStatus: function(e) {
        e = e || this.dropNotAllowed;
        if (this.dropStatus != e) {
            var t, n, r = ["tree-drop-ok-between", "tree-drop-ok-above", "tree-drop-ok-below", "tree-drop-ok-append", "dd-drop-nodrop"];
            for (t in r) {
                n = Ext.baseCSSPrefix + r[t];
                if (n != e) {
                    this.el.removeCls(n)
                }
            }
            this.el.addCls(e);
            this.dropStatus = e
        }
    },
    reset: function(e) {
        var t = this,
        n = Ext.baseCSSPrefix + "dd-drag-proxy ";
        t.el.replaceCls(n + t.dropAllowed, n + t.dropNotAllowed);
        t.dropStatus = t.dropNotAllowed;
        if (e) {
            t.ghost.update("")
        }
    },
    update: function(e) {
        if (typeof e == "string") {
            this.ghost.update(e)
        } else {
            this.ghost.update("");
            e.style.margin = "0";
            this.ghost.dom.appendChild(e)
        }
        var t = this.ghost.dom.firstChild;
        if (t) {
            Ext.fly(t).setStyle("float", "none")
        }
    },
    getGhost: function() {
        return this.ghost
    },
    hide: function(e) {
        this.callParent();
        if (e) {
            this.reset(true)
        }
    },
    stop: function() {
        if (this.anim && this.anim.isAnimated && this.anim.isAnimated()) {
            this.anim.stop()
        }
    },
    sync: function() {
        this.el.sync()
    },
    repair: function(e, t, n) {
        var r = this;
        r.callback = t;
        r.scope = n;
        if (e && r.animRepair !== false) {
            r.el.addCls(r.repairCls);
            r.el.hideUnders(true);
            r.anim = r.el.animate({
                duration: r.repairDuration || 500,
                easing: "ease-out",
                to: {
                    x: e[0],
                    y: e[1]
                },
                stopAnimation: true,
                callback: r.afterRepair,
                scope: r
            })
        } else {
            r.afterRepair()
        }
    },
    afterRepair: function() {
        var e = this;
        e.hide(true);
        e.el.removeCls(e.repairCls);
        if (typeof e.callback == "function") {
            e.callback.call(e.scope || e)
        }
        delete e.callback;
        delete e.scope
    }
});
Ext.define("Ext.dd.DragSource", {
    extend: Ext.dd.DDProxy,
    dropAllowed: Ext.baseCSSPrefix + "dd-drop-ok",
    dropNotAllowed: Ext.baseCSSPrefix + "dd-drop-nodrop",
    animRepair: true,
    repairHighlightColor: "c3daf9",
    constructor: function(e, t) {
        this.el = Ext.get(e);
        if (!this.dragData) {
            this.dragData = {}
        }
        Ext.apply(this, t);
        if (!this.proxy) {
            this.proxy = new Ext.dd.StatusProxy({
                id: this.el.id + "-drag-status-proxy",
                animRepair: this.animRepair
            })
        }
        this.callParent([this.el.dom, this.ddGroup || this.group, {
            dragElId: this.proxy.id,
            resizeFrame: false,
            isTarget: false,
            scroll: this.scroll === true
        }]);
        this.dragging = false
    },
    getDragData: function(e) {
        return this.dragData
    },
    onDragEnter: function(e, t) {
        var n = Ext.dd.DragDropManager.getDDById(t),
        r;
        this.cachedTarget = n;
        if (this.beforeDragEnter(n, e, t) !== false) {
            if (n.isNotifyTarget) {
                r = n.notifyEnter(this, e, this.dragData);
                this.proxy.setStatus(r)
            } else {
                this.proxy.setStatus(this.dropAllowed)
            }
            if (this.afterDragEnter) {
                this.afterDragEnter(n, e, t)
            }
        }
    },
    beforeDragEnter: function(e, t, n) {
        return true
    },
    onDragOver: function(e, t) {
        var n = this.cachedTarget || Ext.dd.DragDropManager.getDDById(t),
        r;
        if (this.beforeDragOver(n, e, t) !== false) {
            if (n.isNotifyTarget) {
                r = n.notifyOver(this, e, this.dragData);
                this.proxy.setStatus(r)
            }
            if (this.afterDragOver) {
                this.afterDragOver(n, e, t)
            }
        }
    },
    beforeDragOver: function(e, t, n) {
        return true
    },
    onDragOut: function(e, t) {
        var n = this.cachedTarget || Ext.dd.DragDropManager.getDDById(t);
        if (this.beforeDragOut(n, e, t) !== false) {
            if (n.isNotifyTarget) {
                n.notifyOut(this, e, this.dragData)
            }
            this.proxy.reset();
            if (this.afterDragOut) {
                this.afterDragOut(n, e, t)
            }
        }
        this.cachedTarget = null
    },
    beforeDragOut: function(e, t, n) {
        return true
    },
    onDragDrop: function(e, t) {
        var n = this.cachedTarget || Ext.dd.DragDropManager.getDDById(t);
        if (this.beforeDragDrop(n, e, t) !== false) {
            if (n.isNotifyTarget) {
                if (n.notifyDrop(this, e, this.dragData) !== false) {
                    this.onValidDrop(n, e, t)
                } else {
                    this.onInvalidDrop(n, e, t)
                }
            } else {
                this.onValidDrop(n, e, t)
            }
            if (this.afterDragDrop) {
                this.afterDragDrop(n, e, t)
            }
        }
        delete this.cachedTarget
    },
    beforeDragDrop: function(e, t, n) {
        return true
    },
    onValidDrop: function(e, t, n) {
        this.hideProxy();
        if (this.afterValidDrop) {
            this.afterValidDrop(e, t, n)
        }
    },
    getRepairXY: function(e, t) {
        return this.el.getXY()
    },
    onInvalidDrop: function(e, t, n) {
        var r = this;
        if (!t) {
            t = e;
            e = null;
            n = t.getTarget().id
        }
        if (r.beforeInvalidDrop(e, t, n) !== false) {
            if (r.cachedTarget) {
                if (r.cachedTarget.isNotifyTarget) {
                    r.cachedTarget.notifyOut(r, t, r.dragData)
                }
                r.cacheTarget = null
            }
            r.proxy.repair(r.getRepairXY(t, r.dragData), r.afterRepair, r);
            if (r.afterInvalidDrop) {
                r.afterInvalidDrop(t, n)
            }
        }
    },
    afterRepair: function() {
        var e = this;
        if (Ext.enableFx) {
            e.el.highlight(e.repairHighlightColor)
        }
        e.dragging = false
    },
    beforeInvalidDrop: function(e, t, n) {
        return true
    },
    handleMouseDown: function(e) {
        if (this.dragging) {
            return
        }
        var t = this.getDragData(e);
        if (t && this.onBeforeDrag(t, e) !== false) {
            this.dragData = t;
            this.proxy.stop();
            this.callParent(arguments)
        }
    },
    onBeforeDrag: function(e, t) {
        return true
    },
    onStartDrag: Ext.emptyFn,
    alignElWithMouse: function() {
        this.proxy.ensureAttachedToBody(true);
        return this.callParent(arguments)
    },
    startDrag: function(e, t) {
        this.proxy.reset();
        this.proxy.hidden = false;
        this.dragging = true;
        this.proxy.update("");
        this.onInitDrag(e, t);
        this.proxy.show()
    },
    onInitDrag: function(e, t) {
        var n = this.el.dom.cloneNode(true);
        n.id = Ext.id();
        this.proxy.update(n);
        this.onStartDrag(e, t);
        return true
    },
    getProxy: function() {
        return this.proxy
    },
    hideProxy: function() {
        this.proxy.hide();
        this.proxy.reset(true);
        this.dragging = false
    },
    triggerCacheRefresh: function() {
        Ext.dd.DDM.refreshCache(this.groups)
    },
    b4EndDrag: function(e) {},
    endDrag: function(e) {
        this.onEndDrag(this.dragData, e)
    },
    onEndDrag: function(e, t) {},
    autoOffset: function(e, t) {
        this.setDelta( - 12, -20)
    },
    destroy: function() {
        this.callParent();
        Ext.destroy(this.proxy)
    }
});
Ext.define("Ext.panel.Proxy", {
    alternateClassName: "Ext.dd.PanelProxy",
    moveOnDrag: true,
    constructor: function(e, t) {
        var n = this;
        n.panel = e;
        n.id = n.panel.id + "-ddproxy";
        Ext.apply(n, t)
    },
    insertProxy: true,
    setStatus: Ext.emptyFn,
    reset: Ext.emptyFn,
    update: Ext.emptyFn,
    stop: Ext.emptyFn,
    sync: Ext.emptyFn,
    getEl: function() {
        return this.ghost.el
    },
    getGhost: function() {
        return this.ghost
    },
    getProxy: function() {
        return this.proxy
    },
    hide: function() {
        var e = this;
        if (e.ghost) {
            if (e.proxy) {
                e.proxy.remove();
                delete e.proxy
            }
            e.panel.unghost(null, e.moveOnDrag);
            delete e.ghost
        }
    },
    show: function() {
        var e = this,
        t;
        if (!e.ghost) {
            t = e.panel.getSize();
            e.panel.el.setVisibilityMode(Ext.Element.DISPLAY);
            e.ghost = e.panel.ghost();
            if (e.insertProxy) {
                e.proxy = e.panel.el.insertSibling({
                    role: "presentation",
                    cls: Ext.baseCSSPrefix + "panel-dd-spacer"
                });
                e.proxy.setSize(t)
            }
        }
    },
    repair: function(e, t, n) {
        this.hide();
        Ext.callback(t, n || this)
    },
    moveProxy: function(e, t) {
        if (this.proxy) {
            e.insertBefore(this.proxy.dom, t)
        }
    }
});
Ext.define("Ext.panel.DD", {
    extend: Ext.dd.DragSource,
    constructor: function(e, t) {
        var n = this;
        n.panel = e;
        n.dragData = {
            panel: e
        };
        n.panelProxy = new Ext.panel.Proxy(e, t);
        n.proxy = n.panelProxy.proxy;
        n.callParent([e.el, t]);
        n.setupEl(e)
    },
    setupEl: function(e) {
        var t = this,
        n = e.header,
        r = e.body;
        if (n) {
            t.setHandleElId(n.id);
            r = n.el
        }
        if (r) {
            r.setStyle("cursor", "move");
            t.scroll = false
        } else {
            e.on("boxready", t.setupEl, t, {
                single: true
            })
        }
    },
    showFrame: Ext.emptyFn,
    startDrag: Ext.emptyFn,
    b4StartDrag: function(e, t) {
        this.panelProxy.show()
    },
    b4MouseDown: function(e) {
        var t = e.getPageX(),
        n = e.getPageY();
        this.autoOffset(t, n)
    },
    onInitDrag: function(e, t) {
        this.onStartDrag(e, t);
        return true
    },
    createFrame: Ext.emptyFn,
    getDragEl: function(e) {
        var t = this.panelProxy.ghost;
        if (t) {
            return t.el.dom
        }
    },
    endDrag: function(e) {
        this.panelProxy.hide();
        this.panel.saveState()
    },
    autoOffset: function(e, t) {
        e -= this.startPageX;
        t -= this.startPageY;
        this.setDelta(e, t)
    },
    onInvalidDrop: function(e, t, n) {
        var r = this;
        if (r.beforeInvalidDrop(e, t, n) !== false) {
            if (r.cachedTarget) {
                if (r.cachedTarget.isNotifyTarget) {
                    r.cachedTarget.notifyOut(r, t, r.dragData)
                }
                r.cacheTarget = null
            }
            if (r.afterInvalidDrop) {
                r.afterInvalidDrop(t, n)
            }
        }
    }
});
Ext.define("Ext.util.Memento",
function() {
    function e(e, t, n, r) {
        e[r ? r + n: n] = t[n]
    }
    function t(e, t, n) {
        delete e[n]
    }
    function n(e, t, n, i) {
        var s = i ? i + n: n,
        o = e[s];
        if (o || e.hasOwnProperty(s)) {
            r(t, n, o)
        }
    }
    function r(e, t, n) {
        if (Ext.isDefined(n)) {
            e[t] = n
        } else {
            delete e[t]
        }
    }
    function i(e, t, n, r, i) {
        if (t) {
            if (Ext.isArray(r)) {
                var s, o = r.length;
                for (s = 0; s < o; s++) {
                    e(t, n, r[s], i)
                }
            } else {
                e(t, n, r, i)
            }
        }
    }
    return {
        data: null,
        target: null,
        constructor: function(e, t) {
            if (e) {
                this.target = e;
                if (t) {
                    this.capture(t)
                }
            }
        },
        capture: function(t, n, r) {
            var s = this;
            i(e, s.data || (s.data = {}), n || s.target, t, r)
        },
        remove: function(e) {
            i(t, this.data, null, e)
        },
        restore: function(e, t, r, s) {
            i(n, this.data, r || this.target, e, s);
            if (t !== false) {
                this.remove(e)
            }
        },
        restoreAll: function(e, t) {
            var n = this,
            i = t || this.target,
            s = n.data,
            o;
            for (o in s) {
                if (s.hasOwnProperty(o)) {
                    r(i, o, s[o])
                }
            }
            if (e !== false) {
                delete n.data
            }
        }
    }
} ());
Ext.define("Ext.layout.component.Body", {
    alias: ["layout.body"],
    extend: Ext.layout.component.Auto,
    type: "body",
    beginLayout: function(e) {
        this.callParent(arguments);
        e.bodyContext = e.getEl("body")
    },
    beginLayoutCycle: function(e, t) {
        var n = this,
        r = n.lastWidthModel,
        i = n.lastHeightModel,
        s = n.owner.body;
        n.callParent(arguments);
        if (r && r.fixed && e.widthModel.shrinkWrap) {
            s.setWidth(null)
        }
        if (i && i.fixed && e.heightModel.shrinkWrap) {
            s.setHeight(null)
        }
    },
    calculateOwnerHeightFromContentHeight: function(e, t) {
        var n = this.callParent(arguments);
        if (e.targetContext != e) {
            n += e.getPaddingInfo().height
        }
        return n
    },
    calculateOwnerWidthFromContentWidth: function(e, t) {
        var n = this.callParent(arguments);
        if (e.targetContext != e) {
            n += e.getPaddingInfo().width
        }
        return n
    },
    measureContentWidth: function(e) {
        return e.bodyContext.setWidth(e.bodyContext.el.dom.offsetWidth, false)
    },
    measureContentHeight: function(e) {
        return e.bodyContext.setHeight(e.bodyContext.el.dom.offsetHeight, false)
    },
    publishInnerHeight: function(e, t) {
        var n = t - e.getFrameInfo().height,
        r = e.targetContext;
        if (r != e) {
            n -= e.getPaddingInfo().height
        }
        return e.bodyContext.setHeight(n, !e.heightModel.natural)
    },
    publishInnerWidth: function(e, t) {
        var n = t - e.getFrameInfo().width,
        r = e.targetContext;
        if (r != e) {
            n -= e.getPaddingInfo().width
        }
        e.bodyContext.setWidth(n, !e.widthModel.natural)
    }
});
Ext.define("Ext.panel.Panel", {
    extend: Ext.panel.AbstractPanel,
    alias: "widget.panel",
    alternateClassName: "Ext.Panel",
    collapsedCls: "collapsed",
    animCollapse: Ext.enableFx,
    minButtonWidth: 75,
    collapsed: false,
    collapseFirst: true,
    hideCollapseTool: false,
    titleCollapse: undefined,
    floatable: true,
    collapsible: undefined,
    closable: false,
    closeAction: "destroy",
    placeholderCollapseHideMode: Ext.Element.VISIBILITY,
    preventHeader: false,
    header: undefined,
    headerPosition: "top",
    frame: false,
    frameHeader: true,
    manageHeight: true,
    constrain: false,
    constrainHeader: false,
    maskElement: "el",
    initComponent: function() {
        var e = this;
        if (window.Wb && Wb.isNeptune && e.height) {
            if (e instanceof Ext.window.Window) {
                if (e.dialog || e.buttons) {
                    e.height += 20
                } else {
                    e.height += 13
                }
            } else {
                if (e.title) {
                    e.height += 13
                }
            }
        }
        e.addEvents("beforeclose", "close", "beforeexpand", "beforecollapse", "expand", "collapse", "titlechange", "iconchange", "iconclschange", "glyphchange", "float", "unfloat");
        if (e.collapsible) {
            e.addStateEvents(["expand", "collapse"])
        }
        if (e.unstyled) {
            e.setUI("plain")
        }
        if (e.frame) {
            e.setUI(e.ui + "-framed")
        }
        e.bridgeToolbars();
        e.callParent();
        e.collapseDirection = e.collapseDirection || e.headerPosition || Ext.Component.DIRECTION_TOP;
        e.hiddenOnCollapse = new Ext.dom.CompositeElement
    },
    beforeDestroy: function() {
        var e = this;
        Ext.destroy(e.placeholder, e.ghostPanel, e.dd);
        e.callParent()
    },
    getFocusEl: function() {
        return this.el
    },
    getHeader: function() {
        return this.header
    },
    setTitle: function(e) {
        var t = this,
        n = t.title,
        r = t.header,
        i = t.reExpander,
        s = t.placeholder;
        t.title = e;
        if (r) {
            if (r.isHeader) {
                r.setTitle(e)
            } else {
                r.title = e
            }
        } else {
            if (t.rendered) {
                t.updateHeader()
            }
        }
        if (i) {
            i.setTitle(e)
        }
        if (s && s.setTitle) {
            s.setTitle(e)
        }
        t.fireEvent("titlechange", t, e, n)
    },
    setIconCls: function(e) {
        var t = this,
        n = t.iconCls,
        r = t.header,
        i = t.placeholder;
        t.iconCls = e;
        if (r) {
            if (r.isHeader) {
                r.setIconCls(e)
            } else {
                r.iconCls = e
            }
        } else {
            t.updateHeader()
        }
        if (i && i.setIconCls) {
            i.setIconCls(e)
        }
        t.fireEvent("iconclschange", t, e, n)
    },
    setIcon: function(e) {
        var t = this,
        n = t.icon,
        r = t.header,
        i = t.placeholder;
        t.icon = e;
        if (r) {
            if (r.isHeader) {
                r.setIcon(e)
            } else {
                r.icon = e
            }
        } else {
            t.updateHeader()
        }
        if (i && i.setIcon) {
            i.setIcon(e)
        }
        t.fireEvent("iconchange", t, e, n)
    },
    setGlyph: function(e) {
        var t = this,
        n = t.glyph,
        r = t.header,
        i = t.placeholder;
        t.glyph = e;
        if (r) {
            if (r.isHeader) {
                r.setGlyph(e)
            } else {
                r.glyph = e
            }
        } else {
            t.updateHeader()
        }
        if (i && i.setGlyph) {
            i.setIcon(e)
        }
        t.fireEvent("glyphchange", t, e, n)
    },
    bridgeToolbars: function() {
        function s(t, n, r) {
            if (Ext.isArray(t)) {
                t = {
                    xtype: "toolbar",
                    items: t
                }
            } else {
                if (!t.xtype) {
                    t.xtype = "toolbar"
                }
            }
            t.dock = n;
            if (n == "left" || n == "right") {
                t.vertical = true
            }
            if (r) {
                t.layout = Ext.applyIf(t.layout || {},
                {
                    pack: {
                        left: "start",
                        center: "center"
                    } [e.buttonAlign] || "end"
                })
            }
            return t
        }
        var e = this,
        t = [],
        n = e.minButtonWidth,
        r,
        i;
        if (e.tbar) {
            t.push(s(e.tbar, "top"));
            e.tbar = null
        }
        if (e.bbar) {
            t.push(s(e.bbar, "bottom"));
            e.bbar = null
        }
        if (e.buttons) {
            e.fbar = e.buttons;
            e.buttons = null
        }
        if (e.fbar) {
            r = s(e.fbar, "bottom", true);
            r.ui = "footer";
            if (n) {
                i = r.defaults;
                r.defaults = function(e) {
                    var t = i || {},
                    r = !e.xtype || e.isButton,
                    s;
                    if (!r) {
                        s = Ext.ClassManager.getByAlias("widget." + e.xtype);
                        if (s) {
                            r = s.prototype.isButton
                        }
                    }
                    if (r && !("minWidth" in t)) {
                        t = Ext.apply({
                            minWidth: n
                        },
                        t)
                    }
                    return t
                }
            }
            t.push(r);
            e.fbar = null
        }
        if (e.lbar) {
            t.push(s(e.lbar, "left"));
            e.lbar = null
        }
        if (e.rbar) {
            t.push(s(e.rbar, "right"));
            e.rbar = null
        }
        if (e.dockedItems) {
            if (!Ext.isArray(e.dockedItems)) {
                e.dockedItems = [e.dockedItems]
            }
            e.dockedItems = e.dockedItems.concat(t)
        } else {
            e.dockedItems = t
        }
    },
    isPlaceHolderCollapse: function() {
        return this.collapseMode == "placeholder"
    },
    onBoxReady: function() {
        this.callParent(arguments);
        if (this.collapsed) {
            this.setHiddenDocked()
        }
    },
    beforeRender: function() {
        var e = this,
        t;
        e.callParent();
        e.initTools();
        if (! (e.preventHeader || e.header === false)) {
            e.updateHeader()
        }
        if (e.collapsed) {
            if (e.isPlaceHolderCollapse()) {
                if (!e.hidden) {
                    e.setHiddenState(true);
                    e.preventCollapseFire = true;
                    e.placeholderCollapse();
                    delete e.preventCollapseFire;
                    t = e.collapsed;
                    e.collapsed = false
                }
            } else {
                e.beginCollapse();
                e.addClsWithUI(e.collapsedCls)
            }
        }
        if (t) {
            e.collapsed = t
        }
    },
    initTools: function() {
        var e = this,
        t = e.tools,
        n, r;
        e.tools = [];
        for (n = t && t.length; n;) {--n;
            e.tools[n] = r = t[n];
            r.toolOwner = e
        }
        if (e.collapsible && !(e.hideCollapseTool || e.header === false || e.preventHeader)) {
            e.collapseDirection = e.collapseDirection || e.headerPosition || "top";
            e.collapseTool = e.expandTool = Ext.widget({
                xtype: "tool",
                handler: e.toggleCollapse,
                scope: e
            });
            e.updateCollapseTool();
            if (e.collapseFirst) {
                e.tools.unshift(e.collapseTool)
            }
        }
        e.addTools();
        if (e.closable) {
            e.addClsWithUI("closable");
            e.addTool({
                xtype: "tool",
                type: "close",
                scope: e,
                handler: e.close
            })
        }
        if (e.collapseTool && !e.collapseFirst) {
            e.addTool(e.collapseTool)
        }
    },
    addTools: Ext.emptyFn,
    updateCollapseTool: function() {
        var e = this,
        t = e.collapseTool;
        if (t) {
            if (e.collapsed && !e.isPlaceHolderCollapse()) {
                t.setType("expand-" + e.getOppositeDirection(e.collapseDirection))
            } else {
                t.setType("collapse-" + e.collapseDirection)
            }
        }
    },
    close: function() {
        if (this.fireEvent("beforeclose", this) !== false) {
            this.doClose()
        }
    },
    doClose: function() {
        this.fireEvent("close", this);
        this[this.closeAction]()
    },
    updateHeader: function(e) {
        var t = this,
        n = t.header,
        r = t.title,
        i = t.tools,
        s = t.icon || t.iconCls,
        o = t.headerPosition === "left" || t.headerPosition === "right";
        if (Ext.isObject(n) || n !== false && (e || r || s || i && i.length || t.collapsible && !t.titleCollapse)) {
            if (n && n.isHeader) {
                n.show()
            } else {
                n = t.header = Ext.widget(Ext.apply({
                    xtype: "header",
                    title: r,
                    titleAlign: t.titleAlign,
                    orientation: o ? "vertical": "horizontal",
                    dock: t.headerPosition || "top",
                    textCls: t.headerTextCls,
                    iconCls: t.iconCls,
                    icon: t.icon,
                    glyph: t.glyph,
                    baseCls: t.baseCls + "-header",
                    tools: i,
                    ui: t.ui,
                    id: t.id + "_header",
                    overCls: t.headerOverCls,
                    indicateDrag: t.draggable,
                    frame: (t.frame || t.alwaysFramed) && t.frameHeader,
                    ignoreParentFrame: t.frame || t.overlapHeader,
                    ignoreBorderManagement: t.frame || t.ignoreHeaderBorderManagement,
                    headerRole: t.headerRole,
                    ownerCt: t,
                    listeners: t.collapsible && t.titleCollapse ? {
                        click: t.toggleCollapse,
                        scope: t
                    }: null
                },
                t.header));
                t.addDocked(n, 0)
            }
        } else {
            if (n) {
                n.hide()
            }
        }
    },
    setUI: function(e) {
        var t = this;
        t.callParent(arguments);
        if (t.header && t.header.rendered) {
            t.header.setUI(e)
        }
    },
    getDefaultContentTarget: function() {
        return this.body
    },
    getTargetEl: function() {
        var e = this;
        return e.body || e.protoBody || e.frameBody || e.el
    },
    isVisible: function(e) {
        var t = this;
        if (t.collapsed && t.placeholder) {
            return t.placeholder.isVisible(e)
        }
        return t.callParent(arguments)
    },
    onHide: function() {
        var e = this,
        t = e.dd;
        if (e.floatedFromCollapse) {
            e.slideOutFloatedPanel(true)
        }
        if (e.draggable && t) {
            t.endDrag()
        }
        if (e.collapsed && e.placeholder) {
            e.placeholder.hide()
        } else {
            e.callParent(arguments)
        }
    },
    onShow: function() {
        var e = this;
        if (e.collapsed && e.isPlaceHolderCollapse()) {
            e.setHiddenState(true);
            e.placeholderCollapse()
        } else {
            e.callParent(arguments)
        }
    },
    onRemoved: function(e) {
        var t = this;
        if (t.placeholder && !e) {
            t.ownerCt.remove(t.placeholder, false)
        }
        t.callParent(arguments)
    },
    addTool: function(e) {
        if (!Ext.isArray(e)) {
            e = [e]
        }
        var t = this,
        n = t.header,
        r, i = e.length,
        s;
        for (r = 0; r < i; r++) {
            s = e[r];
            s.toolOwner = t;
            if (n && n.isHeader) {
                n.addTool(s)
            } else {
                t.tools.push(s)
            }
        }
        t.updateHeader()
    },
    getOppositeDirection: function(e) {
        var t = Ext.Component;
        switch (e) {
        case t.DIRECTION_TOP:
            return t.DIRECTION_BOTTOM;
        case t.DIRECTION_RIGHT:
            return t.DIRECTION_LEFT;
        case t.DIRECTION_BOTTOM:
            return t.DIRECTION_TOP;
        case t.DIRECTION_LEFT:
            return t.DIRECTION_RIGHT
        }
    },
    getWidthAuthority: function() {
        if (this.collapsed && this.collapsedHorizontal()) {
            return 1
        }
        return this.callParent()
    },
    getHeightAuthority: function() {
        if (this.collapsed && this.collapsedVertical()) {
            return 1
        }
        return this.callParent()
    },
    collapsedHorizontal: function() {
        var e = this.getCollapsed();
        return e === "left" || e === "right"
    },
    collapsedVertical: function() {
        var e = this.getCollapsed();
        return e === "top" || e === "bottom"
    },
    restoreDimension: function() {
        var e = this.collapseDirection;
        return e === "top" || e === "bottom" ? "height": "width"
    },
    getCollapsed: function() {
        var e = this;
        if (e.collapsed === true) {
            return e.collapseDirection
        }
        return e.collapsed
    },
    getState: function() {
        var e = this,
        t = e.callParent(),
        n;
        t = e.addPropertyToState(t, "collapsed");
        if (e.collapsed) {
            n = e.collapseMemento;
            n = n && n.data;
            if (e.collapsedVertical()) {
                if (t) {
                    delete t.height
                }
                if (n) {
                    t = e.addPropertyToState(t, "height", n.height)
                }
            } else {
                if (t) {
                    delete t.width
                }
                if (n) {
                    t = e.addPropertyToState(t, "width", n.width)
                }
            }
        }
        return t
    },
    findReExpander: function(e) {
        var t = this,
        n = Ext.Component,
        r = t.dockedItems.items,
        i = r.length,
        s, o;
        if (t.collapseMode === "mini") {
            return
        }
        switch (e) {
        case n.DIRECTION_TOP:
        case n.DIRECTION_BOTTOM:
            for (o = 0; o < i; o++) {
                s = r[o];
                if (!s.hidden) {
                    if (s.isHeader && (!s.dock || s.dock === "top" || s.dock === "bottom")) {
                        return s
                    }
                }
            }
            break;
        case n.DIRECTION_LEFT:
        case n.DIRECTION_RIGHT:
            for (o = 0; o < i; o++) {
                s = r[o];
                if (!s.hidden) {
                    if (s.isHeader && (s.dock === "left" || s.dock === "right")) {
                        return s
                    }
                }
            }
            break;
        default:
            throw "Panel#findReExpander must be passed a valid collapseDirection"
        }
    },
    getReExpander: function(e) {
        var t = this,
        n = e || t.collapseDirection,
        r = t.reExpander || t.findReExpander(n);
        t.expandDirection = t.getOppositeDirection(n);
        if (!r) {
            t.reExpander = r = t.createReExpander(n, {
                dock: n,
                cls: Ext.baseCSSPrefix + "docked " + t.baseCls + "-" + t.ui + "-collapsed",
                isCollapsedExpander: true
            });
            t.dockedItems.insert(0, r)
        }
        return r
    },
    createReExpander: function(e, t) {
        var n = this,
        r = e === "left",
        i = e === "right",
        s = r || i,
        o = n.ownerCt,
        u = Ext.apply({
            hideMode: "offsets",
            title: n.title || "&#160;",
            titleAlign: n.titleAlign,
            orientation: s ? "vertical": "horizontal",
            textCls: n.headerTextCls,
            icon: n.icon,
            iconCls: n.iconCls,
            glyph: n.glyph,
            baseCls: n.self.prototype.baseCls + "-header",
            ui: n.ui,
            frame: n.frame && n.frameHeader,
            ignoreParentFrame: n.frame || n.overlapHeader,
            ignoreBorderManagement: n.frame || n.ignoreHeaderBorderManagement,
            indicateDrag: n.draggable,
            collapseImmune: true,
            headerRole: n.headerRole,
            ownerCt: o && n.collapseMode === "placeholder" ? o: n,
            ownerLayout: n.componentLayout,
            margin: n.margin
        },
        t);
        if (n.collapseMode === "mini") {
            if (s) {
                u.width = 1
            } else {
                u.height = 1
            }
        }
        if (!n.hideCollapseTool) {
            if (r || i && n.isPlaceHolderCollapse()) {
                u.titlePosition = 1
            }
            u.tools = [{
                xtype: "tool",
                type: "expand-" + n.getOppositeDirection(e),
                uiCls: ["top"],
                handler: n.toggleCollapse,
                scope: n
            }]
        }
        u = new Ext.panel.Header(u);
        u.addClsWithUI(n.getHeaderCollapsedClasses(u));
        return u
    },
    getHeaderCollapsedClasses: function(e) {
        var t = this,
        n = t.collapsedCls,
        r;
        r = [n, n + "-" + e.getDockName()];
        if (t.border && (!t.frame || t.frame && Ext.supports.CSS3BorderRadius)) {
            r.push(n + "-border-" + e.getDockName())
        }
        return r
    },
    beginCollapse: function() {
        var e = this,
        t = e.lastBox,
        n = e.rendered,
        r = e.collapseMemento || (e.collapseMemento = new Ext.util.Memento(e)),
        i = e.getSizeModel(),
        s = e.header,
        o;
        r.capture(["height", "minHeight", "width", "minWidth"]);
        if (t) {
            r.capture(e.restoreDimension(), t, "last.")
        }
        if (e.collapsedVertical()) {
            if (i.width.shrinkWrap) {
                e.width = n ? e.getWidth() : e.width || e.minWidth || 100
            }
            delete e.height;
            e.minHeight = 0
        } else {
            if (e.collapsedHorizontal()) {
                if (i.height.shrinkWrap) {
                    e.height = n ? e.getHeight() : e.height || e.minHeight || 100
                }
                delete e.width;
                e.minWidth = 0
            }
        }
        if (e.ownerCt) {
            e.ownerCt.getLayout().beginCollapse(e)
        }
        if (!e.isPlaceHolderCollapse() && s !== false) {
            if (s === (o = e.getReExpander())) {
                s.collapseImmune = true;
                s.getHierarchyState().collapseImmune = true;
                s.addClsWithUI(e.getHeaderCollapsedClasses(s));
                if (s.rendered) {
                    s.updateFrame()
                }
            } else {
                if (o.el) {
                    o.el.show();
                    o.hidden = false
                }
            }
        }
        if (e.resizer) {
            e.resizer.disable()
        }
    },
    beginExpand: function() {
        var e = this,
        t = e.lastBox,
        n = e.collapseMemento,
        r = e.restoreDimension(),
        i = e.header,
        s;
        if (n) {
            n.restore(["minHeight", "minWidth", r]);
            if (t) {
                n.restore(r, true, t, "last.")
            }
        }
        if (e.ownerCt) {
            e.ownerCt.getLayout().beginExpand(e)
        }
        if (!e.isPlaceHolderCollapse() && i !== false) {
            if (i === (s = e.getReExpander())) {
                delete i.collapseImmune;
                delete i.getHierarchyState().collapseImmune;
                i.removeClsWithUI(e.getHeaderCollapsedClasses(i));
                if (i.rendered) {
                    i.expanding = true;
                    i.updateFrame();
                    delete i.expanding
                }
            } else {
                s.hidden = true;
                s.el.hide()
            }
        }
        if (e.resizer) {
            e.resizer.enable()
        }
    },
    collapse: function(e, t) {
        var n = this,
        r = e || n.collapseDirection,
        i = n.ownerCt,
        s = n.ownerLayout;
        if (n.isCollapsingOrExpanding) {
            return n
        }
        if (arguments.length < 2) {
            t = n.animCollapse
        }
        if (n.collapsed || n.fireEvent("beforecollapse", n, e, t) === false) {
            return n
        }
        if (s && s.onBeforeComponentCollapse) {
            if (s.onBeforeComponentCollapse(n) === false) {
                return n
            }
        }
        if (i && n.isPlaceHolderCollapse()) {
            return n.placeholderCollapse(e, t)
        }
        n.collapsed = r;
        n.beginCollapse();
        n.getHierarchyState().collapsed = true;
        n.fireHierarchyEvent("collapse");
        return n.doCollapseExpand(1, t)
    },
    doCollapseExpand: function(e, t) {
        var n = this,
        r = n.animCollapse,
        i = n.ownerLayout;
        n.animCollapse = t;
        n.isCollapsingOrExpanding = e;
        if (t) {
            n.addCls(Ext.baseCSSPrefix + "animating-size")
        }
        if (i && !t) {
            i.onContentChange(n)
        } else {
            n.updateLayout({
                isRoot: true
            })
        }
        n.animCollapse = r;
        return n
    },
    afterCollapse: function(e) {
        var t = this,
        n = t.ownerLayout;
        t.isCollapsingOrExpanding = 0;
        t.updateCollapseTool();
        if (e) {
            t.removeCls(Ext.baseCSSPrefix + "animating-size")
        }
        if (n && e) {
            n.onContentChange(t)
        }
        t.setHiddenDocked();
        t.fireEvent("collapse", t)
    },
    setHiddenDocked: function() {
        var e = this,
        t = e.hiddenOnCollapse,
        n = e.getDockedItems(),
        r = n.length,
        i = 0,
        s,
        o;
        if (e.header !== false) {
            o = e.getReExpander()
        }
        t.add(e.body);
        for (; i < r; i++) {
            s = n[i];
            if (s && s !== o && s.el) {
                t.add(s.el)
            }
        }
        t.setStyle("visibility", "hidden")
    },
    restoreHiddenDocked: function() {
        var e = this.hiddenOnCollapse;
        e.setStyle("visibility", "");
        e.clear()
    },
    getPlaceholder: function(e) {
        var t = this,
        n = e || t.collapseDirection,
        r = null,
        i = t.placeholder,
        s = t.floatable,
        o = t.titleCollapse;
        if (!i) {
            if (s || t.collapsible && o) {
                r = {
                    click: {
                        fn: !o && s ? t.floatCollapsedPanel: t.toggleCollapse,
                        element: "el",
                        scope: t
                    }
                }
            }
            t.placeholder = i = Ext.widget(t.createReExpander(n, {
                id: t.id + "-placeholder",
                listeners: r
            }))
        }
        if (!i.placeholderFor) {
            if (!i.isComponent) {
                t.placeholder = i = t.lookupComponent(i)
            }
            Ext.applyIf(i, {
                margins: t.margins,
                placeholderFor: t
            });
            i.addCls([Ext.baseCSSPrefix + "region-collapsed-placeholder", Ext.baseCSSPrefix + "region-collapsed-" + n + "-placeholder", t.collapsedCls])
        }
        return i
    },
    placeholderCollapse: function(e, t) {
        var n = this,
        r = n.ownerCt,
        i = e || n.collapseDirection,
        s = Ext.baseCSSPrefix + "border-region-slide-in",
        o = n.getPlaceholder(i),
        u;
        n.isCollapsingOrExpanding = 1;
        n.setHiddenState(true);
        n.collapsed = i;
        if (o.rendered) {
            if (o.el.dom.parentNode !== n.el.dom.parentNode) {
                n.el.dom.parentNode.insertBefore(o.el.dom, n.el.dom)
            }
            o.hidden = false;
            o.setHiddenState(false);
            o.el.show();
            r.updateLayout()
        } else {
            r.insert(r.items.indexOf(n), o)
        }
        if (n.rendered) {
            n.el.setVisibilityMode(n.placeholderCollapseHideMode);
            if (t) {
                n.el.addCls(s);
                o.el.hide();
                u = n.convertCollapseDir(i);
                n.el.slideOut(u, {
                    preserveScroll: true,
                    duration: Ext.Number.from(t, Ext.fx.Anim.prototype.duration),
                    listeners: {
                        afteranimate: function() {
                            n.el.removeCls(s);
                            o.el.show().setStyle("display", "none").slideIn(u, {
                                easing: "linear",
                                duration: 100,
                                listeners: {
                                    afteranimate: function() {
                                        o.focus();
                                        o.setHiddenState(false);
                                        n.isCollapsingOrExpanding = 0;
                                        n.fireEvent("collapse", n)
                                    }
                                }
                            })
                        }
                    }
                })
            } else {
                n.el.hide();
                o.setHiddenState(false);
                n.isCollapsingOrExpanding = 0;
                n.fireEvent("collapse", n)
            }
        } else {
            n.isCollapsingOrExpanding = 0;
            if (!n.preventCollapseFire) {
                n.fireEvent("collapse", n)
            }
        }
        return n
    },
    floatCollapsedPanel: function() {
        var e = this,
        t = e.placeholder,
        n = t.getSize(),
        r,
        i = Ext.baseCSSPrefix + "border-region-slide-in",
        s = e.collapsed,
        o = e.ownerCt || e,
        u;
        if (e.isSliding) {
            return
        }
        if (e.el.hasCls(i)) {
            e.slideOutFloatedPanel();
            return
        }
        e.isSliding = true;
        t.el.hide();
        t.hidden = true;
        e.el.show();
        e.setHiddenState(false);
        e.collapsed = false;
        o.updateLayout();
        r = e.getBox(false, true);
        t.el.show();
        t.hidden = false;
        e.el.hide();
        e.setHiddenState(true);
        e.collapsed = s;
        o.updateLayout();
        e.slideOutTask = e.slideOutTask || new Ext.util.DelayedTask(e.slideOutFloatedPanel, e);
        t.el.on("mouseleave", e.onMouseLeaveFloated, e);
        e.el.on("mouseleave", e.onMouseLeaveFloated, e);
        t.el.on("mouseenter", e.onMouseEnterFloated, e);
        e.el.on("mouseenter", e.onMouseEnterFloated, e);
        e.el.addCls(i);
        e.floated = true;
        if (e.collapseTool) {
            e.collapseTool.el.hide()
        }
        switch (e.collapsed) {
        case "top":
            e.setLocalXY(r.x, r.y + n.height - 1);
            break;
        case "right":
            e.setLocalXY(r.x - n.width + 1, r.y);
            break;
        case "bottom":
            e.setLocalXY(r.x, r.y - n.height + 1);
            break;
        case "left":
            e.setLocalXY(r.x + n.width - 1, r.y);
            break
        }
        u = e.convertCollapseDir(e.collapsed);
        e.floatedFromCollapse = e.collapsed;
        e.collapsed = false;
        e.setHiddenState(false);
        e.el.slideIn(u, {
            preserveScroll: true,
            duration: Ext.Number.from(e.animCollapse, Ext.fx.Anim.prototype.duration),
            listeners: {
                afteranimate: function() {
                    e.isSliding = false;
                    e.fireEvent("float", e)
                }
            }
        })
    },
    onMouseLeaveFloated: function(e) {
        this.slideOutTask.delay(500)
    },
    onMouseEnterFloated: function(e) {
        this.slideOutTask.cancel()
    },
    isLayoutRoot: function() {
        if (this.floatedFromCollapse) {
            return true
        }
        return this.callParent()
    },
    slideOutFloatedPanel: function(e) {
        var t = this,
        n = t.el,
        r;
        if (t.isSliding || t.isDestroyed) {
            return
        }
        t.isSliding = true;
        t.floated = false;
        t.slideOutFloatedPanelBegin();
        if (typeof t.collapsed == "string") {
            r = t.convertCollapseDir(t.collapsed)
        }
        n.slideOut(r, {
            preserveScroll: true,
            duration: Ext.Number.from(t.animCollapse, Ext.fx.Anim.prototype.duration),
            autoEnd: e === true,
            listeners: {
                afteranimate: function() {
                    t.slideOutFloatedPanelEnd();
                    t.el.removeCls(Ext.baseCSSPrefix + "border-region-slide-in")
                }
            }
        })
    },
    slideOutFloatedPanelBegin: function() {
        var e = this,
        t = e.placeholder.el,
        n = e.el;
        e.collapsed = e.floatedFromCollapse;
        e.setHiddenState(true);
        e.floatedFromCollapse = null;
        t.un("mouseleave", e.onMouseLeaveFloated, e);
        n.un("mouseleave", e.onMouseLeaveFloated, e);
        t.un("mouseenter", e.onMouseEnterFloated, e);
        n.un("mouseenter", e.onMouseEnterFloated, e)
    },
    slideOutFloatedPanelEnd: function(e) {
        var t = this;
        if (t.collapseTool) {
            t.collapseTool.el.show()
        }
        t.slideOutTask.cancel();
        t.isSliding = false;
        if (!e) {
            t.fireEvent("unfloat", t)
        }
    },
    expand: function(e) {
        var t = this,
        n = t.ownerLayout;
        if (t.isCollapsingOrExpanding) {
            return t
        }
        if (!arguments.length) {
            e = t.animCollapse
        }
        if (!t.collapsed && !t.floatedFromCollapse) {
            return t
        }
        if (t.fireEvent("beforeexpand", t, e) === false) {
            return t
        }
        if (n && n.onBeforeComponentExpand) {
            if (n.onBeforeComponentExpand(t) === false) {
                return t
            }
        }
        delete t.getHierarchyState().collapsed;
        if (t.isPlaceHolderCollapse()) {
            return t.placeholderExpand(e)
        }
        t.restoreHiddenDocked();
        t.beginExpand();
        t.collapsed = false;
        return t.doCollapseExpand(2, e)
    },
    placeholderExpand: function(e) {
        var t = this,
        n = t.collapsed,
        r = Ext.baseCSSPrefix + "border-region-slide-in",
        i, s, o = t.ownerLayout ? t.ownerLayout.centerRegion: null;
        if (Ext.AbstractComponent.layoutSuspendCount) {
            e = false
        }
        if (t.floatedFromCollapse) {
            s = t.getPosition(true);
            t.slideOutFloatedPanelBegin();
            t.slideOutFloatedPanelEnd();
            t.floated = false
        }
        if (e) {
            Ext.suspendLayouts();
            t.placeholder.hide();
            t.el.show();
            t.collapsed = false;
            t.setHiddenState(false);
            if (o && !s) {
                o.hidden = true
            }
            Ext.resumeLayouts(true);
            o.hidden = false;
            t.el.addCls(r);
            t.isCollapsingOrExpanding = 2;
            if (s) {
                i = t.getXY();
                t.setLocalXY(s[0], s[1]);
                t.setXY([i[0], i[1]], {
                    duration: Ext.Number.from(e, Ext.fx.Anim.prototype.duration),
                    listeners: {
                        afteranimate: function() {
                            t.el.removeCls(r);
                            t.isCollapsingOrExpanding = 0;
                            t.fireEvent("expand", t)
                        }
                    }
                })
            } else {
                t.el.hide();
                t.placeholder.el.show();
                t.placeholder.hidden = false;
                t.setHiddenState(false);
                t.el.slideIn(t.convertCollapseDir(n), {
                    preserveScroll: true,
                    duration: Ext.Number.from(e, Ext.fx.Anim.prototype.duration),
                    listeners: {
                        afteranimate: function() {
                            t.el.removeCls(r);
                            t.placeholder.hide();
                            t.updateLayout();
                            t.isCollapsingOrExpanding = 0;
                            t.fireEvent("expand", t)
                        }
                    }
                })
            }
        } else {
            t.floated = t.collapsed = false;
            t.el.removeCls(r);
            Ext.suspendLayouts();
            t.placeholder.hide();
            t.show();
            Ext.resumeLayouts(true);
            t.fireEvent("expand", t)
        }
        return t
    },
    afterExpand: function(e) {
        var t = this,
        n = t.ownerLayout;
        t.isCollapsingOrExpanding = 0;
        t.updateCollapseTool();
        if (e) {
            t.removeCls(Ext.baseCSSPrefix + "animating-size")
        }
        if (n && e) {
            n.onContentChange(t)
        }
        t.fireEvent("expand", t);
        t.fireHierarchyEvent("expand")
    },
    setBorder: function(e, t) {
        if (t) {
            return
        }
        var n = this,
        r = n.header;
        if (!e) {
            e = 0
        } else {
            if (e === true) {
                e = "1px"
            } else {
                e = n.unitizeBox(e)
            }
        }
        if (r) {
            if (r.isHeader) {
                r.setBorder(e)
            } else {
                r.border = e
            }
        }
        if (n.rendered && n.bodyBorder !== false) {
            n.body.setStyle("border-width", e)
        }
        n.updateLayout();
        n.border = e
    },
    toggleCollapse: function() {
        return this.collapsed || this.floatedFromCollapse ? this.expand() : this.collapse()
    },
    getKeyMap: function() {
        return this.keyMap || (this.keyMap = new Ext.util.KeyMap(Ext.apply({
            target: this.el
        },
        this.keys)))
    },
    initDraggable: function() {
        var e = this;
        if (e.simpleDrag) {
            e.initSimpleDraggable()
        } else {
            e.dd = new Ext.panel.DD(e, Ext.isBoolean(e.draggable) ? null: e.draggable)
        }
    },
    initSimpleDraggable: function() {
        var e = this,
        t, n;
        if (!e.header) {
            e.updateHeader(true)
        }
        if (e.header) {
            t = Ext.applyIf({
                el: e.el,
                delegate: "#" + Ext.escapeId(e.header.id)
            },
            e.draggable);
            if (e.constrain || e.constrainHeader) {
                t.constrain = e.constrain;
                t.constrainDelegate = e.constrainHeader;
                t.constrainTo = e.constrainTo || e.container
            }
            n = e.dd = new Ext.util.ComponentDragger(e, t);
            e.relayEvents(n, ["dragstart", "drag", "dragend"]);
            if (e.maximized) {
                n.disable()
            }
        }
    },
    ghostTools: function() {
        var e = [],
        t = this.header,
        n = t ? t.query("tool[hidden=false]") : [],
        r,
        i,
        s;
        if (n.length) {
            r = 0;
            i = n.length;
            for (; r < i; r++) {
                s = n[r];
                e.push({
                    type: s.type
                })
            }
        } else {
            e = [{
                type: "placeholder"
            }]
        }
        return e
    },
    ghost: function(e) {
        var t = this,
        n = t.ghostPanel,
        r = t.getBox(),
        i = t.header,
        s,
        o,
        u;
        if (!n) {
            t.ghostPanel = n = Ext.widget(t.createGhost(e))
        } else {
            n.el.show()
        }
        n.setHiddenState(false);
        n.floatParent = t.floatParent;
        n.toFront();
        if (i && !t.preventHeader) {
            s = n.header;
            s.suspendLayouts();
            o = s.query("tool");
            for (u = o.length; u--;) {
                s.remove(o[u])
            }
            n.addTool(t.ghostTools());
            n.setTitle(t.title);
            if (t.iconCls) {
                n.setIconCls(t.iconCls)
            } else {
                if (t.icon) {
                    n.setIcon(t.icon)
                } else {
                    if (t.glyph) {
                        n.setGlyph(t.glyph)
                    }
                }
            }
            s.setTitlePosition(i.titlePosition);
            s.addCls(Ext.baseCSSPrefix + "header-ghost");
            s.resumeLayouts()
        }
        n.setPagePosition(r.x, r.y);
        n.setSize(r.width, r.height);
        t.el.hide();
        return n
    },
    createGhost: function(e) {
        var t = this,
        n = t.header,
        r = t.frame && !t.alwaysFramed;
        return {
            xtype: "panel",
            hidden: false,
            header: n ? {
                titleAlign: n.titleAlign
            }: null,
            ui: r ? t.ui.replace(/-framed$/, "") : t.ui,
            id: t.id + "-ghost",
            renderTo: Ext.getBody(),
            resizable: false,
            draggable: false,
            closable: false,
            floating: {
                shadow: false
            },
            frame: r,
            alwaysFramed: t.alwaysFramed,
            overlapHeader: t.overlapHeader,
            headerPosition: t.headerPosition,
            baseCls: t.baseCls,
            getRefOwner: function() {
                return t.getRefOwner()
            },
            cls: t.baseCls + "-ghost " + (e || "")
        }
    },
    unghost: function(e, t) {
        var n = this,
        r = n.ghostPanel;
        if (!r) {
            return
        }
        if (e !== false) {
            n.el.show();
            if (t !== false) {
                n.setPagePosition(r.getXY());
                if (n.hideMode == "offsets") {
                    delete n.el.hideModeStyles
                }
            }
            Ext.defer(n.focus, 10, n)
        }
        r.el.hide();
        r.setHiddenState(true)
    },
    beginDrag: function() {
        if (this.floatingDescendants) {
            this.floatingDescendants.hide()
        }
    },
    endDrag: function() {
        if (this.floatingDescendants) {
            this.floatingDescendants.show()
        }
    },
    initResizable: function() {
        this.callParent(arguments);
        if (this.collapsed) {
            this.resizer.disable()
        }
    },
    convertCollapseDir: function(e) {
        return e.substr(0, 1)
    },
    getAnimationProps: function() {
        var e = this,
        t = e.animCollapse,
        n;
        n = e.callParent();
        if (typeof t === "number") {
            n.duration = t
        }
        return n
    }
},
function() {
    this.prototype.animCollapse = Ext.enableFx
});
Ext.define("Ext.tip.Tip", {
    extend: Ext.panel.Panel,
    alias: "widget.tip",
    alternateClassName: "Ext.Tip",
    minWidth: 40,
    maxWidth: 500,
    shadow: "sides",
    defaultAlign: "tl-bl?",
    constrainPosition: true,
    autoRender: true,
    hidden: true,
    baseCls: Ext.baseCSSPrefix + "tip",
    floating: {
        shadow: true,
        shim: true
    },
    focusOnToFront: false,
    closeAction: "hide",
    alwaysFramed: true,
    frameHeader: false,
    initComponent: function() {
        var e = this;
        e.floating = Ext.apply({},
        {
            shadow: e.shadow,
            constrain: e.constrainPosition
        },
        e.self.prototype.floating);
        e.callParent(arguments);
        e.constrain = e.constrain || e.constrainPosition
    },
    showAt: function(e) {
        var t = this;
        this.callParent(arguments);
        if (t.isVisible()) {
            t.setPagePosition(e[0], e[1]);
            if (t.constrainPosition || t.constrain) {
                t.doConstrain()
            }
            t.toFront(true)
        }
    },
    initDraggable: function() {
        var e = this;
        e.draggable = {
            el: e.getDragEl(),
            delegate: e.header.el,
            constrain: e,
            constrainTo: e.el.dom.parentNode
        };
        Ext.Component.prototype.initDraggable.call(e)
    },
    ghost: undefined,
    unghost: undefined
});
Ext.define("Ext.tip.ToolTip", {
    extend: Ext.tip.Tip,
    alias: "widget.tooltip",
    alternateClassName: "Ext.ToolTip",
    autoHide: true,
    showDelay: 500,
    hideDelay: 200,
    dismissDelay: 5e3,
    trackMouse: false,
    anchorToTarget: true,
    anchorOffset: 0,
    targetCounter: 0,
    quickShowInterval: 250,
    ariaRole: "tooltip",
    initComponent: function() {
        var e = this;
        e.callParent(arguments);
        e.lastActive = new Date;
        e.setTarget(e.target);
        e.origAnchor = e.anchor
    },
    onRender: function(e, t) {
        var n = this;
        n.callParent(arguments);
        n.anchorCls = Ext.baseCSSPrefix + "tip-anchor-" + n.getAnchorPosition();
        n.anchorEl = n.el.createChild({
            role: "presentation",
            cls: Ext.baseCSSPrefix + "tip-anchor " + n.anchorCls
        })
    },
    setTarget: function(e) {
        var t = this,
        n = Ext.get(e),
        r;
        if (t.target) {
            r = Ext.get(t.target);
            t.mun(r, "mouseover", t.onTargetOver, t);
            t.mun(r, "mouseout", t.onTargetOut, t);
            t.mun(r, "mousemove", t.onMouseMove, t)
        }
        t.target = n;
        if (n) {
            t.mon(n, {
                freezeEvent: true,
                mouseover: t.onTargetOver,
                mouseout: t.onTargetOut,
                mousemove: t.onMouseMove,
                scope: t
            })
        }
        if (t.anchor) {
            t.anchorTarget = t.target
        }
    },
    onMouseMove: function(e) {
        var t = this,
        n = t.delegate ? e.getTarget(t.delegate) : t.triggerElement = true,
        r;
        if (n) {
            t.targetXY = e.getXY();
            if (n === t.triggerElement) {
                if (!t.hidden && t.trackMouse) {
                    r = t.getTargetXY();
                    if (t.constrainPosition) {
                        r = t.el.adjustForConstraints(r, t.el.parent())
                    }
                    t.setPagePosition(r)
                }
            } else {
                t.hide();
                t.lastActive = new Date(0);
                t.onTargetOver(e)
            }
        } else {
            if (!t.closable && t.isVisible() && t.autoHide !== false) {
                t.hide()
            }
        }
    },
    getTargetXY: function() {
        var e = this,
        t, n, r, i, s, o, u, a, f, l, c, h;
        if (e.delegate) {
            e.anchorTarget = e.triggerElement
        }
        if (e.anchor) {
            e.targetCounter++;
            n = e.getOffsets();
            r = e.anchorToTarget && !e.trackMouse ? e.getAlignToXY(e.anchorTarget, e.getAnchorAlign()) : e.targetXY;
            i = Ext.Element.getViewWidth() - 5;
            s = Ext.Element.getViewHeight() - 5;
            o = document.documentElement;
            u = document.body;
            a = (o.scrollLeft || u.scrollLeft || 0) + 5;
            f = (o.scrollTop || u.scrollTop || 0) + 5;
            l = [r[0] + n[0], r[1] + n[1]];
            c = e.getSize();
            h = e.constrainPosition;
            e.anchorEl.removeCls(e.anchorCls);
            if (e.targetCounter < 2 && h) {
                if (l[0] < a) {
                    if (e.anchorToTarget) {
                        e.defaultAlign = "l-r";
                        if (e.mouseOffset) {
                            e.mouseOffset[0] *= -1
                        }
                    }
                    e.anchor = "left";
                    return e.getTargetXY()
                }
                if (l[0] + c.width > i) {
                    if (e.anchorToTarget) {
                        e.defaultAlign = "r-l";
                        if (e.mouseOffset) {
                            e.mouseOffset[0] *= -1
                        }
                    }
                    e.anchor = "right";
                    return e.getTargetXY()
                }
                if (l[1] < f) {
                    if (e.anchorToTarget) {
                        e.defaultAlign = "t-b";
                        if (e.mouseOffset) {
                            e.mouseOffset[1] *= -1
                        }
                    }
                    e.anchor = "top";
                    return e.getTargetXY()
                }
                if (l[1] + c.height > s) {
                    if (e.anchorToTarget) {
                        e.defaultAlign = "b-t";
                        if (e.mouseOffset) {
                            e.mouseOffset[1] *= -1
                        }
                    }
                    e.anchor = "bottom";
                    return e.getTargetXY()
                }
            }
            e.anchorCls = Ext.baseCSSPrefix + "tip-anchor-" + e.getAnchorPosition();
            e.anchorEl.addCls(e.anchorCls);
            e.targetCounter = 0;
            return l
        } else {
            t = e.getMouseOffset();
            return e.targetXY ? [e.targetXY[0] + t[0], e.targetXY[1] + t[1]] : t
        }
    },
    getMouseOffset: function() {
        var e = this,
        t = e.anchor ? [0, 0] : [15, 18];
        if (e.mouseOffset) {
            t[0] += e.mouseOffset[0];
            t[1] += e.mouseOffset[1]
        }
        return t
    },
    getAnchorPosition: function() {
        var e = this,
        t;
        if (e.anchor) {
            e.tipAnchor = e.anchor.charAt(0)
        } else {
            t = e.defaultAlign.match(/^([a-z]+)-([a-z]+)(\?)?$/);
            e.tipAnchor = t[1].charAt(0)
        }
        switch (e.tipAnchor) {
        case "t":
            return "top";
        case "b":
            return "bottom";
        case "r":
            return "right"
        }
        return "left"
    },
    getAnchorAlign: function() {
        switch (this.anchor) {
        case "top":
            return "tl-bl";
        case "left":
            return "tl-tr";
        case "right":
            return "tr-tl";
        default:
            return "bl-tl"
        }
    },
    getOffsets: function() {
        var e = this,
        t, n, r = e.getAnchorPosition().charAt(0);
        if (e.anchorToTarget && !e.trackMouse) {
            switch (r) {
            case "t":
                n = [0, 9];
                break;
            case "b":
                n = [0, -13];
                break;
            case "r":
                n = [ - 13, 0];
                break;
            default:
                n = [9, 0];
                break
            }
        } else {
            switch (r) {
            case "t":
                n = [ - 15 - e.anchorOffset, 30];
                break;
            case "b":
                n = [ - 19 - e.anchorOffset, -13 - e.el.dom.offsetHeight];
                break;
            case "r":
                n = [ - 15 - e.el.dom.offsetWidth, -13 - e.anchorOffset];
                break;
            default:
                n = [25, -13 - e.anchorOffset];
                break
            }
        }
        t = e.getMouseOffset();
        n[0] += t[0];
        n[1] += t[1];
        return n
    },
    onTargetOver: function(e) {
        var t = this,
        n = t.delegate,
        r;
        if (t.disabled || e.within(t.target.dom, true)) {
            return
        }
        r = n ? e.getTarget(n) : true;
        if (r) {
            t.triggerElement = r;
            t.triggerEvent = e;
            t.clearTimer("hide");
            t.targetXY = e.getXY();
            t.delayShow()
        }
    },
    delayShow: function(e) {
        var t = this,
        n = t.el && (e === false || !t.trackMouse) && t.getTargetXY();
        if (t.hidden && !t.showTimer) {
            if (Ext.Date.getElapsed(t.lastActive) < t.quickShowInterval) {
                t.show()
            } else {
                t.showTimer = Ext.defer(t.showFromDelay, t.showDelay, t, [n])
            }
        } else {
            if (!t.hidden && t.autoHide !== false) {
                t.show(n)
            }
        }
    },
    showFromDelay: function(e) {
        this.fromDelayShow = true;
        this.show(e);
        delete this.fromDelayShow
    },
    onShowVeto: function() {
        this.callParent();
        delete this.triggerElement;
        this.clearTimer("show")
    },
    onTargetOut: function(e) {
        var t = this,
        n = t.triggerElement,
        r = n === true ? t.target: n;
        if (t.disabled || !n || e.within(r, true)) {
            return
        }
        if (t.showTimer) {
            t.clearTimer("show");
            t.triggerElement = null
        }
        if (t.autoHide !== false) {
            t.delayHide()
        }
    },
    delayHide: function() {
        var e = this;
        if (!e.hidden && !e.hideTimer) {
            e.hideTimer = Ext.defer(e.hide, e.hideDelay, e)
        }
    },
    hide: function() {
        var e = this;
        e.clearTimer("dismiss");
        e.lastActive = new Date;
        if (e.anchorEl) {
            e.anchorEl.hide()
        }
        e.callParent(arguments);
        delete e.triggerElement
    },
    show: function(e) {
        var t = this;
        this.callParent();
        if (this.hidden === false) {
            t.setPagePosition( - 1e4, -1e4);
            if (t.anchor) {
                t.anchor = t.origAnchor
            }
            if (!t.calledFromShowAt) {
                t.showAt(e || t.getTargetXY())
            }
            if (t.anchor) {
                t.syncAnchor();
                t.anchorEl.show()
            } else {
                t.anchorEl.hide()
            }
        }
    },
    showAt: function(e) {
        var t = this;
        t.lastActive = new Date;
        t.clearTimers();
        t.calledFromShowAt = true;
        if (!t.isVisible()) {
            this.callParent(arguments)
        }
        if (t.isVisible()) {
            t.setPagePosition(e[0], e[1]);
            if (t.constrainPosition || t.constrain) {
                t.doConstrain()
            }
            t.toFront(true);
            t.el.sync(true);
            if (t.dismissDelay && t.autoHide !== false) {
                t.dismissTimer = Ext.defer(t.hide, t.dismissDelay, t)
            }
            if (t.anchor) {
                t.syncAnchor();
                if (!t.anchorEl.isVisible()) {
                    t.anchorEl.show()
                }
            } else {
                t.anchorEl.hide()
            }
        }
        delete t.calledFromShowAt
    },
    syncAnchor: function() {
        var e = this,
        t, n, r;
        switch (e.tipAnchor.charAt(0)) {
        case "t":
            t = "b";
            n = "tl";
            r = [20 + e.anchorOffset, 1];
            break;
        case "r":
            t = "l";
            n = "tr";
            r = [ - 1, 12 + e.anchorOffset];
            break;
        case "b":
            t = "t";
            n = "bl";
            r = [20 + e.anchorOffset, -1];
            break;
        default:
            t = "r";
            n = "tl";
            r = [1, 12 + e.anchorOffset];
            break
        }
        e.anchorEl.alignTo(e.el, t + "-" + n, r);
        e.anchorEl.setStyle("z-index", parseInt(e.el.getZIndex(), 10) || 0 + 1).setVisibilityMode(Ext.Element.DISPLAY)
    },
    setPagePosition: function(e, t) {
        var n = this;
        n.callParent(arguments);
        if (n.anchor) {
            n.syncAnchor()
        }
    },
    _timerNames: {},
    clearTimer: function(e) {
        var t = this,
        n = t._timerNames,
        r = n[e] || (n[e] = e + "Timer"),
        i = t[r];
        if (i) {
            clearTimeout(i);
            t[r] = null
        }
    },
    clearTimers: function() {
        var e = this;
        e.clearTimer("show");
        e.clearTimer("dismiss");
        e.clearTimer("hide")
    },
    onShow: function() {
        var e = this;
        e.callParent();
        e.mon(Ext.getDoc(), "mousedown", e.onDocMouseDown, e)
    },
    onHide: function() {
        var e = this;
        e.callParent();
        e.mun(Ext.getDoc(), "mousedown", e.onDocMouseDown, e)
    },
    onDocMouseDown: function(e) {
        var t = this;
        if (!t.closable && !e.within(t.el.dom)) {
            t.disable();
            Ext.defer(t.doEnable, 100, t)
        }
    },
    doEnable: function() {
        if (!this.isDestroyed) {
            this.enable()
        }
    },
    onDisable: function() {
        this.callParent();
        this.clearTimers();
        this.hide()
    },
    beforeDestroy: function() {
        var e = this;
        e.clearTimers();
        Ext.destroy(e.anchorEl);
        delete e.anchorEl;
        delete e.target;
        delete e.anchorTarget;
        delete e.triggerElement;
        e.callParent()
    },
    onDestroy: function() {
        Ext.getDoc().un("mousedown", this.onDocMouseDown, this);
        this.callParent()
    }
});
Ext.define("Ext.tip.QuickTip", {
    extend: Ext.tip.ToolTip,
    alias: "widget.quicktip",
    alternateClassName: "Ext.QuickTip",
    interceptTitles: false,
    title: "&#160;",
    tagConfig: {
        namespace: "data-",
        attribute: "qtip",
        width: "qwidth",
        target: "target",
        title: "qtitle",
        hide: "hide",
        cls: "qclass",
        align: "qalign",
        anchor: "anchor",
        showDelay: "qshowDelay"
    },
    shrinkWrapDock: true,
    initComponent: function() {
        var e = this;
        e.target = e.target || Ext.getDoc();
        e.targets = e.targets || {};
        e.callParent()
    },
    register: function(e) {
        var t = Ext.isArray(e) ? e: arguments,
        n = 0,
        r = t.length,
        i,
        s,
        o;
        for (; n < r; n++) {
            e = t[n];
            i = e.target;
            if (i) {
                if (Ext.isArray(i)) {
                    for (s = 0, o = i.length; s < o; s++) {
                        this.targets[Ext.id(i[s])] = e
                    }
                } else {
                    this.targets[Ext.id(i)] = e
                }
            }
        }
    },
    unregister: function(e) {
        delete this.targets[Ext.id(e)]
    },
    cancelShow: function(e) {
        var t = this,
        n = t.activeTarget;
        e = Ext.get(e).dom;
        if (t.isVisible()) {
            if (n && n.el == e) {
                t.hide()
            }
        } else {
            if (n && n.el == e) {
                t.clearTimer("show")
            }
        }
    },
    getTipCfg: function(e) {
        var t = e.getTarget(),
        n = t.title,
        r;
        if (this.interceptTitles && n && Ext.isString(n)) {
            t.qtip = n;
            t.removeAttribute("title");
            e.preventDefault();
            return {
                text: n
            }
        } else {
            r = this.tagConfig;
            t = e.getTarget("[" + r.namespace + r.attribute + "]");
            if (t) {
                return {
                    target: t,
                    text: t.getAttribute(r.namespace + r.attribute)
                }
            }
        }
    },
    onTargetOver: function(e) {
        var t = this,
        n = e.getTarget(t.delegate),
        r,
        i,
        s,
        o,
        u,
        a,
        f,
        l,
        c,
        h,
        p;
        if (t.disabled) {
            return
        }
        t.targetXY = e.getXY();
        if (!n || n.nodeType !== 1 || n == document.documentElement || n == document.body) {
            return
        }
        if (t.activeTarget && (n == t.activeTarget.el || Ext.fly(t.activeTarget.el).contains(n))) {
            if (t.targetTextEmpty()) {
                t.onShowVeto();
                delete t.activeTarget
            } else {
                t.clearTimer("hide");
                t.show()
            }
            return
        }
        if (n) {
            l = t.targets;
            for (p in l) {
                if (l.hasOwnProperty(p)) {
                    h = l[p];
                    c = Ext.fly(h.target);
                    if (c && (c.dom === n || c.contains(n))) {
                        s = c.dom;
                        break
                    }
                }
            }
            if (s) {
                t.activeTarget = t.targets[s.id];
                t.activeTarget.el = n;
                t.anchor = t.activeTarget.anchor;
                if (t.anchor) {
                    t.anchorTarget = n
                }
                r = parseInt(t.activeTarget.showDelay, 10);
                if (r) {
                    i = t.showDelay;
                    t.showDelay = r
                }
                t.delayShow();
                if (r) {
                    t.showDelay = i
                }
                return
            }
        }
        s = Ext.fly(n, "_quicktip-target");
        o = t.tagConfig;
        u = o.namespace;
        a = t.getTipCfg(e);
        if (a) {
            if (a.target) {
                n = a.target;
                s = Ext.fly(n, "_quicktip-target")
            }
            f = s.getAttribute(u + o.hide);
            t.activeTarget = {
                el: n,
                text: a.text,
                width: +s.getAttribute(u + o.width) || null,
                autoHide: f != "user" && f !== "false",
                title: s.getAttribute(u + o.title),
                cls: s.getAttribute(u + o.cls),
                align: s.getAttribute(u + o.align),
                showDelay: parseInt(s.getAttribute(u + o.showDelay), 10)
            };
            t.anchor = s.getAttribute(u + o.anchor);
            if (t.anchor) {
                t.anchorTarget = n
            }
            r = parseInt(t.activeTarget.showDelay, 10);
            if (r) {
                i = t.showDelay;
                t.showDelay = r
            }
            t.delayShow();
            if (r) {
                t.showDelay = i
            }
        }
    },
    onTargetOut: function(e) {
        var t = this,
        n = t.activeTarget,
        r, i;
        if (n && e.within(t.activeTarget.el) && !t.getTipCfg(e)) {
            return
        }
        t.clearTimer("show");
        delete t.activeTarget;
        if (t.autoHide !== false) {
            r = n && parseInt(n.hideDelay, 10);
            if (r) {
                i = t.hideDelay;
                t.hideDelay = r
            }
            t.delayHide();
            if (r) {
                t.hideDelay = i
            }
        }
    },
    targetTextEmpty: function() {
        var e = this,
        t = e.activeTarget,
        n = e.tagConfig,
        r, i;
        if (t) {
            r = t.el;
            if (r) {
                i = r.getAttribute(n.namespace + n.attribute) || e.interceptTitles;
                if (!i && !e.targets[Ext.id(t.target)]) {
                    return true
                }
            }
        }
        return false
    },
    show: function() {
        var e = this,
        t = e.fromDelayShow;
        if (t && e.targetTextEmpty()) {
            e.onShowVeto();
            delete e.activeTarget;
            return
        }
        e.callParent(arguments)
    },
    showAt: function(e) {
        var t = this,
        n = t.activeTarget,
        r = t.header,
        i, s;
        if (n) {
            if (!t.rendered) {
                t.render(Ext.getBody());
                t.activeTarget = n
            }
            t.suspendLayouts();
            if (n.title) {
                t.setTitle(n.title);
                r.show()
            } else {
                if (r) {
                    r.hide()
                }
            }
            t.update(n.text);
            t.autoHide = n.autoHide;
            i = n.dismissDelay;
            t.dismissDelay = Ext.isNumber(i) ? i: t.dismissDelay;
            if (n.mouseOffset) {
                e[0] += n.mouseOffset[0];
                e[1] += n.mouseOffset[1]
            }
            s = t.lastCls;
            if (s) {
                t.removeCls(s);
                delete t.lastCls
            }
            s = n.cls;
            if (s) {
                t.addCls(s);
                t.lastCls = s
            }
            t.setWidth(n.width);
            if (t.anchor) {
                t.constrainPosition = false
            } else {
                if (n.align) {
                    e = t.getAlignToXY(n.el, n.align);
                    t.constrainPosition = false
                } else {
                    t.constrainPosition = true
                }
            }
            t.resumeLayouts(true)
        }
        t.callParent([e])
    },
    hide: function() {
        delete this.activeTarget;
        this.callParent()
    }
});
Ext.define("Ext.tip.QuickTipManager", {
    singleton: true,
    alternateClassName: "Ext.QuickTips",
    disabled: false,
    init: function(e, t) {
        var n = this;
        if (!n.tip) {
            if (!Ext.isReady) {
                Ext.onReady(function() {
                    Ext.tip.QuickTipManager.init(e, t)
                });
                return false
            }
            var r = Ext.apply({
                disabled: n.disabled,
                id: "ext-quicktips-tip"
            },
            t),
            i = r.className,
            s = r.xtype;
            if (i) {
                delete r.className
            } else {
                if (s) {
                    i = "widget." + s;
                    delete r.xtype
                }
            }
            if (e !== false) {
                r.renderTo = document.body
            }
            n.tip = Ext.create(i || "Ext.tip.QuickTip", r);
            Ext.quickTipsActive = true
        }
    },
    destroy: function() {
        Ext.destroy(this.tip);
        this.tip = undefined
    },
    ddDisable: function() {
        var e = this,
        t = e.tip;
        if (t && !e.disabled) {
            t.disable()
        }
    },
    ddEnable: function() {
        var e = this,
        t = e.tip;
        if (t && !e.disabled) {
            t.enable()
        }
    },
    enable: function() {
        var e = this,
        t = e.tip;
        if (t) {
            t.enable()
        }
        e.disabled = false
    },
    disable: function() {
        var e = this,
        t = e.tip;
        if (t) {
            t.disable()
        }
        e.disabled = true
    },
    isEnabled: function() {
        var e = this.tip;
        return e !== undefined && !e.disabled
    },
    getQuickTip: function() {
        return this.tip
    },
    register: function() {
        var e = this.tip;
        e.register.apply(e, arguments)
    },
    unregister: function() {
        var e = this.tip;
        e.unregister.apply(e, arguments)
    },
    tips: function() {
        var e = this.tip;
        e.register.apply(e, arguments)
    }
});
Ext.define("Ext.app.Application", {
    extend: Ext.app.Controller,
    scope: undefined,
    enableQuickTips: true,
    appFolder: "app",
    appProperty: "app",
    namespaces: [],
    autoCreateViewport: false,
    paths: null,
    onClassExtended: function(e, t, n) {
        var r = Ext.app.Controller,
        i = e.prototype,
        s = [],
        o,
        u,
        a,
        f,
        l;
        a = t.name || e.superclass.name;
        l = t.appFolder || e.superclass.appFolder;
        if (a) {
            t.$namespace = a;
            Ext.app.addNamespaces(a)
        }
        if (t.namespaces) {
            Ext.app.addNamespaces(t.namespaces)
        }
        if (!t["paths processed"]) {
            if (a && l) {
                Ext.Loader.setPath(a, l)
            }
            u = t.paths;
            if (u) {
                for (f in u) {
                    if (u.hasOwnProperty(f)) {
                        Ext.Loader.setPath(f, u[f])
                    }
                }
            }
        } else {
            delete t["paths processed"]
        }
        if (t.autoCreateViewport) {
            r.processDependencies(i, s, a, "view", ["Viewport"])
        }
        if (s.length) {
            o = n.onBeforeCreated;
            n.onBeforeCreated = function(e, t) {
                var n = Ext.Array.clone(arguments);
                Ext.require(s,
                function() {
                    return o.apply(this, n)
                })
            }
        }
    },
    constructor: function(e) {
        var t = this;
        t.callParent(arguments);
        t.doInit(t);
        t.initNamespace();
        t.initControllers();
        t.onBeforeLaunch();
        t.finishInitControllers()
    },
    initNamespace: function() {
        var e = this,
        t = e.appProperty,
        n;
        n = Ext.namespace(e.name);
        if (n) {
            n.getApplication = function() {
                return e
            };
            if (t) {
                if (!n[t]) {
                    n[t] = e
                }
            }
        }
    },
    initControllers: function() {
        var e = this,
        t = Ext.Array.from(e.controllers);
        e.controllers = new Ext.util.MixedCollection;
        for (var n = 0,
        r = t.length; n < r; n++) {
            e.getController(t[n])
        }
    },
    finishInitControllers: function() {
        var e = this,
        t, n, r;
        t = e.controllers.getRange();
        for (n = 0, r = t.length; n < r; n++) {
            t[n].finishInit(e)
        }
    },
    launch: Ext.emptyFn,
    onBeforeLaunch: function() {
        var e = this,
        t, n, r, i;
        if (e.enableQuickTips) {
            e.initQuickTips()
        }
        if (e.autoCreateViewport) {
            e.initViewport()
        }
        e.launch.call(e.scope || e);
        e.launched = true;
        e.fireEvent("launch", e);
        t = e.controllers.items;
        r = t.length;
        for (n = 0; n < r; n++) {
            i = t[n];
            i.onLaunch(e)
        }
    },
    getModuleClassName: function(e, t) {
        return Ext.app.Controller.getFullName(e, t, this.name).absoluteName
    },
    initQuickTips: function() {
        Ext.tip.QuickTipManager.init()
    },
    initViewport: function() {
        var e = this.getView("Viewport");
        if (e) {
            e.create()
        }
    },
    getController: function(e) {
        var t = this,
        n = t.controllers,
        r, i;
        i = n.get(e);
        if (!i) {
            r = t.getModuleClassName(e, "controller");
            i = Ext.create(r, {
                application: t,
                id: e
            });
            n.add(i);
            if (t._initialized) {
                i.doInit(t)
            }
        }
        return i
    },
    getApplication: function() {
        return this
    }
});
Ext.define("Ext.app.domain.Controller", {
    extend: Ext.app.EventDomain,
    singleton: true,
    type: "controller",
    idProperty: "id",
    constructor: function() {
        var e = this;
        e.callParent();
        e.monitor(Ext.app.Controller)
    }
});
Ext.define("Ext.direct.Provider", {
    alias: "direct.provider",
    mixins: {
        observable: Ext.util.Observable
    },
    isProvider: true,
    constructor: function(e) {
        var t = this;
        Ext.apply(t, e);
        Ext.applyIf(t, {
            id: Ext.id(null, "provider-")
        });
        t.addEvents("connect", "disconnect", "data", "exception");
        t.mixins.observable.constructor.call(t, e)
    },
    isConnected: function() {
        return false
    },
    connect: Ext.emptyFn,
    disconnect: Ext.emptyFn
});
Ext.define("Ext.app.domain.Direct", {
    extend: Ext.app.EventDomain,
    singleton: true,
    type: "direct",
    idProperty: "id",
    constructor: function() {
        var e = this;
        e.callParent();
        e.monitor(Ext.direct.Provider)
    }
});
Ext.define("Ext.button.Split", {
    alias: "widget.splitbutton",
    extend: Ext.button.Button,
    alternateClassName: "Ext.SplitButton",
    arrowCls: "split",
    split: true,
    initComponent: function() {
        this.callParent();
        this.addEvents("arrowclick")
    },
    setArrowHandler: function(e, t) {
        this.arrowHandler = e;
        this.scope = t
    },
    onClick: function(e) {
        var t = this;
        t.doPreventDefault(e);
        if (!t.disabled) {
            if (t.overMenuTrigger) {
                e.preventDefault();
                t.maybeShowMenu();
                t.fireEvent("arrowclick", t, e);
                if (t.arrowHandler) {
                    t.arrowHandler.call(t.scope || t, t, e)
                }
            } else {
                t.doToggle();
                t.fireHandler(e)
            }
        }
    }
});
Ext.define("Ext.button.Cycle", {
    alias: "widget.cycle",
    extend: Ext.button.Split,
    alternateClassName: "Ext.CycleButton",
    getButtonText: function(e) {
        var t = this,
        n = "";
        if (e && t.showText === true) {
            if (t.prependText) {
                n += t.prependText
            }
            n += e.text;
            return n
        }
        return t.text
    },
    setActiveItem: function(e, t) {
        var n = this;
        if (!Ext.isObject(e)) {
            e = n.menu.getComponent(e)
        }
        if (e) {
            if (!n.rendered) {
                n.text = n.getButtonText(e);
                n.iconCls = e.iconCls;
                n.glyph = e.glyph
            } else {
                n.setText(n.getButtonText(e));
                n.setIconCls(e.iconCls);
                n.setGlyph(e.glyph)
            }
            n.activeItem = e;
            if (!e.checked) {
                e.setChecked(true, false)
            }
            if (n.forceIcon) {
                n.setIconCls(n.forceIcon)
            }
            if (n.forceGlyph) {
                n.setGlyph(n.forceGlyph)
            }
            if (!t) {
                n.fireEvent("change", n, e)
            }
        }
    },
    getActiveItem: function() {
        return this.activeItem
    },
    initComponent: function() {
        var e = this,
        t = 0,
        n, r, i, s;
        e.addEvents("change");
        if (e.changeHandler) {
            e.on("change", e.changeHandler, e.scope || e);
            delete e.changeHandler
        }
        n = (e.menu.items || []).concat(e.items || []);
        e.menu = Ext.applyIf({
            cls: Ext.baseCSSPrefix + "cycle-menu",
            items: []
        },
        e.menu);
        i = n.length;
        for (r = 0; r < i; r++) {
            s = n[r];
            s = Ext.applyIf({
                group: e.id,
                itemIndex: r,
                checkHandler: e.checkHandler,
                scope: e,
                checked: s.checked || false
            },
            s);
            e.menu.items.push(s);
            if (s.checked) {
                t = r
            }
        }
        e.itemCount = e.menu.items.length;
        e.callParent(arguments);
        e.on("click", e.toggleSelected, e);
        e.setActiveItem(t, e);
        if (e.width && e.showText) {
            e.addCls(Ext.baseCSSPrefix + "cycle-fixed-width")
        }
    },
    checkHandler: function(e, t) {
        if (t) {
            this.setActiveItem(e)
        }
    },
    toggleSelected: function() {
        var e = this,
        t = e.menu,
        n;
        n = e.activeItem.next(":not([disabled])") || t.items.getAt(0);
        n.setChecked(true)
    }
});
Ext.define("Ext.chart.Callout", {
    constructor: function(e) {
        if (e.callouts) {
            e.callouts.styles = Ext.applyIf(e.callouts.styles || {},
            {
                color: "#000",
                font: "11px Helvetica, sans-serif"
            });
            this.callouts = Ext.apply(this.callouts || {},
            e.callouts);
            this.calloutsArray = []
        }
    },
    renderCallouts: function() {
        if (!this.callouts) {
            return
        }
        var e = this,
        t = e.items,
        n = e.chart.animate,
        r = e.callouts,
        i = r.styles,
        s = e.calloutsArray,
        o = e.chart.getChartStore(),
        u = o.getCount(),
        a = t.length / u,
        f = [],
        l,
        c,
        h,
        p,
        d,
        v,
        m,
        g;
        for (l = 0, c = 0; l < u; l++) {
            for (h = 0; h < a; h++) {
                d = t[c];
                v = s[c];
                m = o.getAt(l);
                g = !r.filter || r.filter(m);
                if (!g && !v) {
                    c++;
                    continue
                }
                if (!v) {
                    s[c] = v = e.onCreateCallout(m, d, l, g, h, c)
                }
                for (p in v) {
                    if (v[p] && v[p].setAttributes) {
                        v[p].setAttributes(i, true)
                    }
                }
                if (!g) {
                    for (p in v) {
                        if (v[p]) {
                            if (v[p].setAttributes) {
                                v[p].setAttributes({
                                    hidden: true
                                },
                                true)
                            } else {
                                if (v[p].setVisible) {
                                    v[p].setVisible(false)
                                }
                            }
                        }
                    }
                }
                if (r && r.renderer) {
                    r.renderer(v, m)
                }
                e.onPlaceCallout(v, m, d, l, g, n, h, c, f);
                f.push(v);
                c++
            }
        }
        this.hideCallouts(c)
    },
    onCreateCallout: function(e, t, n, r) {
        var i = this,
        s = i.calloutsGroup,
        o = i.callouts,
        u = o ? o.styles: undefined,
        a = u ? u.width: 0,
        f = u ? u.height: 0,
        l = i.chart,
        c = l.surface,
        h = {
            lines: false
        };
        h.lines = c.add(Ext.apply({},
        {
            type: "path",
            path: "M0,0",
            stroke: i.getLegendColor() || "#555"
        },
        u));
        if (o.items) {
            h.panel = new Ext.Panel({
                style: "position: absolute;",
                width: a,
                height: f,
                items: o.items,
                renderTo: l.el
            })
        }
        return h
    },
    hideCallouts: function(e) {
        var t = this.calloutsArray,
        n = t.length,
        r, i;
        while (n-->e) {
            r = t[n];
            for (i in r) {
                if (r[i]) {
                    r[i].hide(true)
                }
            }
        }
    }
});
Ext.define("Ext.draw.CompositeSprite", {
    extend: Ext.util.MixedCollection,
    mixins: {
        animate: Ext.util.Animate
    },
    autoDestroy: false,
    isCompositeSprite: true,
    constructor: function(e) {
        var t = this;
        e = e || {};
        Ext.apply(t, e);
        t.addEvents("mousedown", "mouseup", "mouseover", "mouseout", "click");
        t.id = Ext.id(null, "ext-sprite-group-");
        t.callParent()
    },
    onClick: function(e) {
        this.fireEvent("click", e)
    },
    onMouseUp: function(e) {
        this.fireEvent("mouseup", e)
    },
    onMouseDown: function(e) {
        this.fireEvent("mousedown", e)
    },
    onMouseOver: function(e) {
        this.fireEvent("mouseover", e)
    },
    onMouseOut: function(e) {
        this.fireEvent("mouseout", e)
    },
    attachEvents: function(e) {
        var t = this;
        e.on({
            scope: t,
            mousedown: t.onMouseDown,
            mouseup: t.onMouseUp,
            mouseover: t.onMouseOver,
            mouseout: t.onMouseOut,
            click: t.onClick
        })
    },
    add: function(e, t) {
        var n = this.callParent(arguments);
        this.attachEvents(n);
        return n
    },
    insert: function(e, t, n) {
        return this.callParent(arguments)
    },
    remove: function(e) {
        var t = this;
        e.un({
            scope: t,
            mousedown: t.onMouseDown,
            mouseup: t.onMouseUp,
            mouseover: t.onMouseOver,
            mouseout: t.onMouseOut,
            click: t.onClick
        });
        return t.callParent(arguments)
    },
    getBBox: function() {
        var e = 0,
        t, n, r = this.items,
        i = this.length,
        s = Infinity,
        o = s,
        u = -s,
        a = s,
        f = -s,
        l, c;
        for (; e < i; e++) {
            t = r[e];
            if (t.el && !t.bboxExcluded) {
                n = t.getBBox();
                o = Math.min(o, n.x);
                a = Math.min(a, n.y);
                u = Math.max(u, n.height + n.y);
                f = Math.max(f, n.width + n.x)
            }
        }
        return {
            x: o,
            y: a,
            height: u - a,
            width: f - o
        }
    },
    setAttributes: function(e, t) {
        var n = 0,
        r = this.items,
        i = this.length;
        for (; n < i; n++) {
            r[n].setAttributes(e, t)
        }
        return this
    },
    hide: function(e) {
        var t = 0,
        n = this.items,
        r = this.length;
        for (; t < r; t++) {
            n[t].hide(e)
        }
        return this
    },
    show: function(e) {
        var t = 0,
        n = this.items,
        r = this.length;
        for (; t < r; t++) {
            n[t].show(e)
        }
        return this
    },
    redraw: function() {
        var e = this,
        t = 0,
        n = e.items,
        r = e.getSurface(),
        i = e.length;
        if (r) {
            for (; t < i; t++) {
                r.renderItem(n[t])
            }
        }
        return e
    },
    setStyle: function(e) {
        var t = 0,
        n = this.items,
        r = this.length,
        i, s;
        for (; t < r; t++) {
            i = n[t];
            s = i.el;
            if (s) {
                s.setStyle(e)
            }
        }
    },
    addCls: function(e) {
        var t = 0,
        n = this.items,
        r = this.getSurface(),
        i = this.length;
        if (r) {
            for (; t < i; t++) {
                r.addCls(n[t], e)
            }
        }
    },
    removeCls: function(e) {
        var t = 0,
        n = this.items,
        r = this.getSurface(),
        i = this.length;
        if (r) {
            for (; t < i; t++) {
                r.removeCls(n[t], e)
            }
        }
    },
    getSurface: function() {
        var e = this.first();
        if (e) {
            return e.surface
        }
        return null
    },
    destroy: function() {
        var e = this,
        t = e.getSurface(),
        n = e.autoDestroy,
        r;
        if (t) {
            while (e.getCount() > 0) {
                r = e.first();
                e.remove(r);
                t.remove(r, n)
            }
        }
        e.clearListeners()
    }
});
Ext.define("Ext.draw.Surface", {
    mixins: {
        observable: Ext.util.Observable
    },
    separatorRe: /[, ]+/,
    enginePriority: ["Svg", "Vml"],
    statics: {
        create: function(e, t) {
            t = t || this.prototype.enginePriority;
            var n = 0,
            r = t.length;
            for (; n < r; n++) {
                if (Ext.supports[t[n]]) {
                    return Ext.create("Ext.draw.engine." + t[n], e)
                }
            }
            return false
        },
        save: function(e, t) {
            t = t || {};
            var n = {
                "image/png": "Image",
                "image/jpeg": "Image",
                "image/svg+xml": "Svg"
            },
            r = n[t.type] || "Svg",
            i = Ext.draw.engine[r + "Exporter"];
            return i.generate(e, t)
        }
    },
    availableAttrs: {
        blur: 0,
        "clip-rect": "0 0 1e9 1e9",
        cursor: "default",
        cx: 0,
        cy: 0,
        "dominant-baseline": "auto",
        fill: "none",
        "fill-opacity": 1,
        font: '10px "Arial"',
        "font-family": '"Arial"',
        "font-size": "10",
        "font-style": "normal",
        "font-weight": 400,
        gradient: "",
        height: 0,
        hidden: false,
        href: "http://sencha.com/",
        opacity: 1,
        path: "M0,0",
        radius: 0,
        rx: 0,
        ry: 0,
        scale: "1 1",
        src: "",
        stroke: "none",
        "stroke-dasharray": "",
        "stroke-linecap": "butt",
        "stroke-linejoin": "butt",
        "stroke-miterlimit": 0,
        "stroke-opacity": 1,
        "stroke-width": 1,
        target: "_blank",
        text: "",
        "text-anchor": "middle",
        title: "Ext Draw",
        width: 0,
        x: 0,
        y: 0,
        zIndex: 0
    },
    container: undefined,
    height: 352,
    width: 512,
    x: 0,
    y: 0,
    orderSpritesByZIndex: true,
    constructor: function(e) {
        var t = this;
        e = e || {};
        Ext.apply(t, e);
        t.domRef = Ext.getDoc().dom;
        t.customAttributes = {};
        t.addEvents("mousedown", "mouseup", "mouseover", "mouseout", "mousemove", "mouseenter", "mouseleave", "click", "dblclick");
        t.mixins.observable.constructor.call(t);
        t.getId();
        t.initGradients();
        t.initItems();
        if (t.renderTo) {
            t.render(t.renderTo);
            delete t.renderTo
        }
        t.initBackground(e.background)
    },
    initSurface: Ext.emptyFn,
    renderItem: Ext.emptyFn,
    renderItems: Ext.emptyFn,
    setViewBox: function(e, t, n, r) {
        if (isFinite(e) && isFinite(t) && isFinite(n) && isFinite(r)) {
            this.viewBox = {
                x: e,
                y: t,
                width: n,
                height: r
            };
            this.applyViewBox()
        }
    },
    addCls: Ext.emptyFn,
    removeCls: Ext.emptyFn,
    setStyle: Ext.emptyFn,
    initGradients: function() {
        if (this.hasOwnProperty("gradients")) {
            var e = this.gradients,
            t = this.addGradient,
            n, r;
            if (e) {
                for (n = 0, r = e.length; n < r; n++) {
                    if (t.call(this, e[n], n, r) === false) {
                        break
                    }
                }
            }
        }
    },
    initItems: function() {
        var e = this.items;
        this.items = new Ext.draw.CompositeSprite;
        this.items.autoDestroy = true;
        this.groups = new Ext.draw.CompositeSprite;
        if (e) {
            this.add(e)
        }
    },
    initBackground: function(e) {
        var t = this,
        n = t.width,
        r = t.height,
        i, s;
        if (Ext.isString(e)) {
            e = {
                fill: e
            }
        }
        if (e) {
            if (e.gradient) {
                s = e.gradient;
                i = s.id;
                t.addGradient(s);
                t.background = t.add({
                    type: "rect",
                    isBackground: true,
                    x: 0,
                    y: 0,
                    width: n,
                    height: r,
                    fill: "url(#" + i + ")",
                    zIndex: -1
                })
            } else {
                if (e.fill) {
                    t.background = t.add({
                        type: "rect",
                        isBackground: true,
                        x: 0,
                        y: 0,
                        width: n,
                        height: r,
                        fill: e.fill,
                        zIndex: -1
                    })
                } else {
                    if (e.image) {
                        t.background = t.add({
                            type: "image",
                            isBackground: true,
                            x: 0,
                            y: 0,
                            width: n,
                            height: r,
                            src: e.image,
                            zIndex: -1
                        })
                    }
                }
            }
            t.background.bboxExcluded = true
        }
    },
    setSize: function(e, t) {
        this.applyViewBox()
    },
    scrubAttrs: function(e) {
        var t, n = {},
        r = {},
        i = e.attr;
        for (t in i) {
            if (this.translateAttrs.hasOwnProperty(t)) {
                n[this.translateAttrs[t]] = i[t];
                r[this.translateAttrs[t]] = true
            } else {
                if (this.availableAttrs.hasOwnProperty(t) && !r[t]) {
                    n[t] = i[t]
                }
            }
        }
        return n
    },
    onClick: function(e) {
        this.processEvent("click", e)
    },
    onDblClick: function(e) {
        this.processEvent("dblclick", e)
    },
    onMouseUp: function(e) {
        this.processEvent("mouseup", e)
    },
    onMouseDown: function(e) {
        this.processEvent("mousedown", e)
    },
    onMouseOver: function(e) {
        this.processEvent("mouseover", e)
    },
    onMouseOut: function(e) {
        this.processEvent("mouseout", e)
    },
    onMouseMove: function(e) {
        this.fireEvent("mousemove", e)
    },
    onMouseEnter: Ext.emptyFn,
    onMouseLeave: Ext.emptyFn,
    addGradient: Ext.emptyFn,
    add: function() {
        var e = Array.prototype.slice.call(arguments),
        t,
        n = e.length > 1,
        r,
        i,
        s,
        o,
        u;
        if (n || Ext.isArray(e[0])) {
            r = n ? e: e[0];
            i = [];
            for (s = 0, o = r.length; s < o; s++) {
                u = r[s];
                u = this.add(u);
                i.push(u)
            }
            return i
        }
        t = this.prepareItems(e[0], true)[0];
        this.insertByZIndex(t);
        this.onAdd(t);
        return t
    },
    insertByZIndex: function(e) {
        var t = this,
        n = t.items.items,
        r = n.length,
        i = Math.ceil,
        s = e.attr.zIndex,
        o = r,
        u = o - 1,
        a = 0,
        f;
        if (t.orderSpritesByZIndex && r && s < n[u].attr.zIndex) {
            while (a <= u) {
                o = i((a + u) / 2);
                f = n[o].attr.zIndex;
                if (f > s) {
                    u = o - 1
                } else {
                    if (f < s) {
                        a = o + 1
                    } else {
                        break
                    }
                }
            }
            while (o < r && n[o].attr.zIndex <= s) {
                o++
            }
        }
        t.items.insert(o, e);
        return o
    },
    onAdd: function(e) {
        var t = e.group,
        n = e.draggable,
        r, i, s;
        if (t) {
            r = [].concat(t);
            i = r.length;
            for (s = 0; s < i; s++) {
                t = r[s];
                this.getGroup(t).add(e)
            }
            delete e.group
        }
        if (n) {
            e.initDraggable()
        }
    },
    remove: function(e, t) {
        if (e) {
            this.items.remove(e);
            var n = [].concat(this.groups.items),
            r = n.length,
            i;
            for (i = 0; i < r; i++) {
                n[i].remove(e)
            }
            e.onRemove();
            if (t === true) {
                e.destroy()
            }
        }
    },
    removeAll: function(e) {
        var t = this.items.items,
        n = t.length,
        r;
        for (r = n - 1; r > -1; r--) {
            this.remove(t[r], e)
        }
    },
    onRemove: Ext.emptyFn,
    onDestroy: Ext.emptyFn,
    applyViewBox: function() {
        var e = this,
        t = e.viewBox,
        n = e.width || 1,
        r = e.height || 1,
        i, s, o, u, a, f, l;
        if (t && (n || r)) {
            i = t.x;
            s = t.y;
            o = t.width;
            u = t.height;
            a = r / u;
            f = n / o;
            l = Math.min(f, a);
            if (o * l < n) {
                i -= (n - o * l) / 2 / l
            }
            if (u * l < r) {
                s -= (r - u * l) / 2 / l
            }
            e.viewBoxShift = {
                dx: -i,
                dy: -s,
                scale: l
            };
            if (e.background) {
                e.background.setAttributes(Ext.apply({},
                {
                    x: i,
                    y: s,
                    width: n / l,
                    height: r / l
                },
                {
                    hidden: false
                }), true)
            }
        } else {
            if (e.background && n && r) {
                e.background.setAttributes(Ext.apply({
                    x: 0,
                    y: 0,
                    width: n,
                    height: r
                },
                {
                    hidden: false
                }), true)
            }
        }
    },
    getBBox: function(e, t) {
        var n = this["getPath" + e.type](e);
        if (t) {
            e.bbox.plain = e.bbox.plain || Ext.draw.Draw.pathDimensions(n);
            return e.bbox.plain
        }
        if (e.dirtyTransform) {
            this.applyTransformations(e, true)
        }
        e.bbox.transform = e.bbox.transform || Ext.draw.Draw.pathDimensions(Ext.draw.Draw.mapPath(n, e.matrix));
        return e.bbox.transform
    },
    transformToViewBox: function(e, t) {
        if (this.viewBoxShift) {
            var n = this,
            r = n.viewBoxShift;
            return [e / r.scale - r.dx, t / r.scale - r.dy]
        } else {
            return [e, t]
        }
    },
    applyTransformations: function(e, t) {
        if (e.type == "text") {
            e.bbox.transform = 0;
            this.transform(e, false)
        }
        e.dirtyTransform = false;
        var n = this,
        r = e.attr;
        if (r.translation.x != null || r.translation.y != null) {
            n.translate(e)
        }
        if (r.scaling.x != null || r.scaling.y != null) {
            n.scale(e)
        }
        if (r.rotation.degrees != null) {
            n.rotate(e)
        }
        e.bbox.transform = 0;
        this.transform(e, t);
        e.transformations = []
    },
    rotate: function(e) {
        var t, n = e.attr.rotation.degrees,
        r = e.attr.rotation.x,
        i = e.attr.rotation.y;
        if (!Ext.isNumber(r) || !Ext.isNumber(i)) {
            t = this.getBBox(e, true);
            r = !Ext.isNumber(r) ? t.x + t.width / 2 : r;
            i = !Ext.isNumber(i) ? t.y + t.height / 2 : i
        }
        e.transformations.push({
            type: "rotate",
            degrees: n,
            x: r,
            y: i
        })
    },
    translate: function(e) {
        var t = e.attr.translation.x || 0,
        n = e.attr.translation.y || 0;
        e.transformations.push({
            type: "translate",
            x: t,
            y: n
        })
    },
    scale: function(e) {
        var t, n = e.attr.scaling.x || 1,
        r = e.attr.scaling.y || 1,
        i = e.attr.scaling.centerX,
        s = e.attr.scaling.centerY;
        if (!Ext.isNumber(i) || !Ext.isNumber(s)) {
            t = this.getBBox(e, true);
            i = !Ext.isNumber(i) ? t.x + t.width / 2 : i;
            s = !Ext.isNumber(s) ? t.y + t.height / 2 : s
        }
        e.transformations.push({
            type: "scale",
            x: n,
            y: r,
            centerX: i,
            centerY: s
        })
    },
    rectPath: function(e, t, n, r, i) {
        if (i) {
            return [["M", e + i, t], ["l", n - i * 2, 0], ["a", i, i, 0, 0, 1, i, i], ["l", 0, r - i * 2], ["a", i, i, 0, 0, 1, -i, i], ["l", i * 2 - n, 0], ["a", i, i, 0, 0, 1, -i, -i], ["l", 0, i * 2 - r], ["a", i, i, 0, 0, 1, i, -i], ["z"]]
        }
        return [["M", e, t], ["l", n, 0], ["l", 0, r], ["l", -n, 0], ["z"]]
    },
    ellipsePath: function(e, t, n, r) {
        if (r == null) {
            r = n
        }
        return [["M", e, t], ["m", 0, -r], ["a", n, r, 0, 1, 1, 0, 2 * r], ["a", n, r, 0, 1, 1, 0, -2 * r], ["z"]]
    },
    getPathpath: function(e) {
        return e.attr.path
    },
    getPathcircle: function(e) {
        var t = e.attr;
        return this.ellipsePath(t.x, t.y, t.radius, t.radius)
    },
    getPathellipse: function(e) {
        var t = e.attr;
        return this.ellipsePath(t.x, t.y, t.radiusX || t.width / 2 || 0, t.radiusY || t.height / 2 || 0)
    },
    getPathrect: function(e) {
        var t = e.attr;
        return this.rectPath(t.x || 0, t.y || 0, t.width || 0, t.height || 0, t.r || 0)
    },
    getPathimage: function(e) {
        var t = e.attr;
        return this.rectPath(t.x || 0, t.y || 0, t.width, t.height)
    },
    getPathtext: function(e) {
        var t = this.getBBoxText(e);
        return this.rectPath(t.x, t.y, t.width, t.height)
    },
    createGroup: function(e) {
        var t = this.groups.get(e);
        if (!t) {
            t = new Ext.draw.CompositeSprite({
                surface: this
            });
            t.id = e || Ext.id(null, "ext-surface-group-");
            this.groups.add(t)
        }
        return t
    },
    getGroup: function(e) {
        var t;
        if (typeof e == "string") {
            t = this.groups.get(e);
            if (!t) {
                t = this.createGroup(e)
            }
        } else {
            t = e
        }
        return t
    },
    prepareItems: function(e, t) {
        e = [].concat(e);
        var n, r, i;
        for (r = 0, i = e.length; r < i; r++) {
            n = e[r];
            if (! (n instanceof Ext.draw.Sprite)) {
                n.surface = this;
                e[r] = this.createItem(n)
            } else {
                n.surface = this
            }
        }
        return e
    },
    setText: Ext.emptyFn,
    createItem: Ext.emptyFn,
    getId: function() {
        return this.id || (this.id = Ext.id(null, "ext-surface-"))
    },
    destroy: function() {
        var e = this;
        delete e.domRef;
        if (e.background) {
            e.background.destroy()
        }
        e.removeAll(true);
        Ext.destroy(e.groups.items)
    }
});
Ext.define("Ext.layout.component.Draw", {
    alias: "layout.draw",
    extend: Ext.layout.component.Auto,
    setHeightInDom: true,
    setWidthInDom: true,
    type: "draw",
    measureContentWidth: function(e) {
        var t = e.target,
        n = e.getPaddingInfo(),
        r = this.getBBox(e);
        if (!t.viewBox) {
            if (t.autoSize) {
                return r.width + n.width
            } else {
                return r.x + r.width + n.width
            }
        } else {
            if (e.heightModel.shrinkWrap) {
                return n.width
            } else {
                return r.width / r.height * (e.getProp("contentHeight") - n.height) + n.width
            }
        }
    },
    measureContentHeight: function(e) {
        var t = e.target,
        n = e.getPaddingInfo(),
        r = this.getBBox(e);
        if (!e.target.viewBox) {
            if (t.autoSize) {
                return r.height + n.height
            } else {
                return r.y + r.height + n.height
            }
        } else {
            if (e.widthModel.shrinkWrap) {
                return n.height
            } else {
                return r.height / r.width * (e.getProp("contentWidth") - n.width) + n.height
            }
        }
    },
    getBBox: function(e) {
        var t = e.surfaceBBox;
        if (!t) {
            t = e.target.surface.items.getBBox();
            if (t.width === -Infinity && t.height === -Infinity) {
                t.width = t.height = t.x = t.y = 0
            }
            e.surfaceBBox = t
        }
        return t
    },
    publishInnerWidth: function(e, t) {
        e.setContentWidth(t - e.getFrameInfo().width, true)
    },
    publishInnerHeight: function(e, t) {
        e.setContentHeight(t - e.getFrameInfo().height, true)
    },
    finishedLayout: function(e) {
        var t = e.props,
        n = e.getPaddingInfo();
        this.owner.setSurfaceSize(t.contentWidth - n.width, t.contentHeight - n.height);
        this.callParent(arguments)
    }
});
Ext.define("Ext.draw.Component", {
    alias: "widget.draw",
    extend: Ext.Component,
    enginePriority: ["Svg", "Vml"],
    baseCls: Ext.baseCSSPrefix + "surface",
    componentLayout: "draw",
    viewBox: true,
    shrinkWrap: 3,
    autoSize: false,
    suspendSizing: 0,
    initComponent: function() {
        this.callParent(arguments);
        this.addEvents("mousedown", "mouseup", "mousemove", "mouseenter", "mouseleave", "click", "dblclick")
    },
    onRender: function() {
        this.callParent(arguments);
        if (this.createSurface() !== false) {
            this.configureSurfaceSize()
        }
    },
    configureSurfaceSize: function() {
        var e = this,
        t = e.viewBox,
        n = e.autoSize,
        r;
        if ((t || n) && !e.suspendSizing) {
            r = e.surface.items.getBBox();
            if (t) {
                e.surface.setViewBox(r.x, r.y, r.width, r.height)
            } else {
                e.autoSizeSurface(r)
            }
        }
    },
    autoSizeSurface: function(e) {
        e = e || this.surface.items.getBBox();
        this.setSurfaceSize(e.width, e.height)
    },
    setSurfaceSize: function(e, t) {
        this.surface.setSize(e, t);
        if (this.autoSize) {
            var n = this.surface.items.getBBox();
            this.surface.setViewBox(n.x, n.y - +Ext.isOpera, e, t)
        }
    },
    createSurface: function() {
        function r(t) {
            return function(n) {
                e.fireEvent(t, n)
            }
        }
        var e = this,
        t = Ext.applyIf({
            renderTo: e.el,
            height: e.height,
            width: e.width,
            items: e.items
        },
        e.initialConfig),
        n;
        delete t.listeners;
        if (!t.gradients) {
            t.gradients = e.gradients
        }
        e.initSurfaceCfg(t);
        n = Ext.draw.Surface.create(t, e.enginePriority);
        if (!n) {
            return false
        }
        e.surface = n;
        n.owner = e;
        n.on({
            scope: e,
            mouseup: r("mouseup"),
            mousedown: r("mousedown"),
            mousemove: r("mousemove"),
            mouseenter: r("mouseenter"),
            mouseleave: r("mouseleave"),
            click: r("click"),
            dblclick: r("dblclick")
        })
    },
    initSurfaceCfg: Ext.emptyFn,
    onDestroy: function() {
        Ext.destroy(this.surface);
        this.callParent(arguments)
    }
});
Ext.chart = Ext.chart || {};
Ext.define("Ext.chart.theme.Theme",
function() { (function() {
        Ext.chart.theme = function(e, t) {
            e = e || {};
            var n = 0,
            r = Ext.Date.now(),
            i,
            s,
            o,
            u,
            a,
            f,
            l,
            c,
            h = [],
            p,
            d;
            if (e.baseColor) {
                p = Ext.draw.Color.fromString(e.baseColor);
                d = p.getHSL()[2];
                if (d < .15) {
                    p = p.getLighter(.3)
                } else {
                    if (d < .3) {
                        p = p.getLighter(.15)
                    } else {
                        if (d > .85) {
                            p = p.getDarker(.3)
                        } else {
                            if (d > .7) {
                                p = p.getDarker(.15)
                            }
                        }
                    }
                }
                e.colors = [p.getDarker(.3).toString(), p.getDarker(.15).toString(), p.toString(), p.getLighter(.15).toString(), p.getLighter(.3).toString()];
                delete e.baseColor
            }
            if (e.colors) {
                s = e.colors.slice();
                a = t.markerThemes;
                u = t.seriesThemes;
                i = s.length;
                t.colors = s;
                for (; n < i; n++) {
                    o = s[n];
                    l = a[n] || {};
                    f = u[n] || {};
                    l.fill = f.fill = l.stroke = f.stroke = o;
                    a[n] = l;
                    u[n] = f
                }
                t.markerThemes = a.slice(0, i);
                t.seriesThemes = u.slice(0, i)
            }
            for (c in t) {
                if (c in e) {
                    if (Ext.isObject(e[c]) && Ext.isObject(t[c])) {
                        Ext.apply(t[c], e[c])
                    } else {
                        t[c] = e[c]
                    }
                }
            }
            if (e.useGradients) {
                s = t.colors ||
                function() {
                    var e = [];
                    for (n = 0, u = t.seriesThemes, i = u.length; n < i; n++) {
                        e.push(u[n].fill || u[n].stroke)
                    }
                    return e
                } ();
                for (n = 0, i = s.length; n < i; n++) {
                    p = Ext.draw.Color.fromString(s[n]);
                    if (p) {
                        o = p.getDarker(.1).toString();
                        p = p.toString();
                        c = "theme-" + p.substr(1) + "-" + o.substr(1) + "-" + r;
                        h.push({
                            id: c,
                            angle: 45,
                            stops: {
                                0 : {
                                    color: p.toString()
                                },
                                100 : {
                                    color: o.toString()
                                }
                            }
                        });
                        s[n] = "url(#" + c + ")"
                    }
                }
                t.gradients = h;
                t.colors = s
            }
            Ext.apply(this, t)
        }
    })();
    return {
        theme: "Base",
        themeAttrs: false,
        initTheme: function(e) {
            var t = this,
            n = Ext.chart.theme,
            r, i;
            if (e) {
                e = e.split(":");
                for (r in n) {
                    if (r == e[0]) {
                        i = e[1] == "gradients";
                        t.themeAttrs = new n[r]({
                            useGradients: i
                        });
                        if (i) {
                            t.gradients = t.themeAttrs.gradients
                        }
                        if (t.themeAttrs.background) {
                            t.background = t.themeAttrs.background
                        }
                        return
                    }
                }
            }
        }
    }
} ());
Ext.define("Ext.chart.MaskLayer", {
    extend: Ext.Component,
    constructor: function(e) {
        e = Ext.apply(e || {},
        {
            style: "position:absolute;background-color:#ff9;cursor:crosshair;opacity:0.5;border:1px solid #00f;"
        });
        this.callParent([e])
    },
    initComponent: function() {
        var e = this;
        e.callParent(arguments);
        e.addEvents("mousedown", "mouseup", "mousemove", "mouseenter", "mouseleave")
    },
    initDraggable: function() {
        this.callParent(arguments);
        this.dd.onStart = function(e) {
            var t = this,
            n = t.comp;
            this.startPosition = n.getPosition(true);
            if (n.ghost && !n.liveDrag) {
                t.proxy = n.ghost();
                t.dragTarget = t.proxy.header.el
            }
            if (t.constrain || t.constrainDelegate) {
                t.constrainTo = t.calculateConstrainRegion()
            }
        }
    }
});
Ext.define("Ext.chart.Mask", {
    constructor: function(e) {
        var t = this;
        t.addEvents("select");
        if (e) {
            Ext.apply(t, e)
        }
        if (t.enableMask) {
            t.on("afterrender",
            function() {
                var e = new Ext.chart.MaskLayer({
                    renderTo: t.el,
                    hidden: true
                });
                e.el.on({
                    mousemove: function(e) {
                        t.onMouseMove(e)
                    },
                    mouseup: function(e) {
                        t.onMouseUp(e)
                    }
                });
                e.initDraggable();
                t.maskType = t.mask;
                t.mask = e;
                t.maskSprite = t.surface.add({
                    type: "path",
                    path: ["M", 0, 0],
                    zIndex: 1001,
                    opacity: .6,
                    hidden: true,
                    stroke: "#00f",
                    cursor: "crosshair"
                })
            },
            t, {
                single: true
            })
        }
    },
    onMouseUp: function(e) {
        var t = this,
        n = t.bbox || t.chartBBox,
        r;
        t.maskMouseDown = false;
        t.mouseDown = false;
        if (t.mouseMoved) {
            t.handleMouseEvent(e);
            t.mouseMoved = false;
            r = t.maskSelection;
            t.fireEvent("select", t, {
                x: r.x - n.x,
                y: r.y - n.y,
                width: r.width,
                height: r.height
            })
        }
    },
    onMouseDown: function(e) {
        this.handleMouseEvent(e)
    },
    onMouseMove: function(e) {
        this.handleMouseEvent(e)
    },
    handleMouseEvent: function(e) {
        var t = this,
        n = t.maskType,
        r = t.bbox || t.chartBBox,
        i = r.x,
        s = r.y,
        o = Math,
        u = o.floor,
        a = o.abs,
        f = o.min,
        l = o.max,
        c = u(s + r.height),
        h = u(i + r.width),
        p = e.getPageX() - t.el.getX(),
        d = e.getPageY() - t.el.getY(),
        v = t.maskMouseDown,
        m;
        p = l(p, i);
        d = l(d, s);
        p = f(p, h);
        d = f(d, c);
        if (e.type === "mousedown") {
            t.mouseDown = true;
            t.mouseMoved = false;
            t.maskMouseDown = {
                x: p,
                y: d
            }
        } else {
            t.mouseMoved = t.mouseDown;
            if (v && t.mouseDown) {
                if (n == "horizontal") {
                    d = s;
                    v.y = c
                } else {
                    if (n == "vertical") {
                        p = i;
                        v.x = h
                    }
                }
                h = v.x - p;
                c = v.y - d;
                m = ["M", p, d, "l", h, 0, 0, c, -h, 0, "z"];
                t.maskSelection = {
                    x: (h > 0 ? p: p + h) + t.el.getX(),
                    y: (c > 0 ? d: d + c) + t.el.getY(),
                    width: a(h),
                    height: a(c)
                };
                t.mask.updateBox(t.maskSelection);
                t.mask.show();
                t.maskSprite.setAttributes({
                    hidden: true
                },
                true)
            } else {
                if (n == "horizontal") {
                    m = ["M", p, s, "L", p, c]
                } else {
                    if (n == "vertical") {
                        m = ["M", i, d, "L", h, d]
                    } else {
                        m = ["M", p, s, "L", p, c, "M", i, d, "L", h, d]
                    }
                }
                t.maskSprite.setAttributes({
                    path: m,
                    "stroke-width": n === true ? 1 : 1,
                    hidden: false
                },
                true)
            }
        }
    },
    onMouseLeave: function(e) {
        var t = this;
        t.mouseMoved = false;
        t.mouseDown = false;
        t.maskMouseDown = false;
        t.mask.hide();
        t.maskSprite.hide(true)
    }
});
Ext.define("Ext.chart.Navigation", {
    setZoom: function(e) {
        var t = this,
        n = t.axes.items,
        r, i, s, o = t.chartBBox,
        u = o.width,
        a = o.height,
        f = {
            x: e.x - t.el.getX(),
            y: e.y - t.el.getY(),
            width: e.width,
            height: e.height
        },
        l,
        c,
        h,
        p,
        d,
        v,
        m,
        g,
        y;
        for (r = 0, i = n.length; r < i; r++) {
            s = n[r];
            y = s.position == "bottom" || s.position == "top";
            if (s.type == "Category") {
                if (!d) {
                    d = t.getChartStore();
                    v = d.data.items.length
                }
                l = f;
                g = s.length;
                m = Math.round(g / v);
                if (y) {
                    h = l.x ? Math.floor(l.x / m) + 1 : 0;
                    p = (l.x + l.width) / m
                } else {
                    h = l.y ? Math.floor(l.y / m) + 1 : 0;
                    p = (l.y + l.height) / m
                }
            } else {
                l = {
                    x: f.x / u,
                    y: f.y / a,
                    width: f.width / u,
                    height: f.height / a
                };
                c = s.calcEnds();
                if (y) {
                    h = (c.to - c.from) * l.x + c.from;
                    p = (c.to - c.from) * l.width + h
                } else {
                    p = (c.to - c.from) * (1 - l.y) + c.from;
                    h = p - (c.to - c.from) * l.height
                }
            }
            s.minimum = h;
            s.maximum = p;
            if (y) {
                if (s.doConstrain && t.maskType != "vertical") {
                    s.doConstrain()
                }
            } else {
                if (s.doConstrain && t.maskType != "horizontal") {
                    s.doConstrain()
                }
            }
        }
        t.redraw(false)
    },
    restoreZoom: function() {
        var e = this,
        t = e.axes.items,
        n, r, i;
        e.setSubStore(null);
        for (n = 0, r = t.length; n < r; n++) {
            i = t[n];
            delete i.minimum;
            delete i.maximum
        }
        e.redraw(false)
    }
});
Ext.define("Ext.chart.Shape", {
    singleton: true,
    circle: function(e, t) {
        return e.add(Ext.apply({
            type: "circle",
            x: t.x,
            y: t.y,
            stroke: null,
            radius: t.radius
        },
        t))
    },
    line: function(e, t) {
        return e.add(Ext.apply({
            type: "rect",
            x: t.x - t.radius,
            y: t.y - t.radius,
            height: 2 * t.radius,
            width: 2 * t.radius / 5
        },
        t))
    },
    square: function(e, t) {
        return e.add(Ext.applyIf({
            type: "rect",
            x: t.x - t.radius,
            y: t.y - t.radius,
            height: 2 * t.radius,
            width: 2 * t.radius,
            radius: null
        },
        t))
    },
    triangle: function(e, t) {
        t.radius *= 1.75;
        return e.add(Ext.apply({
            type: "path",
            stroke: null,
            path: "M".concat(t.x, ",", t.y, "m0-", t.radius * .58, "l", t.radius * .5, ",", t.radius * .87, "-", t.radius, ",0z")
        },
        t))
    },
    diamond: function(e, t) {
        var n = t.radius;
        n *= 1.5;
        return e.add(Ext.apply({
            type: "path",
            stroke: null,
            path: ["M", t.x, t.y - n, "l", n, n, -n, n, -n, -n, n, -n, "z"]
        },
        t))
    },
    cross: function(e, t) {
        var n = t.radius;
        n = n / 1.7;
        return e.add(Ext.apply({
            type: "path",
            stroke: null,
            path: "M".concat(t.x - n, ",", t.y, "l", [ - n, -n, n, -n, n, n, n, -n, n, n, -n, n, n, n, -n, n, -n, -n, -n, n, -n, -n, "z"])
        },
        t))
    },
    plus: function(e, t) {
        var n = t.radius / 1.3;
        return e.add(Ext.apply({
            type: "path",
            stroke: null,
            path: "M".concat(t.x - n / 2, ",", t.y - n / 2, "l", [0, -n, n, 0, 0, n, n, 0, 0, n, -n, 0, 0, n, -n, 0, 0, -n, -n, 0, 0, -n, "z"])
        },
        t))
    },
    arrow: function(e, t) {
        var n = t.radius;
        return e.add(Ext.apply({
            type: "path",
            path: "M".concat(t.x - n * .7, ",", t.y - n * .4, "l", [n * .6, 0, 0, -n * .4, n, n * .8, -n, n * .8, 0, -n * .4, -n * .6, 0], "z")
        },
        t))
    },
    drop: function(e, t, n, r, i, s) {
        i = i || 30;
        s = s || 0;
        e.add({
            type: "path",
            path: ["M", t, n, "l", i, 0, "A", i * .4, i * .4, 0, 1, 0, t + i * .7, n - i * .7, "z"],
            fill: "#000",
            stroke: "none",
            rotate: {
                degrees: 22.5 - s,
                x: t,
                y: n
            }
        });
        s = (s + 90) * Math.PI / 180;
        e.add({
            type: "text",
            x: t + i * Math.sin(s) - 10,
            y: n + i * Math.cos(s) + 5,
            text: r,
            "font-size": i * 12 / 40,
            stroke: "none",
            fill: "#fff"
        })
    }
});
Ext.define("Ext.chart.LegendItem", {
    extend: Ext.draw.CompositeSprite,
    hiddenSeries: false,
    label: undefined,
    x: 0,
    y: 0,
    zIndex: 500,
    boldRe: /bold\s\d{1,}.*/i,
    constructor: function(e) {
        this.callParent(arguments);
        this.createLegend(e)
    },
    createLegend: function(e) {
        var t = this,
        n = t.series,
        r = e.yFieldIndex;
        t.label = t.createLabel(e);
        t.createSeriesMarkers(e);
        t.setAttributes({
            hidden: false
        },
        true);
        t.yFieldIndex = r;
        t.on("mouseover", t.onMouseOver, t);
        t.on("mouseout", t.onMouseOut, t);
        t.on("mousedown", t.onMouseDown, t);
        if (!n.visibleInLegend(r)) {
            t.hiddenSeries = true;
            t.label.setAttributes({
                opacity: .5
            },
            true)
        }
        t.updatePosition({
            x: 0,
            y: 0
        })
    },
    getLabelText: function() {
        function r(e) {
            var r = t[e];
            return Ext.isArray(r) ? r[n] : r
        }
        var e = this,
        t = e.series,
        n = e.yFieldIndex;
        return r("title") || r("yField")
    },
    createLabel: function(e) {
        var t = this,
        n = t.legend;
        return t.add("label", t.surface.add({
            type: "text",
            x: 20,
            y: 0,
            zIndex: (t.zIndex || 0) + 2,
            fill: n.labelColor,
            font: n.labelFont,
            text: t.getLabelText(),
            style: {
                cursor: "pointer"
            }
        }))
    },
    createSeriesMarkers: function(e) {
        var t = this,
        n = e.yFieldIndex,
        r = t.series,
        i = r.type,
        s = t.surface,
        o = t.zIndex;
        if (i === "line" || i === "scatter") {
            if (i === "line") {
                var u = Ext.apply(r.seriesStyle, r.style);
                t.drawLine(.5, .5, 16.5, .5, o, u, n)
            }
            if (r.showMarkers || i === "scatter") {
                var a = Ext.apply(r.markerStyle, r.markerConfig || {},
                {
                    fill: r.getLegendColor(n)
                });
                t.drawMarker(8.5, .5, o, a)
            }
        } else {
            t.drawFilledBox(12, 12, o, n)
        }
    },
    drawLine: function(e, t, n, r, i, s, o) {
        var u = this,
        a = u.surface,
        f = u.series;
        return u.add("line", a.add({
            type: "path",
            path: "M" + e + "," + t + "L" + n + "," + r,
            zIndex: (i || 0) + 2,
            "stroke-width": f.lineWidth,
            "stroke-linejoin": "round",
            "stroke-dasharray": f.dash,
            stroke: s.stroke || f.getLegendColor(o) || "#000",
            style: {
                cursor: "pointer"
            }
        }))
    },
    drawMarker: function(e, t, n, r) {
        var i = this,
        s = i.surface,
        o = i.series;
        return i.add("marker", Ext.chart.Shape[r.type](s, {
            fill: r.fill,
            x: e,
            y: t,
            zIndex: (n || 0) + 2,
            radius: r.radius || r.size,
            style: {
                cursor: "pointer"
            }
        }))
    },
    drawFilledBox: function(e, t, n, r) {
        var i = this,
        s = i.surface,
        o = i.series;
        return i.add("box", s.add({
            type: "rect",
            zIndex: (n || 0) + 2,
            x: 0,
            y: 0,
            width: e,
            height: t,
            fill: o.getLegendColor(r),
            style: {
                cursor: "pointer"
            }
        }))
    },
    onMouseOver: function() {
        var e = this;
        e.label.setStyle({
            "font-weight": "bold"
        });
        e.series._index = e.yFieldIndex;
        e.series.highlightItem()
    },
    onMouseOut: function() {
        var e = this,
        t = e.legend,
        n = e.boldRe;
        e.label.setStyle({
            "font-weight": t.labelFont && n.test(t.labelFont) ? "bold": "normal"
        });
        e.series._index = e.yFieldIndex;
        e.series.unHighlightItem()
    },
    onMouseDown: function() {
        var e = this,
        t = e.yFieldIndex;
        if (!e.hiddenSeries) {
            e.series.hideAll(t);
            e.label.setAttributes({
                opacity: .5
            },
            true)
        } else {
            e.series.showAll(t);
            e.label.setAttributes({
                opacity: 1
            },
            true)
        }
        e.hiddenSeries = !e.hiddenSeries;
        e.legend.chart.redraw()
    },
    updatePosition: function(e) {
        var t = this,
        n = t.items,
        r = n.length,
        i = t.x,
        s = t.y,
        o, u, a, f, l, c, h, p;
        if (!e) {
            e = t.legend
        }
        h = e.x;
        p = e.y;
        for (u = 0; u < r; u++) {
            l = true;
            o = n[u];
            switch (o.type) {
            case "text":
                a = 20 + h + i;
                f = p + s;
                l = false;
                break;
            case "rect":
                a = h + i;
                f = p + s - 6;
                break;
            default:
                a = h + i;
                f = p + s
            }
            c = {
                x: a,
                y: f
            };
            o.setAttributes(l ? {
                translate: c
            }: c, true)
        }
    }
});
Ext.define("Ext.chart.Legend", {
    visible: true,
    update: true,
    position: "bottom",
    x: 0,
    y: 0,
    labelColor: "#000",
    labelFont: "12px Helvetica, sans-serif",
    boxStroke: "#000",
    boxStrokeWidth: 1,
    boxFill: "#FFF",
    itemSpacing: 10,
    padding: 5,
    width: 0,
    height: 0,
    boxZIndex: 100,
    constructor: function(e) {
        var t = this;
        if (e) {
            Ext.apply(t, e)
        }
        t.items = [];
        t.isVertical = "left|right|float".indexOf(t.position) !== -1;
        t.origX = t.x;
        t.origY = t.y
    },
    create: function() {
        var e = this,
        t = e.chart.series.items,
        n, r, i;
        e.createBox();
        if (e.rebuild !== false) {
            e.createItems()
        }
        if (!e.created && e.isDisplayed()) {
            e.created = true;
            for (n = 0, r = t.length; n < r; n++) {
                i = t[n];
                i.on("titlechange", e.redraw, e)
            }
        }
    },
    init: Ext.emptyFn,
    redraw: function() {
        var e = this;
        e.create();
        e.updatePosition()
    },
    isDisplayed: function() {
        return this.visible && this.chart.series.findIndex("showInLegend", true) !== -1
    },
    createItems: function() {
        var e = this,
        t = e.chart.series.items,
        n = e.items,
        r, i, s, o, u, a, f;
        e.removeItems();
        for (i = 0, s = t.length; i < s; i++) {
            a = t[i];
            if (a.showInLegend) {
                r = [].concat(a.yField);
                for (o = 0, u = r.length; o < u; o++) {
                    f = e.createLegendItem(a, o);
                    n.push(f)
                }
            }
        }
        e.alignItems()
    },
    removeItems: function() {
        var e = this,
        t = e.items,
        n = t ? t.length: 0,
        r;
        if (n) {
            for (r = 0; r < n; r++) {
                t[r].destroy()
            }
        }
        t.length = []
    },
    alignItems: function() {
        var e = this,
        t = e.padding,
        n = e.isVertical,
        r = Math.floor,
        i, s, o, u, a;
        i = e.updateItemDimensions();
        s = i.maxWidth;
        o = i.maxHeight;
        u = i.totalWidth;
        a = i.totalHeight;
        e.width = r((n ? s: u) + t * 2);
        e.height = r((n ? a: o) + t * 2)
    },
    updateItemDimensions: function() {
        var e = this,
        t = e.items,
        n = e.padding,
        r = e.itemSpacing,
        i = 0,
        s = 0,
        o = 0,
        u = 0,
        a = e.isVertical,
        f = Math.floor,
        l = Math.max,
        c = 0,
        h, p, d, v, m, g;
        for (h = 0, p = t.length; h < p; h++) {
            d = t[h];
            v = d.getBBox();
            m = v.width;
            g = v.height;
            c = h === 0 ? 0 : r;
            d.x = n + f(a ? 0 : o + c);
            d.y = n + f(a ? u + c: 0) + g / 2;
            o += c + m;
            u += c + g;
            i = l(i, m);
            s = l(s, g)
        }
        return {
            totalWidth: o,
            totalHeight: u,
            maxWidth: i,
            maxHeight: s
        }
    },
    createLegendItem: function(e, t) {
        var n = this;
        return new Ext.chart.LegendItem({
            legend: n,
            series: e,
            surface: n.chart.surface,
            yFieldIndex: t
        })
    },
    getBBox: function() {
        var e = this;
        return {
            x: Math.round(e.x) - e.boxStrokeWidth / 2,
            y: Math.round(e.y) - e.boxStrokeWidth / 2,
            width: e.width + e.boxStrokeWidth,
            height: e.height + e.boxStrokeWidth
        }
    },
    createBox: function() {
        var e = this,
        t, n;
        if (e.boxSprite) {
            e.boxSprite.destroy()
        }
        n = e.getBBox();
        if (isNaN(n.width) || isNaN(n.height)) {
            e.boxSprite = false;
            return
        }
        t = e.boxSprite = e.chart.surface.add(Ext.apply({
            type: "rect",
            stroke: e.boxStroke,
            "stroke-width": e.boxStrokeWidth,
            fill: e.boxFill,
            zIndex: e.boxZIndex
        },
        n));
        t.redraw()
    },
    calcPosition: function() {
        var e = this,
        t, n, r = e.width,
        i = e.height,
        s = e.chart,
        o = s.chartBBox,
        u = s.insetPadding,
        a = o.width - u * 2,
        f = o.height - u * 2,
        l = o.x + u,
        c = o.y + u,
        h = s.surface,
        p = Math.floor;
        switch (e.position) {
        case "left":
            t = u;
            n = p(c + f / 2 - i / 2);
            break;
        case "right":
            t = p(h.width - r) - u;
            n = p(c + f / 2 - i / 2);
            break;
        case "top":
            t = p(l + a / 2 - r / 2);
            n = u;
            break;
        case "bottom":
            t = p(l + a / 2 - r / 2);
            n = p(h.height - i) - u;
            break;
        default:
            t = p(e.origX) + u;
            n = p(e.origY) + u
        }
        return {
            x: t,
            y: n
        }
    },
    updatePosition: function() {
        var e = this,
        t = e.items,
        n, r, i, s;
        if (e.isDisplayed()) {
            n = e.calcPosition();
            e.x = n.x;
            e.y = n.y;
            for (r = 0, i = t.length; r < i; r++) {
                t[r].updatePosition()
            }
            s = e.getBBox();
            if (isNaN(s.width) || isNaN(s.height)) {
                if (e.boxSprite) {
                    e.boxSprite.hide(true)
                }
            } else {
                if (!e.boxSprite) {
                    e.createBox()
                }
                e.boxSprite.setAttributes(s, true);
                e.boxSprite.show(true)
            }
        }
    },
    toggle: function(e) {
        var t = this,
        n = 0,
        r = t.items,
        i = r.length;
        if (t.boxSprite) {
            if (e) {
                t.boxSprite.show(true)
            } else {
                t.boxSprite.hide(true)
            }
        }
        for (; n < i; ++n) {
            if (e) {
                r[n].show(true)
            } else {
                r[n].hide(true)
            }
        }
        t.visible = e
    }
});
Ext.define("Ext.chart.theme.Base", {
    constructor: function(e) {
        var t = Ext.identityFn;
        Ext.chart.theme.call(this, e, {
            background: false,
            axis: {
                stroke: "#444",
                "stroke-width": 1
            },
            axisLabelTop: {
                fill: "#444",
                font: "12px Arial, Helvetica, sans-serif",
                spacing: 2,
                padding: 5,
                renderer: t
            },
            axisLabelRight: {
                fill: "#444",
                font: "12px Arial, Helvetica, sans-serif",
                spacing: 2,
                padding: 5,
                renderer: t
            },
            axisLabelBottom: {
                fill: "#444",
                font: "12px Arial, Helvetica, sans-serif",
                spacing: 2,
                padding: 5,
                renderer: t
            },
            axisLabelLeft: {
                fill: "#444",
                font: "12px Arial, Helvetica, sans-serif",
                spacing: 2,
                padding: 5,
                renderer: t
            },
            axisTitleTop: {
                font: "bold 18px Arial",
                fill: "#444"
            },
            axisTitleRight: {
                font: "bold 18px Arial",
                fill: "#444",
                rotate: {
                    x: 0,
                    y: 0,
                    degrees: 270
                }
            },
            axisTitleBottom: {
                font: "bold 18px Arial",
                fill: "#444"
            },
            axisTitleLeft: {
                font: "bold 18px Arial",
                fill: "#444",
                rotate: {
                    x: 0,
                    y: 0,
                    degrees: 270
                }
            },
            series: {
                "stroke-width": 0
            },
            seriesLabel: {
                font: "12px Arial",
                fill: "#333"
            },
            marker: {
                stroke: "#555",
                radius: 3,
                size: 3
            },
            colors: ["#94ae0a", "#115fa6", "#a61120", "#ff8809", "#ffd13e", "#a61187", "#24ad9a", "#7c7474", "#a66111"],
            seriesThemes: [{
                fill: "#94ae0a"
            },
            {
                fill: "#115fa6"
            },
            {
                fill: "#a61120"
            },
            {
                fill: "#ff8809"
            },
            {
                fill: "#ffd13e"
            },
            {
                fill: "#a61187"
            },
            {
                fill: "#24ad9a"
            },
            {
                fill: "#7c7474"
            },
            {
                fill: "#115fa6"
            },
            {
                fill: "#94ae0a"
            },
            {
                fill: "#a61120"
            },
            {
                fill: "#ff8809"
            },
            {
                fill: "#ffd13e"
            },
            {
                fill: "#a61187"
            },
            {
                fill: "#24ad9a"
            },
            {
                fill: "#7c7474"
            },
            {
                fill: "#a66111"
            }],
            markerThemes: [{
                fill: "#115fa6",
                type: "circle"
            },
            {
                fill: "#94ae0a",
                type: "cross"
            },
            {
                fill: "#115fa6",
                type: "plus"
            },
            {
                fill: "#94ae0a",
                type: "circle"
            },
            {
                fill: "#a61120",
                type: "cross"
            }]
        })
    }
},
function() {
    var e = ["#b1da5a", "#4ce0e7", "#e84b67", "#da5abd", "#4d7fe6", "#fec935"],
    t = ["Green", "Sky", "Red", "Purple", "Blue", "Yellow"],
    n = 0,
    r = 0,
    i = e.length,
    s = Ext.chart.theme,
    o = [["#f0a50a", "#c20024", "#2044ba", "#810065", "#7eae29"], ["#6d9824", "#87146e", "#2a9196", "#d39006", "#1e40ac"], ["#fbbc29", "#ce2e4e", "#7e0062", "#158b90", "#57880e"], ["#ef5773", "#fcbd2a", "#4f770d", "#1d3eaa", "#9b001f"], ["#7eae29", "#fdbe2a", "#910019", "#27b4bc", "#d74dbc"], ["#44dce1", "#0b2592", "#996e05", "#7fb325", "#b821a1"]],
    u = o.length;
    for (; n < i; n++) {
        s[t[n]] = function(e) {
            return Ext.extend(s.Base, {
                constructor: function(t) {
                    s.Base.prototype.constructor.call(this, Ext.apply({
                        baseColor: e
                    },
                    t))
                }
            })
        } (e[n])
    }
    for (n = 0; n < u; n++) {
        s["Category" + (n + 1)] = function(e) {
            return Ext.extend(s.Base, {
                constructor: function(t) {
                    s.Base.prototype.constructor.call(this, Ext.apply({
                        colors: e
                    },
                    t))
                }
            })
        } (o[n])
    }
});
Ext.define("Ext.chart.Chart", {
    extend: Ext.draw.Component,
    alias: "widget.chart",
    mixins: {
        themeManager: Ext.chart.theme.Theme,
        mask: Ext.chart.Mask,
        navigation: Ext.chart.Navigation,
        bindable: Ext.util.Bindable,
        observable: Ext.util.Observable
    },
    viewBox: false,
    animate: false,
    legend: false,
    insetPadding: 10,
    background: false,
    refreshBuffer: 1,
    constructor: function(e) {
        var t = this,
        n;
        e = Ext.apply({},
        e);
        t.initTheme(e.theme || t.theme);
        if (t.gradients) {
            Ext.apply(e, {
                gradients: t.gradients
            })
        }
        if (t.background) {
            Ext.apply(e, {
                background: t.background
            })
        }
        if (e.animate) {
            n = {
                easing: "ease",
                duration: 500
            };
            if (Ext.isObject(e.animate)) {
                e.animate = Ext.applyIf(e.animate, n)
            } else {
                e.animate = n
            }
        }
        t.mixins.observable.constructor.call(t, e);
        if (e.mask) {
            e = Ext.apply({
                enableMask: true
            },
            e)
        }
        if (e.enableMask) {
            t.mixins.mask.constructor.call(t, e)
        }
        t.mixins.navigation.constructor.call(t);
        t.callParent([e])
    },
    getChartStore: function() {
        return this.substore || this.store
    },
    initComponent: function() {
        var e = this,
        t, n;
        e.callParent();
        e.addEvents("itemmousedown", "itemmouseup", "itemmouseover", "itemmouseout", "itemclick", "itemdblclick", "itemdragstart", "itemdrag", "itemdragend", "beforerefresh", "refresh");
        Ext.applyIf(e, {
            zoom: {
                width: 1,
                height: 1,
                x: 0,
                y: 0
            }
        });
        e.maxGutters = {
            left: 0,
            right: 0,
            bottom: 0,
            top: 0
        };
        e.store = Ext.data.StoreManager.lookup(e.store);
        t = e.axes;
        e.axes = new Ext.util.MixedCollection(false,
        function(e) {
            return e.position
        });
        if (t) {
            e.axes.addAll(t)
        }
        n = e.series;
        e.series = new Ext.util.MixedCollection(false,
        function(e) {
            return e.seriesId || (e.seriesId = Ext.id(null, "ext-chart-series-"))
        });
        if (n) {
            e.series.addAll(n)
        }
        if (e.legend !== false) {
            e.legend = new Ext.chart.Legend(Ext.applyIf({
                chart: e
            },
            e.legend))
        }
        e.on({
            mousemove: e.onMouseMove,
            mouseleave: e.onMouseLeave,
            mousedown: e.onMouseDown,
            mouseup: e.onMouseUp,
            click: e.onClick,
            dblclick: e.onDblClick,
            scope: e
        })
    },
    afterComponentLayout: function(e, t, n, r) {
        var i = this;
        if (Ext.isNumber(e) && Ext.isNumber(t)) {
            if (e !== n || t !== r) {
                i.curWidth = e;
                i.curHeight = t;
                i.redraw(true);
                i.needsRedraw = false
            } else {
                if (i.needsRedraw) {
                    i.redraw();
                    i.needsRedraw = false
                }
            }
        }
        this.callParent(arguments)
    },
    redraw: function(e) {
        var t = this,
        n = t.series.items,
        r = n.length,
        i = t.axes.items,
        s = i.length,
        o = 0,
        u, a, f = t.chartBBox = {
            x: 0,
            y: 0,
            height: t.curHeight,
            width: t.curWidth
        },
        l = t.legend,
        c;
        t.surface.setSize(f.width, f.height);
        for (u = 0; u < r; u++) {
            a = n[u];
            if (!a.initialized) {
                c = t.initializeSeries(a, u, o)
            } else {
                c = a
            }
            c.onRedraw();
            if (Ext.isArray(a.yField)) {
                o += a.yField.length
            } else {++o
            }
        }
        for (u = 0; u < s; u++) {
            a = i[u];
            if (!a.initialized) {
                t.initializeAxis(a)
            }
        }
        for (u = 0; u < s; u++) {
            i[u].processView()
        }
        for (u = 0; u < s; u++) {
            i[u].drawAxis(true)
        }
        if (l !== false && l.visible) {
            if (l.update || !l.created) {
                l.create()
            }
        }
        t.alignAxes();
        if (l !== false && l.visible) {
            l.updatePosition()
        }
        t.getMaxGutters();
        t.resizing = !!e;
        for (u = 0; u < s; u++) {
            i[u].drawAxis()
        }
        for (u = 0; u < r; u++) {
            t.drawCharts(n[u])
        }
        t.resizing = false
    },
    afterRender: function() {
        var e = this,
        t = e.legend;
        e.callParent(arguments);
        if (e.categoryNames) {
            e.setCategoryNames(e.categoryNames)
        }
        if (t) {
            t.init()
        }
        e.bindStore(e.store, true);
        e.refresh();
        if (e.surface.engine === "Vml") {
            e.on("added", e.onAddedVml, e);
            e.mon(e.hierarchyEventSource, "added", e.onContainerAddedVml, e)
        }
    },
    onAddedVml: function() {
        this.needsRedraw = true
    },
    onContainerAddedVml: function(e) {
        if (this.isDescendantOf(e)) {
            this.needsRedraw = true
        }
    },
    getEventXY: function(e) {
        var t = this.surface.getRegion(),
        n = e.getXY(),
        r = n[0] - t.left,
        i = n[1] - t.top;
        return [r, i]
    },
    onClick: function(e) {
        this.handleClick("itemclick", e)
    },
    onDblClick: function(e) {
        this.handleClick("itemdblclick", e)
    },
    handleClick: function(e, t) {
        var n = this,
        r = n.getEventXY(t),
        i = n.series.items,
        s,
        o,
        u,
        a;
        for (s = 0, o = i.length; s < o; s++) {
            u = i[s];
            if (Ext.draw.Draw.withinBox(r[0], r[1], u.bbox)) {
                if (u.getItemForPoint) {
                    a = u.getItemForPoint(r[0], r[1]);
                    if (a) {
                        u.fireEvent(e, a)
                    }
                }
            }
        }
    },
    onMouseDown: function(e) {
        var t = this,
        n = t.getEventXY(e),
        r = t.series.items,
        i,
        s,
        o,
        u;
        if (t.enableMask) {
            t.mixins.mask.onMouseDown.call(t, e)
        }
        for (i = 0, s = r.length; i < s; i++) {
            o = r[i];
            if (Ext.draw.Draw.withinBox(n[0], n[1], o.bbox)) {
                if (o.getItemForPoint) {
                    u = o.getItemForPoint(n[0], n[1]);
                    if (u) {
                        o.fireEvent("itemmousedown", u)
                    }
                }
            }
        }
    },
    onMouseUp: function(e) {
        var t = this,
        n = t.getEventXY(e),
        r = t.series.items,
        i,
        s,
        o,
        u;
        if (t.enableMask) {
            t.mixins.mask.onMouseUp.call(t, e)
        }
        for (i = 0, s = r.length; i < s; i++) {
            o = r[i];
            if (Ext.draw.Draw.withinBox(n[0], n[1], o.bbox)) {
                if (o.getItemForPoint) {
                    u = o.getItemForPoint(n[0], n[1]);
                    if (u) {
                        o.fireEvent("itemmouseup", u)
                    }
                }
            }
        }
    },
    onMouseMove: function(e) {
        var t = this,
        n = t.getEventXY(e),
        r = t.series.items,
        i,
        s,
        o,
        u,
        a,
        f,
        l;
        if (t.enableMask) {
            t.mixins.mask.onMouseMove.call(t, e)
        }
        for (i = 0, s = r.length; i < s; i++) {
            o = r[i];
            if (Ext.draw.Draw.withinBox(n[0], n[1], o.bbox)) {
                if (o.getItemForPoint) {
                    u = o.getItemForPoint(n[0], n[1]);
                    a = o._lastItemForPoint;
                    f = o._lastStoreItem;
                    l = o._lastStoreField;
                    if (u !== a || u && (u.storeItem != f || u.storeField != l)) {
                        if (a) {
                            o.fireEvent("itemmouseout", a);
                            delete o._lastItemForPoint;
                            delete o._lastStoreField;
                            delete o._lastStoreItem
                        }
                        if (u) {
                            o.fireEvent("itemmouseover", u);
                            o._lastItemForPoint = u;
                            o._lastStoreItem = u.storeItem;
                            o._lastStoreField = u.storeField
                        }
                    }
                }
            } else {
                a = o._lastItemForPoint;
                if (a) {
                    o.fireEvent("itemmouseout", a);
                    delete o._lastItemForPoint;
                    delete o._lastStoreField;
                    delete o._lastStoreItem
                }
            }
        }
    },
    onMouseLeave: function(e) {
        var t = this,
        n = t.series.items,
        r, i, s;
        if (t.enableMask) {
            t.mixins.mask.onMouseLeave.call(t, e)
        }
        for (r = 0, i = n.length; r < i; r++) {
            s = n[r];
            delete s._lastItemForPoint
        }
    },
    delayRefresh: function() {
        var e = this;
        if (!e.refreshTask) {
            e.refreshTask = new Ext.util.DelayedTask(e.refresh, e)
        }
        e.refreshTask.delay(e.refreshBuffer)
    },
    refresh: function() {
        var e = this;
        if (e.rendered && e.curWidth !== undefined && e.curHeight !== undefined) {
            if (!e.isVisible(true)) {
                if (!e.refreshPending) {
                    e.setShowListeners("mon");
                    e.refreshPending = true
                }
                return
            }
            if (e.fireEvent("beforerefresh", e) !== false) {
                e.redraw();
                e.fireEvent("refresh", e)
            }
        }
    },
    onShow: function() {
        var e = this;
        e.callParent(arguments);
        if (e.refreshPending) {
            e.delayRefresh();
            e.setShowListeners("mun")
        }
        delete e.refreshPending
    },
    setShowListeners: function(e) {
        var t = this;
        t[e](t.hierarchyEventSource, {
            scope: t,
            single: true,
            show: t.forceRefresh,
            expand: t.forceRefresh
        })
    },
    doRefresh: function() {
        this.setSubStore(null);
        this.refresh()
    },
    forceRefresh: function(e) {
        var t = this;
        if (t.isDescendantOf(e) && t.refreshPending) {
            t.setShowListeners("mun");
            t.delayRefresh()
        }
        delete t.refreshPending
    },
    bindStore: function(e, t) {
        var n = this;
        n.mixins.bindable.bindStore.apply(n, arguments);
        if (n.store && !t) {
            n.refresh()
        }
    },
    getStoreListeners: function() {
        var e = this.doRefresh,
        t = this.delayRefresh;
        return {
            refresh: e,
            add: t,
            bulkremove: t,
            update: t,
            clear: e
        }
    },
    setSubStore: function(e) {
        this.substore = e
    },
    initializeAxis: function(e) {
        var t = this,
        n = t.chartBBox,
        r = n.width,
        i = n.height,
        s = n.x,
        o = n.y,
        u = t.themeAttrs,
        a = t.axes,
        f = {
            chart: t
        };
        if (u) {
            f.axisStyle = Ext.apply({},
            u.axis);
            f.axisLabelLeftStyle = Ext.apply({},
            u.axisLabelLeft);
            f.axisLabelRightStyle = Ext.apply({},
            u.axisLabelRight);
            f.axisLabelTopStyle = Ext.apply({},
            u.axisLabelTop);
            f.axisLabelBottomStyle = Ext.apply({},
            u.axisLabelBottom);
            f.axisTitleLeftStyle = Ext.apply({},
            u.axisTitleLeft);
            f.axisTitleRightStyle = Ext.apply({},
            u.axisTitleRight);
            f.axisTitleTopStyle = Ext.apply({},
            u.axisTitleTop);
            f.axisTitleBottomStyle = Ext.apply({},
            u.axisTitleBottom);
            t.configureAxisStyles(f)
        }
        switch (e.position) {
        case "top":
            Ext.apply(f, {
                length: r,
                width: i,
                x: s,
                y: o
            });
            break;
        case "bottom":
            Ext.apply(f, {
                length: r,
                width: i,
                x: s,
                y: i
            });
            break;
        case "left":
            Ext.apply(f, {
                length: i,
                width: r,
                x: s,
                y: i
            });
            break;
        case "right":
            Ext.apply(f, {
                length: i,
                width: r,
                x: r,
                y: i
            });
            break
        }
        if (!e.chart) {
            Ext.apply(f, e);
            e = Ext.createByAlias("axis." + e.type.toLowerCase(), f);
            a.replace(e)
        } else {
            Ext.apply(e, f)
        }
        e.initialized = true
    },
    configureAxisStyles: Ext.emptyFn,
    getInsets: function() {
        var e = this,
        t = e.insetPadding;
        return {
            top: t,
            right: t,
            bottom: t,
            left: t
        }
    },
    calculateInsets: function() {
        function c(e) {
            var t = n.findIndex("position", e);
            return t < 0 ? null: n.getAt(t)
        }
        var e = this,
        t = e.legend,
        n = e.axes,
        r = ["top", "right", "bottom", "left"],
        i,
        s,
        o,
        u,
        a,
        f,
        l;
        i = e.getInsets();
        for (s = 0, o = r.length; s < o; s++) {
            u = r[s];
            a = u === "left" || u === "right";
            f = c(u);
            if (t !== false) {
                if (t.position === u) {
                    l = t.getBBox();
                    i[u] += (a ? l.width: l.height) + e.insetPadding
                }
            }
            if (f && f.bbox) {
                l = f.bbox;
                i[u] += a ? l.width: l.height
            }
        }
        return i
    },
    alignAxes: function() {
        var e = this,
        t = e.axes.items,
        n, r, i, s, o, u, a;
        n = e.calculateInsets();
        r = {
            x: n.left,
            y: n.top,
            width: e.curWidth - n.left - n.right,
            height: e.curHeight - n.top - n.bottom
        };
        e.chartBBox = r;
        for (i = 0, s = t.length; i < s; i++) {
            o = t[i];
            u = o.position;
            a = u === "left" || u === "right";
            o.x = u === "right" ? r.x + r.width: r.x;
            o.y = u === "top" ? r.y: r.y + r.height;
            o.width = a ? r.width: r.height;
            o.length = a ? r.height: r.width
        }
    },
    initializeSeries: function(e, t, n) {
        var r = this,
        s = r.themeAttrs,
        o, u, a, f, l, c = [],
        h = (e instanceof Ext.chart.series.Series).i = 0,
        p,
        d;
        if (!e.initialized) {
            d = {
                chart: r,
                seriesId: e.seriesId
            };
            if (s) {
                a = s.seriesThemes;
                l = s.markerThemes;
                o = Ext.apply({},
                s.series);
                u = Ext.apply({},
                s.marker);
                d.seriesStyle = Ext.apply(o, a[n % a.length]);
                d.seriesLabelStyle = Ext.apply({},
                s.seriesLabel);
                d.markerStyle = Ext.apply(u, l[n % l.length]);
                if (s.colors) {
                    d.colorArrayStyle = s.colors
                } else {
                    c = [];
                    for (p = a.length; i < p; i++) {
                        f = a[i];
                        if (f.fill || f.stroke) {
                            c.push(f.fill || f.stroke)
                        }
                    }
                    if (c.length) {
                        d.colorArrayStyle = c
                    }
                }
                d.seriesIdx = t;
                d.themeIdx = n
            }
            if (h) {
                Ext.applyIf(e, d)
            } else {
                Ext.applyIf(d, e);
                e = r.series.replace(Ext.createByAlias("series." + e.type.toLowerCase(), d))
            }
        }
        e.initialize();
        e.initialized = true;
        return e
    },
    getMaxGutters: function() {
        var e = this,
        t = e.series.items,
        n, r, i, s, o = 0,
        u = 0,
        a = 0,
        f = 0;
        for (n = 0, r = t.length; n < r; n++) {
            s = t[n].getGutters();
            if (s) {
                if (s.verticalAxis) {
                    a = Math.max(a, s.lower);
                    f = Math.max(f, s.upper)
                } else {
                    o = Math.max(o, s.lower);
                    u = Math.max(u, s.upper)
                }
            }
        }
        e.maxGutters = {
            left: o,
            right: u,
            bottom: a,
            top: f
        }
    },
    drawAxis: function(e) {
        e.drawAxis()
    },
    drawCharts: function(e) {
        e.triggerafterrender = false;
        e.drawSeries();
        if (!this.animate) {
            e.fireEvent("afterrender", e)
        }
    },
    save: function(e) {
        return Ext.draw.Surface.save(this.surface, e)
    },
    destroy: function() {
        var e = this,
        t = e.refreshTask;
        if (t) {
            t.cancel();
            e.refreshTask = null
        }
        Ext.destroy(e.surface);
        e.bindStore(null);
        e.callParent(arguments)
    }
});
Ext.define("Ext.chart.Highlight", {
    highlight: false,
    highlightCfg: {
        fill: "#fdd",
        "stroke-width": 5,
        stroke: "#f55"
    },
    constructor: function(e) {
        if (e.highlight && typeof e.highlight !== "boolean") {
            this.highlightCfg = Ext.merge({},
            this.highlightCfg, e.highlight)
        }
    },
    highlightItem: function(e) {
        if (!e) {
            return
        }
        var t = this,
        n = e.sprite,
        r = Ext.merge({},
        t.highlightCfg, t.highlight),
        i = t.chart.surface,
        s = t.chart.animate,
        o,
        u,
        a,
        f;
        if (!t.highlight || !n || n._highlighted) {
            return
        }
        if (n._anim) {
            n._anim.paused = true
        }
        n._highlighted = true;
        if (!n._defaults) {
            n._defaults = Ext.apply({},
            n.attr);
            u = {};
            a = {};
            for (o in r) {
                if (! (o in n._defaults)) {
                    n._defaults[o] = i.availableAttrs[o]
                }
                u[o] = n._defaults[o];
                a[o] = r[o];
                if (Ext.isObject(r[o])) {
                    u[o] = {};
                    a[o] = {};
                    Ext.apply(n._defaults[o], n.attr[o]);
                    Ext.apply(u[o], n._defaults[o]);
                    for (f in n._defaults[o]) {
                        if (! (f in r[o])) {
                            a[o][f] = u[o][f]
                        } else {
                            a[o][f] = r[o][f]
                        }
                    }
                    for (f in r[o]) {
                        if (! (f in a[o])) {
                            a[o][f] = r[o][f]
                        }
                    }
                }
            }
            n._from = u;
            n._to = a;
            n._endStyle = a
        }
        if (s) {
            n._anim = new Ext.fx.Anim({
                target: n,
                from: n._from,
                to: n._to,
                duration: 150
            })
        } else {
            n.setAttributes(n._to, true)
        }
    },
    unHighlightItem: function() {
        if (!this.highlight || !this.items) {
            return
        }
        var e = this,
        t = e.items,
        n = t.length,
        r = Ext.merge({},
        e.highlightCfg, e.highlight),
        i = e.chart.animate,
        s = 0,
        o,
        u,
        a;
        for (; s < n; s++) {
            if (!t[s]) {
                continue
            }
            a = t[s].sprite;
            if (a && a._highlighted) {
                if (a._anim) {
                    a._anim.paused = true
                }
                o = {};
                for (u in r) {
                    if (Ext.isObject(a._defaults[u])) {
                        o[u] = Ext.apply({},
                        a._defaults[u])
                    } else {
                        o[u] = a._defaults[u]
                    }
                }
                if (i) {
                    a._endStyle = o;
                    a._anim = new Ext.fx.Anim({
                        target: a,
                        to: o,
                        duration: 150
                    })
                } else {
                    a.setAttributes(o, true)
                }
                delete a._highlighted
            }
        }
    },
    cleanHighlights: function() {
        if (!this.highlight) {
            return
        }
        var e = this.group,
        t = this.markerGroup,
        n = 0,
        r;
        for (r = e.getCount(); n < r; n++) {
            delete e.getAt(n)._defaults
        }
        if (t) {
            for (r = t.getCount(); n < r; n++) {
                delete t.getAt(n)._defaults
            }
        }
    }
});
Ext.define("Ext.chart.Label", {
    colorStringRe: /url\s*\(\s*#([^\/)]+)\s*\)/,
    constructor: function(e) {
        var t = this;
        t.label = Ext.applyIf(t.label || {},
        {
            display: "none",
            stackedDisplay: "none",
            color: "#000",
            field: "name",
            minMargin: 50,
            font: "11px Helvetica, sans-serif",
            orientation: "horizontal",
            renderer: Ext.identityFn
        });
        if (t.label.display !== "none") {
            t.labelsGroup = t.chart.surface.getGroup(t.seriesId + "-labels")
        }
    },
    renderLabels: function() {
        var e = this,
        t = e.chart,
        n = t.gradients,
        r = e.items,
        i = t.animate,
        s = e.label,
        o = s.display,
        u = s.stackedDisplay,
        a = s.renderer,
        f = s.color,
        l = [].concat(s.field),
        c = e.labelsGroup,
        h = (c || 0) && c.length,
        p = e.chart.getChartStore(),
        d = p.getCount(),
        v = (r || 0) && r.length,
        m = v / d,
        g = (n || 0) && n.length,
        y = Ext.draw.Color,
        b = [],
        w,
        E,
        S,
        x,
        T,
        N,
        C,
        k,
        L,
        A,
        O,
        M,
        _,
        D,
        P,
        H,
        B,
        j,
        F,
        I,
        q,
        R,
        U;
        if (o == "none" || !c) {
            return
        }
        if (v == 0) {
            while (h--) {
                b.push(h)
            }
        } else {
            for (E = 0, S = 0, x = 0; E < d; E++) {
                T = 0;
                for (N = 0; N < m; N++) {
                    O = r[S];
                    M = c.getAt(x);
                    _ = p.getAt(E);
                    while (this.__excludes && this.__excludes[T]) {
                        T++
                    }
                    if (!O && M) {
                        M.hide(true);
                        x++
                    }
                    if (O && l[N]) {
                        if (!M) {
                            M = e.onCreateLabel(_, O, E, o);
                            if (!M) {
                                break
                            }
                        }
                        M.setAttributes({
                            fill: String(f)
                        },
                        true);
                        e.onPlaceLabel(M, _, O, E, o, i, T);
                        x++;
                        if (s.contrast && O.sprite) {
                            D = O.sprite;
                            if (i && D._endStyle) {
                                j = D._endStyle.fill
                            } else {
                                if (i && D._to) {
                                    j = D._to.fill
                                } else {
                                    j = D.attr.fill
                                }
                            }
                            j = j || D.attr.fill;
                            P = y.fromString(j);
                            if (j && !P) {
                                j = j.match(e.colorStringRe)[1];
                                for (C = 0; C < g; C++) {
                                    w = n[C];
                                    if (w.id == j) {
                                        A = 0;
                                        k = 0;
                                        for (L in w.stops) {
                                            A++;
                                            k += y.fromString(w.stops[L].color).getGrayscale()
                                        }
                                        H = k / A / 255;
                                        break
                                    }
                                }
                            } else {
                                H = P.getGrayscale() / 255
                            }
                            if (M.isOutside) {
                                H = 1
                            }
                            B = y.fromString(M.attr.fill || M.attr.color).getHSL();
                            B[2] = H > .5 ? .2 : .8;
                            M.setAttributes({
                                fill: String(y.fromHSL.apply({},
                                B))
                            },
                            true)
                        }
                        if (e.stacked && u && (O.totalPositiveValues || O.totalNegativeValues)) {
                            I = O.totalPositiveValues || 0;
                            q = O.totalNegativeValues || 0;
                            F = I + q;
                            if (u == "total") {
                                R = a(F)
                            } else {
                                if (u == "balances") {
                                    if (I == 0 && q == 0) {
                                        R = a(0)
                                    } else {
                                        R = a(I);
                                        U = a(q)
                                    }
                                }
                            }
                            if (R) {
                                M = c.getAt(x);
                                if (!M) {
                                    M = e.onCreateLabel(_, O, E, "over")
                                }
                                B = y.fromString(M.attr.color || M.attr.fill).getHSL();
                                M.setAttributes({
                                    text: R,
                                    style: s.font,
                                    fill: String(y.fromHSL.apply({},
                                    B))
                                },
                                true);
                                e.onPlaceLabel(M, _, O, E, "over", i, T);
                                x++
                            }
                            if (U) {
                                M = c.getAt(x);
                                if (!M) {
                                    M = e.onCreateLabel(_, O, E, "under")
                                }
                                B = y.fromString(M.attr.color || M.attr.fill).getHSL();
                                M.setAttributes({
                                    text: U,
                                    style: s.font,
                                    fill: String(y.fromHSL.apply({},
                                    B))
                                },
                                true);
                                e.onPlaceLabel(M, _, O, E, "under", i, T);
                                x++
                            }
                        }
                    }
                    S++;
                    T++
                }
            }
            h = c.length;
            while (h > x) {
                b.push(x);
                x++
            }
        }
        e.hideLabels(b)
    },
    hideLabels: function(e) {
        var t = this.labelsGroup,
        n = !!e && e.length;
        if (!t) {
            return
        }
        if (n === false) {
            n = t.getCount();
            while (n--) {
                t.getAt(n).hide(true)
            }
        } else {
            while (n--) {
                t.getAt(e[n]).hide(true)
            }
        }
    }
});
Ext.define("Ext.chart.TipSurface", {
    extend: Ext.draw.Component,
    spriteArray: false,
    renderFirst: true,
    constructor: function(e) {
        this.callParent([e]);
        if (e.sprites) {
            this.spriteArray = [].concat(e.sprites);
            delete e.sprites
        }
    },
    onRender: function() {
        var e = this,
        t = 0,
        n = 0,
        r, i;
        this.callParent(arguments);
        i = e.spriteArray;
        if (e.renderFirst && i) {
            e.renderFirst = false;
            for (n = i.length; t < n; t++) {
                r = e.surface.add(i[t]);
                r.setAttributes({
                    hidden: false
                },
                true)
            }
        }
    }
});
Ext.define("Ext.chart.Tip", {
    constructor: function(e) {
        var t = this,
        n, r, i;
        if (e.tips) {
            t.tipTimeout = null;
            t.tipConfig = Ext.apply({},
            e.tips, {
                renderer: Ext.emptyFn,
                constrainPosition: true,
                autoHide: true,
                shrinkWrapDock: true
            });
            t.tooltip = new Ext.tip.ToolTip(t.tipConfig);
            t.chart.surface.on("mousemove", t.tooltip.onMouseMove, t.tooltip);
            t.chart.surface.on("mouseleave",
            function() {
                t.hideTip()
            });
            if (t.tipConfig.surface) {
                n = t.tipConfig.surface;
                r = n.sprites;
                i = new Ext.chart.TipSurface({
                    id: "tipSurfaceComponent",
                    sprites: r
                });
                if (n.width && n.height) {
                    i.setSize(n.width, n.height)
                }
                t.tooltip.add(i);
                t.spriteTip = i
            }
        }
    },
    showTip: function(e) {
        var t = this,
        n, r, i, s, o, u, a, f, l, c;
        if (!t.tooltip) {
            return
        }
        clearTimeout(t.tipTimeout);
        n = t.tooltip;
        r = t.spriteTip;
        i = t.tipConfig;
        s = n.trackMouse;
        if (!s) {
            n.trackMouse = true;
            o = e.sprite;
            u = o.surface;
            a = Ext.get(u.getId());
            if (a) {
                f = a.getXY();
                l = f[0] + (o.attr.x || 0) + (o.attr.translation && o.attr.translation.x || 0);
                c = f[1] + (o.attr.y || 0) + (o.attr.translation && o.attr.translation.y || 0);
                n.targetXY = [l, c]
            }
        }
        if (r) {
            i.renderer.call(n, e.storeItem, e, r.surface)
        } else {
            i.renderer.call(n, e.storeItem, e)
        }
        n.delayShow(s);
        n.trackMouse = s
    },
    hideTip: function(e) {
        var t = this.tooltip;
        if (!t) {
            return
        }
        clearTimeout(this.tipTimeout);
        this.tipTimeout = setTimeout(function() {
            t.delayHide()
        },
        0)
    }
});
Ext.define("Ext.chart.axis.Abstract", {
    constructor: function(e) {
        e = e || {};
        var t = this,
        n = e.position || "left";
        n = n.charAt(0).toUpperCase() + n.substring(1);
        e.label = Ext.apply(e["axisLabel" + n + "Style"] || {},
        e.label || {});
        e.axisTitleStyle = Ext.apply(e["axisTitle" + n + "Style"] || {},
        e.labelTitle || {});
        Ext.apply(t, e);
        t.fields = Ext.Array.from(t.fields);
        this.callParent();
        t.labels = [];
        t.getId();
        t.labelGroup = t.chart.surface.getGroup(t.axisId + "-labels")
    },
    alignment: null,
    grid: false,
    steps: 10,
    x: 0,
    y: 0,
    minValue: 0,
    maxValue: 0,
    getId: function() {
        return this.axisId || (this.axisId = Ext.id(null, "ext-axis-"))
    },
    processView: Ext.emptyFn,
    drawAxis: Ext.emptyFn,
    addDisplayAndLabels: Ext.emptyFn
});
Ext.define("Ext.chart.axis.Axis", {
    extend: Ext.chart.axis.Abstract,
    alternateClassName: "Ext.chart.Axis",
    hidden: false,
    forceMinMax: false,
    dashSize: 3,
    position: "bottom",
    skipFirst: false,
    length: 0,
    width: 0,
    adjustEnd: true,
    majorTickSteps: false,
    nullGutters: {
        lower: 0,
        upper: 0,
        verticalAxis: undefined
    },
    applyData: Ext.emptyFn,
    getRange: function() {
        var e = this,
        t = e.chart,
        n = t.getChartStore(),
        r = n.data.items,
        i = t.series.items,
        s = e.position,
        o,
        u = Ext.chart.series,
        a = [],
        f = Infinity,
        l = -Infinity,
        c = e.position === "left" || e.position === "right" || e.position === "radial",
        h,
        p,
        d,
        v,
        m,
        g = r.length,
        y,
        b = {},
        w = {},
        E = true,
        S,
        x,
        T,
        N,
        C;
        S = e.fields;
        for (v = 0, p = S.length; v < p; v++) {
            w[S[v]] = true
        }
        for (h = 0, p = i.length; h < p; h++) {
            if (i[h].seriesIsHidden) {
                continue
            }
            if (!i[h].getAxesForXAndYFields) {
                continue
            }
            o = i[h].getAxesForXAndYFields();
            if (o.xAxis && o.xAxis !== s && o.yAxis && o.yAxis !== s) {
                continue
            }
            if (u.Bar && i[h] instanceof u.Bar && !i[h].column) {
                S = c ? Ext.Array.from(i[h].xField) : Ext.Array.from(i[h].yField)
            } else {
                S = c ? Ext.Array.from(i[h].yField) : Ext.Array.from(i[h].xField)
            }
            if (e.fields.length) {
                for (v = 0, d = S.length; v < d; v++) {
                    if (w[S[v]]) {
                        break
                    }
                }
                if (v == d) {
                    continue
                }
            }
            if (y = i[h].stacked) {
                if (u.Bar && i[h] instanceof u.Bar) {
                    if (i[h].column != c) {
                        y = false;
                        E = false
                    }
                } else {
                    if (!c) {
                        y = false;
                        E = false
                    }
                }
            }
            if (y) {
                x = {};
                for (v = 0; v < S.length; v++) {
                    if (E && i[h].__excludes && i[h].__excludes[v]) {
                        continue
                    }
                    if (!w[S[v]]) {
                        Ext.Logger.warn("Field `" + S[v] + "` is not included in the " + s + " axis config.")
                    }
                    w[S[v]] = x[S[v]] = true
                }
                a.push({
                    fields: x,
                    positiveValue: 0,
                    negativeValue: 0
                })
            } else {
                if (!S || S.length == 0) {
                    S = e.fields
                }
                for (v = 0; v < S.length; v++) {
                    if (E && i[h].__excludes && i[h].__excludes[v]) {
                        continue
                    }
                    w[S[v]] = b[S[v]] = true
                }
            }
        }
        for (h = 0; h < g; h++) {
            T = r[h];
            for (m = 0; m < a.length; m++) {
                a[m].positiveValue = 0;
                a[m].negativeValue = 0
            }
            for (N in w) {
                C = T.get(N);
                if (e.type == "Time" && typeof C == "string") {
                    C = Date.parse(C)
                }
                if (isNaN(C)) {
                    continue
                }
                if (C === undefined) {
                    C = 0
                } else {
                    C = Number(C)
                }
                if (b[N]) {
                    if (f > C) {
                        f = C
                    }
                    if (l < C) {
                        l = C
                    }
                }
                for (m = 0; m < a.length; m++) {
                    if (a[m].fields[N]) {
                        if (C >= 0) {
                            a[m].positiveValue += C;
                            if (l < a[m].positiveValue) {
                                l = a[m].positiveValue
                            }
                            if (f > 0) {
                                f = 0
                            }
                        } else {
                            a[m].negativeValue += C;
                            if (f > a[m].negativeValue) {
                                f = a[m].negativeValue
                            }
                            if (l < 0) {
                                l = 0
                            }
                        }
                    }
                }
            }
        }
        if (!isFinite(l)) {
            l = e.prevMax || 0
        }
        if (!isFinite(f)) {
            f = e.prevMin || 0
        }
        if (typeof f === "number") {
            f = Ext.Number.correctFloat(f)
        }
        if (typeof l === "number") {
            l = Ext.Number.correctFloat(l)
        }
        if (f != l && (l != Math.floor(l) || f != Math.floor(f))) {
            f = Math.floor(f);
            l = Math.floor(l) + 1
        }
        if (!isNaN(e.minimum)) {
            f = e.minimum
        }
        if (!isNaN(e.maximum)) {
            l = e.maximum
        }
        if (f >= l) {
            f = Math.floor(f);
            l = f + 1
        }
        return {
            min: f,
            max: l
        }
    },
    calcEnds: function() {
        var e = this,
        t = e.getRange(),
        n = t.min,
        r = t.max,
        i,
        s,
        o,
        u;
        i = Ext.isNumber(e.majorTickSteps) ? e.majorTickSteps + 1 : e.steps;
        s = !(Ext.isNumber(e.maximum) && Ext.isNumber(e.minimum) && Ext.isNumber(e.majorTickSteps) && e.majorTickSteps > 0);
        o = Ext.draw.Draw.snapEnds(n, r, i, s);
        if (Ext.isNumber(e.maximum)) {
            o.to = e.maximum;
            u = true
        }
        if (Ext.isNumber(e.minimum)) {
            o.from = e.minimum;
            u = true
        }
        if (e.adjustMaximumByMajorUnit) {
            o.to = Math.ceil(o.to / o.step) * o.step;
            u = true
        }
        if (e.adjustMinimumByMajorUnit) {
            o.from = Math.floor(o.from / o.step) * o.step;
            u = true
        }
        if (u) {
            o.steps = Math.ceil((o.to - o.from) / o.step)
        }
        e.prevMin = n == r ? 0 : n;
        e.prevMax = r;
        return o
    },
    drawAxis: function(e) {
        var t = this,
        n, r = t.x,
        i = t.y,
        s = t.dashSize,
        o = t.length,
        u = t.position,
        a = u == "left" || u == "right",
        f = [],
        l = t.isNumericAxis,
        c = t.applyData(),
        h = c.step,
        p = c.steps,
        d = Ext.isArray(p),
        v = c.from,
        m = c.to,
        g = m - v || 1,
        y,
        b,
        w,
        E,
        S = t.minorTickSteps || 0,
        x = t.minorTickSteps || 0,
        T = Math.max(S + 1, 0),
        N = Math.max(x + 1, 0),
        C = u == "left" || u == "top" ? -1 : 1,
        k = s * C,
        L = t.chart.series.items,
        A = L[0],
        O = Ext.clone(A ? A.nullGutters: t.nullGutters),
        M,
        _,
        D,
        P,
        H,
        B,
        j = 0,
        F = 0,
        I,
        q,
        R,
        U,
        z,
        W;
        t.from = v;
        t.to = m;
        if (t.hidden || v > m) {
            return
        }
        if (d && p.length == 0 || !d && isNaN(h)) {
            return
        }
        if (d) {
            p = Ext.Array.filter(p,
            function(e, n, r) {
                return + e > +t.from && +e < +t.to
            },
            this);
            p = Ext.Array.union([t.from], p, [t.to])
        } else {
            p = new Array;
            for (U = +t.from; U < +t.to; U += h) {
                p.push(U)
            }
            p.push( + t.to)
        }
        F = p.length;
        for (n = 0, R = L.length; n < R; n++) {
            if (L[n].seriesIsHidden) {
                continue
            }
            if (!L[n].getAxesForXAndYFields) {
                continue
            }
            q = L[n].getAxesForXAndYFields();
            if (!q.xAxis || !q.yAxis || q.xAxis === u || q.yAxis === u) {
                M = Ext.clone(L[n].getGutters());
                _ = M.verticalAxis !== undefined;
                D = _ && M.verticalAxis == a;
                if (_) {
                    if (!D) {
                        P = L[n].getPadding();
                        if (a) {
                            M = {
                                lower: P.bottom,
                                upper: P.top,
                                verticalAxis: true
                            }
                        } else {
                            M = {
                                lower: P.left,
                                upper: P.right,
                                verticalAxis: false
                            }
                        }
                    }
                    if (O.lower < M.lower) {
                        O.lower = M.lower
                    }
                    if (O.upper < M.upper) {
                        O.upper = M.upper
                    }
                    O.verticalAxis = a
                }
            }
        }
        if (l) {
            t.labels = []
        }
        if (O) {
            if (a) {
                b = Math.floor(r);
                E = ["M", b + .5, i, "l", 0, -o];
                y = o - (O.lower + O.upper);
                for (I = 0; I < F; I++) {
                    w = i - O.lower - (p[I] - p[0]) * y / g;
                    E.push("M", b, Math.floor(w) + .5, "l", k * 2, 0);
                    f.push([b, Math.floor(w)]);
                    if (l) {
                        t.labels.push(p[I])
                    }
                }
            } else {
                w = Math.floor(i);
                E = ["M", r, w + .5, "l", o, 0];
                y = o - (O.lower + O.upper);
                for (I = 0; I < F; I++) {
                    b = r + O.lower + (p[I] - p[0]) * y / g;
                    E.push("M", Math.floor(b) + .5, w, "l", 0, k * 2 + 1);
                    f.push([Math.floor(b), w]);
                    if (l) {
                        t.labels.push(p[I])
                    }
                }
            }
        }
        H = a ? x: S;
        if (Ext.isArray(H)) {
            if (H.length == 2) {
                B = +Ext.Date.add(new Date, H[0], H[1]) - Date.now()
            } else {
                B = H[0]
            }
        } else {
            if (Ext.isNumber(H) && H > 0) {
                B = h / (H + 1)
            }
        }
        if (O && B) {
            for (I = 0; I < F - 1; I++) {
                z = +p[I];
                W = +p[I + 1];
                if (a) {
                    for (value = z + B; value < W; value += B) {
                        w = i - O.lower - (value - p[0]) * y / g;
                        E.push("M", b, Math.floor(w) + .5, "l", k, 0)
                    }
                } else {
                    for (value = z + B; value < W; value += B) {
                        b = r + O.upper + (value - p[0]) * y / g;
                        E.push("M", Math.floor(b) + .5, w, "l", 0, k + 1)
                    }
                }
            }
        }
        if (!t.axis) {
            t.axis = t.chart.surface.add(Ext.apply({
                type: "path",
                path: E
            },
            t.axisStyle))
        }
        t.axis.setAttributes({
            path: E
        },
        true);
        t.inflections = f;
        if (!e && t.grid) {
            t.drawGrid()
        }
        t.axisBBox = t.axis.getBBox();
        t.drawLabel()
    },
    drawGrid: function() {
        var e = this,
        t = e.chart.surface,
        n = e.grid,
        r = n.odd,
        i = n.even,
        s = e.inflections,
        o = s.length - (r || i ? 0 : 1),
        u = e.position,
        a = e.chart.maxGutters,
        f = e.width - 2,
        l,
        c,
        h = 1,
        p = [],
        d,
        v,
        m,
        g = [],
        y = [];
        if ((a.bottom !== 0 || a.top !== 0) && (u == "left" || u == "right") || (a.left !== 0 || a.right !== 0) && (u == "top" || u == "bottom")) {
            h = 0;
            o++
        }
        for (; h < o; h++) {
            l = s[h];
            c = s[h - 1];
            if (r || i) {
                p = h % 2 ? g: y;
                d = (h % 2 ? r: i) || {};
                v = (d.lineWidth || d["stroke-width"] || 0) / 2;
                m = 2 * v;
                if (u == "left") {
                    p.push("M", c[0] + 1 + v, c[1] + .5 - v, "L", c[0] + 1 + f - v, c[1] + .5 - v, "L", l[0] + 1 + f - v, l[1] + .5 + v, "L", l[0] + 1 + v, l[1] + .5 + v, "Z")
                } else {
                    if (u == "right") {
                        p.push("M", c[0] - v, c[1] + .5 - v, "L", c[0] - f + v, c[1] + .5 - v, "L", l[0] - f + v, l[1] + .5 + v, "L", l[0] - v, l[1] + .5 + v, "Z")
                    } else {
                        if (u == "top") {
                            p.push("M", c[0] + .5 + v, c[1] + 1 + v, "L", c[0] + .5 + v, c[1] + 1 + f - v, "L", l[0] + .5 - v, l[1] + 1 + f - v, "L", l[0] + .5 - v, l[1] + 1 + v, "Z")
                        } else {
                            p.push("M", c[0] + .5 + v, c[1] - v, "L", c[0] + .5 + v, c[1] - f + v, "L", l[0] + .5 - v, l[1] - f + v, "L", l[0] + .5 - v, l[1] - v, "Z")
                        }
                    }
                }
            } else {
                if (u == "left") {
                    p = p.concat(["M", l[0] + .5, l[1] + .5, "l", f, 0])
                } else {
                    if (u == "right") {
                        p = p.concat(["M", l[0] - .5, l[1] + .5, "l", -f, 0])
                    } else {
                        if (u == "top") {
                            p = p.concat(["M", l[0] + .5, l[1] + .5, "l", 0, f])
                        } else {
                            p = p.concat(["M", l[0] + .5, l[1] - .5, "l", 0, -f])
                        }
                    }
                }
            }
        }
        if (r || i) {
            if (g.length) {
                if (!e.gridOdd && g.length) {
                    e.gridOdd = t.add({
                        type: "path",
                        path: g
                    })
                }
                e.gridOdd.setAttributes(Ext.apply({
                    path: g,
                    hidden: false
                },
                r || {}), true)
            }
            if (y.length) {
                if (!e.gridEven) {
                    e.gridEven = t.add({
                        type: "path",
                        path: y
                    })
                }
                e.gridEven.setAttributes(Ext.apply({
                    path: y,
                    hidden: false
                },
                i || {}), true)
            }
        } else {
            if (p.length) {
                if (!e.gridLines) {
                    e.gridLines = e.chart.surface.add({
                        type: "path",
                        path: p,
                        "stroke-width": e.lineWidth || 1,
                        stroke: e.gridColor || "#ccc"
                    })
                }
                e.gridLines.setAttributes({
                    hidden: false,
                    path: p
                },
                true)
            } else {
                if (e.gridLines) {
                    e.gridLines.hide(true)
                }
            }
        }
    },
    getOrCreateLabel: function(e, t) {
        var n = this,
        r = n.labelGroup,
        i = r.getAt(e),
        s = n.chart.surface;
        if (i) {
            if (t != i.attr.text) {
                i.setAttributes(Ext.apply({
                    text: t
                },
                n.label), true);
                i._bbox = i.getBBox()
            }
        } else {
            i = s.add(Ext.apply({
                group: r,
                type: "text",
                x: 0,
                y: 0,
                text: t
            },
            n.label));
            s.renderItem(i);
            i._bbox = i.getBBox()
        }
        if (n.label.rotation) {
            i.setAttributes({
                rotation: {
                    degrees: 0
                }
            },
            true);
            i._ubbox = i.getBBox();
            i.setAttributes(n.label, true)
        } else {
            i._ubbox = i._bbox
        }
        return i
    },
    rect2pointArray: function(e) {
        var t = this.chart.surface,
        n = t.getBBox(e, true),
        r = [n.x, n.y],
        i = r.slice(),
        s = [n.x + n.width, n.y],
        o = s.slice(),
        u = [n.x + n.width, n.y + n.height],
        a = u.slice(),
        f = [n.x, n.y + n.height],
        l = f.slice(),
        c = e.matrix;
        r[0] = c.x.apply(c, i);
        r[1] = c.y.apply(c, i);
        s[0] = c.x.apply(c, o);
        s[1] = c.y.apply(c, o);
        u[0] = c.x.apply(c, a);
        u[1] = c.y.apply(c, a);
        f[0] = c.x.apply(c, l);
        f[1] = c.y.apply(c, l);
        return [r, s, u, f]
    },
    intersect: function(e, t) {
        var n = this.rect2pointArray(e),
        r = this.rect2pointArray(t);
        return !! Ext.draw.Draw.intersect(n, r).length
    },
    drawHorizontalLabels: function() {
        var e = this,
        t = e.label,
        n = Math.floor,
        r = Math.max,
        i = e.chart.axes,
        s = e.chart.insetPadding,
        o = e.chart.maxGutters,
        u = e.position,
        a = e.inflections,
        f = a.length,
        l = e.labels,
        c = 0,
        h, p, d, v, m, g = e.adjustEnd,
        y = i.findIndex("position", "left") != -1,
        b = i.findIndex("position", "right") != -1,
        w = e.reverse,
        E,
        S,
        x,
        T,
        N,
        C,
        k,
        L;
        T = f - 1;
        d = a[0];
        L = e.getOrCreateLabel(0, e.label.renderer(l[0]));
        h = Math.floor(Math.abs(Math.sin(t.rotate && t.rotate.degrees * Math.PI / 180 || 0)));
        for (k = 0; k < f; k++) {
            d = a[k];
            x = k;
            if (w) {
                x = f - k - 1
            }
            S = e.label.renderer(l[x]);
            E = e.getOrCreateLabel(k, S);
            p = E._bbox;
            c = r(c, p.height + e.dashSize + e.label.padding);
            N = n(d[0] - (h ? p.height: p.width) / 2);
            if (g && o.left == 0 && o.right == 0) {
                if (k == 0 && !y) {
                    N = d[0]
                } else {
                    if (k == T && !b) {
                        N = Math.min(N, d[0] - p.width + s)
                    }
                }
            }
            if (u == "top") {
                C = d[1] - e.dashSize * 2 - e.label.padding - p.height / 2
            } else {
                C = d[1] + e.dashSize * 2 + e.label.padding + p.height / 2
            }
            E.setAttributes({
                hidden: false,
                x: N,
                y: C
            },
            true);
            if (k != 0 && (e.intersect(E, v) || e.intersect(E, L))) {
                if (k === T && m !== 0) {
                    v.hide(true)
                } else {
                    E.hide(true);
                    continue
                }
            }
            v = E;
            m = k
        }
        return c
    },
    drawVerticalLabels: function() {
        var e = this,
        t = e.inflections,
        n = e.position,
        r = t.length,
        i = e.chart,
        s = i.insetPadding,
        o = e.labels,
        u = 0,
        a = Math.max,
        f = Math.floor,
        l = Math.ceil,
        c = e.chart.axes,
        h = e.chart.maxGutters,
        p, d, v, m, g = c.findIndex("position", "top") != -1,
        y = c.findIndex("position", "bottom") != -1,
        b = e.adjustEnd,
        w,
        E,
        S = r - 1,
        x,
        T,
        N;
        for (N = 0; N < r; N++) {
            d = t[N];
            E = e.label.renderer(o[N]);
            w = e.getOrCreateLabel(N, E);
            p = w._bbox;
            u = a(u, p.width + e.dashSize + e.label.padding);
            T = d[1];
            if (b && h.bottom + h.top < p.height / 2) {
                if (N == S && !g) {
                    T = Math.max(T, e.y - e.length + l(p.height / 2) - s)
                } else {
                    if (N == 0 && !y) {
                        T = e.y + h.bottom - f(p.height / 2)
                    }
                }
            }
            if (n == "left") {
                x = d[0] - p.width - e.dashSize - e.label.padding - 2
            } else {
                x = d[0] + e.dashSize + e.label.padding + 2
            }
            w.setAttributes(Ext.apply({
                hidden: false,
                x: x,
                y: T
            },
            e.label), true);
            if (N != 0 && e.intersect(w, v)) {
                if (N === S && m !== 0) {
                    v.hide(true)
                } else {
                    w.hide(true);
                    continue
                }
            }
            v = w;
            m = N
        }
        return u
    },
    drawLabel: function() {
        var e = this,
        t = e.position,
        n = e.labelGroup,
        r = e.inflections,
        i = 0,
        s = 0,
        o, u;
        if (t == "left" || t == "right") {
            i = e.drawVerticalLabels()
        } else {
            s = e.drawHorizontalLabels()
        }
        o = n.getCount();
        u = r.length;
        for (; u < o; u++) {
            n.getAt(u).hide(true)
        }
        e.bbox = {};
        Ext.apply(e.bbox, e.axisBBox);
        e.bbox.height = s;
        e.bbox.width = i;
        if (Ext.isString(e.title)) {
            e.drawTitle(i, s)
        }
    },
    setTitle: function(e) {
        this.title = e;
        this.drawLabel()
    },
    drawTitle: function(e, t) {
        var n = this,
        r = n.position,
        i = n.titleAlign,
        s = n.chart.surface,
        o = n.displaySprite,
        u = n.title,
        a = r == "left" || r == "right",
        f = n.x,
        l = n.y,
        c, h, p;
        if (o) {
            o.setAttributes({
                text: u
            },
            true)
        } else {
            c = {
                type: "text",
                x: 0,
                y: 0,
                text: u
            };
            o = n.displaySprite = s.add(Ext.apply(c, n.axisTitleStyle, n.labelTitle));
            s.renderItem(o)
        }
        h = o.getBBox();
        p = n.dashSize + n.label.padding;
        if (a) {
            if (i === "end") {
                l -= n.length - h.height
            } else {
                if (!i || i === "center") {
                    l -= n.length / 2 - h.height / 2
                }
            }
            if (r == "left") {
                f -= e + p + h.width / 2
            } else {
                f += e + p + h.width - h.width / 2
            }
            n.bbox.width += h.width + 10
        } else {
            if (i === "end" || n.reverse && i === "start") {
                f += n.length - h.width
            } else {
                if (!i || i === "center") {
                    f += n.length / 2 - h.width * .5
                }
            }
            if (r == "top") {
                l -= t + p + h.height * .3
            } else {
                l += t + p + h.height * .8
            }
            n.bbox.height += h.height + 10
        }
        o.setAttributes({
            translate: {
                x: f,
                y: l
            }
        },
        true)
    }
});
Ext.define("Ext.chart.axis.Category", {
    extend: Ext.chart.axis.Axis,
    alternateClassName: "Ext.chart.CategoryAxis",
    alias: "axis.category",
    isCategoryAxis: true,
    doConstrain: function() {
        var e = this,
        t = e.chart,
        n = t.getChartStore(),
        r = n.data.items,
        i = t.series.items,
        s = i.length,
        o = [],
        u;
        for (u = 0; u < s; u++) {
            if (i[u].type === "bar" && i[u].stacked) {
                return
            }
        }
        for (u = e.minimum; u < e.maximum; u++) {
            o.push(r[u])
        }
        t.setSubStore(new Ext.data.Store({
            model: n.model,
            data: o
        }))
    },
    setLabels: function() {
        var e = this.chart.getChartStore(),
        t = e.data.items,
        n,
        r,
        i,
        s = this.fields,
        o = s.length,
        u,
        a,
        f;
        u = this.labels = [];
        for (n = 0, r = t.length; n < r; n++) {
            i = t[n];
            for (f = 0; f < o; f++) {
                a = i.get(s[f]);
                u.push(a)
            }
        }
    },
    applyData: function() {
        this.callParent();
        this.setLabels();
        var e = this.chart.getChartStore().getCount();
        return {
            from: 0,
            to: e - 1,
            power: 1,
            step: 1,
            steps: e - 1
        }
    }
});
Ext.define("Ext.chart.axis.Gauge", {
    extend: Ext.chart.axis.Abstract,
    position: "gauge",
    alias: "axis.gauge",
    drawAxis: function(e) {
        var t = this.chart,
        n = t.surface,
        r = t.chartBBox,
        i = r.x + r.width / 2,
        s = r.y + r.height,
        o = this.margin || 10,
        u = Math.min(r.width, 2 * r.height) / 2 + o,
        a = [],
        f,
        l = this.steps,
        c,
        h = Math.PI,
        p = Math.cos,
        d = Math.sin;
        if (this.sprites && !t.resizing) {
            this.drawLabel();
            return
        }
        if (this.margin >= 0) {
            if (!this.sprites) {
                for (c = 0; c <= l; c++) {
                    f = n.add({
                        type: "path",
                        path: ["M", i + (u - o) * p(c / l * h - h), s + (u - o) * d(c / l * h - h), "L", i + u * p(c / l * h - h), s + u * d(c / l * h - h), "Z"],
                        stroke: "#ccc"
                    });
                    f.setAttributes({
                        hidden: false
                    },
                    true);
                    a.push(f)
                }
            } else {
                a = this.sprites;
                for (c = 0; c <= l; c++) {
                    a[c].setAttributes({
                        path: ["M", i + (u - o) * p(c / l * h - h), s + (u - o) * d(c / l * h - h), "L", i + u * p(c / l * h - h), s + u * d(c / l * h - h), "Z"],
                        stroke: "#ccc"
                    },
                    true)
                }
            }
        }
        this.sprites = a;
        this.drawLabel();
        if (this.title) {
            this.drawTitle()
        }
    },
    drawTitle: function() {
        var e = this,
        t = e.chart,
        n = t.surface,
        r = t.chartBBox,
        i = e.titleSprite,
        s;
        if (!i) {
            e.titleSprite = i = n.add(Ext.apply({
                type: "text",
                zIndex: 2
            },
            e.axisTitleStyle, e.labelTitle))
        }
        i.setAttributes(Ext.apply({
            text: e.title
        },
        e.label || {}), true);
        s = i.getBBox();
        i.setAttributes({
            x: r.x + r.width / 2 - s.width / 2,
            y: r.y + r.height - s.height / 2 - 4
        },
        true)
    },
    setTitle: function(e) {
        this.title = e;
        this.drawTitle()
    },
    drawLabel: function() {
        var e = this,
        t = e.chart,
        n = t.surface,
        r = t.chartBBox,
        i = r.x + r.width / 2,
        s = r.y + r.height,
        o = e.margin || 10,
        u = Math.min(r.width, 2 * r.height) / 2 + 2 * o,
        a = Math.round,
        f = [],
        l,
        c = e.maximum || 0,
        h = e.minimum || 0,
        p = e.steps,
        d = Math.PI,
        v = Math.cos,
        m = Math.sin,
        g = this.label,
        y = g.renderer || Ext.identityFn,
        b = e.reverse,
        w,
        E,
        S;
        if (!this.labelArray) {
            for (w = 0; w <= p; w++) {
                E = w === 0 || w === p ? 7 : 0;
                S = b ? p - w: w;
                l = n.add({
                    type: "text",
                    text: y(a(h + S / p * (c - h))),
                    x: i + u * v(w / p * d - d),
                    y: s + u * m(w / p * d - d) - E,
                    "text-anchor": "middle",
                    "stroke-width": .2,
                    zIndex: 10,
                    stroke: "#333"
                });
                l.setAttributes({
                    hidden: false
                },
                true);
                f.push(l)
            }
        } else {
            f = this.labelArray;
            for (w = 0; w <= p; w++) {
                E = w === 0 || w === p ? 7 : 0;
                S = b ? p - w: w;
                f[w].setAttributes({
                    text: y(a(h + S / p * (c - h))),
                    x: i + u * v(w / p * d - d),
                    y: s + u * m(w / p * d - d) - E
                },
                true)
            }
        }
        this.labelArray = f
    }
});
Ext.define("Ext.chart.axis.Numeric", {
    extend: Ext.chart.axis.Axis,
    alternateClassName: "Ext.chart.NumericAxis",
    type: "Numeric",
    isNumericAxis: true,
    alias: "axis.numeric",
    constructor: function(e) {
        var t = this,
        n = !!(e.label && e.label.renderer),
        r;
        t.callParent([e]);
        r = t.label;
        if (e.constrain == null) {
            t.constrain = e.minimum != null && e.maximum != null
        }
        if (!n) {
            r.renderer = function(e) {
                return t.roundToDecimal(e, t.decimals)
            }
        }
    },
    roundToDecimal: function(e, t) {
        var n = Math.pow(10, t || 0);
        return Math.round(e * n) / n
    },
    minimum: NaN,
    maximum: NaN,
    constrain: true,
    decimals: 2,
    scale: "linear",
    doConstrain: function() {
        var e = this,
        t = e.chart,
        n = t.getChartStore(),
        r = n.data.items,
        i,
        s,
        o,
        u = t.series.items,
        a = e.fields,
        f = a.length,
        l = e.calcEnds(),
        c = l.from,
        h = l.to,
        p,
        d,
        v = false,
        m,
        g = [],
        y;
        for (i = 0, s = r.length; i < s; i++) {
            y = true;
            o = r[i];
            for (p = 0; p < f; p++) {
                m = o.get(a[p]);
                if (e.type == "Time" && typeof m == "string") {
                    m = Date.parse(m)
                }
                if ( + m < +c) {
                    y = false;
                    break
                }
                if ( + m > +h) {
                    y = false;
                    break
                }
            }
            if (y) {
                g.push(o)
            }
        }
        t.setSubStore(new Ext.data.Store({
            model: n.model,
            data: g
        }))
    },
    position: "left",
    adjustMaximumByMajorUnit: false,
    adjustMinimumByMajorUnit: false,
    processView: function() {
        var e = this,
        t = e.chart,
        n = t.series.items,
        r, i;
        for (r = 0, i = n.length; r < i; r++) {
            if (n[r].stacked) {
                delete e.minimum;
                delete e.maximum;
                e.constrain = false;
                break
            }
        }
        if (e.constrain) {
            e.doConstrain()
        }
    },
    applyData: function() {
        this.callParent();
        return this.calcEnds()
    }
});
Ext.define("Ext.chart.axis.Radial", {
    extend: Ext.chart.axis.Numeric,
    position: "radial",
    alias: "axis.radial",
    drawAxis: function(e) {
        var t = this.chart,
        n = t.surface,
        r = t.chartBBox,
        i = t.getChartStore(),
        s = i.getCount(),
        o = r.x + r.width / 2,
        u = r.y + r.height / 2,
        a = Math.min(r.width, r.height) / 2,
        f = [],
        l,
        c = this.steps,
        h,
        p,
        d = Math.PI * 2,
        v = Math.cos,
        m = Math.sin;
        if (this.sprites && !t.resizing) {
            this.drawLabel();
            return
        }
        if (!this.sprites) {
            for (h = 1; h <= c; h++) {
                l = n.add({
                    type: "circle",
                    x: o,
                    y: u,
                    radius: Math.max(a * h / c, 0),
                    stroke: "#ccc"
                });
                l.setAttributes({
                    hidden: false
                },
                true);
                f.push(l)
            }
            for (h = 0; h < s; h++) {
                l = n.add({
                    type: "path",
                    path: ["M", o, u, "L", o + a * v(h / s * d), u + a * m(h / s * d), "Z"],
                    stroke: "#ccc"
                });
                l.setAttributes({
                    hidden: false
                },
                true);
                f.push(l)
            }
        } else {
            f = this.sprites;
            for (h = 0; h < c; h++) {
                f[h].setAttributes({
                    x: o,
                    y: u,
                    radius: Math.max(a * (h + 1) / c, 0),
                    stroke: "#ccc"
                },
                true)
            }
            for (p = 0; p < s; p++) {
                f[h + p].setAttributes({
                    path: ["M", o, u, "L", o + a * v(p / s * d), u + a * m(p / s * d), "Z"],
                    stroke: "#ccc"
                },
                true)
            }
        }
        this.sprites = f;
        this.drawLabel()
    },
    drawLabel: function() {
        var e = this.chart,
        t = e.series.items,
        n, r = e.surface,
        i = e.chartBBox,
        s = e.getChartStore(),
        o = s.data.items,
        u,
        a,
        f = i.x + i.width / 2,
        l = i.y + i.height / 2,
        c = Math.min(i.width, i.height) / 2,
        h = Math.max,
        p = Math.round,
        d = [],
        v,
        m = [],
        g,
        y = [],
        b,
        w = !this.maximum,
        E = this.maximum || 0,
        S = this.minimum || 0,
        x = this.steps,
        T = 0,
        N,
        C,
        k,
        L = Math.PI * 2,
        A = Math.cos,
        O = Math.sin,
        M = this.label.display,
        _ = M !== "none",
        D = 10;
        if (!_) {
            return
        }
        for (T = 0, u = t.length; T < u; T++) {
            n = t[T];
            m.push(n.yField);
            b = n.xField
        }
        for (N = 0, u = o.length; N < u; N++) {
            a = o[N];
            y.push(a.get(b));
            if (w) {
                for (T = 0, g = m.length; T < g; T++) {
                    E = h( + a.get(m[T]), E)
                }
            }
        }
        if (!this.labelArray) {
            if (M != "categories") {
                for (T = 1; T <= x; T++) {
                    v = r.add({
                        type: "text",
                        text: p(T / x * E),
                        x: f,
                        y: l - c * T / x,
                        "text-anchor": "middle",
                        "stroke-width": .1,
                        stroke: "#333"
                    });
                    v.setAttributes({
                        hidden: false
                    },
                    true);
                    d.push(v)
                }
            }
            if (M != "scale") {
                for (N = 0, x = y.length; N < x; N++) {
                    C = A(N / x * L) * (c + D);
                    k = O(N / x * L) * (c + D);
                    v = r.add({
                        type: "text",
                        text: y[N],
                        x: f + C,
                        y: l + k,
                        "text-anchor": C * C <= .001 ? "middle": C < 0 ? "end": "start"
                    });
                    v.setAttributes({
                        hidden: false
                    },
                    true);
                    d.push(v)
                }
            }
        } else {
            d = this.labelArray;
            if (M != "categories") {
                for (T = 0; T < x; T++) {
                    d[T].setAttributes({
                        text: p((T + 1) / x * (E - S) + S),
                        x: f,
                        y: l - c * (T + 1) / x,
                        "text-anchor": "middle",
                        "stroke-width": .1,
                        stroke: "#333"
                    },
                    true)
                }
            }
            if (M != "scale") {
                for (N = 0, x = y.length; N < x; N++) {
                    C = A(N / x * L) * (c + D);
                    k = O(N / x * L) * (c + D);
                    if (d[T + N]) {
                        d[T + N].setAttributes({
                            type: "text",
                            text: y[N],
                            x: f + C,
                            y: l + k,
                            "text-anchor": C * C <= .001 ? "middle": C < 0 ? "end": "start"
                        },
                        true)
                    }
                }
            }
        }
        this.labelArray = d
    },
    processView: function() {
        var e = this,
        t = e.chart.series.items,
        n, r, i, s, o = [];
        for (n = 0, r = t.length; n < r; n++) {
            i = t[n];
            o.push(i.yField)
        }
        e.fields = o;
        s = e.calcEnds();
        e.maximum = s.to;
        e.steps = s.steps
    }
});
Ext.define("Ext.chart.axis.Time", {
    extend: Ext.chart.axis.Numeric,
    alternateClassName: "Ext.chart.TimeAxis",
    type: "Time",
    alias: "axis.time",
    dateFormat: false,
    fromDate: false,
    toDate: false,
    step: [Ext.Date.DAY, 1],
    constrain: false,
    constructor: function(e) {
        var t = this,
        n, r, i;
        t.callParent([e]);
        n = t.label || {};
        i = this.dateFormat;
        if (i) {
            if (n.renderer) {
                r = n.renderer;
                n.renderer = function(e) {
                    e = r(e);
                    return Ext.Date.format(new Date(r(e)), i)
                }
            } else {
                n.renderer = function(e) {
                    return Ext.Date.format(new Date(e >> 0), i)
                }
            }
        }
    },
    processView: function() {
        var e = this;
        if (e.fromDate) {
            e.minimum = +e.fromDate
        }
        if (e.toDate) {
            e.maximum = +e.toDate
        }
        if (e.constrain) {
            e.doConstrain()
        }
    },
    calcEnds: function() {
        var e = this,
        t, n = e.step;
        if (n) {
            t = e.getRange();
            t = Ext.draw.Draw.snapEndsByDateAndStep(new Date(t.min), new Date(t.max), Ext.isNumber(n) ? [Date.MILLI, n] : n);
            if (e.minimum) {
                t.from = e.minimum
            }
            if (e.maximum) {
                t.to = e.maximum
            }
            return t
        } else {
            return e.callParent(arguments)
        }
    }
});
Ext.define("Ext.chart.series.Series", {
    mixins: {
        observable: Ext.util.Observable,
        labels: Ext.chart.Label,
        highlights: Ext.chart.Highlight,
        tips: Ext.chart.Tip,
        callouts: Ext.chart.Callout
    },
    type: null,
    title: null,
    showInLegend: true,
    renderer: function(e, t, n, r, i) {
        return n
    },
    shadowAttributes: null,
    animating: false,
    nullGutters: {
        lower: 0,
        upper: 0,
        verticalAxis: undefined
    },
    nullPadding: {
        left: 0,
        right: 0,
        width: 0,
        bottom: 0,
        top: 0,
        height: 0
    },
    constructor: function(e) {
        var t = this;
        if (e) {
            Ext.apply(t, e)
        }
        t.shadowGroups = [];
        t.mixins.labels.constructor.call(t, e);
        t.mixins.highlights.constructor.call(t, e);
        t.mixins.tips.constructor.call(t, e);
        t.mixins.callouts.constructor.call(t, e);
        t.addEvents({
            scope: t,
            itemclick: true,
            itemdblclick: true,
            itemmouseover: true,
            itemmouseout: true,
            itemmousedown: true,
            itemmouseup: true,
            mouseleave: true,
            afterdraw: true,
            titlechange: true
        });
        t.mixins.observable.constructor.call(t, e);
        t.on({
            scope: t,
            itemmouseover: t.onItemMouseOver,
            itemmouseout: t.onItemMouseOut,
            mouseleave: t.onMouseLeave
        });
        if (t.style) {
            Ext.apply(t.seriesStyle, t.style)
        }
    },
    initialize: Ext.emptyFn,
    onRedraw: Ext.emptyFn,
    eachRecord: function(e, t) {
        var n = this.chart;
        n.getChartStore().each(e, t)
    },
    getRecordCount: function() {
        var e = this.chart,
        t = e.getChartStore();
        return t ? t.getCount() : 0
    },
    isExcluded: function(e) {
        var t = this.__excludes;
        return !! (t && t[e])
    },
    setBBox: function(e) {
        var t = this,
        n = t.chart,
        r = n.chartBBox,
        i = e ? {
            left: 0,
            right: 0,
            bottom: 0,
            top: 0
        }: n.maxGutters,
        s,
        o;
        s = {
            x: r.x,
            y: r.y,
            width: r.width,
            height: r.height
        };
        t.clipBox = s;
        o = {
            x: s.x + i.left - n.zoom.x * n.zoom.width,
            y: s.y + i.bottom - n.zoom.y * n.zoom.height,
            width: (s.width - (i.left + i.right)) * n.zoom.width,
            height: (s.height - (i.bottom + i.top)) * n.zoom.height
        };
        t.bbox = o
    },
    onAnimate: function(e, t) {
        var n = this;
        e.stopAnimation();
        if (n.animating) {
            return e.animate(Ext.applyIf(t, n.chart.animate))
        } else {
            n.animating = true;
            return e.animate(Ext.apply(Ext.applyIf(t, n.chart.animate), {
                callback: function() {
                    n.animating = false;
                    n.fireEvent("afterrender", n)
                }
            }))
        }
    },
    getGutters: function() {
        return this.nullGutters
    },
    getPadding: function() {
        return this.nullPadding
    },
    onItemMouseOver: function(e) {
        var t = this;
        if (e.series === t) {
            if (t.highlight) {
                t.highlightItem(e)
            }
            if (t.tooltip) {
                t.showTip(e)
            }
        }
    },
    onItemMouseOut: function(e) {
        var t = this;
        if (e.series === t) {
            t.unHighlightItem();
            if (t.tooltip) {
                t.hideTip(e)
            }
        }
    },
    onMouseLeave: function() {
        var e = this;
        e.unHighlightItem();
        if (e.tooltip) {
            e.hideTip()
        }
    },
    getItemForPoint: function(e, t) {
        if (!this.items || !this.items.length || this.seriesIsHidden) {
            return null
        }
        var n = this,
        r = n.items,
        i = n.bbox,
        s, o, u;
        if (!Ext.draw.Draw.withinBox(e, t, i)) {
            return null
        }
        for (o = 0, u = r.length; o < u; o++) {
            if (r[o] && this.isItemInPoint(e, t, r[o], o)) {
                return r[o]
            }
        }
        return null
    },
    isItemInPoint: function(e, t, n, r) {
        return false
    },
    hideAll: function() {
        var e = this,
        t = e.items,
        n, r, i, s, o, u, a;
        e.seriesIsHidden = true;
        e._prevShowMarkers = e.showMarkers;
        e.showMarkers = false;
        e.hideLabels(0);
        for (i = 0, r = t.length; i < r; i++) {
            n = t[i];
            u = n.sprite;
            if (u) {
                u.setAttributes({
                    hidden: true
                },
                true)
            }
            if (u && u.shadows) {
                a = u.shadows;
                for (s = 0, o = a.length; s < o; ++s) {
                    a[s].setAttributes({
                        hidden: true
                    },
                    true)
                }
            }
        }
    },
    showAll: function() {
        var e = this,
        t = e.chart.animate;
        e.chart.animate = false;
        e.seriesIsHidden = false;
        e.showMarkers = e._prevShowMarkers;
        e.drawSeries();
        e.chart.animate = t
    },
    hide: function() {
        if (this.items) {
            var e = this,
            t = e.items,
            n, r, i, s, o;
            if (t && t.length) {
                for (n = 0, s = t.length; n < s; ++n) {
                    if (t[n].sprite) {
                        t[n].sprite.hide(true);
                        o = t[n].shadows || t[n].sprite.shadows;
                        if (o) {
                            for (r = 0, i = o.length; r < i; ++r) {
                                o[r].hide(true)
                            }
                        }
                    }
                }
                e.hideLabels()
            }
        }
    },
    getLegendColor: function(e) {
        var t = this,
        n, r;
        if (t.seriesStyle) {
            n = t.seriesStyle.fill;
            r = t.seriesStyle.stroke;
            if (n && n != "none") {
                return n
            }
            if (r) {
                return r
            }
        }
        return t.colorArrayStyle ? t.colorArrayStyle[t.themeIdx % t.colorArrayStyle.length] : "#000"
    },
    visibleInLegend: function(e) {
        var t = this.__excludes;
        if (t) {
            return ! t[e]
        }
        return ! this.seriesIsHidden
    },
    setTitle: function(e, t) {
        var n = this,
        r = n.title;
        if (Ext.isString(e)) {
            t = e;
            e = 0
        }
        if (Ext.isArray(r)) {
            r[e] = t
        } else {
            n.title = t
        }
        n.fireEvent("titlechange", t, e)
    }
});
Ext.define("Ext.chart.series.Cartesian", {
    extend: Ext.chart.series.Series,
    alternateClassName: ["Ext.chart.CartesianSeries", "Ext.chart.CartesianChart"],
    xField: null,
    yField: null,
    axis: "left",
    getLegendLabels: function() {
        var e = this,
        t = [],
        n,
        r,
        i,
        s = e.combinations,
        o,
        u,
        a,
        f;
        n = [].concat(e.yField);
        for (r = 0, i = n.length; r < i; r++) {
            o = e.title;
            t.push((Ext.isArray(o) ? o[r] : o) || n[r])
        }
        if (s) {
            s = Ext.Array.from(s);
            for (r = 0, i = s.length; r < i; r++) {
                u = s[r];
                a = t[u[0]];
                f = t[u[1]];
                t[u[1]] = a + " & " + f;
                t.splice(u[0], 1)
            }
        }
        return t
    },
    eachYValue: function(e, t, n) {
        var r = this,
        i = r.getYValueAccessors(),
        s,
        o,
        u;
        for (s = 0, o = i.length; s < o; s++) {
            u = i[s];
            t.call(n, u(e), s)
        }
    },
    getYValueCount: function() {
        return this.getYValueAccessors().length
    },
    combine: function(e, t) {
        var n = this,
        r = n.getYValueAccessors(),
        i = r[e],
        s = r[t];
        r[t] = function(e) {
            return i(e) + s(e)
        };
        r.splice(e, 1);
        n.callParent([e, t])
    },
    clearCombinations: function() {
        delete this.yValueAccessors;
        this.callParent()
    },
    getYValueAccessors: function() {
        function s(e) {
            return function(t) {
                return t.get(e)
            }
        }
        var e = this,
        t = e.yValueAccessors,
        n, r, i;
        if (!t) {
            t = e.yValueAccessors = [];
            n = [].concat(e.yField);
            for (r = 0, i = n.length; r < i; r++) {
                t.push(s(n[r]))
            }
        }
        return t
    },
    getMinMaxXValues: function() {
        var e = this,
        t = e.chart,
        n = t.getChartStore(),
        r = n.data.items,
        i = e.getRecordCount(),
        s,
        o,
        u,
        a,
        f,
        l = e.xField,
        c;
        if (i > 0) {
            a = Infinity;
            f = -a;
            for (s = 0, o = r.length; s < o; s++) {
                u = r[s];
                c = u.get(l);
                if (c > f) {
                    f = c
                }
                if (c < a) {
                    a = c
                }
            }
            if (a == Infinity) {
                a = 0
            }
            if (f == -Infinity) {
                f = i - 1
            }
        } else {
            a = f = 0
        }
        return [a, f]
    },
    getMinMaxYValues: function() {
        function p(t, n) {
            if (!e.isExcluded(n)) {
                if (t < 0) {
                    h += t
                } else {
                    c += t
                }
            }
        }
        function d(t, n) {
            if (!e.isExcluded(n)) {
                if (t > l) {
                    l = t
                }
                if (t < f) {
                    f = t
                }
            }
        }
        var e = this,
        t = e.chart,
        n = t.getChartStore(),
        r = n.data.items,
        i = e.getRecordCount(),
        s,
        o,
        u,
        a = e.stacked,
        f,
        l,
        c,
        h;
        if (i > 0) {
            f = Infinity;
            l = -f;
            for (s = 0, o = r.length; s < o; s++) {
                u = r[s];
                if (a) {
                    c = 0;
                    h = 0;
                    e.eachYValue(u, p);
                    if (c > l) {
                        l = c
                    }
                    if (h < f) {
                        f = h
                    }
                } else {
                    e.eachYValue(u, d)
                }
            }
            if (f == Infinity) {
                f = 0
            }
            if (l == -Infinity) {
                l = i - 1
            }
        } else {
            f = l = 0
        }
        return [f, l]
    },
    getAxesForXAndYFields: function() {
        var e = this,
        t = e.chart.axes,
        n = e.reverse,
        r = [].concat(e.axis),
        i = {},
        s = [].concat(e.yField),
        o = {},
        u = [].concat(e.xField),
        a,
        f,
        l,
        c,
        h,
        p;
        p = e.type === "bar" && e.column === false;
        if (p) {
            a = s;
            s = u;
            u = a
        }
        if (Ext.Array.indexOf(r, "top") > -1) {
            f = "top"
        } else {
            if (Ext.Array.indexOf(r, "bottom") > -1) {
                f = "bottom"
            } else {
                if (t.get("top") && t.get("bottom")) {
                    for (c = 0, h = u.length; c < h; c++) {
                        o[u[c]] = true
                    }
                    a = [].concat(t.get("bottom").fields);
                    for (c = 0, h = a.length; c < h; c++) {
                        if (o[a[c]]) {
                            f = "bottom";
                            break
                        }
                    }
                    a = [].concat(t.get("top").fields);
                    for (c = 0, h = a.length; c < h; c++) {
                        if (o[a[c]]) {
                            f = "top";
                            break
                        }
                    }
                } else {
                    if (t.get("top")) {
                        f = "top"
                    } else {
                        if (t.get("bottom")) {
                            f = "bottom"
                        }
                    }
                }
            }
        }
        if (Ext.Array.indexOf(r, "left") > -1) {
            l = p ? "right": "left"
        } else {
            if (Ext.Array.indexOf(r, "right") > -1) {
                l = p ? "left": "right"
            } else {
                if (t.get("left") && t.get("right")) {
                    for (c = 0, h = s.length; c < h; c++) {
                        i[s[c]] = true
                    }
                    a = [].concat(t.get("right").fields);
                    for (c = 0, h = a.length; c < h; c++) {
                        if (i[a[c]]) {
                            break
                        }
                    }
                    a = [].concat(t.get("left").fields);
                    for (c = 0, h = a.length; c < h; c++) {
                        if (i[a[c]]) {
                            l = "left";
                            break
                        }
                    }
                } else {
                    if (t.get("left")) {
                        l = "left"
                    } else {
                        if (t.get("right")) {
                            l = "right"
                        }
                    }
                }
            }
        }
        return p ? {
            xAxis: l,
            yAxis: f
        }: {
            xAxis: f,
            yAxis: l
        }
    }
});
Ext.define("Ext.chart.series.Area", {
    extend: Ext.chart.series.Cartesian,
    alias: "series.area",
    type: "area",
    stacked: true,
    style: {},
    constructor: function(e) {
        this.callParent(arguments);
        var t = this,
        n = t.chart.surface,
        r, i;
        e.highlightCfg = Ext.Object.merge({},
        {
            lineWidth: 3,
            stroke: "#55c",
            opacity: .8,
            color: "#f00"
        },
        e.highlightCfg);
        Ext.apply(t, e, {
            __excludes: []
        });
        if (t.highlight) {
            t.highlightSprite = n.add({
                type: "path",
                path: ["M", 0, 0],
                zIndex: 1e3,
                opacity: .3,
                lineWidth: 5,
                hidden: true,
                stroke: "#444"
            })
        }
        t.group = n.getGroup(t.seriesId)
    },
    shrink: function(e, t, n) {
        var r = e.length,
        i = Math.floor(r / n),
        s,
        o,
        u = 0,
        a = this.areas.length,
        f = [],
        l = [],
        c = [];
        for (o = 0; o < a; ++o) {
            f[o] = 0
        }
        for (s = 0; s < r; ++s) {
            u += +e[s];
            for (o = 0; o < a; ++o) {
                f[o] += +t[s][o]
            }
            if (s % i == 0) {
                l.push(u / i);
                for (o = 0; o < a; ++o) {
                    f[o] /= i
                }
                c.push(f);
                u = 0;
                for (o = 0, f = []; o < a; ++o) {
                    f[o] = 0
                }
            }
        }
        return {
            x: l,
            y: c
        }
    },
    getBounds: function() {
        var e = this,
        t = e.chart,
        n = t.getChartStore(),
        r = n.data.items,
        i,
        s,
        o,
        u = [].concat(e.yField),
        a = u.length,
        f = [],
        l = [],
        c = Infinity,
        h = c,
        p = c,
        d = -c,
        v = -c,
        m = Math,
        g = m.min,
        y = m.max,
        b = e.getAxesForXAndYFields(),
        w = b.xAxis,
        E = b.yAxis,
        S,
        x,
        T,
        N,
        C,
        k,
        L,
        A,
        O,
        M,
        _,
        D,
        P,
        H,
        B,
        j;
        e.setBBox();
        N = e.bbox;
        if (B = t.axes.get(w)) {
            if (B.type === "Time") {
                x = true
            }
            S = B.applyData();
            h = S.from;
            d = S.to
        }
        if (B = t.axes.get(E)) {
            S = B.applyData();
            p = S.from;
            v = S.to
        }
        if (e.xField && !Ext.isNumber(h)) {
            B = e.getMinMaxXValues();
            x = true;
            h = B[0];
            d = B[1]
        }
        if (e.yField && !Ext.isNumber(p)) {
            B = e.getMinMaxYValues();
            p = B[0];
            v = B[1]
        }
        if (!Ext.isNumber(p)) {
            p = 0
        }
        if (!Ext.isNumber(v)) {
            v = 0
        }
        s = r.length;
        if (s > 0 && x) {
            T = r[0].get(e.xField);
            if (typeof T != "number") {
                T = +T;
                if (isNaN(T)) {
                    x = false
                }
            }
        }
        for (i = 0; i < s; i++) {
            o = r[i];
            L = o.get(e.xField);
            A = [];
            if (typeof L != "number") {
                if (x) {
                    L = +L
                } else {
                    L = i
                }
            }
            f.push(L);
            M = 0;
            for (O = 0; O < a; O++) {
                if (e.__excludes[O]) {
                    continue
                }
                H = o.get(u[O]);
                if (typeof H == "number") {
                    A.push(H)
                }
            }
            l.push(A)
        }
        C = N.width / (d - h || 1);
        k = N.height / (v - p || 1);
        _ = f.length;
        if (_ > N.width && e.areas) {
            D = e.shrink(f, l, N.width);
            f = D.x;
            l = D.y
        }
        return {
            bbox: N,
            minX: h,
            minY: p,
            xValues: f,
            yValues: l,
            xScale: C,
            yScale: k,
            areasLen: a
        }
    },
    getPaths: function() {
        var e = this,
        t = e.chart,
        n = t.getChartStore(),
        r = true,
        i = e.getBounds(),
        s = i.bbox,
        o = e.items = [],
        u = [],
        a,
        f = 0,
        l = [],
        c = e.reverse,
        h,
        p,
        d,
        v,
        m,
        g,
        y,
        b,
        w,
        E,
        S,
        x,
        T;
        p = i.xValues.length;
        for (h = 0; h < p; h++) {
            m = i.xValues[h];
            T = c ? p - h - 1 : h;
            g = i.yValues[T];
            d = s.x + (m - i.minX) * i.xScale;
            if (x === undefined) {
                x = d
            }
            y = 0;
            f = 0;
            for (b = 0; b < i.areasLen; b++) {
                if (e.__excludes[b]) {
                    continue
                }
                if (!u[b]) {
                    u[b] = []
                }
                E = g[f];
                y += E;
                v = s.y + s.height - (y - i.minY) * i.yScale;
                if (!l[b]) {
                    l[b] = ["M", d, v];
                    u[b].push(["L", d, v])
                } else {
                    l[b].push("L", d, v);
                    u[b].push(["L", d, v])
                }
                if (!o[b]) {
                    o[b] = {
                        pointsUp: [],
                        pointsDown: [],
                        series: e
                    }
                }
                o[b].pointsUp.push([d, v]);
                f++
            }
        }
        for (b = 0; b < i.areasLen; b++) {
            if (e.__excludes[b]) {
                continue
            }
            S = l[b];
            if (b == 0 || r) {
                r = false;
                S.push("L", d, s.y + s.height, "L", x, s.y + s.height, "Z")
            } else {
                a = u[w];
                a.reverse();
                S.push("L", d, a[0][2]);
                for (h = 0; h < p; h++) {
                    S.push(a[h][0], a[h][1], a[h][2]);
                    o[b].pointsDown[p - h - 1] = [a[h][1], a[h][2]]
                }
                S.push("L", x, S[2], "Z")
            }
            w = b
        }
        return {
            paths: l,
            areasLen: i.areasLen
        }
    },
    drawSeries: function() {
        var e = this,
        t = e.chart,
        n = t.getChartStore(),
        r = t.surface,
        i = t.animate,
        s = e.group,
        o = Ext.apply(e.seriesStyle, e.style),
        u = e.colorArrayStyle,
        a = u && u.length || 0,
        f = e.themeIdx,
        l,
        c,
        h,
        p,
        d,
        v;
        e.unHighlightItem();
        e.cleanHighlights();
        if (!n || !n.getCount() || e.seriesIsHidden) {
            e.hide();
            e.items = [];
            return
        }
        h = e.getPaths();
        if (!e.areas) {
            e.areas = []
        }
        for (l = 0; l < h.areasLen; l++) {
            if (e.__excludes[l]) {
                continue
            }
            v = f + l;
            if (!e.areas[l]) {
                e.items[l].sprite = e.areas[l] = r.add(Ext.apply({},
                {
                    type: "path",
                    group: s,
                    path: h.paths[l],
                    stroke: o.stroke || u[v % a],
                    fill: u[v % a]
                },
                o || {}))
            }
            c = e.areas[l];
            p = h.paths[l];
            if (i) {
                d = e.renderer(c, false, {
                    path: p,
                    fill: u[l % a],
                    stroke: o.stroke || u[l % a]
                },
                l, n);
                e.animation = e.onAnimate(c, {
                    to: d
                })
            } else {
                d = e.renderer(c, false, {
                    path: p,
                    hidden: false,
                    fill: u[v % a],
                    stroke: o.stroke || u[v % a]
                },
                l, n);
                e.areas[l].setAttributes(d, true)
            }
        }
        e.renderLabels();
        e.renderCallouts()
    },
    onAnimate: function(e, t) {
        e.show();
        return this.callParent(arguments)
    },
    onCreateLabel: function(e, t, n, r) {
        return null;
        var i = this,
        s = i.labelsGroup,
        o = i.label,
        u = i.bbox,
        a = Ext.apply({},
        o, i.seriesLabelStyle || {});
        return i.chart.surface.add(Ext.apply({
            type: "text",
            "text-anchor": "middle",
            group: s,
            x: Number(t.point[0]),
            y: u.y + u.height / 2
        },
        a || {}))
    },
    onPlaceLabel: function(e, t, n, r, i, s, o) {
        var u = this,
        a = u.chart,
        f = a.resizing,
        l = u.label,
        c = l.renderer,
        h = l.field,
        p = u.bbox,
        d = Number(n.point[r][0]),
        v = Number(n.point[r][1]),
        m,
        g,
        y;
        e.setAttributes({
            text: c(t.get(h[o]), e, t, n, r, i, s, o),
            hidden: true
        },
        true);
        m = e.getBBox();
        g = m.width / 2;
        y = m.height / 2;
        if (d < p.x + g) {
            d = p.x + g
        } else {
            if (d + g > p.x + p.width) {
                d = p.x + p.width - g
            }
        }
        v = v - y;
        if (v < p.y + y) {
            v += 2 * y
        } else {
            if (v + y > p.y + p.height) {
                v -= 2 * y
            }
        }
        if (u.chart.animate && !u.chart.resizing) {
            e.show(true);
            u.onAnimate(e, {
                to: {
                    x: d,
                    y: v
                }
            })
        } else {
            e.setAttributes({
                x: d,
                y: v
            },
            true);
            if (f && u.animation) {
                u.animation.on("afteranimate",
                function() {
                    e.show(true)
                })
            } else {
                e.show(true)
            }
        }
    },
    onPlaceCallout: function(e, t, n, r, i, s, o) {
        var u = this,
        a = u.chart,
        f = a.surface,
        l = a.resizing,
        c = u.callouts,
        h = u.items,
        p = r == 0 ? false: h[r - 1].point,
        d = r == h.length - 1 ? false: h[r + 1].point,
        v = n.point,
        m,
        g,
        y,
        b,
        w,
        E,
        S = e && e.label ? e.label.getBBox() : {
            width: 0,
            height: 0
        },
        x = 30,
        T = 10,
        N = 3,
        C,
        k,
        L,
        A,
        O,
        M = u.clipRect,
        _,
        D;
        if (!S.width || !S.height) {
            return
        }
        if (!p) {
            p = v
        }
        if (!d) {
            d = v
        }
        b = (d[1] - p[1]) / (d[0] - p[0]);
        w = (v[1] - p[1]) / (v[0] - p[0]);
        E = (d[1] - v[1]) / (d[0] - v[0]);
        g = Math.sqrt(1 + b * b);
        m = [1 / g, b / g];
        y = [ - m[1], m[0]];
        if (w > 0 && E < 0 && y[1] < 0 || w < 0 && E > 0 && y[1] > 0) {
            y[0] *= -1;
            y[1] *= -1
        } else {
            if (Math.abs(w) < Math.abs(E) && y[0] < 0 || Math.abs(w) > Math.abs(E) && y[0] > 0) {
                y[0] *= -1;
                y[1] *= -1
            }
        }
        _ = v[0] + y[0] * x;
        D = v[1] + y[1] * x;
        C = _ + (y[0] > 0 ? 0 : -(S.width + 2 * N));
        k = D - S.height / 2 - N;
        L = S.width + 2 * N;
        A = S.height + 2 * N;
        if (C < M[0] || C + L > M[0] + M[2]) {
            y[0] *= -1
        }
        if (k < M[1] || k + A > M[1] + M[3]) {
            y[1] *= -1
        }
        _ = v[0] + y[0] * x;
        D = v[1] + y[1] * x;
        C = _ + (y[0] > 0 ? 0 : -(S.width + 2 * N));
        k = D - S.height / 2 - N;
        L = S.width + 2 * N;
        A = S.height + 2 * N;
        e.lines.setAttributes({
            path: ["M", v[0], v[1], "L", _, D, "Z"]
        },
        true);
        e.box.setAttributes({
            x: C,
            y: k,
            width: L,
            height: A
        },
        true);
        e.label.setAttributes({
            x: _ + (y[0] > 0 ? N: -(S.width + N)),
            y: D
        },
        true);
        for (O in e) {
            e[O].show(true)
        }
    },
    isItemInPoint: function(e, t, n, r) {
        var i = this,
        s = n.pointsUp,
        o = n.pointsDown,
        u = Math.abs,
        a = false,
        f = false,
        l = i.reverse,
        c = Infinity,
        h, p, d;
        for (h = 0, p = s.length; h < p; h++) {
            d = [s[h][0], s[h][1]];
            a = false;
            f = h == p - 1;
            if (c > u(e - d[0])) {
                c = u(e - d[0]);
                a = true;
                if (f) {++h
                }
            }
            if (!a || a && f) {
                d = s[h - 1];
                if (t >= d[1] && (!o.length || t <= o[h - 1][1])) {
                    idx = l ? p - h: h - 1;
                    n.storeIndex = idx;
                    n.storeField = i.yField[r];
                    n.storeItem = i.chart.getChartStore().getAt(idx);
                    n._points = o.length ? [d, o[h - 1]] : [d];
                    return true
                } else {
                    break
                }
            }
        }
        return false
    },
    highlightSeries: function() {
        var e, t, n;
        if (this._index !== undefined) {
            e = this.areas[this._index];
            if (e.__highlightAnim) {
                e.__highlightAnim.paused = true
            }
            e.__highlighted = true;
            e.__prevOpacity = e.__prevOpacity || e.attr.opacity || 1;
            e.__prevFill = e.__prevFill || e.attr.fill;
            e.__prevLineWidth = e.__prevLineWidth || e.attr.lineWidth;
            n = Ext.draw.Color.fromString(e.__prevFill);
            t = {
                lineWidth: (e.__prevLineWidth || 0) + 2
            };
            if (n) {
                t.fill = n.getLighter(.2).toString()
            } else {
                t.opacity = Math.max(e.__prevOpacity - .3, 0)
            }
            if (this.chart.animate) {
                e.__highlightAnim = new Ext.fx.Anim(Ext.apply({
                    target: e,
                    to: t
                },
                this.chart.animate))
            } else {
                e.setAttributes(t, true)
            }
        }
    },
    unHighlightSeries: function() {
        var e;
        if (this._index !== undefined) {
            e = this.areas[this._index];
            if (e.__highlightAnim) {
                e.__highlightAnim.paused = true
            }
            if (e.__highlighted) {
                e.__highlighted = false;
                e.__highlightAnim = new Ext.fx.Anim({
                    target: e,
                    to: {
                        fill: e.__prevFill,
                        opacity: e.__prevOpacity,
                        lineWidth: e.__prevLineWidth
                    }
                })
            }
        }
    },
    highlightItem: function(e) {
        var t = this,
        n, r;
        if (!e) {
            this.highlightSeries();
            return
        }
        n = e._points;
        if (n.length === 2) {
            r = ["M", n[0][0], n[0][1], "L", n[1][0], n[1][1]]
        } else {
            r = ["M", n[0][0], n[0][1], "L", n[0][0], t.bbox.y + t.bbox.height]
        }
        t.highlightSprite.setAttributes({
            path: r,
            hidden: false
        },
        true)
    },
    unHighlightItem: function(e) {
        if (!e) {
            this.unHighlightSeries()
        }
        if (this.highlightSprite) {
            this.highlightSprite.hide(true)
        }
    },
    hideAll: function(e) {
        var t = this;
        e = (isNaN(t._index) ? e: t._index) || 0;
        t.__excludes[e] = true;
        t.areas[e].hide(true);
        t.redraw()
    },
    showAll: function(e) {
        var t = this;
        e = (isNaN(t._index) ? e: t._index) || 0;
        t.__excludes[e] = false;
        t.areas[e].show(true);
        t.redraw()
    },
    redraw: function() {
        var e = this,
        t;
        t = e.chart.legend.rebuild;
        e.chart.legend.rebuild = false;
        e.chart.redraw();
        e.chart.legend.rebuild = t
    },
    hide: function() {
        if (this.areas) {
            var e = this,
            t = e.areas,
            n, r, i, s, o;
            if (t && t.length) {
                for (n = 0, s = t.length; n < s; ++n) {
                    if (t[n]) {
                        t[n].hide(true)
                    }
                }
                e.hideLabels()
            }
        }
    },
    getLegendColor: function(e) {
        var t = this;
        e += t.themeIdx;
        return t.colorArrayStyle[e % t.colorArrayStyle.length]
    }
});
Ext.define("Ext.chart.series.Bar", {
    extend: Ext.chart.series.Cartesian,
    alternateClassName: ["Ext.chart.BarSeries", "Ext.chart.BarChart", "Ext.chart.StackedBarChart"],
    type: "bar",
    alias: "series.bar",
    column: false,
    style: {},
    gutter: 38.2,
    groupGutter: 38.2,
    xPadding: 0,
    yPadding: 10,
    defaultRotate: {
        x: 0,
        y: 0,
        degrees: 0
    },
    constructor: function(e) {
        this.callParent(arguments);
        var t = this,
        n = t.chart.surface,
        r = t.chart.shadow,
        i, s;
        e.highlightCfg = Ext.Object.merge({
            lineWidth: 3,
            stroke: "#55c",
            opacity: .8,
            color: "#f00"
        },
        e.highlightCfg);
        Ext.apply(t, e, {
            shadowAttributes: [{
                "stroke-width": 6,
                "stroke-opacity": .05,
                stroke: "rgb(200, 200, 200)",
                translate: {
                    x: 1.2,
                    y: 1.2
                }
            },
            {
                "stroke-width": 4,
                "stroke-opacity": .1,
                stroke: "rgb(150, 150, 150)",
                translate: {
                    x: .9,
                    y: .9
                }
            },
            {
                "stroke-width": 2,
                "stroke-opacity": .15,
                stroke: "rgb(100, 100, 100)",
                translate: {
                    x: .6,
                    y: .6
                }
            }]
        });
        t.group = n.getGroup(t.seriesId + "-bars");
        if (r) {
            for (i = 0, s = t.shadowAttributes.length; i < s; i++) {
                t.shadowGroups.push(n.getGroup(t.seriesId + "-shadows" + i))
            }
        }
    },
    getPadding: function() {
        var e = this,
        t = e.xPadding,
        n = e.yPadding,
        r = {};
        if (Ext.isNumber(t)) {
            r.left = t;
            r.right = t
        } else {
            if (Ext.isObject(t)) {
                r.left = t.left;
                r.right = t.right
            } else {
                r.left = 0;
                r.right = 0
            }
        }
        r.width = r.left + r.right;
        if (Ext.isNumber(n)) {
            r.bottom = n;
            r.top = n
        } else {
            if (Ext.isObject(n)) {
                r.bottom = n.bottom;
                r.top = n.top
            } else {
                r.bottom = 0;
                r.top = 0
            }
        }
        r.height = r.bottom + r.top;
        return r
    },
    getBarGirth: function() {
        var e = this,
        t = e.chart.getChartStore(),
        n = e.column,
        r = t.getCount(),
        i = e.gutter / 100,
        s,
        o;
        o = n ? "width": "height";
        if (e.style && e.style[o]) {
            e.configuredColumnGirth = true;
            return + e.style[o]
        }
        s = e.getPadding();
        return (e.chart.chartBBox[o] - s[o]) / (r * (i + 1) - i)
    },
    getGutters: function() {
        var e = this,
        t = e.column,
        n = e.getPadding(),
        r = e.getBarGirth() / 2,
        i = Math.ceil((t ? n.left: n.bottom) + r),
        s = Math.ceil((t ? n.right: n.top) + r);
        return {
            lower: i,
            upper: s,
            verticalAxis: !t
        }
    },
    getBounds: function() {
        var e = this,
        t = e.chart,
        n = t.getChartStore(),
        r = n.data.items,
        i,
        s,
        o,
        u = [].concat(e.yField),
        a = [],
        f = u.length,
        l = f,
        c = e.groupGutter / 100,
        h = e.column,
        p = e.getPadding(),
        d = e.stacked,
        v = e.getBarGirth(),
        m = h ? "width": "height",
        g = Math,
        y = g.min,
        b = g.max,
        w = g.abs,
        E = e.getAxesForXAndYFields(),
        S = E.yAxis,
        x,
        T,
        N,
        C,
        k,
        L,
        A,
        O,
        M,
        _,
        D,
        P,
        H,
        B,
        j,
        F,
        I,
        q,
        R,
        U,
        z,
        W,
        X;
        e.setBBox(true);
        M = e.bbox;
        if (e.__excludes) {
            for (q = 0, F = e.__excludes.length; q < F; q++) {
                if (e.__excludes[q]) {
                    l--
                }
            }
        }
        P = t.axes.get(S);
        if (P) {
            L = P.applyData();
            _ = L.from;
            D = L.to
        }
        if (e.yField && !Ext.isNumber(_)) {
            H = e.getMinMaxYValues();
            _ = H[0];
            D = H[1]
        }
        if (!Ext.isNumber(_)) {
            _ = 0
        }
        if (!Ext.isNumber(D)) {
            D = 0
        }
        B = (h ? M.height - p.height: M.width - p.width) / (D - _);
        A = v;
        O = v / ((d ? 1 : l) * (c + 1) - c);
        if (m in e.style) {
            O = y(O, e.style[m]);
            A = O * ((d ? 1 : l) * (c + 1) - c)
        }
        j = h ? M.y + M.height - p.bottom: M.x + p.left;
        if (d) {
            F = [[], []];
            for (i = 0, s = r.length; i < s; i++) {
                o = r[i];
                F[0][i] = F[0][i] || 0;
                F[1][i] = F[1][i] || 0;
                for (q = 0; q < f; q++) {
                    if (e.__excludes && e.__excludes[q]) {
                        continue
                    }
                    I = o.get(u[q]);
                    F[ + (I > 0)][i] += w(I)
                }
            }
            F[ + (D > 0)].push(w(D));
            F[ + (_ > 0)].push(w(_));
            U = b.apply(g, F[0]);
            R = b.apply(g, F[1]);
            B = (h ? M.height - p.height: M.width - p.width) / (R + U);
            j = j + U * B * (h ? -1 : 1)
        } else {
            if (_ / D < 0) {
                j = j - _ * B * (h ? -1 : 1)
            }
        }
        if (e.boundColumn) {
            P = t.axes.get(E.xAxis);
            if (P) {
                L = P.applyData();
                x = L.from;
                T = L.to
            }
            if (e.xField && !Ext.isNumber(x)) {
                H = e.getMinMaxYValues();
                x = H[0];
                T = H[1]
            }
            if (!Ext.isNumber(x)) {
                x = 0
            }
            if (!Ext.isNumber(T)) {
                T = 0
            }
            k = e.getGutters();
            N = (M.width - (k.lower + k.upper)) / (T - x || 1);
            C = M.x + k.lower;
            a = [];
            for (i = 0, s = r.length; i < s; i++) {
                o = r[i];
                I = o.get(e.xField);
                a[i] = C + (I - x) * N - O / 2
            }
        } else {
            if (e.configuredColumnGirth) {
                P = t.axes.get(E.xAxis);
                if (P) {
                    z = P.inflections;
                    if (P.isCategoryAxis || z.length == r.length) {
                        a = [];
                        for (i = 0, s = r.length; i < s; i++) {
                            W = z[i];
                            X = h ? W[0] : W[1];
                            a[i] = X - A / 2
                        }
                    }
                }
            }
        }
        return {
            bars: u,
            barsLoc: a,
            bbox: M,
            shrunkBarWidth: A,
            barsLen: f,
            groupBarsLen: l,
            barWidth: v,
            groupBarWidth: O,
            scale: B,
            zero: j,
            padding: p,
            signed: _ / D < 0,
            minY: _,
            maxY: D
        }
    },
    getPaths: function() {
        var e = this,
        t = e.chart,
        n = t.getChartStore(),
        r = n.data.items,
        i,
        s,
        o,
        u = e.bounds = e.getBounds(),
        a = e.items = [],
        f = Ext.isArray(e.yField) ? e.yField: [e.yField],
        l = e.gutter / 100,
        c = e.groupGutter / 100,
        h = t.animate,
        p = e.column,
        d = e.group,
        v = t.shadow,
        m = e.shadowGroups,
        g = e.shadowAttributes,
        y = m.length,
        b = u.bbox,
        w = u.barWidth,
        E = u.shrunkBarWidth,
        S = e.getPadding(),
        x = e.stacked,
        T = u.barsLen,
        N = e.colorArrayStyle,
        C = N && N.length || 0,
        k = e.themeIdx,
        L = e.reverse,
        A = Math,
        O = A.max,
        M = A.min,
        _ = A.abs,
        D,
        P,
        H,
        B,
        j,
        F,
        I,
        q,
        R,
        U,
        z,
        W,
        X,
        V,
        $,
        J,
        K,
        Q,
        G,
        Y,
        Z,
        et,
        tt,
        nt,
        rt;
        for (i = 0, s = r.length; i < s; i++) {
            o = r[i];
            F = u.zero;
            I = u.zero;
            B = 0;
            j = 0;
            W = X = 0;
            q = false;
            nt = 0;
            for (D = 0, z = 0; D < T; D++) {
                if (e.__excludes && e.__excludes[D]) {
                    continue
                }
                P = o.get(u.bars[D]);
                if (P >= 0) {
                    W += P
                } else {
                    X += P
                }
                H = Math.round((P - O(u.minY, 0)) * u.scale);
                G = k + (T > 1 ? D: 0);
                R = {
                    fill: N[G % C]
                };
                if (p) {
                    G = L ? s - i - 1 : i;
                    rt = L ? T - z - 1 : z;
                    if (e.boundColumn) {
                        Z = u.barsLoc[G]
                    } else {
                        if (e.configuredColumnGirth && u.barsLoc.length) {
                            Z = u.barsLoc[G] + rt * u.groupBarWidth * (1 + c) * !x
                        } else {
                            Z = b.x + S.left + (w - E) * .5 + G * w * (1 + l) + rt * u.groupBarWidth * (1 + c) * !x
                        }
                    }
                    Ext.apply(R, {
                        height: H,
                        width: O(u.groupBarWidth, 0),
                        x: Z,
                        y: F - H
                    })
                } else {
                    K = s - 1 - i;
                    tt = H + (F == u.zero);
                    Z = F + (F != u.zero);
                    if (L) {
                        Z = u.zero + b.width - tt - (nt === 0 ? 1 : 0);
                        if (x) {
                            Z -= nt;
                            nt += tt
                        }
                    }
                    if (e.configuredColumnGirth && u.barsLoc.length) {
                        et = u.barsLoc[i] + z * u.groupBarWidth * (1 + c) * !x
                    } else {
                        et = b.y + S.top + (w - E) * .5 + K * w * (1 + l) + z * u.groupBarWidth * (1 + c) * !x + 1
                    }
                    Ext.apply(R, {
                        height: O(u.groupBarWidth, 0),
                        width: tt,
                        x: Z,
                        y: et
                    })
                }
                if (H < 0) {
                    if (p) {
                        R.y = I;
                        R.height = _(H)
                    } else {
                        R.x = I + H;
                        R.width = _(H)
                    }
                }
                if (x) {
                    if (H < 0) {
                        I += H * (p ? -1 : 1)
                    } else {
                        F += H * (p ? -1 : 1)
                    }
                    B += _(H);
                    if (H < 0) {
                        j += _(H)
                    }
                }
                R.x = Math.floor(R.x) + 1;
                Q = Math.floor(R.y);
                if (Ext.isIE8m && R.y > Q) {
                    Q--
                }
                R.y = Q;
                R.width = Math.floor(R.width);
                R.height = Math.floor(R.height);
                a.push({
                    series: e,
                    yField: f[D],
                    storeItem: o,
                    value: [o.get(e.xField), P],
                    attr: R,
                    point: p ? [R.x + R.width / 2, P >= 0 ? R.y: R.y + R.height] : [P >= 0 ? R.x + R.width: R.x, R.y + R.height / 2]
                });
                if (h && t.resizing) {
                    U = p ? {
                        x: R.x,
                        y: u.zero,
                        width: R.width,
                        height: 0
                    }: {
                        x: u.zero,
                        y: R.y,
                        width: 0,
                        height: R.height
                    };
                    if (v && (x && !q || !x)) {
                        q = true;
                        for (V = 0; V < y; V++) {
                            $ = m[V].getAt(x ? i: i * T + D);
                            if ($) {
                                $.setAttributes(U, true)
                            }
                        }
                    }
                    J = d.getAt(i * T + D);
                    if (J) {
                        J.setAttributes(U, true)
                    }
                }
                z++
            }
            if (x && a.length) {
                a[i * z].totalDim = B;
                a[i * z].totalNegDim = j;
                a[i * z].totalPositiveValues = W;
                a[i * z].totalNegativeValues = X
            }
        }
        if (x && z == 0) {
            for (i = 0, s = r.length; i < s; i++) {
                for (V = 0; V < y; V++) {
                    $ = m[V].getAt(i);
                    if ($) {
                        $.hide(true)
                    }
                }
            }
        }
    },
    renderShadows: function(e, t, n, r) {
        var i = this,
        s = i.chart,
        o = s.surface,
        u = s.animate,
        a = i.stacked,
        f = i.shadowGroups,
        l = i.shadowAttributes,
        c = f.length,
        h = s.getChartStore(),
        p = i.column,
        d = i.items,
        v = [],
        m = i.reverse,
        g = r.zero,
        y,
        b,
        w,
        E,
        S,
        x,
        T;
        if (a && e % r.groupBarsLen === 0 || !a) {
            x = e / r.groupBarsLen;
            for (y = 0; y < c; y++) {
                b = Ext.apply({},
                l[y]);
                w = f[y].getAt(a ? x: e);
                Ext.copyTo(b, t, "x,y,width,height");
                if (!w) {
                    w = o.add(Ext.apply({
                        type: "rect",
                        isShadow: true,
                        group: f[y]
                    },
                    Ext.apply({},
                    n, b)))
                }
                if (a) {
                    E = d[e].totalDim;
                    S = d[e].totalNegDim;
                    if (p) {
                        b.y = g + S - E - 1;
                        b.height = E
                    } else {
                        if (m) {
                            b.x = g + r.bbox.width - E
                        } else {
                            b.x = g - S
                        }
                        b.width = E
                    }
                }
                T = i.renderer(w, h.getAt(x), b, e, h);
                T.hidden = !!t.hidden;
                if (u) {
                    i.onAnimate(w, {
                        zero: r.zero + (m ? r.bbox.width: 0),
                        to: T
                    })
                } else {
                    w.setAttributes(T, true)
                }
                v.push(w)
            }
        }
        return v
    },
    drawSeries: function() {
        var e = this,
        t = e.chart,
        n = t.getChartStore(),
        r = t.surface,
        i = t.animate,
        s = e.stacked,
        o = e.column,
        u = t.axes,
        a = e.getAxesForXAndYFields(),
        f = a.xAxis,
        l = a.yAxis,
        c = t.shadow,
        h = e.shadowGroups,
        p = h.length,
        d = e.group,
        v = e.seriesStyle,
        m,
        g,
        y,
        b,
        w,
        E,
        S,
        x,
        T,
        N,
        C,
        k,
        L,
        A;
        if (!n || !n.getCount() || e.seriesIsHidden) {
            e.hide();
            e.items = [];
            return
        }
        C = Ext.apply({},
        this.style, v);
        delete C.fill;
        delete C.x;
        delete C.y;
        delete C.width;
        delete C.height;
        e.unHighlightItem();
        e.cleanHighlights();
        e.boundColumn = f && Ext.Array.contains(e.axis, f) && u.get(f) && u.get(f).isNumericAxis;
        e.getPaths();
        N = e.bounds;
        m = e.items;
        w = o ? {
            y: N.zero,
            height: 0
        }: {
            x: N.zero,
            width: 0
        };
        g = m.length;
        for (y = 0; y < g; y++) {
            E = d.getAt(y);
            k = m[y].attr;
            if (c) {
                m[y].shadows = e.renderShadows(y, k, w, N)
            }
            if (!E) {
                L = Ext.apply({},
                w, k);
                L = Ext.apply(L, C || {});
                E = r.add(Ext.apply({},
                {
                    type: "rect",
                    group: d
                },
                L))
            }
            if (i) {
                S = e.renderer(E, n.getAt(y), k, y, n);
                E._to = S;
                A = e.onAnimate(E, {
                    zero: N.zero + (e.reverse ? N.bbox.width: 0),
                    to: Ext.apply(S, C)
                });
                if (c && s && y % N.barsLen === 0) {
                    b = y / N.barsLen;
                    for (x = 0; x < p; x++) {
                        A.on("afteranimate",
                        function() {
                            this.show(true)
                        },
                        h[x].getAt(b))
                    }
                }
            } else {
                S = e.renderer(E, n.getAt(y), Ext.apply(k, {
                    hidden: false
                }), y, n);
                E.setAttributes(Ext.apply(S, C), true)
            }
            m[y].sprite = E
        }
        g = d.getCount();
        for (b = y; b < g; b++) {
            d.getAt(b).hide(true)
        }
        if (e.stacked) {
            y = n.getCount()
        }
        if (c) {
            for (x = 0; x < p; x++) {
                T = h[x];
                g = T.getCount();
                for (b = y; b < g; b++) {
                    T.getAt(b).hide(true)
                }
            }
        }
        e.renderLabels()
    },
    onCreateLabel: function(e, t, n, r) {
        var i = this,
        s = i.chart.surface,
        o = i.labelsGroup,
        u = i.label,
        a = Ext.apply({},
        u, i.seriesLabelStyle || {}),
        f;
        return s.add(Ext.apply({
            type: "text",
            group: o
        },
        a || {}))
    },
    onPlaceLabel: function(e, t, n, r, i, s, o) {
        var u = this,
        a = u.bounds,
        f = a.groupBarWidth,
        l = u.column,
        c = u.chart,
        h = c.chartBBox,
        p = c.resizing,
        d = n.value[0],
        v = n.value[1],
        m = n.attr,
        g = u.label,
        y = u.stacked,
        b = g.stackedDisplay,
        w = g.orientation == "vertical",
        E = [].concat(g.field),
        S = g.renderer,
        x,
        T,
        N,
        C,
        k = a.zero,
        L = "insideStart",
        A = "insideEnd",
        O = "outside",
        M = "over",
        _ = "under",
        D = 4,
        P = 2,
        H = a.signed,
        B = u.reverse,
        j,
        F,
        I;
        if (i == L || i == A || i == O) {
            if (y && i == O) {
                e.hide(true);
                return
            }
            e.setAttributes({
                style: undefined
            });
            x = Ext.isNumber(o) ? S(t.get(E[o]), e, t, n, r, i, s, o) : "";
            e.setAttributes({
                text: x
            });
            T = u.getLabelSize(x, e.attr.style);
            N = T.width;
            C = T.height;
            if (l) {
                if (!N || !C || y && m.height < C) {
                    e.hide(true);
                    return
                }
                j = m.x + (w ? f / 2 : (f - N) / 2);
                if (i == O) {
                    var q = v >= 0 ? m.y - h.y: h.y + h.height - m.y - m.height;
                    if (q < C + P) {
                        i = A
                    }
                }
                if (!y && i != O) {
                    if (C + P > m.height) {
                        i = O
                    }
                }
                if (!F) {
                    F = m.y;
                    if (v >= 0) {
                        switch (i) {
                        case L:
                            F += m.height + (w ? -P: -C / 2);
                            break;
                        case A:
                            F += w ? C + D: C / 2;
                            break;
                        case O:
                            F += w ? -P: -C / 2;
                            break
                        }
                    } else {
                        switch (i) {
                        case L:
                            F += w ? C + P: C / 2;
                            break;
                        case A:
                            F += w ? m.height - P: m.height - C / 2;
                            break;
                        case O:
                            F += w ? m.height + C + P: m.height + C / 2;
                            break
                        }
                    }
                }
            } else {
                if (!N || !C || y && !m.width) {
                    e.hide(true);
                    return
                }
                F = m.y + (w ? (f + C) / 2 : f / 2);
                if (i == O) {
                    var q = v >= 0 ? h.x + h.width - m.x - m.width: m.x - h.x;
                    if (q < N + D) {
                        i = A
                    }
                }
                if (i != O && !w) {
                    if (N + D * 2 >= m.width) {
                        if (y) {
                            if (C > m.width) {
                                e.hide(true);
                                return
                            }
                            j = m.x + m.width / 2;
                            w = true
                        } else {
                            i = O
                        }
                    }
                }
                if (!j) {
                    j = m.x;
                    if (v >= 0) {
                        switch (i) {
                        case L:
                            if (B) {
                                j += m.width + (w ? -N / 2 : -N - D)
                            } else {
                                j += w ? N / 2 : D
                            }
                            break;
                        case A:
                            if (B) {
                                j -= w ? -N / 2 : -N - D
                            } else {
                                j += m.width + (w ? -N / 2 : -N - D)
                            }
                            break;
                        case O:
                            if (B) {
                                j -= N + (w ? N / 2 : D)
                            } else {
                                j += m.width + (w ? N / 2 : D)
                            }
                            break
                        }
                    } else {
                        switch (i) {
                        case L:
                            if (B) {
                                j -= w ? -N / 2 : -N - D
                            } else {
                                j += m.width + (w ? -N / 2 : -N - D)
                            }
                            break;
                        case A:
                            if (B) {
                                j += m.width + (w ? -N / 2 : -N - D)
                            } else {
                                j += w ? N / 2 : D
                            }
                            break;
                        case O:
                            if (B) {
                                j -= N + (w ? N / 2 : D)
                            } else {
                                j += w ? -N / 2 : -N - D
                            }
                            break
                        }
                    }
                }
            }
        } else {
            if (i == M || i == _) {
                if (y && b) {
                    x = e.attr.text;
                    e.setAttributes({
                        style: Ext.applyIf(e.attr && e.attr.style || {},
                        {
                            "font-weight": "bold",
                            "font-size": "14px"
                        })
                    });
                    T = u.getLabelSize(x, e.attr.style);
                    N = T.width;
                    C = T.height;
                    switch (i) {
                    case M:
                        if (l) {
                            j = m.x + (w ? f / 2 : (f - N) / 2);
                            F = k - (n.totalDim - n.totalNegDim) - C / 2 - P
                        } else {
                            j = k + (n.totalDim - n.totalNegDim) + D;
                            F = m.y + (w ? (f + C) / 2 : f / 2)
                        }
                        break;
                    case _:
                        if (l) {
                            j = m.x + (w ? f / 2 : (f - N) / 2);
                            F = k + n.totalNegDim + C / 2
                        } else {
                            j = k - n.totalNegDim - N - D;
                            F = m.y + (w ? (f + C) / 2 : f / 2)
                        }
                        break
                    }
                }
            }
        }
        if (j == undefined || F == undefined) {
            e.hide(true);
            return
        }
        e.isOutside = i == O;
        e.setAttributes({
            text: x
        });
        I = {
            x: j,
            y: F
        };
        I.rotate = w ? {
            x: j,
            y: F,
            degrees: 270
        }: u.defaultRotate;
        if (s && p) {
            if (l) {
                j = m.x + m.width / 2;
                F = k
            } else {
                j = k;
                F = m.y + m.height / 2
            }
            e.setAttributes({
                x: j,
                y: F
            },
            true);
            if (w) {
                e.setAttributes({
                    rotate: {
                        x: j,
                        y: F,
                        degrees: 270
                    }
                },
                true)
            }
        }
        if (s) {
            u.onAnimate(e, {
                zero: n.point[0],
                to: I
            })
        } else {
            e.setAttributes(Ext.apply(I, {
                hidden: false
            }), true)
        }
    },
    getLabelSize: function(e, t) {
        var n = this.testerLabel,
        r = this.label,
        i = Ext.apply({},
        r, t, this.seriesLabelStyle || {}),
        s = r.orientation === "vertical",
        o,
        u,
        a,
        f;
        if (!n) {
            n = this.testerLabel = this.chart.surface.add(Ext.apply({
                type: "text",
                opacity: 0
            },
            i))
        }
        n.setAttributes({
            style: t,
            text: e
        },
        true);
        o = n.getBBox();
        u = o.width;
        a = o.height;
        return {
            width: s ? a: u,
            height: s ? u: a
        }
    },
    onAnimate: function(e, t) {
        var n = this,
        r = t.to,
        i = n.stacked,
        s = n.reverse,
        o = 0,
        u, a, f, l;
        e.show();
        if (!n.column) {
            if (s) {
                a = e.getBBox();
                u = e.type == "text";
                if (!n.inHighlight) {
                    if (!i) {
                        if (u) {
                            f = a.x >= 5 ? f: t.zero
                        } else {
                            if (a.width) {
                                o = a.width
                            }
                            f = a.width ? a.x: r.x + r.width
                        }
                    } else {
                        f = t.zero
                    }
                }
                t.from = {
                    x: f,
                    width: o
                }
            }
            if (i) {
                l = t.from;
                if (!l) {
                    l = t.from = {}
                }
                l.y = r.y;
                if (!s) {
                    l.x = t.zero;
                    if (e.isShadow) {
                        l.width = 0
                    }
                }
            }
        }
        return this.callParent(arguments)
    },
    isItemInPoint: function(e, t, n) {
        var r = n.sprite.getBBox();
        return r.x <= e && r.y <= t && r.x + r.width >= e && r.y + r.height >= t
    },
    hideAll: function(e) {
        var t = this.chart.axes,
        n = t.items,
        r = n.length,
        i = 0;
        e = (isNaN(this._index) ? e: this._index) || 0;
        if (!this.__excludes) {
            this.__excludes = []
        }
        this.__excludes[e] = true;
        this.drawSeries();
        for (i; i < r; i++) {
            n[i].drawAxis()
        }
    },
    showAll: function(e) {
        var t = this.chart.axes,
        n = t.items,
        r = n.length,
        i = 0;
        e = (isNaN(this._index) ? e: this._index) || 0;
        if (!this.__excludes) {
            this.__excludes = []
        }
        this.__excludes[e] = false;
        this.drawSeries();
        for (i; i < r; i++) {
            n[i].drawAxis()
        }
    },
    getLegendColor: function(e) {
        var t = this,
        n = t.colorArrayStyle,
        r = n && n.length;
        if (t.style && t.style.fill) {
            return t.style.fill
        } else {
            return n ? n[(t.themeIdx + e) % r] : "#000"
        }
    },
    highlightItem: function(e) {
        this.callParent(arguments);
        this.inHighlight = true;
        this.renderLabels();
        delete this.inHighlight
    },
    unHighlightItem: function() {
        this.callParent(arguments);
        this.inHighlight = true;
        this.renderLabels();
        delete this.inHighlight
    },
    cleanHighlights: function() {
        this.callParent(arguments);
        this.inHighlight = true;
        this.renderLabels();
        delete this.inHighlight
    }
});
Ext.define("Ext.chart.series.Column", {
    alternateClassName: ["Ext.chart.ColumnSeries", "Ext.chart.ColumnChart", "Ext.chart.StackedColumnChart"],
    extend: Ext.chart.series.Bar,
    type: "column",
    alias: "series.column",
    column: true,
    boundColumn: false,
    xPadding: 10,
    yPadding: 0
});
Ext.define("Ext.chart.series.Gauge", {
    extend: Ext.chart.series.Series,
    type: "gauge",
    alias: "series.gauge",
    rad: Math.PI / 180,
    highlightDuration: 150,
    angleField: false,
    needle: false,
    donut: false,
    showInLegend: false,
    style: {},
    constructor: function(e) {
        this.callParent(arguments);
        var t = this,
        n = t.chart,
        r = n.surface,
        i = n.store,
        s = n.shadow,
        o, u, a;
        Ext.apply(t, e, {
            shadowAttributes: [{
                "stroke-width": 6,
                "stroke-opacity": 1,
                stroke: "rgb(200, 200, 200)",
                translate: {
                    x: 1.2,
                    y: 2
                }
            },
            {
                "stroke-width": 4,
                "stroke-opacity": 1,
                stroke: "rgb(150, 150, 150)",
                translate: {
                    x: .9,
                    y: 1.5
                }
            },
            {
                "stroke-width": 2,
                "stroke-opacity": 1,
                stroke: "rgb(100, 100, 100)",
                translate: {
                    x: .6,
                    y: 1
                }
            }]
        });
        t.group = r.getGroup(t.seriesId);
        if (s) {
            for (o = 0, u = t.shadowAttributes.length; o < u; o++) {
                t.shadowGroups.push(r.getGroup(t.seriesId + "-shadows" + o))
            }
        }
        r.customAttributes.segment = function(e) {
            return t.getSegment(e)
        }
    },
    initialize: function() {
        var e = this,
        t = e.chart.getChartStore(),
        n = t.data.items,
        r = e.label,
        i = n.length;
        e.yField = [];
        if (r && r.field && i > 0) {
            e.yField.push(n[0].get(r.field))
        }
    },
    getSegment: function(e) {
        var t = this,
        n = t.rad,
        r = Math.cos,
        i = Math.sin,
        s = Math.abs,
        o = t.centerX,
        u = t.centerY,
        a = 0,
        f = 0,
        l = 0,
        c = 0,
        h = 0,
        p = 0,
        d = 0,
        v = 0,
        m = .01,
        g = e.endRho - e.startRho,
        y = e.startAngle,
        b = e.endAngle,
        w = (y + b) / 2 * n,
        E = e.margin || 0,
        S = s(b - y) > 180,
        x = Math.min(y, b) * n,
        T = Math.max(y, b) * n,
        N = false;
        o += E * r(w);
        u += E * i(w);
        a = o + e.startRho * r(x);
        h = u + e.startRho * i(x);
        f = o + e.endRho * r(x);
        p = u + e.endRho * i(x);
        l = o + e.startRho * r(T);
        d = u + e.startRho * i(T);
        c = o + e.endRho * r(T);
        v = u + e.endRho * i(T);
        if (s(a - l) <= m && s(h - d) <= m) {
            N = true
        }
        if (N) {
            return {
                path: [["M", a, h], ["L", f, p], ["A", e.endRho, e.endRho, 0, +S, 1, c, v], ["Z"]]
            }
        } else {
            return {
                path: [["M", a, h], ["L", f, p], ["A", e.endRho, e.endRho, 0, +S, 1, c, v], ["L", l, d], ["A", e.startRho, e.startRho, 0, +S, 0, a, h], ["Z"]]
            }
        }
    },
    calcMiddle: function(e) {
        var t = this,
        n = t.rad,
        r = e.slice,
        i = t.centerX,
        s = t.centerY,
        o = r.startAngle,
        u = r.endAngle,
        a = Math.max("rho" in r ? r.rho: t.radius, t.label.minMargin),
        f = +t.donut,
        l = Math.min(o, u) * n,
        c = Math.max(o, u) * n,
        h = -(l + (c - l) / 2),
        p = i + (e.endRho + e.startRho) / 2 * Math.cos(h),
        d = s - (e.endRho + e.startRho) / 2 * Math.sin(h);
        e.middle = {
            x: p,
            y: d
        }
    },
    drawSeries: function() {
        var e = this,
        t = e.chart,
        n = t.getChartStore(),
        r = e.group,
        i = e.chart.animate,
        s = e.chart.axes.get(0),
        o = s && s.minimum || e.minimum || 0,
        u = s && s.maximum || e.maximum || 0,
        a = e.angleField || e.field || e.xField,
        f = t.surface,
        l = t.chartBBox,
        c = e.rad,
        h = +e.donut,
        p = {},
        d = [],
        v = e.seriesStyle,
        m = e.seriesLabelStyle,
        g = e.colorArrayStyle,
        y = g && g.length || 0,
        b = Math.cos,
        w = Math.sin,
        E = -180,
        S = e.reverse,
        x,
        T,
        N,
        C,
        k,
        L,
        A,
        O,
        M,
        _,
        D,
        P,
        H,
        B,
        j,
        F,
        I,
        q,
        R,
        U,
        z,
        W,
        X;
        Ext.apply(v, e.style || {});
        e.setBBox();
        U = e.bbox;
        if (e.colorSet) {
            g = e.colorSet;
            y = g.length
        }
        if (!n || !n.getCount() || e.seriesIsHidden) {
            e.hide();
            e.items = [];
            return
        }
        T = e.centerX = l.x + l.width / 2;
        N = e.centerY = l.y + l.height;
        e.radius = Math.min(T - l.x, N - l.y);
        e.slices = k = [];
        e.items = d = [];
        if (!e.value) {
            _ = n.getAt(0);
            e.value = _.get(a)
        }
        A = S ? u - e.value: e.value;
        if (e.needle) {
            W = {
                series: e,
                value: A,
                startAngle: E,
                endAngle: 0,
                rho: e.radius
            };
            z = E * (1 - (A - o) / (u - o));
            k.push(W)
        } else {
            z = E * (1 - (A - o) / (u - o));
            W = {
                series: e,
                value: A,
                startAngle: E,
                endAngle: z,
                rho: e.radius
            };
            X = {
                series: e,
                value: u - A,
                startAngle: z,
                endAngle: 0,
                rho: e.radius
            };
            if (S) {
                k.push(X, W)
            } else {
                k.push(W, X)
            }
        }
        for (D = 0, M = k.length; D < M; D++) {
            C = k[D];
            L = r.getAt(D);
            x = Ext.apply({
                segment: {
                    startAngle: C.startAngle,
                    endAngle: C.endAngle,
                    margin: 0,
                    rho: C.rho,
                    startRho: C.rho * +h / 100,
                    endRho: C.rho
                }
            },
            Ext.apply(v, g && {
                fill: g[D % y]
            } || {}));
            O = Ext.apply({},
            x.segment, {
                slice: C,
                series: e,
                storeItem: _,
                index: D
            });
            d[D] = O;
            if (!L) {
                R = Ext.apply({
                    type: "path",
                    group: r
                },
                Ext.apply(v, g && {
                    fill: g[D % y]
                } || {}));
                L = f.add(Ext.apply(R, x))
            }
            C.sprite = C.sprite || [];
            O.sprite = L;
            C.sprite.push(L);
            if (i) {
                x = e.renderer(L, _, x, D, n);
                L._to = x;
                e.onAnimate(L, {
                    to: x
                })
            } else {
                x = e.renderer(L, _, Ext.apply(x, {
                    hidden: false
                }), D, n);
                L.setAttributes(x, true)
            }
        }
        if (e.needle) {
            z = z * Math.PI / 180;
            if (!e.needleSprite) {
                e.needleSprite = e.chart.surface.add({
                    type: "path",
                    path: ["M", T + e.radius * +h / 100 * b(z), N + -Math.abs(e.radius * +h / 100 * w(z)), "L", T + e.radius * b(z), N + -Math.abs(e.radius * w(z))],
                    "stroke-width": 4,
                    stroke: "#222"
                })
            } else {
                if (i) {
                    e.onAnimate(e.needleSprite, {
                        to: {
                            path: ["M", T + e.radius * +h / 100 * b(z), N + -Math.abs(e.radius * +h / 100 * w(z)), "L", T + e.radius * b(z), N + -Math.abs(e.radius * w(z))]
                        }
                    })
                } else {
                    e.needleSprite.setAttributes({
                        type: "path",
                        path: ["M", T + e.radius * +h / 100 * b(z), N + -Math.abs(e.radius * +h / 100 * w(z)), "L", T + e.radius * b(z), N + -Math.abs(e.radius * w(z))]
                    })
                }
            }
            e.needleSprite.setAttributes({
                hidden: false
            },
            true)
        }
        delete e.value
    },
    setValue: function(e) {
        this.value = e;
        this.drawSeries()
    },
    onCreateLabel: function(e, t, n, r) {},
    onPlaceLabel: function(e, t, n, r, i, s, o) {},
    onPlaceCallout: function() {},
    onAnimate: function(e, t) {
        e.show();
        return this.callParent(arguments)
    },
    isItemInPoint: function(e, t, n, r) {
        var i = this,
        s = i.centerX,
        o = i.centerY,
        u = Math.abs,
        a = u(e - s),
        f = u(t - o),
        l = n.startAngle,
        c = n.endAngle,
        h = Math.sqrt(a * a + f * f),
        p = Math.atan2(t - o, e - s) / i.rad;
        return r === 0 && p >= l && p < c && h >= n.startRho && h <= n.endRho
    },
    getLegendColor: function(e) {
        var t = this.colorSet || this.colorArrayStyle;
        return t[e % t.length]
    }
});
Ext.define("Ext.chart.series.Line", {
    extend: Ext.chart.series.Cartesian,
    alternateClassName: ["Ext.chart.LineSeries", "Ext.chart.LineChart"],
    type: "line",
    alias: "series.line",
    selectionTolerance: 20,
    showMarkers: true,
    markerConfig: {},
    style: {},
    smooth: false,
    defaultSmoothness: 3,
    fill: false,
    constructor: function(e) {
        this.callParent(arguments);
        var t = this,
        n = t.chart.surface,
        r = t.chart.shadow,
        i, s;
        e.highlightCfg = Ext.Object.merge({
            "stroke-width": 3
        },
        e.highlightCfg);
        Ext.apply(t, e, {
            shadowAttributes: [{
                "stroke-width": 6,
                "stroke-opacity": .05,
                stroke: "rgb(0, 0, 0)",
                translate: {
                    x: 1,
                    y: 1
                }
            },
            {
                "stroke-width": 4,
                "stroke-opacity": .1,
                stroke: "rgb(0, 0, 0)",
                translate: {
                    x: 1,
                    y: 1
                }
            },
            {
                "stroke-width": 2,
                "stroke-opacity": .15,
                stroke: "rgb(0, 0, 0)",
                translate: {
                    x: 1,
                    y: 1
                }
            }]
        });
        t.group = n.getGroup(t.seriesId);
        if (t.showMarkers) {
            t.markerGroup = n.getGroup(t.seriesId + "-markers")
        }
        if (r) {
            for (i = 0, s = t.shadowAttributes.length; i < s; i++) {
                t.shadowGroups.push(n.getGroup(t.seriesId + "-shadows" + i))
            }
        }
    },
    shrink: function(e, t, n) {
        var r = e.length,
        i = Math.floor(r / n),
        s = 1,
        o = 0,
        u = 0,
        a = [ + e[0]],
        f = [ + t[0]];
        for (; s < r; ++s) {
            o += +e[s] || 0;
            u += +t[s] || 0;
            if (s % i == 0) {
                a.push(o / i);
                f.push(u / i);
                o = 0;
                u = 0
            }
        }
        return {
            x: a,
            y: f
        }
    },
    drawSeries: function() {
        var e = this,
        t = e.chart,
        n = t.axes,
        r = t.getChartStore(),
        i = r.data.items,
        s,
        o = r.getCount(),
        u = e.chart.surface,
        a = {},
        f = e.group,
        l = e.showMarkers,
        c = e.markerGroup,
        h = t.shadow,
        p = e.shadowGroups,
        d = e.shadowAttributes,
        v = e.smooth,
        m = p.length,
        g = ["M"],
        y = ["M"],
        b = ["M"],
        w = ["M"],
        E = t.markerIndex,
        S = [].concat(e.axis),
        x,
        T = [],
        N = [],
        C = false,
        k = e.reverse,
        L = [],
        A = Ext.apply({},
        e.markerStyle),
        O = e.seriesStyle,
        M = e.colorArrayStyle,
        _ = M && M.length || 0,
        D = Ext.isNumber,
        P = e.seriesIdx,
        H = e.getAxesForXAndYFields(),
        B = H.xAxis,
        j = H.yAxis,
        F = n && n.get(B),
        I = n && n.get(j),
        q = B ? F && F.type: "",
        R = j ? I && I.type: "",
        U,
        z,
        W,
        X,
        V,
        $,
        J,
        K,
        Q,
        G,
        Y,
        Z,
        et,
        tt,
        nt,
        rt,
        it,
        st,
        ot,
        ut,
        at,
        ft,
        lt,
        ct,
        ht,
        pt,
        dt,
        vt,
        mt,
        gt,
        yt,
        bt,
        wt,
        Et,
        St,
        xt,
        Tt,
        Nt,
        Ct,
        kt,
        Lt;
        if (e.fireEvent("beforedraw", e) === false) {
            return
        }
        if (!o || e.seriesIsHidden) {
            e.hide();
            e.items = [];
            if (e.line) {
                e.line.hide(true);
                if (e.line.shadows) {
                    U = e.line.shadows;
                    for (rt = 0, m = U.length; rt < m; rt++) {
                        z = U[rt];
                        z.hide(true)
                    }
                }
                if (e.fillPath) {
                    e.fillPath.hide(true)
                }
            }
            e.line = null;
            e.fillPath = null;
            return
        }
        Et = Ext.apply(A || {},
        e.markerConfig, {
            fill: e.seriesStyle.fill || M[e.themeIdx % M.length]
        });
        xt = Et.type;
        delete Et.type;
        St = O;
        if (!St["stroke-width"]) {
            St["stroke-width"] = .5
        }
        Nt = "opacity" in St ? St.opacity: 1;
        Lt = "opacity" in St ? St.opacity: .3;
        Ct = "lineOpacity" in St ? St.lineOpacity: Nt;
        kt = "fillOpacity" in St ? St.fillOpacity: Lt;
        if (E && c && c.getCount()) {
            for (nt = 0; nt < E; nt++) {
                ut = c.getAt(nt);
                c.remove(ut);
                c.add(ut);
                at = c.getAt(c.getCount() - 2);
                ut.setAttributes({
                    x: 0,
                    y: 0,
                    translate: {
                        x: at.attr.translation.x,
                        y: at.attr.translation.y
                    }
                },
                true)
            }
        }
        e.unHighlightItem();
        e.cleanHighlights();
        e.setBBox();
        a = e.bbox;
        e.clipRect = [a.x, a.y, a.width, a.height];
        if (F) {
            ot = F.applyData();
            vt = ot.from;
            mt = ot.to
        }
        if (I) {
            ot = I.applyData();
            gt = ot.from;
            yt = ot.to
        }
        if (e.xField && !Ext.isNumber(vt)) {
            st = e.getMinMaxXValues();
            vt = st[0];
            mt = st[1]
        }
        if (e.yField && !Ext.isNumber(gt)) {
            st = e.getMinMaxYValues();
            gt = st[0];
            yt = st[1]
        }
        if (isNaN(vt)) {
            vt = 0;
            pt = a.width / (o - 1 || 1)
        } else {
            pt = a.width / (mt - vt || o - 1 || 1)
        }
        if (isNaN(gt)) {
            gt = 0;
            dt = a.height / (o - 1 || 1)
        } else {
            dt = a.height / (yt - gt || o - 1 || 1)
        }
        for (nt = 0, it = i.length; nt < it; nt++) {
            s = i[nt];
            lt = s.get(e.xField);
            if (q === "Time" && typeof lt === "string") {
                lt = Date.parse(lt)
            }
            if (typeof lt === "string" || typeof lt === "object" && !Ext.isDate(lt) || q === "Category") {
                lt = nt
            }
            ct = s.get(e.yField);
            if (R === "Time" && typeof ct === "string") {
                ct = Date.parse(ct)
            }
            if (typeof ct === "undefined" || typeof ct === "string" && !ct) {
                continue
            }
            if (typeof ct === "string" || typeof ct === "object" && !Ext.isDate(ct) || R === "Category") {
                ct = nt
            }
            L.push(nt);
            T.push(lt);
            N.push(ct)
        }
        it = T.length;
        if (it > a.width) {
            ht = e.shrink(T, N, a.width);
            T = ht.x;
            N = ht.y
        }
        e.items = [];
        Tt = 0;
        it = T.length;
        for (nt = 0; nt < it; nt++) {
            lt = T[nt];
            ct = N[nt];
            if (ct === false) {
                if (y.length == 1) {
                    y = []
                }
                C = true;
                e.items.push(false);
                continue
            } else {
                if (k) {
                    K = a.x + a.width - (lt - vt) * pt
                } else {
                    K = a.x + (lt - vt) * pt
                }
                K = Ext.Number.toFixed(K, 2);
                Q = Ext.Number.toFixed(a.y + a.height - (ct - gt) * dt, 2);
                if (C) {
                    C = false;
                    y.push("M")
                }
                y = y.concat([K, Q])
            }
            if (typeof et == "undefined" && typeof Q != "undefined") {
                et = Q;
                Z = K
            }
            if (!e.line || t.resizing) {
                g = g.concat([K, a.y + a.height / 2])
            }
            if (t.animate && t.resizing && e.line) {
                e.line.setAttributes({
                    path: g,
                    opacity: Ct
                },
                true);
                if (e.fillPath) {
                    e.fillPath.setAttributes({
                        path: g,
                        opacity: kt
                    },
                    true)
                }
                if (e.line.shadows) {
                    U = e.line.shadows;
                    for (rt = 0, m = U.length; rt < m; rt++) {
                        z = U[rt];
                        z.setAttributes({
                            path: g
                        },
                        true)
                    }
                }
            }
            if (l) {
                ut = c.getAt(Tt++);
                if (!ut) {
                    ut = Ext.chart.Shape[xt](u, Ext.apply({
                        group: [f, c],
                        x: 0,
                        y: 0,
                        translate: {
                            x: +(G || K),
                            y: Y || a.y + a.height / 2
                        },
                        value: '"' + lt + ", " + ct + '"',
                        zIndex: 4e3
                    },
                    Et));
                    ut._to = {
                        translate: {
                            x: +K,
                            y: +Q
                        }
                    }
                } else {
                    ut.setAttributes({
                        value: '"' + lt + ", " + ct + '"',
                        x: 0,
                        y: 0,
                        hidden: false
                    },
                    true);
                    ut._to = {
                        translate: {
                            x: +K,
                            y: +Q
                        }
                    }
                }
            }
            e.items.push({
                series: e,
                value: [lt, ct],
                point: [K, Q],
                sprite: ut,
                storeItem: r.getAt(L[nt])
            });
            G = K;
            Y = Q
        }
        if (y.length <= 1) {
            return
        }
        if (e.smooth) {
            w = Ext.draw.Draw.smooth(y, D(v) ? v: e.defaultSmoothness)
        }
        b = v ? w: y;
        if (t.markerIndex && e.previousPath) {
            X = e.previousPath;
            if (!v) {
                Ext.Array.erase(X, 1, 2)
            }
        } else {
            X = y
        }
        if (!e.line) {
            e.line = u.add(Ext.apply({
                type: "path",
                group: f,
                path: g,
                stroke: St.stroke || St.fill
            },
            St || {}));
            e;
            e.line.setAttributes({
                opacity: Ct
            },
            true);
            if (h) {
                e.line.setAttributes(Ext.apply({},
                e.shadowOptions), true)
            }
            e.line.setAttributes({
                fill: "none",
                zIndex: 3e3
            });
            if (!St.stroke && _) {
                e.line.setAttributes({
                    stroke: M[e.themeIdx % _]
                },
                true)
            }
            if (h) {
                U = e.line.shadows = [];
                for (W = 0; W < m; W++) {
                    x = d[W];
                    x = Ext.apply({},
                    x, {
                        path: g
                    });
                    z = u.add(Ext.apply({},
                    {
                        type: "path",
                        group: p[W]
                    },
                    x));
                    U.push(z)
                }
            }
        }
        if (e.fill) {
            $ = b.concat([["L", K, a.y + a.height], ["L", Z, a.y + a.height], ["L", Z, et]]);
            if (!e.fillPath) {
                e.fillPath = u.add({
                    group: f,
                    type: "path",
                    fill: St.fill || M[e.themeIdx % _],
                    path: g
                })
            }
        }
        tt = l && c.getCount();
        if (t.animate) {
            V = e.fill;
            bt = e.line;
            J = e.renderer(bt, false, {
                path: b
            },
            nt, r);
            Ext.apply(J, St || {},
            {
                stroke: St.stroke || St.fill
            });
            delete J.fill;
            bt.show(true);
            if (t.markerIndex && e.previousPath) {
                e.animation = wt = e.onAnimate(bt, {
                    to: J,
                    from: {
                        path: X
                    }
                })
            } else {
                e.animation = wt = e.onAnimate(bt, {
                    to: J
                })
            }
            if (h) {
                U = bt.shadows;
                for (rt = 0; rt < m; rt++) {
                    U[rt].show(true);
                    if (t.markerIndex && e.previousPath) {
                        e.onAnimate(U[rt], {
                            to: {
                                path: b
                            },
                            from: {
                                path: X
                            }
                        })
                    } else {
                        e.onAnimate(U[rt], {
                            to: {
                                path: b
                            }
                        })
                    }
                }
            }
            if (V) {
                e.fillPath.show(true);
                e.onAnimate(e.fillPath, {
                    to: Ext.apply({},
                    {
                        path: $,
                        fill: St.fill || M[e.themeIdx % _],
                        "stroke-width": 0,
                        opacity: kt
                    },
                    St || {})
                })
            }
            if (l) {
                Tt = 0;
                for (nt = 0; nt < it; nt++) {
                    if (e.items[nt]) {
                        ft = c.getAt(Tt++);
                        if (ft) {
                            J = e.renderer(ft, r.getAt(nt), ft._to, nt, r);
                            e.onAnimate(ft, {
                                to: Ext.applyIf(J, Et || {})
                            });
                            ft.show(true)
                        }
                    }
                }
                for (; Tt < tt; Tt++) {
                    ft = c.getAt(Tt);
                    ft.hide(true)
                }
            }
        } else {
            J = e.renderer(e.line, false, {
                path: b,
                hidden: false
            },
            nt, r);
            Ext.apply(J, St || {},
            {
                stroke: St.stroke || St.fill
            });
            delete J.fill;
            e.line.setAttributes(J, true);
            e.line.setAttributes({
                opacity: Ct
            },
            true);
            if (h) {
                U = e.line.shadows;
                for (rt = 0; rt < m; rt++) {
                    U[rt].setAttributes({
                        path: b,
                        hidden: false
                    },
                    true)
                }
            }
            if (e.fill) {
                e.fillPath.setAttributes({
                    path: $,
                    hidden: false,
                    opacity: kt
                },
                true)
            }
            if (l) {
                Tt = 0;
                for (nt = 0; nt < it; nt++) {
                    if (e.items[nt]) {
                        ft = c.getAt(Tt++);
                        if (ft) {
                            J = e.renderer(ft, r.getAt(nt), ft._to, nt, r);
                            ft.setAttributes(Ext.apply(Et || {},
                            J || {}), true);
                            if (!ft.attr.hidden) {
                                ft.show(true)
                            }
                        }
                    }
                }
                for (; Tt < tt; Tt++) {
                    ft = c.getAt(Tt);
                    ft.hide(true)
                }
            }
        }
        if (t.markerIndex) {
            if (e.smooth) {
                Ext.Array.erase(y, 1, 2)
            } else {
                Ext.Array.splice(y, 1, 0, y[1], y[2])
            }
            e.previousPath = y
        }
        e.renderLabels();
        e.renderCallouts();
        e.fireEvent("draw", e)
    },
    onCreateLabel: function(e, t, n, r) {
        var i = this,
        s = i.labelsGroup,
        o = i.label,
        u = i.bbox,
        a = Ext.apply({},
        o, i.seriesLabelStyle || {});
        return i.chart.surface.add(Ext.apply({
            type: "text",
            "text-anchor": "middle",
            group: s,
            x: Number(t.point[0]),
            y: u.y + u.height / 2
        },
        a || {}))
    },
    onPlaceLabel: function(e, t, n, r, i, s, o) {
        var u = this,
        a = u.chart,
        f = a.resizing,
        l = u.label,
        c = l.renderer,
        h = l.field,
        p = u.bbox,
        d = Number(n.point[0]),
        v = Number(n.point[1]),
        m = n.sprite.attr.radius,
        g,
        y,
        b,
        w,
        E,
        S;
        e.setAttributes({
            text: c(t.get(h), e, t, n, r, i, s, o),
            hidden: true
        },
        true);
        y = n.sprite.getBBox();
        y.width = y.width || m * 2;
        y.height = y.height || m * 2;
        g = e.getBBox();
        b = g.width / 2;
        w = g.height / 2;
        if (i == "rotate") {
            E = y.width / 2 + b + w / 2;
            if (d + E + b > p.x + p.width) {
                d -= E
            } else {
                d += E
            }
            e.setAttributes({
                rotation: {
                    x: d,
                    y: v,
                    degrees: -45
                }
            },
            true)
        } else {
            if (i == "under" || i == "over") {
                e.setAttributes({
                    rotation: {
                        degrees: 0
                    }
                },
                true);
                if (d < p.x + b) {
                    d = p.x + b
                } else {
                    if (d + b > p.x + p.width) {
                        d = p.x + p.width - b
                    }
                }
                S = y.height / 2 + w;
                v = v + (i == "over" ? -S: S);
                if (v < p.y + w) {
                    v += 2 * S
                } else {
                    if (v + w > p.y + p.height) {
                        v -= 2 * S
                    }
                }
            }
        }
        if (u.chart.animate && !u.chart.resizing) {
            e.show(true);
            u.onAnimate(e, {
                to: {
                    x: d,
                    y: v
                }
            })
        } else {
            e.setAttributes({
                x: d,
                y: v
            },
            true);
            if (f && a.animate) {
                u.on({
                    single: true,
                    afterrender: function() {
                        e.show(true)
                    }
                })
            } else {
                e.show(true)
            }
        }
    },
    highlightItem: function() {
        var e = this,
        t = e.line;
        e.callParent(arguments);
        if (t && !e.highlighted) {
            if (! ("__strokeWidth" in t)) {
                t.__strokeWidth = parseFloat(t.attr["stroke-width"]) || 0
            }
            if (t.__anim) {
                t.__anim.paused = true
            }
            t.__anim = new Ext.fx.Anim({
                target: t,
                to: {
                    "stroke-width": t.__strokeWidth + 3
                }
            });
            e.highlighted = true
        }
    },
    unHighlightItem: function() {
        var e = this,
        t = e.line,
        n;
        e.callParent(arguments);
        if (t && e.highlighted) {
            n = t.__strokeWidth || parseFloat(t.attr["stroke-width"]) || 0;
            t.__anim = new Ext.fx.Anim({
                target: t,
                to: {
                    "stroke-width": n
                }
            });
            e.highlighted = false
        }
    },
    onPlaceCallout: function(e, t, n, r, i, s, o) {
        if (!i) {
            return
        }
        var u = this,
        a = u.chart,
        f = a.surface,
        l = a.resizing,
        c = u.callouts,
        h = u.items,
        p = r == 0 ? false: h[r - 1].point,
        d = r == h.length - 1 ? false: h[r + 1].point,
        v = [ + n.point[0], +n.point[1]],
        m,
        g,
        y,
        b,
        w,
        E,
        S = c.offsetFromViz || 30,
        x = c.offsetToSide || 10,
        T = c.offsetBox || 3,
        N,
        C,
        k,
        L,
        A,
        O = u.clipRect,
        M = {
            width: c.styles.width || 10,
            height: c.styles.height || 10
        },
        _,
        D;
        if (!p) {
            p = v
        }
        if (!d) {
            d = v
        }
        b = (d[1] - p[1]) / (d[0] - p[0]);
        w = (v[1] - p[1]) / (v[0] - p[0]);
        E = (d[1] - v[1]) / (d[0] - v[0]);
        g = Math.sqrt(1 + b * b);
        m = [1 / g, b / g];
        y = [ - m[1], m[0]];
        if (w > 0 && E < 0 && y[1] < 0 || w < 0 && E > 0 && y[1] > 0) {
            y[0] *= -1;
            y[1] *= -1
        } else {
            if (Math.abs(w) < Math.abs(E) && y[0] < 0 || Math.abs(w) > Math.abs(E) && y[0] > 0) {
                y[0] *= -1;
                y[1] *= -1
            }
        }
        _ = v[0] + y[0] * S;
        D = v[1] + y[1] * S;
        N = _ + (y[0] > 0 ? 0 : -(M.width + 2 * T));
        C = D - M.height / 2 - T;
        k = M.width + 2 * T;
        L = M.height + 2 * T;
        if (N < O[0] || N + k > O[0] + O[2]) {
            y[0] *= -1
        }
        if (C < O[1] || C + L > O[1] + O[3]) {
            y[1] *= -1
        }
        _ = v[0] + y[0] * S;
        D = v[1] + y[1] * S;
        N = _ + (y[0] > 0 ? 0 : -(M.width + 2 * T));
        C = D - M.height / 2 - T;
        k = M.width + 2 * T;
        L = M.height + 2 * T;
        if (a.animate) {
            u.onAnimate(e.lines, {
                to: {
                    path: ["M", v[0], v[1], "L", _, D, "Z"]
                }
            });
            if (e.panel) {
                e.panel.setPosition(N, C, true)
            }
        } else {
            e.lines.setAttributes({
                path: ["M", v[0], v[1], "L", _, D, "Z"]
            },
            true);
            if (e.panel) {
                e.panel.setPosition(N, C)
            }
        }
        for (A in e) {
            e[A].show(true)
        }
    },
    isItemInPoint: function(e, t, n, r) {
        var i = this,
        s = i.items,
        o = i.selectionTolerance,
        u = null,
        a, f, l, c, h, p, d, v, m, g, y, b, w, E, S, x, T = Math.sqrt,
        N = Math.abs;
        f = s[r];
        a = r && s[r - 1];
        if (r >= h) {
            a = s[h - 1]
        }
        l = a && a.point;
        c = f && f.point;
        p = a ? l[0] : c[0] - o;
        d = a ? l[1] : c[1];
        v = f ? c[0] : l[0] + o;
        m = f ? c[1] : l[1];
        b = T((e - p) * (e - p) + (t - d) * (t - d));
        w = T((e - v) * (e - v) + (t - m) * (t - m));
        E = Math.min(b, w);
        if (E <= o) {
            return E == b ? a: f
        }
        return false
    },
    toggleAll: function(e) {
        var t = this,
        n, r, i, s;
        if (!e) {
            Ext.chart.series.Cartesian.prototype.hideAll.call(t)
        } else {
            Ext.chart.series.Cartesian.prototype.showAll.call(t)
        }
        if (t.line) {
            t.line.setAttributes({
                hidden: !e
            },
            true);
            if (t.line.shadows) {
                for (n = 0, s = t.line.shadows, r = s.length; n < r; n++) {
                    i = s[n];
                    i.setAttributes({
                        hidden: !e
                    },
                    true)
                }
            }
        }
        if (t.fillPath) {
            t.fillPath.setAttributes({
                hidden: !e
            },
            true)
        }
    },
    hideAll: function() {
        this.toggleAll(false)
    },
    showAll: function() {
        this.toggleAll(true)
    }
});
Ext.define("Ext.chart.series.Pie", {
    alternateClassName: ["Ext.chart.PieSeries", "Ext.chart.PieChart"],
    extend: Ext.chart.series.Series,
    type: "pie",
    alias: "series.pie",
    accuracy: 1e5,
    rad: Math.PI * 2 / 1e5,
    highlightDuration: 150,
    angleField: false,
    lengthField: false,
    donut: false,
    showInLegend: false,
    style: {},
    clockwise: false,
    rotation: undefined,
    constructor: function(e) {
        this.callParent(arguments);
        var t = this,
        n = t.chart,
        r = n.surface,
        i = n.store,
        s = n.shadow,
        o = e.highlight,
        u, a, f;
        if (o) {
            e.highlightCfg = Ext.merge({
                segment: {
                    margin: 20
                }
            },
            o, e.highlightCfg)
        }
        Ext.apply(t, e, {
            shadowAttributes: [{
                "stroke-width": 6,
                "stroke-opacity": 1,
                stroke: "rgb(200, 200, 200)",
                translate: {
                    x: 1.2,
                    y: 2
                }
            },
            {
                "stroke-width": 4,
                "stroke-opacity": 1,
                stroke: "rgb(150, 150, 150)",
                translate: {
                    x: .9,
                    y: 1.5
                }
            },
            {
                "stroke-width": 2,
                "stroke-opacity": 1,
                stroke: "rgb(100, 100, 100)",
                translate: {
                    x: .6,
                    y: 1
                }
            }]
        });
        t.group = r.getGroup(t.seriesId);
        if (s) {
            for (u = 0, a = t.shadowAttributes.length; u < a; u++) {
                t.shadowGroups.push(r.getGroup(t.seriesId + "-shadows" + u))
            }
        }
        r.customAttributes.segment = function(e) {
            var n = t.getSegment(e);
            if (!n.path || n.path.length === 0) {
                n.path = ["M", 0, 0]
            }
            return n
        };
        t.__excludes = t.__excludes || []
    },
    onRedraw: function() {
        this.initialize()
    },
    initialize: function() {
        var e = this,
        t = e.chart.getChartStore(),
        n = t.data.items,
        r,
        i,
        s;
        e.callParent();
        e.yField = [];
        if (e.label.field) {
            for (r = 0, i = n.length; r < i; r++) {
                s = n[r];
                e.yField.push(s.get(e.label.field))
            }
        }
    },
    getSegment: function(e) {
        var t = this,
        n = t.rad,
        r = Math.cos,
        i = Math.sin,
        s = t.centerX,
        o = t.centerY,
        u = 0,
        a = 0,
        f = 0,
        l = 0,
        c = 0,
        h = 0,
        p = 0,
        d = 0,
        v = 0,
        m = 0,
        g = 0,
        y = 0,
        b = .01,
        w = e.startAngle,
        E = e.endAngle,
        S = (w + E) / 2 * n,
        x = e.margin || 0,
        T = Math.min(w, E) * n,
        N = Math.max(w, E) * n,
        C = r(T),
        k = i(T),
        L = r(N),
        A = i(N),
        O = r(S),
        M = i(S),
        _ = 0,
        D = .7071067811865476;
        if (N - T < b) {
            return {
                path: ""
            }
        }
        if (x !== 0) {
            s += x * O;
            o += x * M
        }
        a = s + e.endRho * C;
        h = o + e.endRho * k;
        l = s + e.endRho * L;
        d = o + e.endRho * A;
        g = s + e.endRho * O;
        y = o + e.endRho * M;
        if (e.startRho !== 0) {
            u = s + e.startRho * C;
            c = o + e.startRho * k;
            f = s + e.startRho * L;
            p = o + e.startRho * A;
            v = s + e.startRho * O;
            m = o + e.startRho * M;
            return {
                path: [["M", a, h], ["A", e.endRho, e.endRho, 0, 0, 1, g, y], ["L", g, y], ["A", e.endRho, e.endRho, 0, _, 1, l, d], ["L", l, d], ["L", f, p], ["A", e.startRho, e.startRho, 0, _, 0, v, m], ["L", v, m], ["A", e.startRho, e.startRho, 0, 0, 0, u, c], ["L", u, c], ["Z"]]
            }
        } else {
            return {
                path: [["M", s, o], ["L", a, h], ["A", e.endRho, e.endRho, 0, 0, 1, g, y], ["L", g, y], ["A", e.endRho, e.endRho, 0, _, 1, l, d], ["L", l, d], ["L", s, o], ["Z"]]
            }
        }
    },
    calcMiddle: function(e) {
        var t = this,
        n = t.rad,
        r = e.slice,
        i = t.centerX,
        s = t.centerY,
        o = r.startAngle,
        u = r.endAngle,
        a = +t.donut,
        f = -(o + u) * n / 2,
        l = (e.endRho + e.startRho) / 2,
        c = i + l * Math.cos(f),
        h = s - l * Math.sin(f);
        e.middle = {
            x: c,
            y: h
        }
    },
    drawSeries: function() {
        var e = this,
        t = e.chart.getChartStore(),
        n = t.data.items,
        r,
        i = e.group,
        s = e.chart.animate,
        o = e.angleField || e.field || e.xField,
        u = [].concat(e.lengthField),
        a = 0,
        f = e.chart,
        l = f.surface,
        c = f.chartBBox,
        h = f.shadow,
        p = e.shadowGroups,
        d = e.shadowAttributes,
        v = p.length,
        m = u.length,
        g = 0,
        y = +e.donut,
        b = [],
        w = [],
        E = 0,
        S = 0,
        x = 0,
        T = e.rotation,
        N = e.seriesStyle,
        C = e.colorArrayStyle,
        k = C && C.length || 0,
        L,
        A,
        O,
        M,
        _,
        D,
        P,
        H,
        B = 0,
        j,
        F,
        I,
        q,
        R,
        U,
        z,
        W,
        X,
        V,
        $,
        J,
        K,
        Q;
        Ext.apply(N, e.style || {});
        e.setBBox();
        Q = e.bbox;
        if (e.colorSet) {
            C = e.colorSet;
            k = C.length
        }
        if (!t || !t.getCount() || e.seriesIsHidden) {
            e.hide();
            e.items = [];
            return
        }
        e.unHighlightItem();
        e.cleanHighlights();
        D = e.centerX = c.x + c.width / 2;
        P = e.centerY = c.y + c.height / 2;
        e.radius = Math.min(D - c.x, P - c.y);
        e.slices = F = [];
        e.items = w = [];
        for (W = 0, z = n.length; W < z; W++) {
            r = n[W];
            if (this.__excludes && this.__excludes[W]) {
                continue
            }
            E += +r.get(o);
            if (u[0]) {
                for (X = 0, a = 0; X < m; X++) {
                    a += +r.get(u[X])
                }
                b[W] = a;
                S = Math.max(S, a)
            }
        }
        E = E || 1;
        for (W = 0, z = n.length; W < z; W++) {
            r = n[W];
            if (this.__excludes && this.__excludes[W]) {
                q = 0
            } else {
                q = r.get(o);
                if (B === 0) {
                    B = 1
                }
            }
            if (B == 1) {
                B = 2;
                if (Ext.isEmpty(T)) {
                    e.firstAngle = x = (e.clockwise ? -1 : 1) * (e.accuracy * q / E / 2)
                } else {
                    if (!Ext.isEmpty(T.degrees)) {
                        T = Ext.draw.Draw.rad(T.degrees)
                    } else {
                        if (!Ext.isEmpty(T.radians)) {
                            T = T.radians
                        }
                    }
                    e.firstAngle = x = e.accuracy * T / (2 * Math.PI)
                }
                for (X = 0; X < W; X++) {
                    F[X].startAngle = F[X].endAngle = e.firstAngle
                }
            }
            V = x + (e.clockwise ? 1 : -1) * (e.accuracy * q / E);
            j = {
                series: e,
                value: q,
                startAngle: e.clockwise ? V: x,
                endAngle: e.clockwise ? x: V,
                storeItem: r
            };
            if (u[0] && !(this.__excludes && this.__excludes[W])) {
                U = +b[W];
                j.rho = Math.floor(e.radius / S * U)
            } else {
                j.rho = e.radius
            }
            F[W] = j; (function() {
                x = V
            })()
        }
        if (h) {
            for (W = 0, z = F.length; W < z; W++) {
                j = F[W];
                j.shadowAttrs = [];
                r = t.getAt(W);
                for (X = 0, g = 0, O = []; X < m; X++) {
                    I = i.getAt(W * m + X);
                    if (u[X] && !(this.__excludes && this.__excludes[W])) {
                        H = r.get(u[X]) / b[W] * j.rho
                    } else {
                        H = j.rho
                    }
                    L = {
                        segment: {
                            startAngle: j.startAngle,
                            endAngle: j.endAngle,
                            margin: 0,
                            rho: j.rho,
                            startRho: g + H * y / 100,
                            endRho: g + H
                        },
                        hidden: !j.value && j.startAngle % e.accuracy == j.endAngle % e.accuracy
                    };
                    for (_ = 0, O = []; _ < v; _++) {
                        A = d[_];
                        M = p[_].getAt(W);
                        if (!M) {
                            M = f.surface.add(Ext.apply({},
                            {
                                type: "path",
                                group: p[_],
                                strokeLinejoin: "round"
                            },
                            L, A))
                        }
                        A = e.renderer(M, r, Ext.apply({},
                        L, A), W, t);
                        if (s) {
                            e.onAnimate(M, {
                                to: A
                            })
                        } else {
                            M.setAttributes(A, true)
                        }
                        O.push(M)
                    }
                    j.shadowAttrs[X] = O
                }
            }
        }
        for (W = 0, z = F.length; W < z; W++) {
            j = F[W];
            r = t.getAt(W);
            for (X = 0, g = 0; X < m; X++) {
                I = i.getAt(W * m + X);
                if (u[X] && !(this.__excludes && this.__excludes[W])) {
                    H = r.get(u[X]) / b[W] * j.rho
                } else {
                    H = j.rho
                }
                L = Ext.apply({
                    segment: {
                        startAngle: j.startAngle,
                        endAngle: j.endAngle,
                        margin: 0,
                        rho: j.rho,
                        startRho: g + H * y / 100,
                        endRho: g + H
                    },
                    hidden: !j.value && j.startAngle % e.accuracy == j.endAngle % e.accuracy
                },
                Ext.apply(N, C && {
                    fill: C[(m > 1 ? X: W) % k]
                } || {}));
                R = Ext.apply({},
                L.segment, {
                    slice: j,
                    series: e,
                    storeItem: j.storeItem,
                    index: W
                });
                e.calcMiddle(R);
                if (h) {
                    R.shadows = j.shadowAttrs[X]
                }
                w[W] = R;
                if (!I) {
                    K = Ext.apply({
                        type: "path",
                        group: i,
                        middle: R.middle
                    },
                    Ext.apply(N, C && {
                        fill: C[(m > 1 ? X: W) % k]
                    } || {}));
                    I = l.add(Ext.apply(K, L))
                }
                j.sprite = j.sprite || [];
                R.sprite = I;
                j.sprite.push(I);
                j.point = [R.middle.x, R.middle.y];
                if (s) {
                    L = e.renderer(I, r, L, W, t);
                    I._to = L;
                    I._animating = true;
                    e.onAnimate(I, {
                        to: L,
                        listeners: {
                            afteranimate: {
                                fn: function() {
                                    this._animating = false
                                },
                                scope: I
                            }
                        }
                    })
                } else {
                    L = e.renderer(I, r, Ext.apply(L, {
                        hidden: false
                    }), W, t);
                    I.setAttributes(L, true)
                }
                g += H
            }
        }
        z = i.getCount();
        for (W = 0; W < z; W++) {
            if (!F[W / m >> 0] && i.getAt(W)) {
                i.getAt(W).hide(true)
            }
        }
        if (h) {
            v = p.length;
            for (_ = 0; _ < z; _++) {
                if (!F[_ / m >> 0]) {
                    for (X = 0; X < v; X++) {
                        if (p[X].getAt(_)) {
                            p[X].getAt(_).hide(true)
                        }
                    }
                }
            }
        }
        e.renderLabels();
        e.renderCallouts()
    },
    setSpriteAttributes: function(e, t, n) {
        var r = this;
        if (n) {
            e.stopAnimation();
            e.animate({
                to: t,
                duration: r.highlightDuration
            })
        } else {
            e.setAttributes(t, true)
        }
    },
    createLabelLine: function(e, t) {
        var n = this;
        calloutLine = n.label.calloutLine,
        line = n.chart.surface.add({
            type: "path",
            stroke: e === undefined ? "#555": calloutLine && calloutLine.color || n.getLegendColor(e),
            lineWidth: calloutLine && calloutLine.width || 2,
            path: "M0,0Z",
            hidden: t
        });
        return line
    },
    drawLabelLine: function(e, t, n, r) {
        var i = this,
        s = e.lineSprite,
        o = "M" + t.x + " " + t.y + "L" + n.x + " " + n.y + "Z";
        i.setSpriteAttributes(s, {
            path: o
        },
        r)
    },
    onCreateLabel: function(e, t, n, r) {
        var i = this,
        s = i.labelsGroup,
        o = i.label,
        u = i.centerX,
        a = i.centerY,
        f = t.middle,
        l = Ext.apply(i.seriesLabelStyle || {},
        o || {});
        return i.chart.surface.add(Ext.apply({
            type: "text",
            "text-anchor": "middle",
            group: s,
            x: f.x,
            y: f.y
        },
        l))
    },
    onPlaceLabel: function(e, t, n, r, i, s, o) {
        var u = this,
        a = u.rad,
        f = u.chart,
        l = f.resizing,
        c = u.label,
        h = c.renderer,
        p = c.field,
        d = u.centerX,
        v = u.centerY,
        m = n.startAngle,
        g = n.endAngle,
        y = n.middle,
        b = {
            x: y.x,
            y: y.y
        },
        w = y.x - d,
        E = y.y - v,
        S = {},
        x = 1,
        T = Math.atan2(E, w || 1),
        N = Ext.draw.Draw.degrees(T),
        C,
        k,
        L,
        A,
        O = i === "outside",
        M = e.attr.calloutLine,
        _ = M && M.width || 2,
        D = (e.attr.padding || 20) + (O ? _ / 2 + 4 : 0),
        P = 0,
        H = 0,
        B,
        j,
        F;
        b.hidden = false;
        if (this.__excludes && this.__excludes[r]) {
            b.hidden = true
        }
        if (c.hideLessThan) {
            B = Math.min(m, g) * a;
            j = Math.max(m, g) * a;
            F = (j - B) * n.rho;
            if (F < c.hideLessThan) {
                b.hidden = e.showOnHighlight = true
            }
        }
        e.setAttributes({
            opacity: b.hidden ? 0 : 1,
            text: h(t.get(p), e, t, n, r, i, s, o)
        },
        true);
        if (e.lineSprite) {
            var I = {
                opacity: b.hidden ? 0 : 1
            };
            if (b.hidden) {
                I.translate = {
                    x: 0,
                    y: 0
                }
            }
            u.setSpriteAttributes(e.lineSprite, I, false)
        }
        switch (i) {
        case "outside":
            e.isOutside = true;
            x = n.endRho;
            P = Math.abs(N) <= 90 ? D: -D;
            H = N >= 0 ? D: -D;
            e.setAttributes({
                rotation: {
                    degrees: 0
                }
            },
            true);
            k = e.getBBox();
            L = k.width / 2 * Math.cos(T);
            A = k.height / 2 * Math.sin(T);
            L += P;
            A += H;
            x += Math.sqrt(L * L + A * A);
            b.x = x * Math.cos(T) + d;
            b.y = x * Math.sin(T) + v;
            break;
        case "rotate":
            N = Ext.draw.Draw.normalizeDegrees(N);
            N = N > 90 && N < 270 ? N + 180 : N;
            C = e.attr.rotation.degrees;
            if (C != null && Math.abs(C - N) > 180 * .5) {
                if (N > C) {
                    N -= 360
                } else {
                    N += 360
                }
                N = N % 360
            } else {
                N = Ext.draw.Draw.normalizeDegrees(N)
            }
            b.rotate = {
                degrees: N,
                x: b.x,
                y: b.y
            };
            break;
        default:
            break
        }
        b.translate = {
            x: 0,
            y: 0
        };
        if (s && !l && (i != "rotate" || C != null)) {
            u.onAnimate(e, {
                to: b
            })
        } else {
            e.setAttributes(b, true)
        }
        e._from = S;
        if (e.isOutside && M) {
            var q = e.lineSprite,
            R = s,
            U = {
                x: (n.endRho - _ / 2) * Math.cos(T) + d,
                y: (n.endRho - _ / 2) * Math.sin(T) + v
            },
            z = {
                x: b.x,
                y: b.y
            },
            W = {};
            function X(e) {
                return e ? e < 0 ? -1 : 1 : 0
            }
            if (M && M.length) {
                W = {
                    x: (n.endRho + M.length) * Math.cos(T) + d,
                    y: (n.endRho + M.length) * Math.sin(T) + v
                }
            } else {
                var V = Ext.draw.Draw.normalizeRadians( - T),
                $ = Math.cos(V),
                J = Math.sin(V),
                K = (k.width + _ + 4) / 2,
                Q = (k.height + _ + 4) / 2;
                if (Math.abs($) * Q > Math.abs(J) * K) {
                    W.x = z.x - K * X($);
                    W.y = z.y + K * J / $ * X($)
                } else {
                    W.x = z.x - Q * $ / J * X(J);
                    W.y = z.y + Q * X(J)
                }
            }
            if (!q) {
                q = e.lineSprite = u.createLabelLine(r, b.hidden);
                R = false
            }
            u.drawLabelLine(e, U, W, R)
        } else {
            delete e.lineSprite
        }
    },
    onPlaceCallout: function(e, t, n, r, i, s, o) {
        var u = this,
        a = u.chart,
        f = u.centerX,
        l = u.centerY,
        c = n.middle,
        h = {
            x: c.x,
            y: c.y
        },
        p = c.x - f,
        d = c.y - l,
        v = 1,
        m,
        g = Math.atan2(d, p || 1),
        y = e && e.label ? e.label.getBBox() : {
            width: 0,
            height: 0
        },
        b = 20,
        w = 10,
        E = 10,
        S;
        if (!y.width || !y.height) {
            return
        }
        v = n.endRho + b;
        m = (n.endRho + n.startRho) / 2 + (n.endRho - n.startRho) / 3;
        h.x = v * Math.cos(g) + f;
        h.y = v * Math.sin(g) + l;
        p = m * Math.cos(g);
        d = m * Math.sin(g);
        if (a.animate) {
            u.onAnimate(e.lines, {
                to: {
                    path: ["M", p + f, d + l, "L", h.x, h.y, "Z", "M", h.x, h.y, "l", p > 0 ? w: -w, 0, "z"]
                }
            });
            u.onAnimate(e.box, {
                to: {
                    x: h.x + (p > 0 ? w: -(w + y.width + 2 * E)),
                    y: h.y + (d > 0 ? -y.height - E / 2 : -y.height - E / 2),
                    width: y.width + 2 * E,
                    height: y.height + 2 * E
                }
            });
            u.onAnimate(e.label, {
                to: {
                    x: h.x + (p > 0 ? w + E: -(w + y.width + E)),
                    y: h.y + (d > 0 ? -y.height / 4 : -y.height / 4)
                }
            })
        } else {
            e.lines.setAttributes({
                path: ["M", p + f, d + l, "L", h.x, h.y, "Z", "M", h.x, h.y, "l", p > 0 ? w: -w, 0, "z"]
            },
            true);
            e.box.setAttributes({
                x: h.x + (p > 0 ? w: -(w + y.width + 2 * E)),
                y: h.y + (d > 0 ? -y.height - E / 2 : -y.height - E / 2),
                width: y.width + 2 * E,
                height: y.height + 2 * E
            },
            true);
            e.label.setAttributes({
                x: h.x + (p > 0 ? w + E: -(w + y.width + E)),
                y: h.y + (d > 0 ? -y.height / 4 : -y.height / 4)
            },
            true)
        }
        for (S in e) {
            e[S].show(true)
        }
    },
    onAnimate: function(e, t) {
        e.show();
        return this.callParent(arguments)
    },
    isItemInPoint: function(e, t, n, r) {
        var i = this,
        s = i.centerX,
        o = i.centerY,
        u = Math.abs,
        a = u(e - s),
        f = u(t - o),
        l = n.startAngle,
        c = n.endAngle,
        h = Math.sqrt(a * a + f * f),
        p = Math.atan2(t - o, e - s) / i.rad;
        if (i.clockwise) {
            if (p < i.firstAngle) {
                p += i.accuracy
            }
        } else {
            if (p > i.firstAngle) {
                p -= i.accuracy
            }
        }
        return p <= l && p > c && h >= n.startRho && h <= n.endRho
    },
    hideAll: function(e) {
        var t, n, r, i, s, o, u;
        e = (isNaN(this._index) ? e: this._index) || 0;
        this.__excludes = this.__excludes || [];
        this.__excludes[e] = true;
        u = this.slices[e].sprite;
        for (s = 0, o = u.length; s < o; s++) {
            u[s].setAttributes({
                hidden: true
            },
            true);
            var a = u[s].lineSprite;
            if (a) {
                a.setAttributes({
                    hidden: true
                },
                true)
            }
        }
        if (this.slices[e].shadowAttrs) {
            for (t = 0, i = this.slices[e].shadowAttrs, n = i.length; t < n; t++) {
                r = i[t];
                for (s = 0, o = r.length; s < o; s++) {
                    r[s].setAttributes({
                        hidden: true
                    },
                    true)
                }
            }
        }
        this.drawSeries()
    },
    showAll: function(e) {
        e = (isNaN(this._index) ? e: this._index) || 0;
        this.__excludes[e] = false;
        this.drawSeries()
    },
    highlightItem: function(e) {
        var t = this,
        n = t.rad,
        r, i, s, o, u, a, f, l, c, h, p, d, v, m, g, y, b, w;
        e = e || this.items[this._index];
        this.unHighlightItem();
        if (!e || t.animating || e.sprite && e.sprite._animating) {
            return
        }
        t.callParent([e]);
        if (!t.highlight) {
            return
        }
        if ("segment" in t.highlightCfg) {
            r = t.highlightCfg.segment;
            i = t.chart.animate;
            if (t.labelsGroup) {
                p = t.labelsGroup;
                d = t.label.display;
                v = p.getAt(e.index);
                m = (e.startAngle + e.endAngle) / 2 * n;
                g = r.margin || 0;
                y = g * Math.cos(m);
                b = g * Math.sin(m);
                if (Math.abs(y) < 1e-10) {
                    y = 0
                }
                if (Math.abs(b) < 1e-10) {
                    b = 0
                }
                s = {
                    translate: {
                        x: y,
                        y: b
                    }
                };
                if (v.showOnHighlight) {
                    s.opacity = 1;
                    s.hidden = false
                }
                t.setSpriteAttributes(v, s, i);
                w = v.lineSprite;
                if (w) {
                    t.setSpriteAttributes(w, s, i)
                }
            }
            if (t.chart.shadow && e.shadows) {
                o = 0;
                u = e.shadows;
                f = u.length;
                for (; o < f; o++) {
                    a = u[o];
                    l = {};
                    c = e.sprite._from.segment;
                    for (h in c) {
                        if (! (h in r)) {
                            l[h] = c[h]
                        }
                    }
                    s = {
                        segment: Ext.applyIf(l, t.highlightCfg.segment)
                    };
                    t.setSpriteAttributes(a, s, i)
                }
            }
        }
    },
    unHighlightItem: function() {
        var e = this,
        t, n, r, i, s, o, u, a, f, l, c, h, p, d, v, m, g, y, b;
        if (!e.highlight) {
            return
        }
        if ("segment" in e.highlightCfg && e.items) {
            t = e.items;
            n = e.chart.animate;
            r = !!e.chart.shadow;
            i = e.labelsGroup;
            s = t.length;
            o = 0;
            u = 0;
            a = e.label.display;
            for (; o < s; o++) {
                g = t[o];
                if (!g) {
                    continue
                }
                d = g.sprite;
                if (d && d._highlighted) {
                    if (i) {
                        y = i.getAt(g.index);
                        b = Ext.apply({
                            translate: {
                                x: 0,
                                y: 0
                            }
                        },
                        a == "rotate" ? {
                            rotate: {
                                x: y.attr.x,
                                y: y.attr.y,
                                degrees: y.attr.rotation.degrees
                            }
                        }: {});
                        if (y.showOnHighlight) {
                            b.opacity = 0;
                            b.hidden = true
                        }
                        e.setSpriteAttributes(y, b, n);
                        var w = y.lineSprite;
                        if (w) {
                            e.setSpriteAttributes(w, b, n)
                        }
                    }
                    if (r) {
                        v = g.shadows;
                        f = v.length;
                        for (; u < f; u++) {
                            c = {};
                            h = g.sprite._to.segment;
                            p = g.sprite._from.segment;
                            Ext.apply(c, p);
                            for (l in h) {
                                if (! (l in p)) {
                                    c[l] = h[l]
                                }
                            }
                            m = v[u];
                            e.setSpriteAttributes(m, {
                                segment: c
                            },
                            n)
                        }
                    }
                }
            }
        }
        e.callParent(arguments)
    },
    getLegendColor: function(e) {
        var t = this;
        return t.colorSet && t.colorSet[e % t.colorSet.length] || t.colorArrayStyle[e % t.colorArrayStyle.length]
    }
});
Ext.define("Ext.chart.series.Radar", {
    extend: Ext.chart.series.Series,
    type: "radar",
    alias: "series.radar",
    rad: Math.PI / 180,
    showInLegend: false,
    style: {},
    constructor: function(e) {
        this.callParent(arguments);
        var t = this,
        n = t.chart.surface;
        t.group = n.getGroup(t.seriesId);
        if (t.showMarkers) {
            t.markerGroup = n.getGroup(t.seriesId + "-markers")
        }
    },
    drawSeries: function() {
        var e = this,
        t = e.chart.getChartStore(),
        n = t.data.items,
        r,
        i,
        s = e.group,
        o = e.chart,
        u = o.series.items,
        a,
        f,
        l,
        c = e.field || e.yField,
        h = o.surface,
        p = o.chartBBox,
        d = e.colorArrayStyle,
        v,
        m,
        g,
        y,
        b = 0,
        w = 0,
        E = [],
        S = Math.max,
        x = Math.cos,
        T = Math.sin,
        N = Math.PI * 2,
        C = t.getCount(),
        k,
        L,
        A,
        O,
        M,
        _,
        D,
        P = e.seriesStyle,
        H = o.axes && o.axes.get(0),
        B = !(H && H.maximum);
        e.setBBox();
        b = B ? 0 : H.maximum || 0;
        w = H.minimum || 0;
        Ext.apply(P, e.style || {});
        if (!t || !t.getCount() || e.seriesIsHidden) {
            e.hide();
            e.items = [];
            if (e.radar) {
                e.radar.hide(true)
            }
            e.radar = null;
            return
        }
        if (!P.stroke) {
            P.stroke = d[e.themeIdx % d.length]
        }
        e.unHighlightItem();
        e.cleanHighlights();
        v = e.centerX = p.x + p.width / 2;
        m = e.centerY = p.y + p.height / 2;
        e.radius = y = Math.min(p.width, p.height) / 2;
        e.items = g = [];
        if (B) {
            for (a = 0, f = u.length; a < f; a++) {
                l = u[a];
                E.push(l.yField)
            }
            for (r = 0; r < C; r++) {
                i = n[r];
                for (_ = 0, D = E.length; _ < D; _++) {
                    b = S( + i.get(E[_]), b)
                }
            }
        }
        b = b || 1;
        if (w >= b) {
            w = b - 1
        }
        k = [];
        L = [];
        for (_ = 0; _ < C; _++) {
            i = n[_];
            M = y * (i.get(c) - w) / (b - w);
            if (M < 0) {
                M = 0
            }
            A = M * x(_ / C * N);
            O = M * T(_ / C * N);
            if (_ == 0) {
                L.push("M", A + v, O + m);
                k.push("M", .01 * A + v, .01 * O + m)
            } else {
                L.push("L", A + v, O + m);
                k.push("L", .01 * A + v, .01 * O + m)
            }
            g.push({
                sprite: false,
                point: [v + A, m + O],
                storeItem: i,
                series: e
            })
        }
        L.push("Z");
        if (!e.radar) {
            e.radar = h.add(Ext.apply({
                type: "path",
                group: s,
                path: k
            },
            P || {}))
        }
        if (o.resizing) {
            e.radar.setAttributes({
                path: k
            },
            true)
        }
        if (o.animate) {
            e.onAnimate(e.radar, {
                to: Ext.apply({
                    path: L
                },
                P || {})
            })
        } else {
            e.radar.setAttributes(Ext.apply({
                path: L
            },
            P || {}), true)
        }
        if (e.showMarkers) {
            e.drawMarkers()
        }
        e.renderLabels();
        e.renderCallouts()
    },
    drawMarkers: function() {
        var e = this,
        t = e.chart,
        n = t.surface,
        r = t.getChartStore(),
        i = Ext.apply({},
        e.markerStyle || {}),
        s = Ext.apply(i, e.markerConfig, {
            fill: e.colorArrayStyle[e.themeIdx % e.colorArrayStyle.length]
        }),
        o = e.items,
        u = s.type,
        a = e.markerGroup,
        f = e.centerX,
        l = e.centerY,
        c,
        h,
        p,
        d,
        v;
        delete s.type;
        for (h = 0, p = o.length; h < p; h++) {
            c = o[h];
            d = a.getAt(h);
            if (!d) {
                d = Ext.chart.Shape[u](n, Ext.apply({
                    group: a,
                    x: 0,
                    y: 0,
                    translate: {
                        x: f,
                        y: l
                    }
                },
                s))
            } else {
                d.show()
            }
            c.sprite = d;
            if (t.resizing) {
                d.setAttributes({
                    x: 0,
                    y: 0,
                    translate: {
                        x: f,
                        y: l
                    }
                },
                true)
            }
            d._to = {
                translate: {
                    x: c.point[0],
                    y: c.point[1]
                }
            };
            v = e.renderer(d, r.getAt(h), d._to, h, r);
            v = Ext.applyIf(v || {},
            s || {});
            if (t.animate) {
                e.onAnimate(d, {
                    to: v
                })
            } else {
                d.setAttributes(v, true)
            }
        }
    },
    isItemInPoint: function(e, t, n) {
        var r, i = 10,
        s = Math.abs;
        r = n.point;
        return s(r[0] - e) <= i && s(r[1] - t) <= i
    },
    onCreateLabel: function(e, t, n, r) {
        var i = this,
        s = i.labelsGroup,
        o = i.label,
        u = i.centerX,
        a = i.centerY,
        f = Ext.apply({},
        o, i.seriesLabelStyle || {});
        return i.chart.surface.add(Ext.apply({
            type: "text",
            "text-anchor": "middle",
            group: s,
            x: u,
            y: a
        },
        f || {}))
    },
    onPlaceLabel: function(e, t, n, r, i, s, o) {
        function S(e) {
            if (e < 0) {
                e += 360
            }
            return e % 360
        }
        var u = this,
        a = u.chart,
        f = a.resizing,
        l = u.label,
        c = l.renderer,
        h = l.field,
        p = u.centerX,
        d = u.centerY,
        v = {
            x: Number(n.point[0]),
            y: Number(n.point[1])
        },
        m = v.x - p,
        g = v.y - d,
        y = Math.atan2(g, m || 1),
        b = y * 180 / Math.PI,
        w,
        E;
        e.setAttributes({
            text: c(t.get(h), e, t, n, r, i, s, o),
            hidden: true
        },
        true);
        w = e.getBBox();
        b = S(b);
        if (b > 45 && b < 135 || b > 225 && b < 315) {
            E = b > 45 && b < 135 ? 1 : -1;
            v.y += E * w.height / 2
        } else {
            E = b >= 135 && b <= 225 ? -1 : 1;
            v.x += E * w.width / 2
        }
        if (f) {
            e.setAttributes({
                x: p,
                y: d
            },
            true)
        }
        if (s) {
            e.show(true);
            u.onAnimate(e, {
                to: v
            })
        } else {
            e.setAttributes(v, true);
            e.show(true)
        }
    },
    toggleAll: function(e) {
        var t = this,
        n, r, i, s;
        if (!e) {
            Ext.chart.series.Radar.superclass.hideAll.call(t)
        } else {
            Ext.chart.series.Radar.superclass.showAll.call(t)
        }
        if (t.radar) {
            t.radar.setAttributes({
                hidden: !e
            },
            true);
            if (t.radar.shadows) {
                for (n = 0, s = t.radar.shadows, r = s.length; n < r; n++) {
                    i = s[n];
                    i.setAttributes({
                        hidden: !e
                    },
                    true)
                }
            }
        }
    },
    hideAll: function() {
        this.toggleAll(false);
        this.hideMarkers(0)
    },
    showAll: function() {
        this.toggleAll(true)
    },
    hideMarkers: function(e) {
        var t = this,
        n = t.markerGroup && t.markerGroup.getCount() || 0,
        r = e || 0;
        for (; r < n; r++) {
            t.markerGroup.getAt(r).hide(true)
        }
    },
    getAxesForXAndYFields: function() {
        var e = this,
        t = e.chart,
        n = t.axes,
        r = [].concat(n && n.get(0));
        return {
            yAxis: r
        }
    }
});
Ext.define("Ext.chart.series.Scatter", {
    extend: Ext.chart.series.Cartesian,
    type: "scatter",
    alias: "series.scatter",
    constructor: function(e) {
        this.callParent(arguments);
        var t = this,
        n = t.chart.shadow,
        r = t.chart.surface,
        i, s;
        Ext.apply(t, e, {
            style: {},
            markerConfig: {},
            shadowAttributes: [{
                "stroke-width": 6,
                "stroke-opacity": .05,
                stroke: "rgb(0, 0, 0)"
            },
            {
                "stroke-width": 4,
                "stroke-opacity": .1,
                stroke: "rgb(0, 0, 0)"
            },
            {
                "stroke-width": 2,
                "stroke-opacity": .15,
                stroke: "rgb(0, 0, 0)"
            }]
        });
        t.group = r.getGroup(t.seriesId);
        if (n) {
            for (i = 0, s = t.shadowAttributes.length; i < s; i++) {
                t.shadowGroups.push(r.getGroup(t.seriesId + "-shadows" + i))
            }
        }
    },
    getBounds: function() {
        var e = this,
        t = e.chart,
        n = t.getChartStore(),
        r = t.axes,
        i = e.getAxesForXAndYFields(),
        s = i.xAxis,
        o = i.yAxis,
        u,
        a,
        f,
        l,
        c,
        h,
        p,
        d,
        v,
        m,
        g;
        e.setBBox();
        u = e.bbox;
        if (m = r.get(s)) {
            g = m.applyData();
            c = g.from;
            p = g.to
        }
        if (m = r.get(o)) {
            g = m.applyData();
            h = g.from;
            d = g.to
        }
        if (e.xField && !Ext.isNumber(c)) {
            m = e.getMinMaxXValues();
            c = m[0];
            p = m[1]
        }
        if (e.yField && !Ext.isNumber(h)) {
            m = e.getMinMaxYValues();
            h = m[0];
            d = m[1]
        }
        if (isNaN(c)) {
            c = 0;
            p = n.getCount() - 1;
            a = u.width / (n.getCount() - 1)
        } else {
            a = u.width / (p - c)
        }
        if (isNaN(h)) {
            h = 0;
            d = n.getCount() - 1;
            f = u.height / (n.getCount() - 1)
        } else {
            f = u.height / (d - h)
        }
        return {
            bbox: u,
            minX: c,
            minY: h,
            xScale: a,
            yScale: f
        }
    },
    getPaths: function() {
        var e = this,
        t = e.chart,
        n = t.shadow,
        r = t.getChartStore(),
        i = r.data.items,
        s,
        o,
        u,
        a = e.group,
        f = e.bounds = e.getBounds(),
        l = e.bbox,
        c = f.xScale,
        h = f.yScale,
        p = f.minX,
        d = f.minY,
        v = l.x,
        m = l.y,
        g = l.height,
        y = e.items = [],
        b = [],
        w = e.reverse,
        E,
        S,
        x,
        T,
        N;
        for (s = 0, o = i.length; s < o; s++) {
            u = i[s];
            x = u.get(e.xField);
            T = u.get(e.yField);
            if (typeof T == "undefined" || typeof T == "string" && !T || x == null || T == null) {
                continue
            }
            if (typeof x == "string" || typeof x == "object" && !Ext.isDate(x)) {
                x = s
            }
            if (typeof T == "string" || typeof T == "object" && !Ext.isDate(T)) {
                T = s
            }
            if (w) {
                E = v + l.width - (x - p) * c
            } else {
                E = v + (x - p) * c
            }
            S = m + g - (T - d) * h;
            b.push({
                x: E,
                y: S
            });
            e.items.push({
                series: e,
                value: [x, T],
                point: [E, S],
                storeItem: u
            });
            if (t.animate && t.resizing) {
                N = a.getAt(s);
                if (N) {
                    e.resetPoint(N);
                    if (n) {
                        e.resetShadow(N)
                    }
                }
            }
        }
        return b
    },
    resetPoint: function(e) {
        var t = this.bbox;
        e.setAttributes({
            translate: {
                x: (t.x + t.width) / 2,
                y: (t.y + t.height) / 2
            }
        },
        true)
    },
    resetShadow: function(e) {
        var t = this,
        n = e.shadows,
        r = t.shadowAttributes,
        i = t.shadowGroups.length,
        s = t.bbox,
        o, u;
        for (o = 0; o < i; o++) {
            u = Ext.apply({},
            r[o]);
            if (u.translate) {
                u.translate.x += (s.x + s.width) / 2;
                u.translate.y += (s.y + s.height) / 2
            } else {
                u.translate = {
                    x: (s.x + s.width) / 2,
                    y: (s.y + s.height) / 2
                }
            }
            n[o].setAttributes(u, true)
        }
    },
    createPoint: function(e, t) {
        var n = this,
        r = n.chart,
        i = n.group,
        s = n.bbox;
        return Ext.chart.Shape[t](r.surface, Ext.apply({},
        {
            x: 0,
            y: 0,
            group: i,
            translate: {
                x: (s.x + s.width) / 2,
                y: (s.y + s.height) / 2
            }
        },
        e))
    },
    createShadow: function(e, t, n) {
        var r = this,
        i = r.chart,
        s = r.shadowGroups,
        o = r.shadowAttributes,
        u = s.length,
        a = r.bbox,
        f, l, c, h;
        e.shadows = c = [];
        for (f = 0; f < u; f++) {
            h = Ext.apply({},
            o[f]);
            if (h.translate) {
                h.translate.x += (a.x + a.width) / 2;
                h.translate.y += (a.y + a.height) / 2
            } else {
                Ext.apply(h, {
                    translate: {
                        x: (a.x + a.width) / 2,
                        y: (a.y + a.height) / 2
                    }
                })
            }
            Ext.apply(h, t);
            l = Ext.chart.Shape[n](i.surface, Ext.apply({},
            {
                x: 0,
                y: 0,
                group: s[f]
            },
            h));
            c.push(l)
        }
    },
    drawSeries: function() {
        var e = this,
        t = e.chart,
        n = t.getChartStore(),
        r = e.group,
        i = t.shadow,
        s = e.shadowGroups,
        o = e.shadowAttributes,
        u = s.length,
        a,
        f,
        l,
        c,
        h,
        p,
        d,
        v,
        m,
        g,
        y;
        if (!n || !n.getCount() || e.seriesIsHidden) {
            e.hide();
            e.items = [];
            return
        }
        p = Ext.apply({},
        e.markerStyle, e.markerConfig);
        v = p.type || "circle";
        delete p.type;
        if (!n || !n.getCount()) {
            e.hide();
            e.items = [];
            return
        }
        e.unHighlightItem();
        e.cleanHighlights();
        f = e.getPaths();
        c = f.length;
        for (h = 0; h < c; h++) {
            l = f[h];
            a = r.getAt(h);
            Ext.apply(l, p);
            if (!a) {
                a = e.createPoint(l, v);
                if (i) {
                    e.createShadow(a, p, v)
                }
            }
            m = a.shadows;
            if (t.animate) {
                g = e.renderer(a, n.getAt(h), {
                    translate: l
                },
                h, n);
                a._to = g;
                e.onAnimate(a, {
                    to: g
                });
                for (d = 0; d < u; d++) {
                    y = Ext.apply({},
                    o[d]);
                    g = e.renderer(m[d], n.getAt(h), Ext.apply({},
                    {
                        hidden: false,
                        translate: {
                            x: l.x + (y.translate ? y.translate.x: 0),
                            y: l.y + (y.translate ? y.translate.y: 0)
                        }
                    },
                    y), h, n);
                    e.onAnimate(m[d], {
                        to: g
                    })
                }
            } else {
                g = e.renderer(a, n.getAt(h), {
                    translate: l
                },
                h, n);
                a._to = g;
                a.setAttributes(g, true);
                for (d = 0; d < u; d++) {
                    y = Ext.apply({},
                    o[d]);
                    g = e.renderer(m[d], n.getAt(h), Ext.apply({},
                    {
                        hidden: false,
                        translate: {
                            x: l.x + (y.translate ? y.translate.x: 0),
                            y: l.y + (y.translate ? y.translate.y: 0)
                        }
                    },
                    y), h, n);
                    m[d].setAttributes(g, true)
                }
            }
            e.items[h].sprite = a
        }
        c = r.getCount();
        for (h = f.length; h < c; h++) {
            r.getAt(h).hide(true)
        }
        e.renderLabels();
        e.renderCallouts()
    },
    onCreateLabel: function(e, t, n, r) {
        var i = this,
        s = i.labelsGroup,
        o = i.label,
        u = Ext.apply({},
        o, i.seriesLabelStyle),
        a = i.bbox;
        return i.chart.surface.add(Ext.apply({
            type: "text",
            "text-anchor": "middle",
            group: s,
            x: Number(t.point[0]),
            y: a.y + a.height / 2
        },
        u))
    },
    onPlaceLabel: function(e, t, n, r, i, s, o) {
        var u = this,
        a = u.chart,
        f = a.resizing,
        l = u.label,
        c = l.renderer,
        h = l.field,
        p = u.bbox,
        d = Number(n.point[0]),
        v = Number(n.point[1]),
        m = n.sprite.attr.radius,
        g,
        y,
        b,
        w,
        E,
        S,
        x;
        e.setAttributes({
            text: c(t.get(h), e, t, n, r, i, s, o),
            hidden: true
        },
        true);
        y = n.sprite.getBBox();
        y.width = y.width || m * 2;
        y.height = y.height || m * 2;
        g = e.getBBox();
        b = g.width / 2;
        w = g.height / 2;
        if (i == "rotate") {
            E = y.width / 2 + b + w / 2;
            if (d + E + b > p.x + p.width) {
                d -= E
            } else {
                d += E
            }
            e.setAttributes({
                rotation: {
                    x: d,
                    y: v,
                    degrees: -45
                }
            },
            true)
        } else {
            if (i == "under" || i == "over") {
                e.setAttributes({
                    rotation: {
                        degrees: 0
                    }
                },
                true);
                if (d < p.x + b) {
                    d = p.x + b
                } else {
                    if (d + b > p.x + p.width) {
                        d = p.x + p.width - b
                    }
                }
                S = y.height / 2 + w;
                v = v + (i == "over" ? -S: S);
                if (v < p.y + w) {
                    v += 2 * S
                } else {
                    if (v + w > p.y + p.height) {
                        v -= 2 * S
                    }
                }
            }
        }
        if (!a.animate) {
            e.setAttributes({
                x: d,
                y: v
            },
            true);
            e.show(true)
        } else {
            if (f) {
                x = n.sprite.getActiveAnimation();
                if (x) {
                    x.on("afteranimate",
                    function() {
                        e.setAttributes({
                            x: d,
                            y: v
                        },
                        true);
                        e.show(true)
                    })
                } else {
                    e.show(true)
                }
            } else {
                u.onAnimate(e, {
                    to: {
                        x: d,
                        y: v
                    }
                })
            }
        }
    },
    onPlaceCallout: function(e, t, n, r, i, s, o) {
        var u = this,
        a = u.chart,
        f = a.surface,
        l = a.resizing,
        c = u.callouts,
        h = u.items,
        p = n.point,
        d, v = e.label.getBBox(),
        m = 30,
        g = 10,
        y = 3,
        b,
        w,
        E,
        S,
        x,
        T = u.bbox,
        N,
        C;
        d = [Math.cos(Math.PI / 4), -Math.sin(Math.PI / 4)];
        N = p[0] + d[0] * m;
        C = p[1] + d[1] * m;
        b = N + (d[0] > 0 ? 0 : -(v.width + 2 * y));
        w = C - v.height / 2 - y;
        E = v.width + 2 * y;
        S = v.height + 2 * y;
        if (b < T[0] || b + E > T[0] + T[2]) {
            d[0] *= -1
        }
        if (w < T[1] || w + S > T[1] + T[3]) {
            d[1] *= -1
        }
        N = p[0] + d[0] * m;
        C = p[1] + d[1] * m;
        b = N + (d[0] > 0 ? 0 : -(v.width + 2 * y));
        w = C - v.height / 2 - y;
        E = v.width + 2 * y;
        S = v.height + 2 * y;
        if (a.animate) {
            u.onAnimate(e.lines, {
                to: {
                    path: ["M", p[0], p[1], "L", N, C, "Z"]
                }
            },
            true);
            u.onAnimate(e.box, {
                to: {
                    x: b,
                    y: w,
                    width: E,
                    height: S
                }
            },
            true);
            u.onAnimate(e.label, {
                to: {
                    x: N + (d[0] > 0 ? y: -(v.width + y)),
                    y: C
                }
            },
            true)
        } else {
            e.lines.setAttributes({
                path: ["M", p[0], p[1], "L", N, C, "Z"]
            },
            true);
            e.box.setAttributes({
                x: b,
                y: w,
                width: E,
                height: S
            },
            true);
            e.label.setAttributes({
                x: N + (d[0] > 0 ? y: -(v.width + y)),
                y: C
            },
            true)
        }
        for (x in e) {
            e[x].show(true)
        }
    },
    onAnimate: function(e, t) {
        e.show();
        return this.callParent(arguments)
    },
    isItemInPoint: function(e, t, n) {
        function o(n) {
            var r = s(n[0] - e),
            i = s(n[1] - t);
            return Math.sqrt(r * r + i * i)
        }
        var r, i = 10,
        s = Math.abs;
        r = n.point;
        return r[0] - i <= e && r[0] + i >= e && r[1] - i <= t && r[1] + i >= t
    }
});
Ext.define("Ext.layout.container.Table", {
    alias: ["layout.table"],
    extend: Ext.layout.container.Container,
    alternateClassName: "Ext.layout.TableLayout",
    type: "table",
    createsInnerCt: true,
    targetCls: Ext.baseCSSPrefix + "table-layout-ct",
    tableCls: Ext.baseCSSPrefix + "table-layout",
    cellCls: Ext.baseCSSPrefix + "table-layout-cell",
    tableAttrs: null,
    getItemSizePolicy: function(e) {
        return this.autoSizePolicy
    },
    initHierarchyState: function(e) {
        e.inShrinkWrapTable = true
    },
    getLayoutItems: function() {
        var e = this,
        t = [],
        n = e.callParent(),
        r,
        i = n.length,
        s;
        for (s = 0; s < i; s++) {
            r = n[s];
            if (!r.hidden) {
                t.push(r)
            }
        }
        return t
    },
    getHiddenItems: function() {
        var e = [],
        t = this.owner.items.items,
        n = t.length,
        r = 0,
        i;
        for (; r < n; ++r) {
            i = t[r];
            if (i.rendered && i.hidden) {
                e.push(i)
            }
        }
        return e
    },
    renderChildren: function() {
        var e = this,
        t = e.getLayoutItems(),
        n = e.owner.getTargetEl().child("table", true).tBodies[0],
        r = n.rows,
        i = 0,
        s = t.length,
        o = e.getHiddenItems(),
        u,
        a,
        f,
        l,
        c,
        h,
        p,
        d,
        v;
        u = e.calculateCells(t);
        for (; i < s; i++) {
            a = u[i];
            f = a.rowIdx;
            l = a.cellIdx;
            c = t[i];
            h = r[f];
            if (!h) {
                h = n.insertRow(f);
                if (e.trAttrs) {
                    h.set(e.trAttrs)
                }
            }
            d = p = Ext.get(h.cells[l] || h.insertCell(l));
            if (e.needsDivWrap()) {
                d = p.first() || p.createChild({
                    tag: "div",
                    role: "presentation"
                });
                d.setWidth(null)
            }
            if (!c.rendered) {
                e.renderItem(c, d, 0)
            } else {
                if (!e.isValidParent(c, d, f, l, n)) {
                    e.moveItem(c, d, 0)
                }
            }
            if (e.tdAttrs) {
                p.set(e.tdAttrs)
            }
            if (c.tdAttrs) {
                p.set(c.tdAttrs)
            }
            p.set({
                colSpan: c.colspan || 1,
                rowSpan: c.rowspan || 1,
                id: c.cellId || "",
                cls: e.cellCls + " " + (c.cellCls || "")
            });
            if (!u[i + 1] || u[i + 1].rowIdx !== f) {
                l++;
                while (h.cells[l]) {
                    h.deleteCell(l)
                }
            }
        }
        f++;
        while (n.rows[f]) {
            n.deleteRow(f)
        }
        for (i = 0, s = o.length; i < s; ++i) {
            e.ensureInDocument(o[i].getEl())
        }
    },
    ensureInDocument: function(e) {
        var t = e.dom.parentNode;
        while (t) {
            if (t.tagName.toUpperCase() == "BODY") {
                return
            }
            t = t.parentNode
        }
        Ext.getDetachedBody().appendChild(e)
    },
    calculate: function(e) {
        if (!e.hasDomProp("containerChildrenSizeDone")) {
            this.done = false
        } else {
            var t = e.targetContext,
            n = e.widthModel.shrinkWrap,
            r = e.heightModel.shrinkWrap,
            i = r || n,
            s = i && t.el.child("table", true),
            o = i && t.getPaddingInfo();
            if (n) {
                e.setContentWidth(s.offsetWidth + o.width, true)
            }
            if (r) {
                e.setContentHeight(s.offsetHeight + o.height, true)
            }
        }
    },
    finalizeLayout: function() {
        if (this.needsDivWrap()) {
            var e = this.getLayoutItems(),
            t,
            n = e.length,
            r;
            for (t = 0; t < n; t++) {
                r = e[t];
                Ext.fly(r.el.dom.parentNode).setWidth(r.getWidth())
            }
        }
        if (Ext.isIE6 || Ext.isIEQuirks) {
            this.owner.getTargetEl().child("table").repaint()
        }
    },
    calculateCells: function(e) {
        var t = [],
        n = 0,
        r = 0,
        i = 0,
        s = this.columns || Infinity,
        o = [],
        u = 0,
        a,
        f = e.length,
        l;
        for (; u < f; u++) {
            l = e[u];
            while (r >= s || o[r] > 0) {
                if (r >= s) {
                    r = 0;
                    i = 0;
                    n++;
                    for (a = 0; a < s; a++) {
                        if (o[a] > 0) {
                            o[a]--
                        }
                    }
                } else {
                    r++
                }
            }
            t.push({
                rowIdx: n,
                cellIdx: i
            });
            for (a = l.colspan || 1; a; --a) {
                o[r] = l.rowspan || 1; ++r
            }++i
        }
        return t
    },
    getRenderTree: function() {
        var e = this,
        t = e.getLayoutItems(),
        n,
        r = [],
        i = Ext.apply({
            tag: "table",
            role: "presentation",
            cls: e.tableCls,
            cellspacing: 0,
            cellpadding: 0,
            cn: {
                tag: "tbody",
                role: "presentation",
                cn: r
            }
        },
        e.tableAttrs),
        s = e.tdAttrs,
        o = e.needsDivWrap(),
        u,
        a = t.length,
        f,
        l,
        c,
        h,
        p,
        d;
        n = e.calculateCells(t);
        for (u = 0; u < a; u++) {
            f = t[u];
            l = n[u];
            h = l.rowIdx;
            p = l.cellIdx;
            c = r[h];
            if (!c) {
                c = r[h] = {
                    tag: "tr",
                    role: "presentation",
                    cn: []
                };
                if (e.trAttrs) {
                    Ext.apply(c, e.trAttrs)
                }
            }
            d = c.cn[p] = {
                tag: "td",
                role: "presentation"
            };
            if (s) {
                Ext.apply(d, s)
            }
            Ext.apply(d, {
                colSpan: f.colspan || 1,
                rowSpan: f.rowspan || 1,
                id: f.cellId || "",
                cls: e.cellCls + " " + (f.cellCls || "")
            });
            if (o) {
                d = d.cn = {
                    tag: "div",
                    role: "presentation"
                }
            }
            e.configureItem(f);
            d.cn = f.getRenderTree()
        }
        return i
    },
    isValidParent: function(e, t, n, r) {
        var i, s, o;
        if (arguments.length === 3) {
            o = e.el.up("table");
            return o && o.dom.parentNode === t.dom
        }
        i = this.owner.getTargetEl().child("table", true).tBodies[0];
        s = i.rows[n].cells[r];
        return e.el.dom.parentNode === s
    },
    needsDivWrap: function() {
        return Ext.isOpera10_5
    }
});
Ext.define("Ext.container.ButtonGroup", {
    extend: Ext.panel.Panel,
    alias: "widget.buttongroup",
    alternateClassName: "Ext.ButtonGroup",
    baseCls: Ext.baseCSSPrefix + "btn-group",
    layout: {
        type: "table"
    },
    defaultType: "button",
    frame: true,
    frameHeader: false,
    titleAlign: "center",
    noTitleCls: "notitle",
    ariaRole: "group",
    initComponent: function() {
        var e = this,
        t = e.columns;
        if (t) {
            e.layout = Ext.apply({},
            {
                columns: t
            },
            e.layout)
        }
        if (!e.title) {
            e.addClsWithUI(e.noTitleCls)
        }
        e.callParent(arguments)
    },
    onBeforeAdd: function(e) {
        if (e.isButton) {
            if (this.defaultButtonUI && e.ui === "default" && !e.hasOwnProperty("ui")) {
                e.ui = this.defaultButtonUI
            } else {
                e.ui = e.ui + "-toolbar"
            }
        }
        this.callParent(arguments)
    },
    applyDefaults: function(e) {
        if (!Ext.isString(e)) {
            e = this.callParent(arguments)
        }
        return e
    }
});
Ext.define("Ext.container.Monitor", {
    target: null,
    selector: "",
    scope: null,
    addHandler: null,
    removeHandler: null,
    invalidateHandler: null,
    disabled: 0,
    constructor: function(e) {
        Ext.apply(this, e)
    },
    bind: function(e) {
        var t = this;
        t.target = e;
        e.on("beforedestroy", t.disable, t);
        t.onContainerAdd(e)
    },
    unbind: function() {
        var e = this,
        t = e.target;
        if (t) {
            t.un("beforedestroy", e.disable, e)
        }
        e.items = null
    },
    disable: function() {++this.disabled
    },
    enable: function() {
        if (this.disabled > 0) {--this.disabled
        }
    },
    handleAdd: function(e, t) {
        if (!this.disabled) {
            if (t.is(this.selector)) {
                this.onItemAdd(t.ownerCt, t)
            }
            if (t.isQueryable) {
                this.onContainerAdd(t)
            }
        }
    },
    onItemAdd: function(e, t) {
        var n = this,
        r = n.items,
        i = n.addHandler;
        if (!n.disabled) {
            if (i) {
                i.call(n.scope || t, t)
            }
            if (r) {
                r.add(t)
            }
        }
    },
    onItemRemove: function(e, t) {
        var n = this,
        r = n.items,
        i = n.removeHandler;
        if (!n.disabled) {
            if (i) {
                i.call(n.scope || t, t)
            }
            if (r) {
                r.remove(t)
            }
        }
    },
    onContainerAdd: function(e, t) {
        var n = this,
        r, i, s = n.handleAdd,
        o = n.handleRemove,
        u, a;
        if (e.isContainer) {
            e.on("add", s, n);
            e.on("dockedadd", s, n);
            e.on("remove", o, n);
            e.on("dockedremove", o, n)
        }
        if (t !== true) {
            r = e.query(n.selector);
            for (u = 0, i = r.length; u < i; ++u) {
                a = r[u];
                n.onItemAdd(a.ownerCt, a)
            }
        }
        r = e.query(">container");
        for (u = 0, i = r.length; u < i; ++u) {
            n.onContainerAdd(r[u], true)
        }
    },
    handleRemove: function(e, t) {
        var n = this;
        if (!n.disabled) {
            if (t.is(n.selector)) {
                n.onItemRemove(e, t)
            }
            if (t.isQueryable) {
                n.onContainerRemove(e, t)
            }
        }
    },
    onContainerRemove: function(e, t) {
        var n = this,
        r, i, s, o;
        if (!t.isDestroyed && !t.destroying && t.isContainer) {
            n.removeCtListeners(t);
            r = t.query(n.selector);
            for (i = 0, s = r.length; i < s; ++i) {
                o = r[i];
                n.onItemRemove(o.ownerCt, o)
            }
            r = t.query("container");
            for (i = 0, s = r.length; i < s; ++i) {
                n.removeCtListeners(r[i])
            }
        } else {
            n.invalidateItems(true)
        }
    },
    removeCtListeners: function(e) {
        var t = this;
        e.un("add", t.handleAdd, t);
        e.un("dockedadd", t.handleAdd, t);
        e.un("remove", t.handleRemove, t);
        e.un("dockedremove", t.handleRemove, t)
    },
    getItems: function() {
        var e = this,
        t = e.items;
        if (!t) {
            t = e.items = new Ext.util.MixedCollection;
            t.addAll(e.target.query(e.selector))
        }
        return t
    },
    invalidateItems: function(e) {
        var t = this,
        n = t.invalidateHandler;
        if (e && n) {
            n.call(t.scope || t, t)
        }
        t.items = null
    }
});
Ext.define("Ext.container.Viewport", {
    extend: Ext.container.Container,
    alias: "widget.viewport",
    alternateClassName: "Ext.Viewport",
    isViewport: true,
    ariaRole: "application",
    preserveElOnDestroy: true,
    viewportCls: Ext.baseCSSPrefix + "viewport",
    initComponent: function() {
        var e = this,
        t = document.body.parentNode,
        n = e.el = Ext.getBody();
        Ext.getScrollbarSize();
        e.width = e.height = undefined;
        e.callParent(arguments);
        Ext.fly(t).addCls(e.viewportCls);
        if (e.autoScroll) {
            Ext.fly(t).setStyle(e.getOverflowStyle());
            delete e.autoScroll
        }
        n.setHeight = n.setWidth = Ext.emptyFn;
        n.dom.scroll = "no";
        e.allowDomMove = false;
        e.renderTo = e.el
    },
    applyTargetCls: function(e) {
        this.el.addCls(e)
    },
    onRender: function() {
        var e = this;
        e.callParent(arguments);
        e.width = Ext.Element.getViewportWidth();
        e.height = Ext.Element.getViewportHeight()
    },
    afterFirstLayout: function() {
        var e = this;
        e.callParent(arguments);
        setTimeout(function() {
            Ext.EventManager.onWindowResize(e.fireResize, e)
        },
        1)
    },
    fireResize: function(e, t) {
        if (e != this.width || t != this.height) {
            this.setSize(e, t)
        }
    },
    initHierarchyState: function(e) {
        this.callParent([this.hierarchyState = Ext.rootHierarchyState])
    },
    beforeDestroy: function() {
        var e = this;
        e.removeUIFromElement();
        e.el.removeCls(e.baseCls);
        Ext.fly(document.body.parentNode).removeCls(e.viewportCls);
        e.callParent()
    }
});
Ext.define("Ext.data.IdGenerator", {
    isGenerator: true,
    constructor: function(e) {
        var t = this;
        Ext.apply(t, e);
        if (t.id) {
            Ext.data.IdGenerator.all[t.id] = t
        }
    },
    getRecId: function(e) {
        return e.modelName + "-" + e.internalId
    },
    statics: {
        all: {},
        get: function(e) {
            var t, n, r;
            if (typeof e == "string") {
                n = r = e;
                e = null
            } else {
                if (e.isGenerator) {
                    return e
                } else {
                    n = e.id || e.type;
                    r = e.type
                }
            }
            t = this.all[n];
            if (!t) {
                t = Ext.create("idgen." + r, e)
            }
            return t
        }
    }
});
Ext.define("Ext.data.SortTypes", {
    singleton: true,
    none: Ext.identityFn,
    stripTagsRE: /<\/?[^>]+>/gi,
    asText: function(e) {
        return String(e).replace(this.stripTagsRE, "")
    },
    asUCText: function(e) {
        return String(e).toUpperCase().replace(this.stripTagsRE, "")
    },
    asUCString: function(e) {
        return String(e).toUpperCase()
    },
    asDate: function(e) {
        if (!e) {
            return 0
        }
        if (Ext.isDate(e)) {
            return e.getTime()
        }
        return Date.parse(String(e))
    },
    asFloat: function(e) {
        var t = parseFloat(String(e).replace(/,/g, ""));
        return isNaN(t) ? 0 : t
    },
    asInt: function(e) {
        var t = parseInt(String(e).replace(/,/g, ""), 10);
        return isNaN(t) ? 0 : t
    }
});
Ext.define("Ext.data.Types", {
    singleton: true
},
function(e) {
    var t = Ext.data.SortTypes;
    Ext.apply(e, {
        stripRe: /[\$,%]/g,
        AUTO: {
            sortType: t.none,
            type: "auto"
        },
        STRING: {
            convert: function(e) {
                var t = this.useNull ? null: "";
                return e === undefined || e === null ? t: String(e)
            },
            sortType: t.asUCString,
            type: "string"
        },
        INT: {
            convert: function(t) {
                if (typeof t == "number") {
                    return parseInt(t)
                }
                return t !== undefined && t !== null && t !== "" ? parseInt(String(t).replace(e.stripRe, ""), 10) : this.useNull ? null: 0
            },
            sortType: t.none,
            type: "int"
        },
        FLOAT: {
            convert: function(t) {
                if (typeof t === "number") {
                    return t
                }
                return t !== undefined && t !== null && t !== "" ? parseFloat(String(t).replace(e.stripRe, ""), 10) : this.useNull ? null: 0
            },
            sortType: t.none,
            type: "float"
        },
        BOOL: {
            convert: function(e) {
                if (typeof e === "boolean") {
                    return e
                }
                if (this.useNull && (e === undefined || e === null || e === "")) {
                    return null
                }
                return e === "true" || e == 1
            },
            sortType: t.none,
            type: "bool"
        },
        DATE: {
            convert: function(e) {
                var t = this.dateReadFormat || this.dateFormat,
                n;
                if (!e) {
                    return null
                }
                if (e instanceof Date) {
                    return e
                }
                if (t) {
                    return Ext.Date.parse(e, t)
                }
                n = Date.parse(e);
                return n ? new Date(n) : null
            },
            sortType: t.asDate,
            type: "date"
        }
    });
    e.BOOLEAN = e.BOOL;
    e.INTEGER = e.INT;
    e.NUMBER = e.FLOAT
});
Ext.define("Ext.data.Field", {
    alias: "data.field",
    isField: true,
    constructor: function(e) {
        var t = this,
        n = Ext.data.Types,
        r;
        if (Ext.isString(e)) {
            e = {
                name: e
            }
        }
        Ext.apply(t, e);
        r = t.sortType;
        if (t.type) {
            if (Ext.isString(t.type)) {
                t.type = n[t.type.toUpperCase()] || n.AUTO
            }
        } else {
            t.type = n.AUTO
        }
        if (Ext.isString(r)) {
            t.sortType = Ext.data.SortTypes[r]
        } else {
            if (Ext.isEmpty(r)) {
                t.sortType = t.type.sortType
            }
        }
        if (!e.hasOwnProperty("convert")) {
            t.convert = t.type.convert
        } else {
            if (!t.convert && t.type.convert && !e.hasOwnProperty("defaultValue")) {
                t.defaultValue = t.type.convert(t.defaultValue)
            }
        }
        if (e.convert) {
            t.hasCustomConvert = true
        }
    },
    dateFormat: null,
    dateReadFormat: null,
    dateWriteFormat: null,
    useNull: true,
    defaultValue: "",
    mapping: null,
    sortType: null,
    sortDir: "ASC",
    allowBlank: true,
    persist: true
});
Ext.define("Ext.data.Errors", {
    extend: Ext.util.MixedCollection,
    isValid: function() {
        return this.length === 0
    },
    getByField: function(e) {
        var t = [],
        n,
        r;
        for (r = 0; r < this.length; r++) {
            n = this.items[r];
            if (n.field == e) {
                t.push(n)
            }
        }
        return t
    }
});
Ext.define("Ext.data.validations", {
    singleton: true,
    presenceMessage: "must be present",
    lengthMessage: "is the wrong length",
    formatMessage: "is the wrong format",
    inclusionMessage: "is not included in the list of acceptable values",
    exclusionMessage: "is not an acceptable value",
    emailMessage: "is not a valid email address",
    emailRe: /^([a-zA-Z0-9_\.\-])+\@(([a-zA-Z0-9\-])+\.)+([a-zA-Z0-9]{2,4})+$/,
    presence: function(e, t) {
        if (arguments.length === 1) {
            t = e
        }
        return !! t || t === 0 || t === false
    },
    length: function(e, t) {
        if (t === undefined || t === null) {
            return false
        }
        var n = t.length,
        r = e.min,
        i = e.max;
        if (r && n < r || i && n > i) {
            return false
        } else {
            return true
        }
    },
    email: function(e, t) {
        return Ext.data.validations.emailRe.test(t)
    },
    format: function(e, t) {
        return !! (e.matcher && e.matcher.test(t))
    },
    inclusion: function(e, t) {
        return e.list && Ext.Array.indexOf(e.list, t) != -1
    },
    exclusion: function(e, t) {
        return e.list && Ext.Array.indexOf(e.list, t) == -1
    }
});
Ext.define("Ext.data.Model", {
    alternateClassName: "Ext.data.Record",
    mixins: {
        observable: Ext.util.Observable
    },
    compareConvertFields: function(e, t) {
        var n = e.convert && e.type && e.convert !== e.type.convert,
        r = t.convert && t.type && t.convert !== t.type.convert;
        if (n && !r) {
            return 1
        }
        if (!n && r) {
            return - 1
        }
        return 0
    },
    itemNameFn: function(e) {
        return e.name
    },
    onClassExtended: function(e, t, n) {
        var r = n.onBeforeCreated;
        n.onBeforeCreated = function(e, t) {
            var i = this,
            s = Ext.getClassName(e),
            o = e.prototype,
            u = e.prototype.superclass,
            f = t.validations || [],
            l = t.fields || [],
            c,
            h = t.associations || [],
            p = function(e, t) {
                var n = 0,
                r, i;
                if (e) {
                    e = Ext.Array.from(e);
                    for (r = e.length; n < r; ++n) {
                        i = e[n];
                        if (!Ext.isObject(i)) {
                            i = {
                                model: i
                            }
                        }
                        i.type = t;
                        h.push(i)
                    }
                }
            },
            v = t.idgen,
            m = new Ext.util.MixedCollection(false, o.itemNameFn),
            g = new Ext.util.MixedCollection(false, o.itemNameFn),
            y = u.validations,
            b = u.fields,
            w = u.associations,
            E,
            S,
            x,
            T = [],
            N = "idProperty" in t ? t.idProperty: o.idProperty,
            C = N ? N.isField ? N: new Ext.data.Field(N) : null,
            k = false,
            L = function(e, t, n) {
                var r, i;
                if (m.events.add.firing) {
                    i = e;
                    r = t
                } else {
                    r = n;
                    i = t.originalIndex
                }
                r.originalIndex = i;
                if (C && (r.mapping && r.mapping === C.mapping || r.name === C.name)) {
                    o.idField = r;
                    k = true;
                    r.defaultValue = undefined
                }
            },
            A = t.proxy,
            O = function() {
                m.sortBy(o.compareConvertFields)
            };
            e.modelName = s;
            o.modelName = s;
            if (y) {
                f = y.concat(f)
            }
            t.validations = f;
            if (b) {
                l = b.items.concat(l)
            }
            m.on({
                add: L,
                replace: L
            });
            for (S = 0, x = l.length; S < x; ++S) {
                c = l[S];
                m.add(c.isField ? c: new Ext.data.Field(c))
            }
            if (C && !k) {
                o.idField = C;
                C.defaultValue = undefined;
                m.add(C)
            }
            O();
            m.on({
                add: O,
                replace: O
            });
            t.fields = m;
            if (v) {
                t.idgen = Ext.data.IdGenerator.get(v)
            }
            p(t.belongsTo, "belongsTo");
            delete t.belongsTo;
            p(t.hasMany, "hasMany");
            delete t.hasMany;
            p(t.hasOne, "hasOne");
            delete t.hasOne;
            if (w) {
                h = w.items.concat(h)
            }
            Ext.Array.forEach(Ext.ModelManager.associationStack,
            function(e) {
                var t = function(e, n) {
                    n = n;
                    if (e.ownerModel === n.modelName) {
                        return true
                    } else {
                        if (n.superclass) {
                            return t(e, n.superclass)
                        }
                    }
                    return false
                },
                n;
                if (t(e, u)) {
                    n = Ext.clone(e);
                    n.ownerModel = this.modelName;
                    h.push(n)
                }
            },
            this);
            for (S = 0, x = h.length; S < x; ++S) {
                T.push("association." + h[S].type.toLowerCase())
            }
            if (A) {
                if (!A.isProxy) {
                    T.push("proxy." + (A.type || A))
                }
            } else {
                if (!e.prototype.proxy) {
                    e.prototype.proxy = e.prototype.defaultProxyType;
                    T.push("proxy." + e.prototype.defaultProxyType)
                }
            }
            Ext.require(T,
            function() {
                if (s) {
                    Ext.ModelManager.registerType(s, e);
                    for (S = 0, x = h.length; S < x; ++S) {
                        E = h[S];
                        if (E.isAssociation) {
                            E = Ext.applyIf({
                                ownerModel: s,
                                associatedModel: E.model
                            },
                            E.initialConfig)
                        } else {
                            Ext.apply(E, {
                                ownerModel: s,
                                associatedModel: E.model
                            })
                        }
                        if (Ext.ModelManager.getModel(E.model) === undefined) {
                            Ext.ModelManager.registerDeferredAssociation(E)
                        } else {
                            g.add(Ext.data.association.Association.create(E))
                        }
                    }
                }
                t.associations = g;
                r.call(i, e, t, n);
                if (A && A.isProxy) {
                    e.setProxy(A)
                }
                if (s) {
                    Ext.ModelManager.onModelDefined(e)
                }
            })
        }
    },
    inheritableStatics: {
        setProxy: function(e) {
            if (!e.isProxy) {
                if (typeof e == "string") {
                    e = {
                        type: e
                    }
                }
                e = Ext.createByAlias("proxy." + e.type, e)
            }
            e.setModel(this);
            this.proxy = this.prototype.proxy = e;
            return e
        },
        getProxy: function() {
            var e = this.proxy;
            if (!e) {
                e = this.prototype.proxy;
                if (e.isProxy) {
                    e = e.clone()
                }
                return this.setProxy(e)
            }
            return e
        },
        setFields: function(e, t, n) {
            var r = this,
            i, s, o = false,
            u = r.prototype,
            a = u.fields,
            f = u.superclass.fields,
            l, c;
            if (t) {
                u.idProperty = t;
                s = t.isField ? t: new Ext.data.Field(t)
            }
            if (n) {
                u.clientIdProperty = n
            }
            if (a) {
                a.clear()
            } else {
                a = r.prototype.fields = new Ext.util.MixedCollection(false,
                function(e) {
                    return e.name
                })
            }
            if (f) {
                e = f.items.concat(e)
            }
            for (c = 0, l = e.length; c < l; c++) {
                i = new Ext.data.Field(e[c]);
                if (s && (i.mapping && i.mapping === s.mapping || i.name === s.name)) {
                    o = true;
                    i.defaultValue = undefined
                }
                a.add(i)
            }
            if (s && !o) {
                s.defaultValue = undefined;
                a.add(s)
            }
            r.fields = a;
            return a
        },
        getFields: function() {
            return this.prototype.fields.items
        },
        load: function(e, t) {
            t = Ext.apply({},
            t);
            t = Ext.applyIf(t, {
                action: "read",
                id: e
            });
            var n = new Ext.data.Operation(t),
            r = t.scope || this,
            i;
            i = function(n) {
                var i = null,
                s = n.wasSuccessful();
                if (s) {
                    i = n.getRecords()[0];
                    if (!i.hasId()) {
                        i.setId(e)
                    }
                    Ext.callback(t.success, r, [i, n])
                } else {
                    Ext.callback(t.failure, r, [i, n])
                }
                Ext.callback(t.callback, r, [i, n, s])
            };
            this.getProxy().read(n, i, this)
        }
    },
    statics: {
        PREFIX: "ext-record",
        AUTO_ID: 1,
        EDIT: "edit",
        REJECT: "reject",
        COMMIT: "commit",
        id: function(e) {
            var t = [this.PREFIX, "-", this.AUTO_ID++].join("");
            e.phantom = true;
            e.internalId = t;
            return t
        }
    },
    idgen: {
        isGenerator: true,
        type: "default",
        generate: function() {
            return null
        },
        getRecId: function(e) {
            return e.modelName + "-" + e.internalId
        }
    },
    editing: false,
    dirty: false,
    persistenceProperty: "data",
    evented: false,
    isModel: true,
    phantom: false,
    idProperty: "id",
    clientIdProperty: null,
    defaultProxyType: "ajax",
    emptyData: [],
    constructor: function(e, t, n, r) {
        var i = this,
        s = t || t === 0,
        o, u, a, f, l, c, h, p, d = i.idProperty,
        v = i.idField,
        m;
        i.raw = n || e;
        i.modified = {};
        p = i[i.persistenceProperty] = r || {};
        i.data = i[i.persistenceProperty];
        i.mixins.observable.constructor.call(i);
        if (!r) {
            if (e) {
                if (!s && d) {
                    t = e[d];
                    o = t || t === 0
                }
            } else {
                e = i.emptyData
            }
            u = i.fields.items;
            a = u.length;
            m = 0;
            if (Ext.isArray(e)) {
                for (; m < a; m++) {
                    f = u[m];
                    l = f.name;
                    c = e[f.originalIndex];
                    if (c === undefined) {
                        c = f.defaultValue
                    }
                    if (f.convert) {
                        c = f.convert(c, i)
                    }
                    if (c !== undefined) {
                        p[l] = c
                    }
                }
            } else {
                for (; m < a; m++) {
                    f = u[m];
                    l = f.name;
                    c = e[l];
                    if (c === undefined) {
                        c = f.defaultValue
                    }
                    if (f.convert) {
                        c = f.convert(c, i)
                    }
                    if (c !== undefined) {
                        p[l] = c
                    }
                }
            }
        }
        i.stores = [];
        if (s) {
            o = true;
            p[d] = v && v.convert ? v.convert(t, i) : t
        } else {
            if (!o) {
                h = i.idgen.generate();
                if (h != null) {
                    i.preventInternalUpdate = true;
                    i.setId(h);
                    delete i.preventInternalUpdate
                }
            }
        }
        i.internalId = o ? t: Ext.data.Model.id(i);
        if (typeof i.init == "function") {
            i.init()
        }
        i.id = i.idgen.getRecId(i)
    },
    get: function(e) {
        return this[this.persistenceProperty][e]
    },
    _singleProp: {},
    set: function(e, t) {
        var n = this,
        r = n[n.persistenceProperty],
        i = n.fields,
        s = n.modified,
        o = typeof e == "string",
        u,
        a,
        f,
        l,
        c,
        h,
        p,
        d,
        v,
        m;
        if (o) {
            m = n._singleProp;
            m[e] = t
        } else {
            m = e
        }
        for (h in m) {
            if (m.hasOwnProperty(h)) {
                v = m[h];
                if (i && (a = i.get(h)) && a.convert) {
                    v = a.convert(v, n)
                }
                u = r[h];
                if (n.isEqual(u, v)) {
                    continue
                }
                r[h] = v; (c || (c = [])).push(h);
                if (a && a.persist) {
                    if (s.hasOwnProperty(h)) {
                        if (n.isEqual(s[h], v)) {
                            delete s[h];
                            n.dirty = false;
                            for (l in s) {
                                if (s.hasOwnProperty(l)) {
                                    n.dirty = true;
                                    break
                                }
                            }
                        }
                    } else {
                        n.dirty = true;
                        s[h] = u
                    }
                }
                if (h == n.idProperty) {
                    f = true;
                    p = u;
                    d = v
                }
            }
        }
        if (o) {
            delete m[e]
        }
        if (f) {
            n.changeId(p, d)
        }
        if (!n.editing && c) {
            n.afterEdit(c)
        }
        return c || null
    },
    copyFrom: function(e) {
        var t = this,
        n = t.fields.items,
        r = n.length,
        i = [],
        s,
        o = 0,
        u,
        a,
        f = t.idProperty,
        l,
        c;
        if (e) {
            u = t[t.persistenceProperty];
            a = e[e.persistenceProperty];
            for (; o < r; o++) {
                s = n[o];
                l = s.name;
                if (l != f) {
                    c = a[l];
                    if (c !== undefined && !t.isEqual(u[l], c)) {
                        u[l] = c;
                        i.push(l)
                    }
                }
            }
            if (t.phantom && !e.phantom) {
                t.beginEdit();
                t.setId(e.getId());
                t.endEdit(true);
                t.commit(true)
            }
        }
        return i
    },
    isEqual: function(e, t) {
        if (e instanceof Date && t instanceof Date) {
            return e.getTime() === t.getTime()
        }
        return e === t
    },
    beginEdit: function() {
        var e = this,
        t, n, r;
        if (!e.editing) {
            e.editing = true;
            e.dirtySave = e.dirty;
            r = e[e.persistenceProperty];
            n = e.dataSave = {};
            for (t in r) {
                if (r.hasOwnProperty(t)) {
                    n[t] = r[t]
                }
            }
            r = e.modified;
            n = e.modifiedSave = {};
            for (t in r) {
                if (r.hasOwnProperty(t)) {
                    n[t] = r[t]
                }
            }
        }
    },
    cancelEdit: function() {
        var e = this;
        if (e.editing) {
            e.editing = false;
            e.modified = e.modifiedSave;
            e[e.persistenceProperty] = e.dataSave;
            e.dirty = e.dirtySave;
            e.modifiedSave = e.dataSave = e.dirtySave = null
        }
    },
    endEdit: function(e, t) {
        var n = this,
        r, i;
        e = e === true;
        if (n.editing) {
            n.editing = false;
            r = n.dataSave;
            n.modifiedSave = n.dataSave = n.dirtySave = null;
            if (!e) {
                if (!t) {
                    t = n.getModifiedFieldNames(r)
                }
                i = n.dirty || t.length > 0;
                if (i) {
                    n.afterEdit(t)
                }
            }
        }
    },
    getModifiedFieldNames: function(e) {
        var t = this,
        n = t[t.persistenceProperty],
        r = [],
        i;
        e = e || t.dataSave;
        for (i in n) {
            if (n.hasOwnProperty(i)) {
                if (!t.isEqual(n[i], e[i])) {
                    r.push(i)
                }
            }
        }
        return r
    },
    getChanges: function() {
        var e = this.modified,
        t = {},
        n;
        for (n in e) {
            if (e.hasOwnProperty(n)) {
                t[n] = this.get(n)
            }
        }
        return t
    },
    isModified: function(e) {
        return this.modified.hasOwnProperty(e)
    },
    setDirty: function() {
        var e = this,
        t = e.fields.items,
        n = t.length,
        r, i, s;
        e.dirty = true;
        for (s = 0; s < n; s++) {
            r = t[s];
            if (r.persist) {
                i = r.name;
                e.modified[i] = e.get(i)
            }
        }
    },
    reject: function(e) {
        var t = this,
        n = t.modified,
        r;
        for (r in n) {
            if (n.hasOwnProperty(r)) {
                if (typeof n[r] != "function") {
                    t[t.persistenceProperty][r] = n[r]
                }
            }
        }
        t.dirty = false;
        t.editing = false;
        t.modified = {};
        if (e !== true) {
            t.afterReject()
        }
    },
    commit: function(e, t) {
        var n = this;
        n.phantom = n.dirty = n.editing = false;
        n.modified = {};
        if (e !== true) {
            n.afterCommit(t)
        }
    },
    copy: function(e) {
        var t = this;
        return new t.self(t.raw, e, null, Ext.apply({},
        t[t.persistenceProperty]))
    },
    setProxy: function(e) {
        if (!e.isProxy) {
            if (typeof e === "string") {
                e = {
                    type: e
                }
            }
            e = Ext.createByAlias("proxy." + e.type, e)
        }
        e.setModel(this.self);
        this.proxy = e;
        return e
    },
    getProxy: function() {
        return this.hasOwnProperty("proxy") ? this.proxy: this.self.getProxy()
    },
    validate: function() {
        var e = new Ext.data.Errors,
        t = this.validations,
        n = Ext.data.validations,
        r, i, s, o, u, a;
        if (t) {
            r = t.length;
            for (a = 0; a < r; a++) {
                i = t[a];
                s = i.field || i.name;
                u = i.type;
                o = n[u](i, this.get(s));
                if (!o) {
                    e.add({
                        field: s,
                        message: i.message || n[u + "Message"]
                    })
                }
            }
        }
        return e
    },
    isValid: function() {
        return this.validate().isValid()
    },
    save: function(e) {
        e = Ext.apply({},
        e);
        var t = this,
        n = t.phantom ? "create": "update",
        r = e.scope || t,
        i = t.stores,
        s = 0,
        o,
        u,
        a,
        f;
        Ext.apply(e, {
            records: [t],
            action: n
        });
        a = new Ext.data.Operation(e);
        f = function(n) {
            var a = n.wasSuccessful();
            if (a) {
                for (o = i.length; s < o; s++) {
                    u = i[s];
                    u.fireEvent("write", u, n);
                    u.fireEvent("datachanged", u)
                }
                Ext.callback(e.success, r, [t, n])
            } else {
                Ext.callback(e.failure, r, [t, n])
            }
            Ext.callback(e.callback, r, [t, n, a])
        };
        t.getProxy()[n](a, f, t);
        return t
    },
    destroy: function(e) {
        e = Ext.apply({
            records: [this],
            action: "destroy"
        },
        e);
        var t = this,
        n = t.phantom !== true,
        r = e.scope || t,
        i, s = 0,
        o, u, a, f, l;
        f = new Ext.data.Operation(e);
        l = function(f) {
            a = [t, f];
            i = Ext.Array.clone(t.stores);
            if (f.wasSuccessful()) {
                for (o = i.length; s < o; s++) {
                    u = i[s];
                    if (u.remove) {
                        u.remove(t, true)
                    } else {
                        u.fireEvent("bulkremove", u, [t], [u.indexOf(t)], false)
                    }
                    if (n) {
                        u.fireEvent("write", u, f)
                    }
                }
                t.clearListeners();
                Ext.callback(e.success, r, a)
            } else {
                Ext.callback(e.failure, r, a)
            }
            Ext.callback(e.callback, r, a)
        };
        if (n) {
            t.getProxy().destroy(f, l, t)
        } else {
            f.complete = f.success = true;
            f.resultSet = t.getProxy().reader.nullResultSet;
            l(f)
        }
        return t
    },
    getId: function() {
        return this.get(this.idField.name)
    },
    getObservableId: function() {
        return this.id
    },
    setId: function(e) {
        this.set(this.idProperty, e)
    },
    changeId: function(e, t) {
        var n = this,
        r, i, s;
        if (!n.preventInternalUpdate) {
            r = n.hasId(e);
            i = n.hasId(t);
            s = n.internalId;
            n.phantom = !i;
            if (i !== r || i && r) {
                n.internalId = i ? t: Ext.data.Model.id(n)
            }
            n.fireEvent("idchanged", n, e, t, s);
            n.callStore("onIdChanged", e, t, s)
        }
    },
    hasId: function(e) {
        if (arguments.length === 0) {
            e = this.getId()
        }
        return !! (e || e === 0)
    },
    join: function(e) {
        var t = this;
        if (!t.stores.length) {
            t.stores[0] = e
        } else {
            Ext.Array.include(this.stores, e)
        }
        this.store = this.stores[0]
    },
    unjoin: function(e) {
        Ext.Array.remove(this.stores, e);
        this.store = this.stores[0] || null
    },
    afterEdit: function(e) {
        this.callStore("afterEdit", e)
    },
    afterReject: function() {
        this.callStore("afterReject")
    },
    afterCommit: function(e) {
        this.callStore("afterCommit", e)
    },
    callStore: function(e) {
        var t = Ext.Array.clone(arguments),
        n = this.stores,
        r = 0,
        i = n.length,
        s;
        t[0] = this;
        for (; r < i; ++r) {
            s = n[r];
            if (s && Ext.isFunction(s[e])) {
                s[e].apply(s, t)
            }
        }
    },
    getData: function(e) {
        var t = this,
        n = t.fields.items,
        r = n.length,
        i = {},
        s, o;
        for (o = 0; o < r; o++) {
            s = n[o].name;
            i[s] = t.get(s)
        }
        if (e === true) {
            Ext.apply(i, t.getAssociatedData())
        }
        return i
    },
    getAssociatedData: function() {
        return this.prepareAssociatedData({},
        1)
    },
    prepareAssociatedData: function(e, t) {
        var n = this,
        r = n.associations.items,
        i = r.length,
        s = {},
        o = [],
        u = [],
        a = [],
        f,
        l,
        c,
        h,
        p,
        d,
        v,
        m,
        g,
        y,
        b,
        w,
        E,
        S;
        for (b = 0; b < i; b++) {
            y = r[b];
            m = y.associationId;
            v = e[m];
            if (v && v !== t) {
                continue
            }
            e[m] = t;
            E = y.type;
            S = y.name;
            if (E == "hasMany") {
                f = n[y.storeName];
                s[S] = [];
                if (f && f.getCount() > 0) {
                    l = f.data.items;
                    g = l.length;
                    for (w = 0; w < g; w++) {
                        c = l[w];
                        s[S][w] = c.getData();
                        o.push(c);
                        u.push(S);
                        a.push(w)
                    }
                }
            } else {
                if (E == "belongsTo" || E == "hasOne") {
                    c = n[y.instanceName];
                    if (c !== undefined) {
                        s[S] = c.getData();
                        o.push(c);
                        u.push(S);
                        a.push( - 1)
                    }
                }
            }
        }
        for (b = 0, g = o.length; b < g; ++b) {
            c = o[b];
            h = s[u[b]];
            p = a[b];
            d = c.prepareAssociatedData(e, t + 1);
            if (p === -1) {
                Ext.apply(h, d)
            } else {
                Ext.apply(h[p], d)
            }
        }
        return s
    }
});
Ext.define("Ext.data.proxy.Server", {
    extend: Ext.data.proxy.Proxy,
    alias: "proxy.server",
    alternateClassName: "Ext.data.ServerProxy",
    pageParam: "page",
    startParam: "start",
    limitParam: "limit",
    groupParam: "group",
    groupDirectionParam: "groupDir",
    sortParam: "sort",
    filterParam: "filter",
    directionParam: "dir",
    idParam: "id",
    simpleSortMode: false,
    simpleGroupMode: false,
    noCache: false,
    cacheString: "_dc",
    timeout: 3e4,
    constructor: function(e) {
        var t = this;
        e = e || {};
        t.callParent([e]);
        t.extraParams = e.extraParams || {};
        t.api = Ext.apply({},
        e.api || t.api);
        t.nocache = t.noCache
    },
    create: function() {
        return this.doRequest.apply(this, arguments)
    },
    read: function() {
        return this.doRequest.apply(this, arguments)
    },
    update: function() {
        return this.doRequest.apply(this, arguments)
    },
    destroy: function() {
        return this.doRequest.apply(this, arguments)
    },
    setExtraParam: function(e, t) {
        this.extraParams[e] = t
    },
    buildRequest: function(e) {
        var t = this,
        n = e.params = Ext.apply({},
        e.params, t.extraParams),
        r;
        Ext.applyIf(n, t.getParams(e));
        if (e.id !== undefined && n[t.idParam] === undefined) {
            n[t.idParam] = e.id
        }
        r = new Ext.data.Request({
            params: n,
            action: e.action,
            records: e.records,
            operation: e,
            url: e.url,
            proxy: t
        });
        r.url = t.buildUrl(r);
        e.request = r;
        return r
    },
    processResponse: function(e, t, n, r, i, s) {
        var o = this,
        u, a, f = e,
        l;
        if (e === true) {
            u = o.getReader();
            u.applyDefaults = t.action === "read";
            l = u.read(o.extractResponseData(r));
            f = l.success !== false;
            if (f) {
                Ext.apply(t, {
                    response: r,
                    resultSet: l
                });
                t.commitRecords(l.records);
                t.setCompleted();
                t.setSuccessful()
            } else {
                if (t.showError !== undefined) {
                    a = t.showError
                } else {
                    a = s.showError
                }
                if (a) {
                    Wb.error(l.message)
                }
                t.setException(l.message);
                o.fireEvent("exception", this, r, t)
            }
        } else {
            o.setException(t, r);
            o.fireEvent("exception", this, r, t)
        }
        if (typeof i == "function") {
            i.call(s || o, t)
        }
        if (s.hasListeners && s.hasListeners.loadraw) {
            s.fireEvent("loadraw", s, r, f)
        }
        o.afterRequest(n, e)
    },
    setException: function(e, t) {
        e.setException({
            status: t.status,
            statusText: t.statusText
        })
    },
    extractResponseData: Ext.identityFn,
    applyEncoding: function(e) {
        return Ext.encode(e)
    },
    encodeSorters: function(e) {
        var t = [],
        n = e.length,
        r = 0;
        for (; r < n; r++) {
            t[r] = {
                property: e[r].property,
                direction: e[r].direction
            }
        }
        return this.applyEncoding(t)
    },
    encodeFilters: function(e) {
        var t = [],
        n = e.length,
        r = 0;
        for (; r < n; r++) {
            t[r] = {
                property: e[r].property,
                value: e[r].value
            }
        }
        return this.applyEncoding(t)
    },
    getParams: function(e) {
        var t = this,
        n = {},
        r = Ext.isDefined,
        i = e.groupers,
        s = e.sorters,
        o = e.filters,
        u = e.page,
        a = e.start,
        f = e.limit,
        l = t.simpleSortMode,
        c = t.simpleGroupMode,
        h = t.pageParam,
        p = t.startParam,
        d = t.limitParam,
        v = t.groupParam,
        m = t.groupDirectionParam,
        g = t.sortParam,
        y = t.filterParam,
        b = t.directionParam,
        w, E;
        if (h && r(u)) {
            n[h] = u
        }
        if (p && r(a)) {
            n[p] = a
        }
        if (d && r(f)) {
            n[d] = f
        }
        w = v && i && i.length > 0;
        if (w) {
            if (c) {
                n[v] = i[0].property;
                n[m] = i[0].direction || "ASC"
            } else {
                n[v] = t.encodeSorters(i)
            }
        }
        if (g && s && s.length > 0) {
            if (l) {
                E = 0;
                if (s.length > 1 && w) {
                    E = 1
                }
                n[g] = s[E].property;
                n[b] = s[E].direction
            } else {
                n[g] = t.encodeSorters(s)
            }
        }
        if (y && o && o.length > 0) {
            n[y] = t.encodeFilters(o)
        }
        return n
    },
    buildUrl: function(e) {
        var t = this,
        n = t.getUrl(e);
        if (t.noCache) {
            n = Ext.urlAppend(n, Ext.String.format("{0}={1}", t.cacheString, Ext.Date.now()))
        }
        return n
    },
    getUrl: function(e) {
        return e.url || this.api[e.action] || this.url
    },
    doRequest: function(e, t, n) {},
    afterRequest: Ext.emptyFn,
    onDestroy: function() {
        Ext.destroy(this.reader, this.writer)
    }
});
Ext.define("Ext.data.proxy.Ajax", {
    extend: Ext.data.proxy.Server,
    alias: "proxy.ajax",
    alternateClassName: ["Ext.data.HttpProxy", "Ext.data.AjaxProxy"],
    actionMethods: {
        create: "POST",
        read: "POST",
        update: "POST",
        destroy: "POST"
    },
    defaultActionMethods: {
        create: "POST",
        read: "POST",
        update: "POST",
        destroy: "POST"
    },
    binary: false,
    paramsAsJson: false,
    doRequest: function(e, t, n) {
        var r = this,
        i = r.getWriter(),
        s = r.buildRequest(e),
        o = r.getMethod(s);
        if (e.allowWrite()) {
            s = i.write(s)
        }
        Ext.apply(s, {
            binary: r.binary,
            headers: r.headers,
            timeout: r.timeout,
            scope: r,
            callback: r.createRequestCallback(s, e, t, n),
            method: o,
            disableCaching: false
        });
        if (o.toUpperCase() !== "GET" && r.paramsAsJson) {
            s = Ext.apply({
                jsonData: s.params
            },
            s);
            delete s.params
        }
        n.lastRequest = Ext.Ajax.request(s);
        return s
    },
    getMethod: function(e) {
        var t = this.actionMethods,
        n = e.action,
        r;
        if (t) {
            r = t[n]
        }
        return r || this.defaultActionMethods[n]
    },
    createRequestCallback: function(e, t, n, r) {
        var i = this,
        s, o, u, a;
        if (r.params) {
            Ext.applyIf(t.params, r.params)
        }
        s = t.message || r.message;
        o = t.mask || r.mask;
        if (t.showError !== undefined) {
            u = t.showError
        } else {
            u = r.showError
        }
        if (t.showMask !== undefined) {
            a = t.showMask
        } else {
            if (r.showMask === undefined) {
                if (s || o) {
                    a = true
                } else {
                    if (r instanceof Ext.data.TreeStore) {
                        a = r.ownerTree && !r.ownerTree.rootVisible && t.node && t.node.isRoot()
                    } else {
                        a = true
                    }
                }
            } else {
                a = r.showMask
            }
        }
        if (a) {
            Wb.mask(o, s)
        }
        return function(f, l, p) {
            delete r.lastRequest;
            if (a) {
                Wb.unmask(o, s)
            }
            if (!l && u && p) {
                Wb.except(p)
            }
            i.processResponse(l, t, e, p, n, r)
        }
    }
});
Ext.define("Ext.data.PageMap", {
    extend: Ext.util.LruCache,
    clear: function(e) {
        var t = this;
        t.pageMapGeneration = (t.pageMapGeneration || 0) + 1;
        t.callParent(arguments)
    },
    forEach: function(e, t) {
        var n = this,
        r = Ext.Object.getKeys(n.map),
        i = r.length,
        s,
        o,
        u,
        a,
        f;
        for (s = 0; s < i; s++) {
            r[s] = +r[s]
        }
        Ext.Array.sort(r,
        function(e, t) {
            return e - t
        });
        t = t || n;
        for (s = 0; s < i; s++) {
            u = r[s];
            a = n.getPage(u);
            f = a.length;
            for (o = 0; o < f; o++) {
                if (e.call(t, a[o], (u - 1) * n.pageSize + o) === false) {
                    return
                }
            }
        }
    },
    findBy: function(e, t) {
        var n = this,
        r = null;
        t = t || n;
        n.forEach(function(n, i) {
            if (e.call(t, n, i)) {
                r = n;
                return false
            }
        });
        return r
    },
    findIndexBy: function(e, t) {
        var n = this,
        r = -1;
        t = t || n;
        n.forEach(function(n, i) {
            if (e.call(t, n)) {
                r = i;
                return false
            }
        });
        return r
    },
    getPageFromRecordIndex: function() {
        return Ext.data.Store.prototype.getPageFromRecordIndex.apply(this, arguments)
    },
    addAll: function(e) {
        this.addPage(1, e)
    },
    addPage: function(e, t) {
        var n = this,
        r = e + Math.floor((t.length - 1) / n.pageSize),
        i,
        s;
        for (i = 0; e <= r; e++, i += n.pageSize) {
            s = Ext.Array.slice(t, i, i + n.pageSize);
            n.add(e, s);
            n.fireEvent("pageAdded", e, s)
        }
    },
    getCount: function() {
        var e = this.callParent();
        if (e) {
            e = (e - 1) * this.pageSize + this.last.value.length
        }
        return e
    },
    indexOf: function(e) {
        return e ? e.index: -1
    },
    insert: function() {},
    remove: function() {},
    removeAt: function() {},
    getPage: function(e) {
        return this.get(e)
    },
    hasRange: function(e, t) {
        var n = this.getPageFromRecordIndex(e),
        r = this.getPageFromRecordIndex(t);
        for (; n <= r; n++) {
            if (!this.hasPage(n)) {
                return false
            }
        }
        return true
    },
    hasPage: function(e) {
        return !! this.get(e)
    },
    getAt: function(e) {
        return this.getRange(e, e)[0]
    },
    getRange: function(e, t) {
        if (!this.hasRange(e, t)) {
            Ext.Error.raise("PageMap asked for range which it does not have")
        }
        var n = this,
        r = n.getPageFromRecordIndex(e),
        i = n.getPageFromRecordIndex(t),
        s = (r - 1) * n.pageSize,
        o = i * n.pageSize - 1,
        u = r,
        a = [],
        f,
        l,
        c,
        h = 0,
        p;
        for (; u <= i; u++) {
            if (u == r) {
                f = e - s;
                c = true
            } else {
                f = 0;
                c = false
            }
            if (u == i) {
                l = n.pageSize - (o - t);
                c = true
            }
            if (c) {
                Ext.Array.push(a, Ext.Array.slice(n.getPage(u), f, l))
            } else {
                Ext.Array.push(a, n.getPage(u))
            }
        }
        for (p = a.length; h < p; h++) {
            a[h].index = e++
        }
        return a
    }
});
Ext.define("Ext.data.Group", {
    extend: Ext.util.Observable,
    key: undefined,
    dirty: true,
    constructor: function() {
        this.callParent(arguments);
        this.records = []
    },
    contains: function(e) {
        return Ext.Array.indexOf(this.records, e) !== -1
    },
    add: function(e) {
        Ext.Array.push(this.records, e);
        this.dirty = true
    },
    remove: function(e) {
        if (!Ext.isArray(e)) {
            e = [e]
        }
        var t = e.length,
        n;
        for (n = 0; n < t; ++n) {
            Ext.Array.remove(this.records, e[n])
        }
        this.dirty = true
    },
    isDirty: function() {
        return this.dirty
    },
    hasAggregate: function() {
        return !! this.aggregate
    },
    setDirty: function() {
        this.dirty = true
    },
    commit: function() {
        this.dirty = false
    },
    isCollapsed: function() {
        return this.collapsed
    },
    getAggregateRecord: function(e) {
        var t = this,
        n;
        if (e === true || t.dirty || !t.aggregate) {
            n = t.store.model;
            t.aggregate = new n;
            t.aggregate.isSummary = true
        }
        return t.aggregate
    }
});
Ext.define("Ext.data.Store", {
    extend: Ext.data.AbstractStore,
    alias: "store.store",
    remoteSort: false,
    remoteFilter: false,
    remoteGroup: false,
    groupField: undefined,
    groupDir: "ASC",
    trailingBufferZone: 25,
    leadingBufferZone: 200,
    pageSize: undefined,
    currentPage: 1,
    clearOnPageLoad: true,
    loading: false,
    sortOnFilter: true,
    buffered: false,
    purgePageCount: 5,
    clearRemovedOnLoad: true,
    defaultPageSize: 50,
    defaultViewSize: 50,
    addRecordsOptions: {
        addRecords: true
    },
    statics: {
        recordIdFn: function(e) {
            return e.internalId
        },
        recordIndexFn: function(e) {
            return e.index
        },
        grouperIdFn: function(e) {
            return e.id || e.property
        },
        groupIdFn: function(e) {
            return e.key
        }
    },
    constructor: function(e) {
        e = Ext.apply({},
        e);
        var t = this,
        n = e.groupers || t.groupers,
        r = e.groupField || t.groupField,
        i, s;
        s = e.data || t.data;
        if (s) {
            t.inlineData = s;
            delete e.data
        }
        if (!n && r) {
            n = [{
                property: r,
                direction: e.groupDir || t.groupDir
            }];
            if (e.getGroupString || t.getGroupString !== Ext.data.Store.prototype.getGroupString) {
                n[0].getGroupString = function(e) {
                    return t.getGroupString(e)
                }
            }
        }
        delete e.groupers;
        t.groupers = new Ext.util.MixedCollection(false, Ext.data.Store.grouperIdFn);
        t.groupers.addAll(t.decodeGroupers(n));
        t.groups = new Ext.util.MixedCollection(false, Ext.data.Store.groupIdFn);
        t.callParent([e]);
        if (t.buffered) {
            t.data = new Ext.data.PageMap({
                store: t,
                keyFn: Ext.data.Store.recordIdFn,
                pageSize: t.pageSize,
                maxSize: t.purgePageCount,
                listeners: {
                    clear: t.onPageMapClear,
                    scope: t
                }
            });
            t.pageRequests = {};
            t.remoteSort = t.remoteGroup = t.remoteFilter = true;
            t.sortOnLoad = false;
            t.filterOnLoad = false
        } else {
            t.data = new Ext.util.MixedCollection({
                getKey: Ext.data.Store.recordIdFn,
                maintainIndices: true
            })
        }
        if (t.remoteGroup) {
            t.remoteSort = true
        }
        i = t.proxy;
        s = t.inlineData;
        if (t.pageSize == -1) {
            t.pageSize = Wb.maxInt
        }
        if (!t.pageSize) {
            t.pageSize = t.defaultPageSize
        }
        if (s) {
            if (i instanceof Ext.data.proxy.Memory) {
                i.data = s;
                t.read()
            } else {
                t.add.apply(t, [s])
            }
            delete t.inlineData
        } else {
            if (t.autoLoad) {
                t.autoLoadTask = new Ext.util.DelayedTask(t.load, t, [typeof t.autoLoad === "object" ? t.autoLoad: undefined]);
                t.autoLoadTask.delay(1)
            }
        }
        t.mon(t, "load",
        function(e, t, n) {
            if (n) {
                e.fireEvent("success", e, t)
            } else {
                e.fireEvent("failure", e, t)
            }
        })
    },
    decodeGroupers: function(e) {
        if (!Ext.isArray(e)) {
            if (e === undefined) {
                e = []
            } else {
                e = [e]
            }
        }
        var t = e.length,
        n = Ext.util.Grouper,
        r, i, s = [];
        for (i = 0; i < t; i++) {
            r = e[i];
            if (! (r instanceof n)) {
                if (Ext.isString(r)) {
                    r = {
                        property: r
                    }
                }
                r = Ext.apply({
                    root: "data",
                    direction: "ASC"
                },
                r);
                if (r.fn) {
                    r.sorterFn = r.fn
                }
                if (typeof r == "function") {
                    r = {
                        sorterFn: r
                    }
                }
                s.push(new n(r))
            } else {
                s.push(r)
            }
        }
        return s
    },
    group: function(e, t, n) {
        var r = this,
        i, s;
        if (e) {
            r.sorters.removeAll(r.groupers.items);
            if (Ext.isArray(e)) {
                s = e
            } else {
                if (Ext.isObject(e)) {
                    s = [e]
                } else {
                    if (Ext.isString(e)) {
                        i = r.groupers.get(e);
                        if (!i) {
                            i = {
                                property: e,
                                direction: t || r.groupDir
                            };
                            s = [i]
                        } else {
                            if (t === undefined) {
                                i.toggle()
                            } else {
                                i.setDirection(t)
                            }
                        }
                    }
                }
            }
            if (s && s.length) {
                r.groupers.clear();
                r.groupers.addAll(r.decodeGroupers(s))
            }
            r.sorters.insert(0, r.groupers.items)
        }
        if (r.remoteGroup) {
            if (r.buffered) {
                r.data.clear();
                r.loadPage(1, {
                    groupChange: true
                })
            } else {
                r.load({
                    scope: r,
                    callback: n ? null: r.fireGroupChange
                })
            }
        } else {
            r.doSort(r.generateComparator());
            r.constructGroups();
            if (!n) {
                r.fireGroupChange()
            }
        }
    },
    getGroupField: function() {
        var e = this.groupers.first(),
        t;
        if (e) {
            t = e.property
        }
        return t
    },
    constructGroups: function() {
        var e = this,
        t = this.data.items,
        n = t.length,
        r = e.groups,
        i, s, o, u;
        r.clear();
        if (e.isGrouped()) {
            for (s = 0; s < n; ++s) {
                u = t[s];
                i = e.getGroupString(u);
                o = r.get(i);
                if (!o) {
                    o = new Ext.data.Group({
                        key: i,
                        store: e
                    });
                    r.add(o)
                }
                o.add(u)
            }
        }
    },
    clearGrouping: function() {
        var e = this,
        t = e.groupers.items,
        n = t.length,
        r;
        for (r = 0; r < n; r++) {
            e.sorters.remove(t[r])
        }
        e.groupers.clear();
        if (e.remoteGroup) {
            if (e.buffered) {
                e.data.clear();
                e.loadPage(1, {
                    groupChange: true
                })
            } else {
                e.load({
                    scope: e,
                    callback: e.fireGroupChange
                })
            }
        } else {
            e.groups.clear();
            if (e.sorters.length) {
                e.sort()
            } else {
                e.fireEvent("datachanged", e);
                e.fireEvent("refresh", e)
            }
            e.fireGroupChange()
        }
    },
    isGrouped: function() {
        return this.groupers.getCount() > 0
    },
    fireGroupChange: function() {
        this.fireEvent("groupchange", this, this.groupers)
    },
    getGroups: function(e) {
        var t = this.data.items,
        n = t.length,
        r = [],
        i = {},
        s,
        o,
        u,
        a;
        for (a = 0; a < n; a++) {
            s = t[a];
            o = this.getGroupString(s);
            u = i[o];
            if (u === undefined) {
                u = {
                    name: o,
                    children: []
                };
                r.push(u);
                i[o] = u
            }
            u.children.push(s)
        }
        return e ? i[e] : r
    },
    getGroupsForGrouper: function(e, t) {
        var n = e.length,
        r = [],
        i,
        s,
        o,
        u,
        a;
        for (a = 0; a < n; a++) {
            o = e[a];
            s = t.getGroupString(o);
            if (s !== i) {
                u = {
                    name: s,
                    grouper: t,
                    records: []
                };
                r.push(u)
            }
            u.records.push(o);
            i = s
        }
        return r
    },
    getGroupsForGrouperIndex: function(e, t) {
        var n = this,
        r = n.groupers,
        i = r.getAt(t),
        s = n.getGroupsForGrouper(e, i),
        o = s.length,
        u;
        if (t + 1 < r.length) {
            for (u = 0; u < o; u++) {
                s[u].children = n.getGroupsForGrouperIndex(s[u].records, t + 1)
            }
        }
        for (u = 0; u < o; u++) {
            s[u].depth = t
        }
        return s
    },
    getGroupData: function(e) {
        var t = this;
        if (e !== false) {
            t.sort()
        }
        return t.getGroupsForGrouperIndex(t.data.items, 0)
    },
    getGroupString: function(e) {
        var t = this.groupers.first();
        if (t) {
            return t.getGroupString(e)
        }
        return ""
    },
    insert: function(e, t) {
        var n = this,
        r = false,
        i, s, o, u = n.modelDefaults,
        a;
        if (!Ext.isIterable(t)) {
            a = t = [t]
        } else {
            a = []
        }
        s = t.length;
        if (s) {
            for (i = 0; i < s; i++) {
                o = t[i];
                if (!o.isModel) {
                    o = n.createModel(o)
                }
                a[i] = o;
                if (u) {
                    o.set(u)
                }
                o.join(n);
                r = r || o.phantom === true
            }
            n.data.insert(e, a);
            if (n.snapshot) {
                n.snapshot.addAll(a)
            }
            if (n.requireSort) {
                n.suspendEvents();
                n.sort();
                n.resumeEvents()
            }
            if (n.isGrouped()) {
                n.updateGroupsOnAdd(a)
            }
            n.fireEvent("add", n, a, e);
            n.fireEvent("datachanged", n);
            if (n.autoSync && r && !n.autoSyncSuspended) {
                n.sync()
            }
        }
        return a
    },
    updateGroupsOnAdd: function(e) {
        var t = this,
        n = t.groups,
        r = e.length,
        i, s, o, u;
        for (i = 0; i < r; ++i) {
            u = e[i];
            s = t.getGroupString(u);
            o = n.getByKey(s);
            if (!o) {
                o = n.add(new Ext.data.Group({
                    key: s,
                    store: t
                }))
            }
            o.add(u)
        }
    },
    updateGroupsOnRemove: function(e) {
        var t = this,
        n = t.groups,
        r = e.length,
        i, s, o, u;
        for (i = 0; i < r; ++i) {
            u = e[i];
            s = t.getGroupString(u);
            o = n.getByKey(s);
            if (o) {
                o.remove(u);
                if (o.records.length === 0) {
                    n.remove(o)
                }
            }
        }
    },
    updateGroupsOnUpdate: function(e, t) {
        var n = this,
        r = n.getGroupField(),
        i = n.getGroupString(e),
        s = n.groups,
        o,
        u,
        a,
        f;
        if (t && Ext.Array.contains(t, r)) {
            if (n.buffered) {
                Ext.Error.raise({
                    msg: "Cannot move records between groups in a buffered store record"
                })
            }
            a = s.items;
            for (u = 0, o = a.length; u < o; ++u) {
                f = a[u];
                if (f.contains(e)) {
                    f.remove(e);
                    break
                }
            }
            f = s.getByKey(i);
            if (!f) {
                f = s.add(new Ext.data.Group({
                    key: i,
                    store: n
                }))
            }
            f.add(e);
            n.data.remove(e);
            n.data.insert(n.data.findInsertionIndex(e, n.generateComparator()), e)
        } else {
            s.getByKey(i).setDirty()
        }
    },
    add: function(e) {
        var t = this,
        n, r, i;
        if (Ext.isArray(e)) {
            n = e
        } else {
            n = arguments
        }
        r = n.length;
        i = !t.remoteSort && t.getSorterCount();
        if (i && r === 1) {
            return [t.addSorted(t.createModel(n[0]))]
        }
        if (i) {
            t.requireSort = true
        }
        n = t.insert(t.data.length, n);
        delete t.requireSort;
        return n
    },
    addSorted: function(e) {
        var t = this,
        n = t.data.findInsertionIndex(e, t.generateComparator());
        t.insert(n, e);
        return e
    },
    createModel: function(e) {
        if (!e.isModel) {
            e = Ext.ModelManager.create(e, this.model)
        }
        return e
    },
    onUpdate: function(e, t, n) {
        if (this.isGrouped()) {
            this.updateGroupsOnUpdate(e, n)
        }
    },
    each: function(e, t) {
        var n = this.data.items,
        r = n.length,
        i, s;
        for (s = 0; s < r; s++) {
            i = n[s];
            if (e.call(t || i, i, s, r) === false) {
                break
            }
        }
    },
    remove: function(e, t, n) {
        t = t === true;
        var r = this,
        i = false,
        s = r.snapshot,
        o = r.data,
        u = 0,
        a, f = [],
        l = [],
        c = [],
        h = [],
        p = r.groups.length,
        d,
        v,
        m,
        g,
        y,
        b,
        w = !n && r.hasListeners.remove;
        if (e.isModel) {
            e = [e];
            a = 1
        } else {
            if (Ext.isIterable(e)) {
                a = e.length
            } else {
                if (typeof e === "object") {
                    y = true;
                    u = e.start;
                    a = e.end + 1;
                    b = a - u
                }
            }
        }
        if (!y) {
            for (u = 0; u < a; ++u) {
                g = e[u];
                if (typeof g == "number") {
                    m = g;
                    g = o.getAt(m)
                } else {
                    m = r.indexOf(g)
                }
                if (g && m > -1) {
                    f.push({
                        record: g,
                        index: m
                    })
                }
                if (s) {
                    s.remove(g)
                }
            }
            f = Ext.Array.sort(f,
            function(e, t) {
                var n = e.index,
                r = t.index;
                return n === t.index2 ? 0 : n < r ? -1 : 1
            });
            u = 0;
            a = f.length
        }
        if (!a) {
            return
        }
        for (; u < a; u++) {
            if (y) {
                g = o.getAt(u);
                m = u
            } else {
                d = f[u];
                g = d.record;
                m = d.index
            }
            l.push(g);
            c.push(m);
            v = g.phantom !== true;
            if (!t && v) {
                g.removedFrom = m;
                r.removed.push(g)
            } else {
                if (p) {
                    h.push(g)
                }
            }
            g.unjoin(r);
            m -= u;
            i = i || v;
            if (!y) {
                o.removeAt(m);
                if (w) {
                    r.fireEvent("remove", r, g, m, !!t)
                }
            }
        }
        if (p) {
            r.updateGroupsOnRemove(r.removed.concat(h))
        }
        if (y) {
            o.removeRange(e.start, b)
        }
        if (!n) {
            r.fireEvent("bulkremove", r, l, c, !!t, y);
            r.fireEvent("datachanged", r)
        }
        if (!t && r.autoSync && i && !r.autoSyncSuspended) {
            r.sync()
        }
    },
    removeAt: function(e, t) {
        var n = this,
        r = n.getCount();
        e = Math.max(e, 0);
        if (e <= r) {
            if (arguments.length === 1) {
                n.remove([e])
            } else {
                if (t) {
                    n.remove({
                        start: e,
                        end: Math.min(e + t, r) - 1
                    })
                }
            }
        }
    },
    removeAll: function(e) {
        var t = this,
        n = t.snapshot,
        r = t.data;
        if (n) {
            n.removeAll(r.getRange())
        }
        if (t.buffered) {
            if (r) {
                if (e) {
                    t.suspendEvent("clear")
                }
                r.clear();
                if (e) {
                    t.resumeEvent("clear")
                }
            }
        } else {
            t.remove({
                start: 0,
                end: t.getCount() - 1
            },
            false, e);
            if (e !== true) {
                t.fireEvent("clear", t)
            }
        }
    },
    load: function(e) {
        var t = this;
        if (typeof e == "function") {
            e = {
                callback: e
            }
        } else {
            e = Ext.apply({},
            e)
        }
        if (t.remoteGroup && !e.groupers && t.groupers.items.length) {
            e.groupers = t.groupers.items
        }
        e.page = e.page || t.currentPage;
        e.start = e.start !== undefined ? e.start: (e.page - 1) * t.pageSize;
        e.limit = e.limit || t.pageSize;
        e.addRecords = e.addRecords || false;
        if (t.buffered) {
            e.limit = t.viewSize || t.defaultViewSize;
            e.loadCallback = e.callback;
            delete e.callback;
            return t.loadToPrefetch(e)
        }
        return t.callParent([e])
    },
    reload: function(e) {
        var t = this,
        n, r, i, s, o, u, a, f;
        if (!e) {
            e = {}
        }
        if (t.buffered) {
            delete t.totalCount;
            t.data.clear(true);
            u = function() {
                if (t.rangeCached(n, r)) {
                    t.loading = false;
                    t.data.un("pageAdded", u);
                    f = t.data.getRange(n, r);
                    t.fireEvent("load", t, f, true)
                }
            };
            a = Math.ceil((t.leadingBufferZone + t.trailingBufferZone) / 2);
            if (!t.lastRequestStart) {
                n = e.start || 0;
                r = n + (e.count || t.pageSize) - 1
            } else {
                n = t.lastRequestStart;
                r = t.lastRequestEnd
            }
            i = t.getPageFromRecordIndex(Math.max(n - a, 0));
            s = t.getPageFromRecordIndex(r + a);
            if (t.fireEvent("beforeload", t, e) !== false) {
                t.loading = true;
                t.data.on("pageAdded", u);
                for (o = i; o <= s; o++) {
                    t.prefetchPage(o, e)
                }
            }
        } else {
            return t.callParent(arguments)
        }
    },
    onProxyLoad: function(e) {
        var t = this,
        n = e.getResultSet(),
        r = e.getRecords(),
        i = e.wasSuccessful();
        if (t.isDestroyed) {
            return
        }
        if (n) {
            t.totalCount = n.total
        }
        t.loading = false;
        if (i) {
            Wb.autoLoadColumns(t.bindTable);
            t.loadRecords(r, e)
        }
        if (t.hasListeners.load) {
            t.fireEvent("load", t, r, i)
        }
        if (t.hasListeners.read) {
            t.fireEvent("read", t, r, i)
        }
        Ext.callback(e.callback, e.scope || t, [r, e, i])
    },
    getNewRecords: function() {
        return (this.snapshot || this.data).filterBy(this.filterNew).items
    },
    getUpdatedRecords: function() {
        return (this.snapshot || this.data).filterBy(this.filterUpdated).items
    },
    filter: function(e, t) {
        if (Ext.isString(e)) {
            e = {
                property: e,
                value: t
            }
        }
        var n = this,
        r = n.decodeFilters(e),
        i,
        s = n.sorters.length && n.sortOnFilter && !n.remoteSort,
        o = r.length;
        for (i = 0; i < o; i++) {
            n.filters.replace(r[i])
        }
        e = n.filters.items;
        if (e.length) {
            if (n.remoteFilter) {
                delete n.totalCount;
                if (n.buffered) {
                    n.data.clear();
                    n.loadPage(1)
                } else {
                    n.currentPage = 1;
                    n.load()
                }
            } else {
                n.snapshot = n.snapshot || n.data.clone();
                n.data = n.snapshot.filter(e);
                n.constructGroups();
                if (s) {
                    n.sort()
                } else {
                    n.fireEvent("datachanged", n);
                    n.fireEvent("refresh", n)
                }
            }
            n.fireEvent("filterchange", n, e)
        }
    },
    clearFilter: function(e) {
        var t = this;
        t.filters.clear();
        if (t.remoteFilter) {
            if (e) {
                return
            }
            delete t.totalCount;
            if (t.buffered) {
                t.data.clear();
                t.loadPage(1)
            } else {
                t.currentPage = 1;
                t.load()
            }
        } else {
            if (t.isFiltered()) {
                t.data = t.snapshot;
                delete t.snapshot;
                t.constructGroups();
                if (e !== true) {
                    t.fireEvent("datachanged", t);
                    t.fireEvent("refresh", t)
                }
            }
        }
        t.fireEvent("filterchange", t, t.filters.items)
    },
    removeFilter: function(e, t) {
        var n = this;
        if (!n.remoteFilter && n.isFiltered()) {
            if (e instanceof Ext.util.Filter) {
                n.filters.remove(e)
            } else {
                n.filters.removeAtKey(e)
            }
            if (t !== false) {
                if (n.filters.length) {
                    n.filter()
                } else {
                    n.clearFilter()
                }
            } else {
                n.fireEvent("filterchange", n, n.filters.items)
            }
        }
    },
    addFilter: function(e, t) {
        var n = this,
        r, i, s;
        r = n.decodeFilters(e);
        s = r.length;
        for (i = 0; i < s; i++) {
            n.filters.replace(r[i])
        }
        if (t !== false && n.filters.length) {
            n.filter()
        } else {
            n.fireEvent("filterchange", n, n.filters.items)
        }
    },
    isFiltered: function() {
        var e = this.snapshot;
        return !! (e && e !== this.data)
    },
    filterBy: function(e, t) {
        var n = this;
        n.snapshot = n.snapshot || n.data.clone();
        n.data = n.queryBy(e, t || n);
        n.fireEvent("datachanged", n);
        n.fireEvent("refresh", n)
    },
    queryBy: function(e, t) {
        var n = this;
        return (n.snapshot || n.data).filterBy(e, t || n)
    },
    query: function(e, t, n, r, i) {
        var s = this,
        o = s.createFilterFn(e, t, n, r, i),
        u = s.queryBy(o);
        if (!u) {
            u = new Ext.util.MixedCollection
        }
        return u
    },
    loadData: function(e, t) {
        var n = e.length,
        r = [],
        i;
        for (i = 0; i < n; i++) {
            r.push(this.createModel(e[i]))
        }
        this.loadRecords(r, t ? this.addRecordsOptions: undefined)
    },
    loadRawData: function(e, t) {
        var n = this,
        r = n.proxy.reader.read(e),
        i = r.records;
        if (r.success) {
            n.totalCount = r.total;
            n.loadRecords(i, t ? n.addRecordsOptions: undefined)
        }
    },
    loadRecords: function(e, t) {
        var n = this,
        r = 0,
        i = e.length,
        s, o, u = n.snapshot;
        if (t) {
            s = t.start;
            o = t.addRecords
        }
        if (!o) {
            delete n.snapshot;
            n.clearData(true)
        } else {
            if (u) {
                u.addAll(e)
            }
        }
        n.data.addAll(e);
        if (s !== undefined) {
            for (; r < i; r++) {
                e[r].index = s + r;
                e[r].join(n)
            }
        } else {
            for (; r < i; r++) {
                e[r].join(n)
            }
        }
        n.suspendEvents();
        if (n.filterOnLoad && !n.remoteFilter) {
            n.filter()
        }
        if (n.sortOnLoad && !n.remoteSort) {
            n.sort()
        }
        n.resumeEvents();
        if (n.isGrouped()) {
            n.constructGroups()
        }
        n.fireEvent("datachanged", n);
        n.fireEvent("refresh", n)
    },
    loadPage: function(e, t) {
        var n = this,
        r;
        n.currentPage = e;
        if (n.lastOptions) {
            r = Ext.apply({},
            n.lastOptions)
        } else {
            r = {}
        }
        t = Ext.apply(r, t, {
            page: e,
            start: (e - 1) * n.pageSize,
            limit: n.pageSize,
            addRecords: !n.clearOnPageLoad
        });
        if (n.buffered) {
            t.limit = n.viewSize || n.defaultViewSize;
            t.loadCallback = t.callback;
            delete t.callback;
            return n.loadToPrefetch(t)
        }
        n.read(t)
    },
    nextPage: function(e) {
        this.loadPage(this.currentPage + 1, e)
    },
    previousPage: function(e) {
        this.loadPage(this.currentPage - 1, e)
    },
    clearData: function(e, t) {
        var n = this,
        r, i;
        t = t || n.data;
        if (!n.buffered && t) {
            r = t.items;
            i = r.length;
            while (i--) {
                r[i].unjoin(n)
            }
        }
        if (t) {
            t.clear()
        }
        if (e !== true || n.clearRemovedOnLoad) {
            n.removed.length = 0
        }
    },
    destroyClear: function() {
        this.clearData(null, this.snapshot)
    },
    loadToPrefetch: function(e) {
        var t = this,
        n, r, i, s = e,
        o = e.start,
        u = e.start + e.limit - 1,
        a = Math.min(u, e.start + (t.viewSize || e.limit) - 1),
        f = t.getPageFromRecordIndex(Math.max(o - t.trailingBufferZone, 0)),
        l = t.getPageFromRecordIndex(u + t.leadingBufferZone),
        c = function() {
            if (t.rangeCached(o, a)) {
                t.loading = false;
                r = t.data.getRange(o, a);
                t.data.un("pageAdded", c);
                if (t.hasListeners.guaranteedrange) {
                    t.guaranteeRange(o, a, e.callback, e.scope)
                }
                if (e.loadCallback) {
                    e.loadCallback.call(e.scope || t, r, h, true)
                }
                if (e.callback) {
                    e.callback.call(e.scope || t, r, o, u, e)
                }
                Wb.autoLoadColumns(t.bindTable);
                t.fireEvent("datachanged", t);
                t.fireEvent("refresh", t);
                t.fireEvent("load", t, r, true);
                if (e.groupChange) {
                    t.fireGroupChange()
                }
            }
        },
        h;
        if (t.purgePageCount) {
            t.data.maxSize = t.purgePageCount = Math.max(t.purgePageCount, l - f + 1)
        }
        if (t.fireEvent("beforeload", t, e) !== false) {
            delete t.totalCount;
            t.loading = true;
            if (e.callback) {
                s = Ext.apply({},
                e);
                delete s.callback
            }
            t.on("prefetch",
            function(e, r, o, u) {
                if (o) {
                    h = u;
                    if (i = t.getTotalCount()) {
                        t.data.on("pageAdded", c);
                        a = Math.min(a, i - 1);
                        l = t.getPageFromRecordIndex(Math.min(a + t.leadingBufferZone, i - 1));
                        for (n = f + 1; n <= l; ++n) {
                            t.prefetchPage(n, s)
                        }
                    } else {
                        t.fireEvent("datachanged", t);
                        t.fireEvent("refresh", t);
                        t.fireEvent("load", t, r, true)
                    }
                } else {
                    t.fireEvent("load", t, r, false)
                }
            },
            null, {
                single: true
            });
            t.prefetchPage(f, s)
        }
    },
    prefetch: function(e) {
        var t = this,
        n = t.pageSize,
        r, i;
        if (n) {
            if (t.lastPageSize && n != t.lastPageSize) {
                Ext.Error.raise("pageSize cannot be dynamically altered")
            }
            if (!t.data.pageSize) {
                t.data.pageSize = n
            }
        } else {
            t.pageSize = t.data.pageSize = n = e.limit
        }
        t.lastPageSize = n;
        if (!e.page) {
            e.page = t.getPageFromRecordIndex(e.start);
            e.start = (e.page - 1) * n;
            e.limit = Math.ceil(e.limit / n) * n
        }
        if (!t.pageRequests[e.page]) {
            e = Ext.apply({
                action: "read",
                filters: t.filters.items,
                sorters: t.sorters.items,
                groupers: t.groupers.items,
                pageMapGeneration: t.data.pageMapGeneration
            },
            e);
            i = new Ext.data.Operation(e);
            if (t.fireEvent("beforeprefetch", t, i) !== false) {
                r = t.proxy;
                t.pageRequests[e.page] = r.read(i, t.onProxyPrefetch, t);
                if (r.isSynchronous) {
                    delete t.pageRequests[e.page]
                }
            }
        }
        return t
    },
    onPageMapClear: function() {
        var e = this,
        t = e.wasLoading,
        n = e.pageRequests,
        r, i;
        if (e.data.events.pageadded) {
            e.data.events.pageadded.clearListeners()
        }
        e.loading = true;
        e.totalCount = 0;
        for (i in n) {
            if (n.hasOwnProperty(i)) {
                r = n[i];
                delete n[i];
                delete r.callback
            }
        }
        e.fireEvent("clear", e);
        e.loading = t
    },
    prefetchPage: function(e, t) {
        var n = this,
        r = n.pageSize || n.defaultPageSize,
        i = (e - 1) * n.pageSize,
        s = n.totalCount;
        if (s !== undefined && n.getCount() === s) {
            return
        }
        n.prefetch(Ext.applyIf({
            page: e,
            start: i,
            limit: r
        },
        t))
    },
    onProxyPrefetch: function(e) {
        var t = this,
        n = e.getResultSet(),
        r = e.getRecords(),
        i = e.wasSuccessful(),
        s = e.page;
        if (e.pageMapGeneration === t.data.pageMapGeneration) {
            if (n) {
                t.totalCount = n.total;
                t.fireEvent("totalcountchange", t.totalCount)
            }
            if (s !== undefined) {
                delete t.pageRequests[s]
            }
            t.loading = false;
            t.fireEvent("prefetch", t, r, i, e);
            if (i) {
                t.cachePage(r, e.page)
            }
            Ext.callback(e.callback, e.scope || t, [r, e, i])
        }
    },
    cachePage: function(e, t) {
        var n = this,
        r = e.length,
        i;
        if (!Ext.isDefined(n.totalCount)) {
            n.totalCount = e.length;
            n.fireEvent("totalcountchange", n.totalCount)
        }
        for (i = 0; i < r; i++) {
            e[i].join(n)
        }
        n.data.addPage(t, e)
    },
    rangeCached: function(e, t) {
        return this.data && this.data.hasRange(e, t)
    },
    pageCached: function(e) {
        return this.data && this.data.hasPage(e)
    },
    pagePending: function(e) {
        return !! this.pageRequests[e]
    },
    rangeSatisfied: function(e, t) {
        return this.rangeCached(e, t)
    },
    getPageFromRecordIndex: function(e) {
        return Math.floor(e / this.pageSize) + 1
    },
    onGuaranteedRange: function(e) {
        var t = this,
        n = t.getTotalCount(),
        r = e.prefetchStart,
        i = e.prefetchEnd > n - 1 ? n - 1 : e.prefetchEnd,
        s;
        i = Math.max(0, i);
        s = t.data.getRange(r, i);
        if (e.fireEvent !== false) {
            t.fireEvent("guaranteedrange", s, r, i, e)
        }
        if (e.callback) {
            e.callback.call(e.scope || t, s, r, i, e)
        }
    },
    guaranteeRange: function(e, t, n, r, i) {
        i = Ext.apply({
            callback: n,
            scope: r
        },
        i);
        this.getRange(e, t, i)
    },
    prefetchRange: function(e, t) {
        var n = this,
        r, i, s;
        if (!n.rangeCached(e, t)) {
            r = n.getPageFromRecordIndex(e);
            i = n.getPageFromRecordIndex(t);
            n.data.maxSize = n.purgePageCount ? i - r + 1 + n.purgePageCount: 0;
            for (s = r; s <= i; s++) {
                if (!n.pageCached(s)) {
                    n.prefetchPage(s)
                }
            }
        }
    },
    primeCache: function(e, t, n) {
        var r = this;
        if (n === -1) {
            e = Math.max(e - r.leadingBufferZone, 0);
            t = Math.min(t + r.trailingBufferZone, r.totalCount - 1)
        } else {
            if (n === 1) {
                e = Math.max(Math.min(e - r.trailingBufferZone, r.totalCount - r.pageSize), 0);
                t = Math.min(t + r.leadingBufferZone, r.totalCount - 1)
            } else {
                e = Math.min(Math.max(Math.floor(e - (r.leadingBufferZone + r.trailingBufferZone) / 2), 0), r.totalCount - r.pageSize);
                t = Math.min(Math.max(Math.ceil(t + (r.leadingBufferZone + r.trailingBufferZone) / 2), 0), r.totalCount - 1)
            }
        }
        r.prefetchRange(e, t)
    },
    sort: function(e) {
        var t = this;
        if (e && t.buffered && t.remoteSort) {
            t.data.clear()
        }
        return t.callParent(arguments)
    },
    generateComparator: function() {
        var e = this,
        t = e.sorters.items,
        n = t.length,
        r = n ? e.groupers.getRange() : e.groupers.items,
        i,
        s,
        o;
        if (r.length) {
            for (i = 0; i < n; i++) {
                s = t[i];
                if (s.property && (o = e.groupers.get(s.property))) {
                    o.setDirection(s.direction)
                } else {
                    Ext.Array.push(r, s)
                }
            }
            t = r
        }
        return t.length ? this.createComparator(t) : this.emptyComparator
    },
    getSorterCount: function() {
        return this.groupers.items.length + this.sorters.items.length
    },
    doSort: function(e) {
        var t = this,
        n, r, i, s = function() {
            t.fireEvent("sort", t, t.sorters.getRange())
        };
        if (t.remoteSort) {
            if (t.buffered) {
                t.data.clear();
                t.loadPage(1, Ext.apply({
                    callback: s
                },
                t.lastOptions ? {
                    params: t.lastOptions.params
                }: null))
            } else {
                t.load(Ext.apply({
                    callback: s
                },
                t.lastOptions ? {
                    params: t.lastOptions.params
                }: null))
            }
        } else {
            t.data.sortBy(e);
            if (!t.buffered) {
                n = t.getRange();
                r = n.length;
                for (i = 0; i < r; i++) {
                    n[i].index = i
                }
            }
            t.fireEvent("datachanged", t);
            t.fireEvent("refresh", t);
            s()
        }
    },
    find: function(e, t, n, r, i, s) {
        var o = this.createFilterFn(e, t, r, i, s);
        return o ? this.data.findIndexBy(o, null, n) : -1
    },
    findRecord: function() {
        var e = this,
        t = e.find.apply(e, arguments);
        return t !== -1 ? e.getAt(t) : null
    },
    createFilterFn: function(e, t, n, r, i) {
        if (Ext.isEmpty(t)) {
            return false
        }
        t = Ext.util.AbstractMixedCollection.prototype.createValueMatcher(t, n, r, i);
        return function(n) {
            return t.test(n.data[e])
        }
    },
    findExact: function(e, t, n) {
        return this.data.findIndexBy(function(n) {
            return n.isEqual(n.get(e), t)
        },
        this, n)
    },
    findBy: function(e, t, n) {
        return this.data.findIndexBy(e, t, n)
    },
    collect: function(e, t, n) {
        var r = this,
        i = n === true && r.snapshot ? r.snapshot: r.data;
        return i.collect(e, "data", t)
    },
    getCount: function() {
        return this.data.getCount()
    },
    getTotalCount: function() {
        return this.totalCount || 0
    },
    getAt: function(e) {
        return this.data.getAt(e)
    },
    getRange: function(e, t, n) {
        var r = this,
        i, s, o = r.totalCount - 1,
        u = r.lastRequestStart,
        a = [],
        f;
        n = Ext.apply({
            prefetchStart: e,
            prefetchEnd: t
        },
        n);
        if (r.buffered) {
            t = t >= r.totalCount ? o: t;
            i = e === 0 ? 0 : e - 1;
            s = t === o ? t: t + 1;
            r.lastRequestStart = e;
            r.lastRequestEnd = t;
            if (r.rangeCached(i, s)) {
                r.onGuaranteedRange(n);
                a = r.data.getRange(e, t)
            } else {
                r.fireEvent("cachemiss", r, e, t);
                f = function(o, u) {
                    if (r.rangeCached(i, s)) {
                        r.fireEvent("cachefilled", r, e, t);
                        r.data.un("pageAdded", f);
                        r.onGuaranteedRange(n)
                    }
                };
                r.data.on("pageAdded", f);
                r.prefetchRange(e, t)
            }
            r.primeCache(e, t, e < u ? -1 : 1)
        } else {
            a = r.data.getRange(e, t);
            if (n.callback) {
                n.callback.call(n.scope || r, a, e, t, n)
            }
        }
        return a
    },
    getById: function(e) {
        var t = (this.snapshot || this.data).findBy(function(t) {
            return t.getId() === e
        });
        return t
    },
    getByInternalId: function(e) {
        var t;
        if (this.buffered) {
            t = (this.snapshot || this.data).findBy(function(t) {
                return t.internalId === e
            })
        } else {
            t = this.data.get(e)
        }
        return t
    },
    indexOf: function(e) {
        return this.data.indexOf(e)
    },
    indexOfTotal: function(e) {
        var t = e.index;
        if (t || t === 0) {
            return t
        }
        return this.indexOf(e)
    },
    indexOfId: function(e) {
        return this.indexOf(this.getById(e))
    },
    first: function(e) {
        var t = this;
        if (e && t.isGrouped()) {
            return t.aggregate(function(e) {
                return e.length ? e[0] : undefined
            },
            t, true)
        } else {
            return t.data.first()
        }
    },
    last: function(e) {
        var t = this;
        if (e && t.isGrouped()) {
            return t.aggregate(function(e) {
                var t = e.length;
                return t ? e[t - 1] : undefined
            },
            t, true)
        } else {
            return t.data.last()
        }
    },
    sum: function(e, t) {
        var n = this;
        if (t && n.isGrouped()) {
            return n.aggregate(n.getSum, n, true, [e])
        } else {
            return n.getSum(n.data.items, e)
        }
    },
    getSum: function(e, t) {
        var n = 0,
        r = 0,
        i = e.length;
        for (; r < i; ++r) {
            n += e[r].get(t)
        }
        return n
    },
    count: function(e) {
        var t = this;
        if (e && t.isGrouped()) {
            return t.aggregate(function(e) {
                return e.length
            },
            t, true)
        } else {
            return t.getCount()
        }
    },
    min: function(e, t) {
        var n = this;
        if (t && n.isGrouped()) {
            return n.aggregate(n.getMin, n, true, [e])
        } else {
            return n.getMin(n.data.items, e)
        }
    },
    getMin: function(e, t) {
        var n = 1,
        r = e.length,
        i, s;
        if (r > 0) {
            s = e[0].get(t)
        }
        for (; n < r; ++n) {
            i = e[n].get(t);
            if (i < s) {
                s = i
            }
        }
        return s
    },
    max: function(e, t) {
        var n = this;
        if (t && n.isGrouped()) {
            return n.aggregate(n.getMax, n, true, [e])
        } else {
            return n.getMax(n.data.items, e)
        }
    },
    getMax: function(e, t) {
        var n = 1,
        r = e.length,
        i, s;
        if (r > 0) {
            s = e[0].get(t)
        }
        for (; n < r; ++n) {
            i = e[n].get(t);
            if (i > s) {
                s = i
            }
        }
        return s
    },
    average: function(e, t) {
        var n = this;
        if (t && n.isGrouped()) {
            return n.aggregate(n.getAverage, n, true, [e])
        } else {
            return n.getAverage(n.data.items, e)
        }
    },
    getAverage: function(e, t) {
        var n = 0,
        r = e.length,
        i = 0;
        if (e.length > 0) {
            for (; n < r; ++n) {
                i += e[n].get(t)
            }
            return i / r
        }
        return 0
    },
    aggregate: function(e, t, n, r) {
        r = r || [];
        if (n && this.isGrouped()) {
            var i = this.getGroups(),
            s = i.length,
            o = {},
            u,
            a;
            for (a = 0; a < s; ++a) {
                u = i[a];
                o[u.name] = this.getAggregate(e, t || this, u.children, r)
            }
            return o
        } else {
            return this.getAggregate(e, t, this.data.items, r)
        }
    },
    getAggregate: function(e, t, n, r) {
        r = r || [];
        return e.apply(t || this, [n].concat(r))
    },
    onIdChanged: function(e, t, n, r) {
        var i = this.snapshot;
        if (i) {
            i.updateKey(r, n)
        }
        this.data.updateKey(r, n);
        this.callParent(arguments)
    },
    commitChanges: function() {
        var e = this,
        t = e.getModifiedRecords(),
        n = t.length,
        r = 0;
        for (; r < n; r++) {
            t[r].commit()
        }
        e.removed.length = 0
    },
    filterNewOnly: function(e) {
        return e.phantom === true
    },
    getRejectRecords: function() {
        return Ext.Array.push(this.data.filterBy(this.filterNewOnly).items, this.getUpdatedRecords())
    },
    rejectChanges: function() {
        var e = this,
        t = e.getRejectRecords(),
        n = t.length,
        r = 0,
        i;
        for (; r < n; r++) {
            i = t[r];
            i.reject();
            if (i.phantom) {
                e.remove(i)
            }
        }
        t = e.removed;
        n = t.length;
        for (r = n - 1; r >= 0; r--) {
            i = t[r];
            e.insert(i.removedFrom || 0, i);
            i.reject()
        }
        e.removed.length = 0
    }
},
function() {
    Ext.regStore("ext-empty-store", {
        fields: [],
        autoDestroy: false,
        proxy: "memory"
    })
});
Ext.define("Ext.data.reader.Array", {
    extend: Ext.data.reader.Json,
    alternateClassName: "Ext.data.ArrayReader",
    alias: "reader.array",
    totalProperty: undefined,
    successProperty: undefined,
    createFieldAccessExpression: function(e, t, n) {
        var r = e.mapping == null ? e.originalIndex: e.mapping,
        i;
        if (typeof r === "function") {
            i = t + ".mapping(" + n + ", this)"
        } else {
            if (isNaN(r)) {
                r = '"' + r + '"'
            }
            i = n + "[" + r + "]"
        }
        return i
    }
});
Ext.define("Ext.data.ArrayStore", {
    extend: Ext.data.Store,
    alias: "store.array",
    constructor: function(e) {
        e = Ext.apply({
            proxy: {
                type: "memory",
                reader: "array"
            }
        },
        e);
        this.callParent([e])
    },
    loadData: function(e, t) {
        if (this.expandData === true) {
            var n = [],
            r = 0,
            i = e.length;
            for (; r < i; r++) {
                n[n.length] = [e[r]]
            }
            e = n
        }
        this.callParent([e, t])
    }
},
function() {
    Ext.data.SimpleStore = Ext.data.ArrayStore
});
Ext.define("Ext.data.Batch", {
    mixins: {
        observable: Ext.util.Observable
    },
    autoStart: false,
    pauseOnException: false,
    current: -1,
    total: 0,
    isRunning: false,
    isComplete: false,
    hasException: false,
    constructor: function(e) {
        var t = this;
        t.mixins.observable.constructor.call(t, e);
        t.operations = [];
        t.exceptions = []
    },
    add: function(e) {
        this.total++;
        e.setBatch(this);
        this.operations.push(e);
        return this
    },
    start: function(e) {
        var t = this;
        if (t.isRunning) {
            return t
        }
        t.exceptions.length = 0;
        t.hasException = false;
        t.isRunning = true;
        return t.runOperation(Ext.isDefined(e) ? e: t.current + 1)
    },
    retry: function() {
        return this.start(this.current)
    },
    runNextOperation: function() {
        return this.runOperation(this.current + 1)
    },
    pause: function() {
        this.isRunning = false;
        return this
    },
    runOperation: function(e) {
        var t = this,
        n = t.operations,
        r = n[e],
        i;
        if (r === undefined) {
            t.isRunning = false;
            t.isComplete = true;
            t.fireEvent("complete", t, n[n.length - 1])
        } else {
            t.current = e;
            i = function(e) {
                var n = e.hasException();
                if (n) {
                    t.hasException = true;
                    t.exceptions.push(e);
                    t.fireEvent("exception", t, e)
                }
                if (n && t.pauseOnException) {
                    t.pause()
                } else {
                    e.setCompleted();
                    t.fireEvent("operationcomplete", t, e);
                    t.runNextOperation()
                }
            };
            r.setStarted();
            t.proxy[r.action](r, i, t)
        }
        return t
    }
});
Ext.define("Ext.data.BufferStore", {
    extend: Ext.data.Store,
    alias: "store.buffer",
    sortOnLoad: false,
    filterOnLoad: false,
    constructor: function() {
        Ext.Error.raise("The BufferStore class has been deprecated. Instead, specify the buffered config option on Ext.data.Store")
    }
});
Ext.define("Ext.direct.Manager", {
    singleton: true,
    mixins: {
        observable: Ext.util.Observable
    },
    exceptions: {
        TRANSPORT: "xhr",
        PARSE: "parse",
        DATA: "data",
        LOGIN: "login",
        SERVER: "exception"
    },
    constructor: function() {
        var e = this;
        e.addEvents("event", "exception");
        e.transactions = new Ext.util.MixedCollection;
        e.providers = new Ext.util.MixedCollection;
        e.mixins.observable.constructor.call(e)
    },
    addProvider: function(e) {
        var t = this,
        n = arguments,
        r = t.relayers || (t.relayers = {}),
        i,
        s;
        if (n.length > 1) {
            for (i = 0, s = n.length; i < s; ++i) {
                t.addProvider(n[i])
            }
            return
        }
        if (!e.isProvider) {
            e = Ext.create("direct." + e.type + "provider", e)
        }
        t.providers.add(e);
        e.on("data", t.onProviderData, t);
        if (e.relayedEvents) {
            r[e.id] = t.relayEvents(e, e.relayedEvents)
        }
        if (!e.isConnected()) {
            e.connect()
        }
        return e
    },
    getProvider: function(e) {
        return e.isProvider ? e: this.providers.get(e)
    },
    removeProvider: function(e) {
        var t = this,
        n = t.providers,
        r = t.relayers,
        i;
        e = e.isProvider ? e: n.get(e);
        if (e) {
            e.un("data", t.onProviderData, t);
            i = e.id;
            if (r[i]) {
                r[i].destroy();
                delete r[i]
            }
            n.remove(e);
            return e
        }
        return null
    },
    addTransaction: function(e) {
        this.transactions.add(e);
        return e
    },
    removeTransaction: function(e) {
        var t = this;
        e = t.getTransaction(e);
        t.transactions.remove(e);
        return e
    },
    getTransaction: function(e) {
        return typeof e === "object" ? e: this.transactions.get(e)
    },
    onProviderData: function(e, t) {
        var n = this,
        r, i;
        if (Ext.isArray(t)) {
            for (r = 0, i = t.length; r < i; ++r) {
                n.onProviderData(e, t[r])
            }
            return
        }
        if (t.name && t.name != "event" && t.name != "exception") {
            n.fireEvent(t.name, t)
        } else {
            if (t.status === false) {
                n.fireEvent("exception", t)
            }
        }
        n.fireEvent("event", t, e)
    },
    parseMethod: function(e) {
        if (Ext.isString(e)) {
            var t = e.split("."),
            n = 0,
            r = t.length,
            i = Ext.global;
            while (i && n < r) {
                i = i[t[n]]; ++n
            }
            e = Ext.isFunction(i) ? i: null
        }
        return e || null
    }
},
function() {
    Ext.Direct = Ext.direct.Manager
});
Ext.define("Ext.data.proxy.Direct", {
    extend: Ext.data.proxy.Server,
    alternateClassName: "Ext.data.DirectProxy",
    alias: "proxy.direct",
    paramOrder: undefined,
    paramsAsHash: true,
    directFn: undefined,
    paramOrderRe: /[\s,|]/,
    constructor: function(e) {
        var t = this,
        n;
        t.callParent(arguments);
        n = t.paramOrder;
        if (Ext.isString(n)) {
            t.paramOrder = n.split(t.paramOrderRe)
        }
    },
    resolveMethods: function() {
        var e = this,
        t = e.directFn,
        n = e.api,
        r = Ext.direct.Manager,
        i;
        if (t) {
            i = e.directFn = r.parseMethod(t);
            if (!Ext.isFunction(i)) {
                Ext.Error.raise("Cannot resolve directFn " + t)
            }
        } else {
            if (n) {
                for (t in n) {
                    if (n.hasOwnProperty(t)) {
                        i = n[t];
                        n[t] = r.parseMethod(i);
                        if (!Ext.isFunction(n[t])) {
                            Ext.Error.raise("Cannot resolve Direct api " + t + " method " + i)
                        }
                    }
                }
            }
        }
        e.methodsResolved = true
    },
    doRequest: function(e, t, n) {
        var r = this,
        i = r.getWriter(),
        s = r.buildRequest(e),
        o = s.params,
        u = [],
        a,
        f;
        if (!r.methodsResolved) {
            r.resolveMethods()
        }
        a = r.api[s.action] || r.directFn;
        if (e.allowWrite()) {
            s = i.write(s)
        }
        if (e.action == "read") {
            f = a.directCfg.method;
            u = f.getArgs(o, r.paramOrder, r.paramsAsHash)
        } else {
            u.push(s.jsonData)
        }
        Ext.apply(s, {
            args: u,
            directFn: a
        });
        u.push(r.createRequestCallback(s, e, t, n), r);
        a.apply(window, u);
        return s
    },
    applyEncoding: Ext.identityFn,
    createRequestCallback: function(e, t, n, r) {
        var i = this;
        return function(s, o) {
            i.processResponse(o.status, t, e, o, n, r)
        }
    },
    extractResponseData: function(e) {
        return Ext.isDefined(e.result) ? e.result: e.data
    },
    setException: function(e, t) {
        e.setException(t.message)
    },
    buildUrl: function() {
        return ""
    }
});
Ext.define("Ext.data.DirectStore", {
    extend: Ext.data.Store,
    alias: "store.direct",
    constructor: function(e) {
        e = Ext.apply({},
        e);
        if (!e.proxy) {
            var t = {
                type: "direct",
                reader: {
                    type: "json"
                }
            };
            Ext.copyTo(t, e, "paramOrder,paramsAsHash,directFn,api,simpleSortMode");
            Ext.copyTo(t.reader, e, "totalProperty,root,idProperty");
            e.proxy = t
        }
        this.callParent([e])
    }
});
Ext.define("Ext.data.JsonP", {
    singleton: true,
    requestCount: 0,
    requests: {},
    timeout: 3e4,
    disableCaching: false,
    disableCachingParam: "_dc",
    callbackKey: "callback",
    request: function(e) {
        e = Ext.apply({},
        e);
        var t = this,
        n = Ext.isDefined(e.disableCaching) ? e.disableCaching: t.disableCaching,
        r = e.disableCachingParam || t.disableCachingParam,
        i = ++t.requestCount,
        s = e.callbackName || "callback" + i,
        o = e.callbackKey || t.callbackKey,
        u = Ext.isDefined(e.timeout) ? e.timeout: t.timeout,
        a = Ext.apply({},
        e.params),
        f = e.url,
        l = Ext.name,
        c,
        h;
        if (n && !a[r]) {
            a[r] = Ext.Date.now()
        }
        e.params = a;
        a[o] = l + ".data.JsonP." + s;
        h = t.createScript(f, a, e);
        t.requests[i] = c = {
            url: f,
            params: a,
            script: h,
            id: i,
            scope: e.scope,
            success: e.success,
            failure: e.failure,
            callback: e.callback,
            callbackKey: o,
            callbackName: s
        };
        if (u > 0) {
            c.timeout = setTimeout(Ext.bind(t.handleTimeout, t, [c]), u)
        }
        t.setupErrorHandling(c);
        t[s] = Ext.bind(t.handleResponse, t, [c], true);
        t.loadScript(c);
        return c
    },
    abort: function(e) {
        var t = this,
        n = t.requests,
        r;
        if (e) {
            if (!e.id) {
                e = n[e]
            }
            t.handleAbort(e)
        } else {
            for (r in n) {
                if (n.hasOwnProperty(r)) {
                    t.abort(n[r])
                }
            }
        }
    },
    setupErrorHandling: function(e) {
        e.script.onerror = Ext.bind(this.handleError, this, [e])
    },
    handleAbort: function(e) {
        e.errorType = "abort";
        this.handleResponse(null, e)
    },
    handleError: function(e) {
        e.errorType = "error";
        this.handleResponse(null, e)
    },
    cleanupErrorHandling: function(e) {
        e.script.onerror = null
    },
    handleTimeout: function(e) {
        e.errorType = "timeout";
        this.handleResponse(null, e)
    },
    handleResponse: function(e, t) {
        var n = true;
        if (t.timeout) {
            clearTimeout(t.timeout)
        }
        delete this[t.callbackName];
        delete this.requests[t.id];
        this.cleanupErrorHandling(t);
        Ext.fly(t.script).remove();
        if (t.errorType) {
            n = false;
            Ext.callback(t.failure, t.scope, [t.errorType])
        } else {
            Ext.callback(t.success, t.scope, [e])
        }
        Ext.callback(t.callback, t.scope, [n, e, t.errorType]);
        Ext.EventManager.idleEvent.fire()
    },
    createScript: function(e, t, n) {
        var r = document.createElement("script");
        r.setAttribute("src", Ext.urlAppend(e, Ext.Object.toQueryString(t)));
        r.setAttribute("async", true);
        r.setAttribute("type", "text/javascript");
        return r
    },
    loadScript: function(e) {
        Ext.getHead().appendChild(e.script)
    }
});
Ext.define("Ext.data.proxy.JsonP", {
    extend: Ext.data.proxy.Server,
    alternateClassName: "Ext.data.ScriptTagProxy",
    alias: ["proxy.jsonp", "proxy.scripttag"],
    defaultWriterType: "base",
    callbackKey: "callback",
    recordParam: "records",
    autoAppendParams: true,
    constructor: function() {
        this.addEvents("exception");
        this.callParent(arguments)
    },
    doRequest: function(e, t, n) {
        var r = this,
        i = r.buildRequest(e),
        s = i.params;
        Ext.apply(i, {
            callbackKey: r.callbackKey,
            timeout: r.timeout,
            scope: r,
            disableCaching: false,
            callback: r.createRequestCallback(i, e, t, n)
        });
        if (r.autoAppendParams) {
            i.params = {}
        }
        i.jsonp = Ext.data.JsonP.request(i);
        i.params = s;
        e.setStarted();
        r.lastRequest = i;
        return i
    },
    createRequestCallback: function(e, t, n, r) {
        var i = this;
        return function(s, o, u) {
            delete i.lastRequest;
            i.processResponse(s, t, e, o, n, r)
        }
    },
    setException: function(e, t) {
        e.setException(e.request.jsonp.errorType)
    },
    buildUrl: function(e) {
        var t = this,
        n = t.callParent(arguments),
        r = e.records,
        i = t.getWriter(),
        s,
        o,
        u,
        a;
        if (i && e.operation.allowWrite()) {
            e = i.write(e)
        }
        s = e.params;
        o = s.filters,
        delete s.filters;
        if (o && o.length) {
            for (a = 0; a < o.length; a++) {
                u = o[a];
                if (u.value) {
                    s[u.property] = u.value
                }
            }
        }
        if ((!i || !i.encode) && Ext.isArray(r) && r.length > 0) {
            s[t.recordParam] = t.encodeRecords(r)
        }
        if (t.autoAppendParams) {
            n = Ext.urlAppend(n, Ext.Object.toQueryString(s))
        }
        return n
    },
    abort: function() {
        var e = this.lastRequest;
        if (e) {
            Ext.data.JsonP.abort(e.jsonp)
        }
    },
    encodeRecords: function(e) {
        var t = [],
        n = 0,
        r = e.length;
        for (; n < r; n++) {
            t.push(Ext.encode(e[n].getData()))
        }
        return t
    }
});
Ext.define("Ext.data.JsonPStore", {
    extend: Ext.data.Store,
    alias: "store.jsonp",
    constructor: function(e) {
        e = Ext.apply({
            proxy: {
                type: "jsonp",
                reader: "json"
            }
        },
        e);
        this.callParent([e])
    }
});
Ext.define("Ext.data.JsonStore", {
    extend: Ext.data.Store,
    alias: "store.json",
    constructor: function(e) {
        e = Ext.apply({
            proxy: {
                type: "ajax",
                reader: "json",
                writer: "json"
            }
        },
        e);
        this.callParent([e])
    }
});
Ext.define("Ext.data.NodeInterface", {
    statics: {
        decorate: function(e) {
            var t, n, r;
            if (typeof e == "string") {
                e = Ext.ModelManager.getModel(e)
            } else {
                if (e.isModel) {
                    e = Ext.ModelManager.getModel(e.modelName)
                }
            }
            if (e.prototype.isNode) {
                return
            }
            t = e.prototype.idProperty;
            n = e.prototype.fields.get(t);
            r = e.prototype.fields.get(t).type.type;
            e.override(this.getPrototypeBody());
            this.applyFields(e, [{
                name: "parentId",
                type: r,
                defaultValue: null,
                useNull: n.useNull
            },
            {
                name: "index",
                type: "int",
                defaultValue: -1,
                persist: false,
                convert: null
            },
            {
                name: "depth",
                type: "int",
                defaultValue: 0,
                persist: false,
                convert: null
            },
            {
                name: "expanded",
                type: "bool",
                defaultValue: false,
                persist: false,
                convert: null
            },
            {
                name: "expandable",
                type: "bool",
                defaultValue: true,
                persist: false,
                convert: null
            },
            {
                name: "checked",
                type: "auto",
                defaultValue: null,
                persist: false,
                convert: null
            },
            {
                name: "leaf",
                type: "bool",
                defaultValue: false
            },
            {
                name: "cls",
                type: "string",
                defaultValue: "",
                persist: false,
                convert: null
            },
            {
                name: "iconCls",
                type: "string",
                defaultValue: "",
                persist: false,
                convert: null
            },
            {
                name: "icon",
                type: "string",
                defaultValue: "",
                persist: false,
                convert: null
            },
            {
                name: "root",
                type: "boolean",
                defaultValue: false,
                persist: false,
                convert: null
            },
            {
                name: "isLast",
                type: "boolean",
                defaultValue: false,
                persist: false,
                convert: null
            },
            {
                name: "isFirst",
                type: "boolean",
                defaultValue: false,
                persist: false,
                convert: null
            },
            {
                name: "allowDrop",
                type: "boolean",
                defaultValue: true,
                persist: false,
                convert: null
            },
            {
                name: "allowDrag",
                type: "boolean",
                defaultValue: true,
                persist: false,
                convert: null
            },
            {
                name: "loaded",
                type: "boolean",
                defaultValue: false,
                persist: false,
                convert: null
            },
            {
                name: "loading",
                type: "boolean",
                defaultValue: false,
                persist: false,
                convert: null
            },
            {
                name: "href",
                type: "string",
                defaultValue: "",
                persist: false,
                convert: null
            },
            {
                name: "hrefTarget",
                type: "string",
                defaultValue: "",
                persist: false,
                convert: null
            },
            {
                name: "qtip",
                type: "string",
                defaultValue: "",
                persist: false,
                convert: null
            },
            {
                name: "qtitle",
                type: "string",
                defaultValue: "",
                persist: false,
                convert: null
            },
            {
                name: "qshowDelay",
                type: "int",
                defaultValue: 0,
                persist: false,
                convert: null
            },
            {
                name: "children",
                type: "auto",
                defaultValue: null,
                persist: false,
                convert: null
            },
            {
                name: "visible",
                type: "boolean",
                defaultValue: true,
                persist: false,
                convert: null
            }])
        },
        applyFields: function(e, t) {
            var n = e.prototype,
            r = n.fields,
            i = r.keys,
            s = t.length,
            o, u;
            for (u = 0; u < s; u++) {
                o = t[u];
                if (!Ext.Array.contains(i, o.name)) {
                    r.add(new Ext.data.Field(o))
                }
            }
        },
        getPrototypeBody: function() {
            var e = {
                idchanged: true,
                append: true,
                remove: true,
                bulkremove: true,
                move: true,
                insert: true,
                beforeappend: true,
                beforeremove: true,
                beforemove: true,
                beforeinsert: true,
                expand: true,
                collapse: true,
                beforeexpand: true,
                beforecollapse: true,
                sort: true,
                rootchange: true
            };
            return {
                isNode: true,
                constructor: function() {
                    var e = this;
                    e.callParent(arguments);
                    e.firstChild = e.lastChild = e.parentNode = e.previousSibling = e.nextSibling = null;
                    e.childNodes = [];
                    return e
                },
                createNode: function(e) {
                    var t = this;
                    if (!e.isModel) {
                        e = new this.self(e)
                    }
                    if (!e.childNodes) {
                        e.firstChild = e.lastChild = e.parentNode = e.previousSibling = e.nextSibling = null;
                        e.childNodes = []
                    }
                    return e
                },
                isLeaf: function() {
                    return this.get("leaf") === true
                },
                setFirstChild: function(e) {
                    this.firstChild = e
                },
                setLastChild: function(e) {
                    this.lastChild = e
                },
                updateInfo: function(e, t) {
                    var n = this,
                    r = n.data.depth,
                    i = {},
                    s = n.childNodes,
                    o = s.length,
                    u, a = n.phantom,
                    f = n[n.persistenceProperty],
                    l = n.fields,
                    c = n.modified,
                    h,
                    p,
                    d,
                    v,
                    m,
                    g = t.parentId,
                    y,
                    b;
                    if (!t) {
                        Ext.Error.raise("NodeInterface expects update info to be passed")
                    }
                    for (h in t) {
                        d = l.get(h);
                        p = t[h];
                        b = d && d.persist;
                        v = f[h];
                        y = b && h === "index" && v !== -1 && g && g !== c.parentId;
                        if (!y && n.isEqual(v, p)) {
                            continue
                        }
                        f[h] = p;
                        if (b) {
                            if (!y && c.hasOwnProperty(h)) {
                                if (n.isEqual(c[h], p)) {
                                    delete c[h];
                                    n.dirty = false;
                                    for (m in c) {
                                        if (c.hasOwnProperty(m)) {
                                            n.dirty = true;
                                            break
                                        }
                                    }
                                }
                            } else {
                                n.dirty = true;
                                c[h] = v
                            }
                        }
                    }
                    if (e) {
                        n.commit();
                        n.phantom = a
                    }
                    if (n.data.depth !== r) {
                        i = {
                            depth: n.data.depth + 1
                        };
                        for (u = 0; u < o; u++) {
                            s[u].updateInfo(e, i)
                        }
                    }
                },
                isLast: function() {
                    return this.get("isLast")
                },
                isFirst: function() {
                    return this.get("isFirst")
                },
                hasChildNodes: function() {
                    return ! this.isLeaf() && this.childNodes.length > 0
                },
                isExpandable: function() {
                    var e = this;
                    if (e.get("expandable")) {
                        return ! (e.isLeaf() || e.isLoaded() && !e.phantom && !e.hasChildNodes())
                    }
                    return false
                },
                triggerUIUpdate: function() {
                    this.afterEdit([])
                },
                appendChild: function(e, t, n) {
                    var r = this,
                    i, s, o, u, a, f = {
                        isLast: true,
                        parentId: r.getId(),
                        depth: (r.data.depth || 0) + 1
                    };
                    if (Ext.isArray(e)) {
                        r.callStore("suspendAutoSync");
                        for (i = 0, s = e.length - 1; i < s; i++) {
                            r.appendChild(e[i], t, n)
                        }
                        r.callStore("resumeAutoSync");
                        r.appendChild(e[s], t, n)
                    } else {
                        e = r.createNode(e);
                        if (t !== true && r.fireEventArgs("beforeappend", [r, e]) === false) {
                            return false
                        }
                        o = r.childNodes.length;
                        u = e.parentNode;
                        if (u) {
                            if (t !== true && e.fireEventArgs("beforemove", [e, u, r, o]) === false) {
                                return false
                            }
                            u.removeChild(e, false, false, true)
                        }
                        if (Ext.suspendLayouts) {
                            Ext.suspendLayouts()
                        }
                        o = r.childNodes.length;
                        if (o === 0) {
                            r.setFirstChild(e)
                        }
                        r.childNodes[o] = e;
                        e.parentNode = r;
                        e.nextSibling = null;
                        r.setLastChild(e);
                        a = r.childNodes[o - 1];
                        if (a) {
                            e.previousSibling = a;
                            a.nextSibling = e;
                            a.updateInfo(n, {
                                isLast: false
                            });
                            a.triggerUIUpdate()
                        } else {
                            e.previousSibling = null
                        }
                        f.isFirst = o === 0;
                        f.index = o;
                        e.updateInfo(n, f);
                        if (r.isLeaf()) {
                            r.set("leaf", false)
                        }
                        if (!r.isLoaded()) {
                            r.set("loaded", true)
                        } else {
                            if (r.childNodes.length === 1) {
                                r.triggerUIUpdate()
                            }
                        }
                        if (o && r.childNodes[o - 1].isExpanded()) {
                            r.childNodes[o - 1].cascadeBy(r.triggerUIUpdate)
                        }
                        if (Ext.resumeLayouts) {
                            Ext.resumeLayouts(true)
                        }
                        if (t !== true) {
                            r.fireEventArgs("append", [r, e, o]);
                            if (u) {
                                e.fireEventArgs("move", [e, u, r, o])
                            }
                        }
                        r.callStore("onNodeAdded", e, o);
                        return e
                    }
                },
                getOwnerTree: function() {
                    var e = this,
                    t;
                    while (e.parentNode) {
                        e = e.parentNode
                    }
                    t = e.store;
                    if (t) {
                        if (t.treeStore) {
                            t = t.treeStore
                        }
                        if (t.tree) {
                            return t.ownerTree
                        }
                    }
                    return undefined
                },
                getTreeStore: function() {
                    var e = this.stores[0];
                    return e.treeStore || e
                },
                removeChild: function(e, t, n, r) {
                    var i = this,
                    s = i.indexOf(e),
                    o,
                    u,
                    a,
                    f;
                    if (s === -1 || n !== true && i.fireEventArgs("beforeremove", [i, e, !!r]) === false) {
                        return false
                    }
                    if (Ext.suspendLayouts) {
                        Ext.suspendLayouts()
                    }
                    a = e.getOwnerTree();
                    if (a && a.selModel) {
                        a.selModel.deselect(e, true)
                    }
                    Ext.Array.erase(i.childNodes, s, 1);
                    if (i.firstChild === e) {
                        i.setFirstChild(e.nextSibling)
                    }
                    if (i.lastChild === e) {
                        i.setLastChild(e.previousSibling)
                    }
                    f = e.previousSibling;
                    if (f) {
                        e.previousSibling.nextSibling = e.nextSibling
                    }
                    if (e.nextSibling) {
                        e.nextSibling.previousSibling = e.previousSibling;
                        if (s === 0) {
                            e.nextSibling.updateInfo(false, {
                                isFirst: true
                            })
                        }
                        for (o = s, u = i.childNodes.length; o < u; o++) {
                            i.childNodes[o].updateInfo(false, {
                                index: o
                            })
                        }
                    } else {
                        if (f) {
                            f.updateInfo(false, {
                                isLast: true
                            });
                            if (f.isExpanded()) {
                                f.cascadeBy(i.triggerUIUpdate)
                            } else {
                                f.triggerUIUpdate()
                            }
                        }
                    }
                    if (!i.childNodes.length) {
                        i.triggerUIUpdate()
                    }
                    if (Ext.resumeLayouts) {
                        Ext.resumeLayouts(true)
                    }
                    if (n !== true) {
                        e.removeContext = {
                            parentNode: e.parentNode,
                            previousSibling: e.previousSibling,
                            nextSibling: e.nextSibling
                        };
                        e.previousSibling = e.nextSibling = e.parentNode = null;
                        i.fireEventArgs("remove", [i, e, !!r]);
                        i.callStore("onNodeRemove", e, !!r);
                        e.removeContext = null
                    }
                    if (t) {
                        e.destroy(true)
                    } else {
                        e.clear()
                    }
                    return e
                },
                copy: function(e, t) {
                    var n = this,
                    r = n.callParent(arguments),
                    i = n.childNodes ? n.childNodes.length: 0,
                    s;
                    if (t) {
                        for (s = 0; s < i; s++) {
                            r.appendChild(n.childNodes[s].copy(undefined, true))
                        }
                    }
                    r.phantom = false;
                    return r
                },
                clear: function(e) {
                    var t = this;
                    t.parentNode = t.previousSibling = t.nextSibling = null;
                    if (e) {
                        t.firstChild = t.lastChild = null
                    }
                },
                destroy: function(e) {
                    var t = this,
                    n = t.destroyOptions,
                    r = t.childNodes,
                    i = r.length,
                    s;
                    if (e === true) {
                        t.clear(true);
                        for (s = 0; s < i; s++) {
                            r[s].destroy(true)
                        }
                        t.childNodes = null;
                        delete t.destroyOptions;
                        t.callParent([n])
                    } else {
                        t.destroyOptions = e;
                        t.remove(true)
                    }
                },
                insertBefore: function(e, t, n) {
                    var r = this,
                    i = r.indexOf(t),
                    s = e.parentNode,
                    o = i,
                    u,
                    a,
                    f;
                    if (!t) {
                        return r.appendChild(e)
                    }
                    if (e === t) {
                        return false
                    }
                    e = r.createNode(e);
                    if (n !== true && r.fireEventArgs("beforeinsert", [r, e, t]) === false) {
                        return false
                    }
                    if (s === r && r.indexOf(e) < i) {
                        o--
                    }
                    if (s) {
                        if (n !== true && e.fireEventArgs("beforemove", [e, s, r, i, t]) === false) {
                            return false
                        }
                        s.removeChild(e, false, false, true)
                    }
                    if (o === 0) {
                        r.setFirstChild(e)
                    }
                    Ext.Array.splice(r.childNodes, o, 0, e);
                    e.parentNode = r;
                    e.nextSibling = t;
                    t.previousSibling = e;
                    a = r.childNodes[o - 1];
                    if (a) {
                        e.previousSibling = a;
                        a.nextSibling = e
                    } else {
                        e.previousSibling = null
                    }
                    e.updateInfo(false, {
                        parentId: r.getId(),
                        index: o,
                        isFirst: o === 0,
                        isLast: false,
                        depth: (r.data.depth || 0) + 1
                    });
                    for (f = o + 1, u = r.childNodes.length; f < u; f++) {
                        r.childNodes[f].updateInfo(false, {
                            index: f
                        })
                    }
                    if (!r.isLoaded()) {
                        r.set("loaded", true)
                    } else {
                        if (r.childNodes.length === 1) {
                            r.triggerUIUpdate()
                        }
                    }
                    if (n !== true) {
                        r.fireEventArgs("insert", [r, e, t]);
                        if (s) {
                            e.fireEventArgs("move", [e, s, r, o, t])
                        }
                    }
                    r.callStore("onNodeAdded", e, t);
                    return e
                },
                insertChild: function(e, t) {
                    var n = this.childNodes[e];
                    if (n) {
                        return this.insertBefore(t, n)
                    } else {
                        return this.appendChild(t)
                    }
                },
                remove: function(e, t) {
                    var n = this,
                    r = n.parentNode;
                    if (r) {
                        r.removeChild(n, e, t)
                    } else {
                        if (e) {
                            n.destroy(true)
                        }
                    }
                    return n
                },
                removeAll: function(e, t, n) {
                    var r = this,
                    i = r.childNodes,
                    s = 0,
                    o = i.length,
                    u;
                    if (!o) {
                        return
                    }
                    r.fireEventArgs("bulkremove", [r, i, false]);
                    for (; s < o; ++s) {
                        u = i[s];
                        u.removeContext = {
                            parentNode: u.parentNode,
                            previousSibling: u.previousSibling,
                            nextSibling: u.nextSibling
                        };
                        u.previousSibling = u.nextSibling = u.parentNode = null;
                        r.fireEventArgs("remove", [r, u, false]);
                        r.callStore("onNodeRemove", u, false);
                        u.removeContext = null;
                        if (e) {
                            u.destroy(true)
                        } else {
                            u.removeAll(false, t, true)
                        }
                    }
                    r.firstChild = r.lastChild = null;
                    if (n) {
                        r.childNodes = null
                    } else {
                        r.childNodes.length = 0;
                        r.triggerUIUpdate()
                    }
                    return r
                },
                getChildAt: function(e) {
                    return this.childNodes[e]
                },
                replaceChild: function(e, t, n) {
                    var r = t ? t.nextSibling: null;
                    this.removeChild(t, false, n);
                    this.insertBefore(e, r, n);
                    return t
                },
                indexOf: function(e) {
                    return Ext.Array.indexOf(this.childNodes, e)
                },
                indexOfId: function(e) {
                    var t = this.childNodes,
                    n = t.length,
                    r = 0;
                    for (; r < n; ++r) {
                        if (t[r].getId() === e) {
                            return r
                        }
                    }
                    return - 1
                },
                getPath: function(e, t) {
                    e = e || this.idProperty;
                    t = t || "/";
                    var n = [this.get(e)],
                    r = this.parentNode;
                    while (r) {
                        n.unshift(r.get(e));
                        r = r.parentNode
                    }
                    return t + n.join(t)
                },
                getDepth: function() {
                    return this.get("depth")
                },
                bubble: function(e, t, n) {
                    var r = this;
                    while (r) {
                        if (e.apply(t || r, n || [r]) === false) {
                            break
                        }
                        r = r.parentNode
                    }
                },
                cascade: function() {
                    if (Ext.isDefined(Ext.global.console)) {
                        Ext.global.console.warn("Ext.data.Node: cascade has been deprecated. Please use cascadeBy instead.")
                    }
                    return this.cascadeBy.apply(this, arguments)
                },
                cascadeBy: function(e, t, n, r) {
                    var i = this;
                    if (arguments.length === 1 && !Ext.isFunction(e)) {
                        r = e.after;
                        t = e.scope;
                        n = e.args;
                        e = e.before
                    }
                    if (!e || e.apply(t || i, n || [i]) !== false) {
                        var s = i.childNodes,
                        o = s.length,
                        u;
                        for (u = 0; u < o; u++) {
                            s[u].cascadeBy.call(s[u], e, t, n, r)
                        }
                        if (r) {
                            r.apply(t || i, n || [i])
                        }
                    }
                },
                eachChild: function(e, t, n) {
                    var r = this.childNodes,
                    i = r.length,
                    s;
                    for (s = 0; s < i; s++) {
                        if (e.apply(t || this, n || [r[s]]) === false) {
                            break
                        }
                    }
                },
                findChild: function(e, t, n) {
                    return this.findChildBy(function() {
                        return this.get(e) == t
                    },
                    null, n)
                },
                findChildBy: function(e, t, n) {
                    var r = this.childNodes,
                    i = r.length,
                    s = 0,
                    o, u;
                    for (; s < i; s++) {
                        o = r[s];
                        if (e.call(t || o, o) === true) {
                            return o
                        } else {
                            if (n) {
                                u = o.findChildBy(e, t, n);
                                if (u !== null) {
                                    return u
                                }
                            }
                        }
                    }
                    return null
                },
                contains: function(e) {
                    return e.isAncestor(this)
                },
                isAncestor: function(e) {
                    var t = this.parentNode;
                    while (t) {
                        if (t === e) {
                            return true
                        }
                        t = t.parentNode
                    }
                    return false
                },
                sort: function(e, t, n) {
                    var r = this,
                    i = r.childNodes,
                    s = i.length,
                    o, u, a = {
                        isFirst: true
                    };
                    if (s > 0) {
                        if (!e) {
                            e = r.getTreeStore().generateComparator()
                        }
                        Ext.Array.sort(i, e);
                        r.setFirstChild(i[0]);
                        r.setLastChild(i[s - 1]);
                        for (o = 0; o < s; o++) {
                            u = i[o];
                            u.previousSibling = i[o - 1];
                            u.nextSibling = i[o + 1];
                            a.isLast = o === s - 1;
                            a.index = o;
                            u.updateInfo(false, a);
                            a.isFirst = false;
                            if (t && !u.isLeaf()) {
                                u.sort(e, true, true)
                            }
                        }
                        if (n !== true) {
                            r.fireEventArgs("sort", [r, i]);
                            r.callStore("onNodeSort", i)
                        }
                    }
                },
                isExpanded: function() {
                    return this.get("expanded")
                },
                isLoaded: function() {
                    return this.get("loaded")
                },
                isLoading: function() {
                    return this.get("loading")
                },
                isRoot: function() {
                    return ! this.parentNode
                },
                isVisible: function() {
                    var e = this.parentNode;
                    while (e) {
                        if (!e.isExpanded()) {
                            return false
                        }
                        e = e.parentNode
                    }
                    return true
                },
                expand: function(e, t, n) {
                    var r = this;
                    if (!r.isLeaf()) {
                        if (r.isLoading()) {
                            r.on("expand",
                            function() {
                                r.expand(e, t, n)
                            },
                            r, {
                                single: true
                            })
                        } else {
                            if (!r.isExpanded()) {
                                r.fireEventArgs("beforeexpand", [r]);
                                r.callStore("onBeforeNodeExpand", r.onChildNodesAvailable, r, [e, t, n])
                            } else {
                                if (e) {
                                    r.expandChildren(true, t, n)
                                } else {
                                    Ext.callback(t, n || r, [r.childNodes])
                                }
                            }
                        }
                    } else {
                        Ext.callback(t, n || r)
                    }
                },
                onChildNodesAvailable: function(e, t, n, r) {
                    var i = this;
                    if (Ext.suspendLayouts) {
                        Ext.suspendLayouts()
                    }
                    i.set("expanded", true);
                    i.fireEventArgs("expand", [i, i.childNodes, false]);
                    if (t) {
                        i.expandChildren(true, n, r)
                    } else {
                        Ext.callback(n, r || i, [i.childNodes])
                    }
                    if (Ext.resumeLayouts) {
                        Ext.resumeLayouts(true)
                    }
                },
                expandChildren: function(e, t, n, r) {
                    var i = this,
                    s, o, u, a, f, l;
                    if (Ext.isBoolean(t)) {
                        s = t;
                        t = n;
                        n = r;
                        r = s
                    }
                    if (r === undefined) {
                        r = i.getTreeStore().singleExpand
                    }
                    u = i.childNodes;
                    a = [];
                    f = r ? Math.min(u.length, 1) : u.length;
                    for (o = 0; o < f; ++o) {
                        l = u[o];
                        if (!l.isLeaf()) {
                            a[a.length] = l
                        }
                    }
                    f = a.length;
                    for (o = 0; o < f; ++o) {
                        a[o].expand(e)
                    }
                    if (t) {
                        Ext.callback(t, n || i, [i.childNodes])
                    }
                },
                collapse: function(e, t, n) {
                    var r = this,
                    i = r.isExpanded(),
                    s = r.childNodes.length,
                    o,
                    u;
                    if (!r.isLeaf() && (!i && e || r.fireEventArgs("beforecollapse", [r]) !== false)) {
                        if (Ext.suspendLayouts) {
                            Ext.suspendLayouts()
                        }
                        if (r.isExpanded()) {
                            if (e) {
                                u = function() {
                                    for (o = 0; o < s; o++) {
                                        r.childNodes[o].setCollapsed(true)
                                    }
                                };
                                if (t) {
                                    t = Ext.Function.createSequence(u, t)
                                } else {
                                    t = u
                                }
                            }
                            r.set("expanded", false);
                            r.fireEventArgs("collapse", [r, r.childNodes, false, t ? Ext.Function.bind(t, n, [r.childNodes]) : null, null]);
                            t = null
                        } else {
                            if (e) {
                                for (o = 0; o < s; o++) {
                                    r.childNodes[o].setCollapsed(true)
                                }
                            }
                        }
                        if (Ext.resumeLayouts) {
                            Ext.resumeLayouts(true)
                        }
                    }
                    Ext.callback(t, n || r, [r.childNodes])
                },
                setCollapsed: function(e) {
                    var t = this,
                    n = t.childNodes.length,
                    r;
                    if (!t.isLeaf() && t.fireEventArgs("beforecollapse", [t, Ext.emptyFn]) !== false) {
                        t.data.expanded = false;
                        t.fireEventArgs("collapse", [t, t.childNodes, false, null, null]);
                        if (e) {
                            for (r = 0; r < n; r++) {
                                t.childNodes[r].setCollapsed(true)
                            }
                        }
                    }
                },
                collapseChildren: function(e, t, n) {
                    var r = this,
                    i, s = r.childNodes,
                    o = s.length,
                    u = [],
                    a;
                    for (i = 0; i < o; ++i) {
                        a = s[i];
                        if (!a.isLeaf() && a.isLoaded() && a.isExpanded()) {
                            u.push(a)
                        }
                    }
                    o = u.length;
                    if (o) {
                        for (i = 0; i < o; ++i) {
                            a = u[i];
                            if (i === o - 1) {
                                a.collapse(e, t, n)
                            } else {
                                a.collapse(e)
                            }
                        }
                    } else {
                        Ext.callback(t, n)
                    }
                },
                fireEventArgs: function(t, n) {
                    var r = Ext.data.Model.prototype.fireEventArgs,
                    i, s, o, u, f;
                    if (e[t]) {
                        for (s = this; i !== false && s; s = (f = s).parentNode) {
                            if (s.hasListeners[t]) {
                                i = r.call(s, t, n)
                            }
                        }
                        o = f.rootOf;
                        if (i !== false && o) {
                            u = o.treeStore;
                            if (u && u.hasListeners[t]) {
                                i = u.fireEventArgs.call(u, t, n)
                            }
                            if (i !== false && o.hasListeners[t]) {
                                i = o.fireEventArgs.call(o, t, n)
                            }
                        }
                        return i
                    } else {
                        return r.apply(this, arguments)
                    }
                },
                serialize: function() {
                    var e = Ext.data.writer.Json.prototype.getRecordData(this),
                    t = this.childNodes,
                    n = t.length,
                    r,
                    i;
                    if (n > 0) {
                        r = [];
                        for (i = 0; i < n; i++) {
                            r.push(t[i].serialize())
                        }
                        e.children = r
                    }
                    return e
                }
            }
        }
    }
});
Ext.define("Ext.data.NodeStore", {
    extend: Ext.data.Store,
    alias: "store.node",
    isNodeStore: true,
    node: null,
    recursive: false,
    rootVisible: false,
    isExpandingOrCollapsing: 0,
    constructor: function(e) {
        var t = this,
        n;
        e = e || {};
        Ext.apply(t, e);
        e.proxy = {
            type: "proxy"
        };
        t.callParent([e]);
        n = t.node;
        if (n) {
            t.node = null;
            t.setNode(n)
        }
    },
    getTotalCount: function() {
        return this.getCount()
    },
    setNode: function(e) {
        var t = this;
        if (t.node && t.node != e) {
            t.mun(t.node, {
                expand: t.onNodeExpand,
                collapse: t.onNodeCollapse,
                append: t.onNodeAppend,
                insert: t.onNodeInsert,
                bulkremove: t.onBulkRemove,
                remove: t.onNodeRemove,
                sort: t.onNodeSort,
                filterchange: t.onNodeFilter,
                scope: t
            });
            t.node = null
        }
        if (e) {
            Ext.data.NodeInterface.decorate(e.self);
            t.removeAll();
            if (t.rootVisible) {
                t.add(e)
            } else {
                if (!e.isExpanded() && t.treeStore.autoLoad !== false) {
                    e.expand()
                }
            }
            t.mon(e, {
                expand: t.onNodeExpand,
                collapse: t.onNodeCollapse,
                append: t.onNodeAppend,
                insert: t.onNodeInsert,
                bulkremove: t.onBulkRemove,
                remove: t.onNodeRemove,
                sort: t.onNodeSort,
                filterchange: t.onNodeFilter,
                scope: t
            });
            t.node = e;
            if (e.isExpanded() && e.isLoaded()) {
                t.onNodeExpand(e, e.childNodes, true)
            }
        }
    },
    onNodeFilter: function(e, t) {
        var n = this,
        r = [];
        this.data.clear();
        n.handleNodeExpand(e, t, r);
        this.data.addAll(r);
        this.fireEvent("refresh", this)
    },
    onNodeSort: function(e, t) {
        var n = this;
        if (n.indexOf(e) !== -1 || e === n.node && !n.rootVisible && e.isExpanded()) {
            Ext.suspendLayouts();
            n.onNodeCollapse(e, t, true);
            n.onNodeExpand(e, t, true);
            Ext.resumeLayouts(true)
        }
    },
    onNodeExpand: function(e, t, n) {
        var r = this,
        i = r.indexOf(e) + 1,
        s = [];
        if (!n) {
            r.fireEvent("beforeexpand", e, t, i)
        }
        r.handleNodeExpand(e, t, s);
        r.insert(i, s);
        if (!n) {
            r.fireEvent("expand", e, t)
        }
    },
    handleNodeExpand: function(e, t, n) {
        var r = this,
        i = t ? t.length: 0,
        s,
        o;
        if (!r.recursive && e !== r.node) {
            return
        }
        if (e !== this.node && !r.isVisible(e)) {
            return
        }
        if (i) {
            for (s = 0; s < i; s++) {
                o = t[s];
                if (o.get("visible")) {
                    n.push(o);
                    if (o.isExpanded()) {
                        if (o.isLoaded()) {
                            r.handleNodeExpand(o, o.childNodes, n)
                        } else {
                            o.set("expanded", false);
                            o.expand()
                        }
                    }
                }
            }
        }
    },
    onBulkRemove: function(e, t, n) {
        this.onNodeCollapse(e, t, true)
    },
    onNodeCollapse: function(e, t, n, r, i) {
        var s = this,
        o = s.indexOf(e) + 1,
        u,
        a,
        f,
        l;
        if (!s.recursive && e !== s.node) {
            return
        }
        if (e.store.filterFn) {
            t = Ext.Array.filter(t, s.filterVisible)
        }
        if (!n) {
            s.fireEvent("beforecollapse", e, t, o, r, i)
        }
        if (t.length && s.data.contains(t[0])) {
            u = e;
            while (u.parentNode) {
                for (f = u.nextSibling; f && !f.get("visible"); f = f.nextSibling) {}
                if (f) {
                    l = true;
                    a = s.indexOf(f);
                    break
                } else {
                    u = u.parentNode
                }
            }
            if (!l) {
                a = s.getCount()
            }
            s.removeAt(o, a - o)
        }
        if (!n) {
            s.fireEvent("collapse", e, t, o)
        }
    },
    onNodeAppend: function(e, t, n) {
        var r = this,
        i, s;
        if (r.isVisible(t)) {
            if (n === 0) {
                i = e
            } else {
                for (s = t.previousSibling; s && !s.get("visible"); s = s.previousSibling) {}
                while (s.isExpanded() && s.lastChild) {
                    s = s.lastChild
                }
                i = s
            }
            r.insert(r.indexOf(i) + 1, t);
            if (!t.isLeaf() && t.isExpanded()) {
                if (t.isLoaded()) {
                    r.onNodeExpand(t, t.childNodes, true)
                } else {
                    if (!r.treeStore.fillCount) {
                        t.set("expanded", false);
                        t.join(r.treeStore);
                        t.expand()
                    }
                }
            }
        }
    },
    onNodeInsert: function(e, t, n) {
        var r = this,
        i = this.indexOf(n);
        if (i !== -1 && r.isVisible(t)) {
            r.insert(i, t);
            if (!t.isLeaf() && t.isExpanded()) {
                if (t.isLoaded()) {
                    r.onNodeExpand(t, t.childNodes, true)
                } else {
                    t.set("expanded", false);
                    t.join(r.treeStore);
                    t.expand()
                }
            }
        }
    },
    onNodeRemove: function(e, t, n) {
        var r = this;
        if (r.indexOf(t) != -1) {
            if (!t.isLeaf() && t.isExpanded()) {
                t.parentNode = t.removeContext.parentNode;
                t.nextSibling = t.removeContext.nextSibling;
                r.onNodeCollapse(t, t.childNodes, true);
                t.parentNode = t.nextSibling = null
            }
            r.remove(t)
        }
    },
    filterVisible: function(e) {
        return e.get("visible")
    },
    isVisible: function(e) {
        if (e.get("visible")) {
            var t = e.parentNode;
            while (t) {
                if (t === this.node && t.data.expanded) {
                    return true
                }
                if (!t.data.expanded) {
                    return false
                }
                t = t.parentNode
            }
        }
        return false
    }
});
Ext.define("Ext.data.Request", {
    action: undefined,
    params: undefined,
    method: "POST",
    url: undefined,
    constructor: function(e) {
        Ext.apply(this, e)
    }
});
Ext.define("Ext.data.SequentialIdGenerator", {
    extend: Ext.data.IdGenerator,
    alias: "idgen.sequential",
    constructor: function() {
        var e = this;
        e.callParent(arguments);
        e.parts = [e.prefix, ""]
    },
    prefix: "",
    seed: 1,
    generate: function() {
        var e = this,
        t = e.parts;
        t[1] = e.seed++;
        return t.join("")
    }
});
Ext.define("Ext.data.Tree", {
    alias: "data.tree",
    mixins: {
        observable: Ext.util.Observable
    },
    root: null,
    constructor: function(e) {
        var t = this;
        t.mixins.observable.constructor.call(t);
        if (e) {
            t.setRootNode(e)
        }
        t.on({
            scope: t,
            idchanged: t.onNodeIdChanged,
            insert: t.onNodeInsert,
            append: t.onNodeAppend,
            remove: t.onNodeRemove
        })
    },
    getRootNode: function() {
        return this.root
    },
    setRootNode: function(e) {
        var t = this;
        t.root = e;
        if (e.rootOf) {
            e.rootOf.removeRootNode()
        } else {
            if (e.parentNode) {
                e.parentNode.removeChild(e)
            }
        }
        e.rootOf = t;
        if (e.fireEventArgs("beforeappend", [null, e]) !== false) {
            e.set("root", true);
            e.updateInfo(true, {
                isFirst: true,
                isLast: true,
                depth: 0,
                index: 0,
                parentId: null
            });
            t.nodeHash = {};
            e.fireEvent("append", null, e);
            e.fireEvent("rootchange", e)
        }
        return e
    },
    removeRootNode: function() {
        var e = this,
        t = e.root;
        t.set("root", false);
        t.fireEvent("remove", null, t, false);
        t.fireEvent("rootchange", null);
        t.rootOf = e.root = null;
        return t
    },
    flatten: function() {
        return Ext.Object.getValues(this.nodeHash)
    },
    onNodeInsert: function(e, t) {
        this.registerNode(t, true)
    },
    onNodeAppend: function(e, t) {
        this.registerNode(t, true)
    },
    onNodeRemove: function(e, t) {
        this.unregisterNode(t, true)
    },
    onNodeIdChanged: function(e, t, n, r) {
        var i = this.nodeHash;
        delete i[t || r];
        i[n] = e
    },
    getNodeById: function(e) {
        return this.nodeHash[e]
    },
    registerNode: function(e, t) {
        var n = this,
        r, i, s;
        n.nodeHash[e.getId() || e.internalId] = e;
        if (t === true) {
            r = e.childNodes;
            i = r.length;
            for (s = 0; s < i; s++) {
                n.registerNode(r[s], true)
            }
        }
    },
    unregisterNode: function(e, t) {
        var n = this,
        r, i, s;
        delete n.nodeHash[e.getId() || e.internalId];
        if (t === true) {
            r = e.childNodes;
            i = r.length;
            for (s = 0; s < i; s++) {
                n.unregisterNode(r[s], true)
            }
        }
    },
    sort: function(e, t) {
        this.getRootNode().sort(e, t)
    },
    filter: function(e, t) {
        this.getRootNode().filter(e, t)
    }
});
Ext.define("Ext.data.TreeModel", {
    extend: Ext.data.Model,
    mixins: {
        queryable: Ext.Queryable
    },
    getRefItems: function() {
        return this.childNodes
    },
    getRefOwner: function() {
        return this.parentNode
    }
},
function() {
    Ext.data.NodeInterface.decorate(this)
});
Ext.define("Ext.data.TreeStore", {
    extend: Ext.data.AbstractStore,
    alias: "store.tree",
    clearOnLoad: true,
    clearRemovedOnLoad: true,
    nodeParam: "node",
    defaultRootId: "root",
    defaultRootText: "Root",
    defaultRootProperty: "children",
    fillCount: 0,
    folderSort: false,
    constructor: function(e) {
        var t = this,
        n, r, i;
        e = Ext.apply({},
        e);
        r = e.fields || t.fields;
        i = e.model || t.model;
        if (!i) {
            if (!r) {
                r = [{
                    name: "text",
                    type: "string"
                }]
            }
            if (t.defaultRootProperty !== t.self.prototype.defaultRootProperty) {
                r.push({
                    name: t.defaultRootProperty,
                    type: "auto",
                    defaultValue: null,
                    persist: false
                })
            }
            e.model = Ext.define(null, {
                extend: "Ext.data.TreeModel",
                fields: r,
                proxy: t.proxy || t.defaultProxyType
            });
            delete t.fields;
            t.implicitModel = true
        }
        t.callParent([e]);
        t.tree = new Ext.data.Tree;
        t.tree.treeStore = t;
        t.onBeforeSort();
        n = t.root;
        if (n) {
            delete t.root;
            t.setRootNode(n)
        }
        if (Ext.isDefined(t.nodeParameter)) {
            if (Ext.isDefined(Ext.global.console)) {
                Ext.global.console.warn("Ext.data.TreeStore: nodeParameter has been deprecated. Please use nodeParam instead.")
            }
            t.nodeParam = t.nodeParameter;
            delete t.nodeParameter
        }
        t.mon(t, "load",
        function(e, t, n, r) {
            if (r) {
                e.fireEvent("success", e, t, n)
            } else {
                e.fireEvent("failure", e, t, n)
            }
        })
    },
    setProxy: function(e) {
        var t, n;
        if (e instanceof Ext.data.proxy.Proxy) {
            n = Ext.isEmpty(e.getReader().root)
        } else {
            if (Ext.isString(e)) {
                n = true
            } else {
                t = e.reader;
                n = !(t && !Ext.isEmpty(t.root))
            }
        }
        e = this.callParent(arguments);
        e.idParam = this.nodeParam;
        if (n) {
            t = e.getReader();
            t.root = this.defaultRootProperty;
            t.buildExtractors(true)
        }
        return e
    },
    filter: function(e, t) {
        if (Ext.isString(e)) {
            e = {
                property: e,
                value: t
            }
        }
        var n = this,
        r = n.decodeFilters(e),
        i,
        s = r.length,
        o = n.getRootNode(),
        u;
        for (i = 0; i < s; i++) {
            n.filters.replace(r[i])
        }
        e = n.filters.items;
        if (e.length) {
            u = [];
            n.filterFn = Ext.util.Filter.createFilterFn(e);
            o.cascadeBy({
                after: function(e) {
                    e.set("visible", n.filterFn(e))
                }
            });
            for (i = 0, s = o.childNodes.length; i < s; i++) {
                if (o.childNodes[i].get("visible")) {
                    u.push(o.childNodes[i])
                }
            }
            n.fireEvent("datachanged", n);
            n.fireEvent("refresh", n)
        } else {
            u = o.childNodes
        }
        o.fireEvent("filterchange", o, u);
        n.fireEvent("filterchange", n, e)
    },
    clearFilter: function() {
        var e = this,
        t = e.getRootNode();
        e.filters.clear();
        e.filterFn = null;
        t.cascadeBy(function(e) {
            e.set("visible", true)
        });
        t.fireEvent("filterchange", t, t.childNodes);
        e.fireEvent("filterchange", e, [])
    },
    onBeforeSort: function() {
        if (this.folderSort) {
            this.sort({
                property: "leaf",
                direction: "ASC"
            },
            "prepend", false)
        }
    },
    onBeforeNodeExpand: function(e, t, n, r) {
        var i = this,
        s = i.proxy.getReader(),
        o,
        u;
        if (e.isLoaded()) {
            u = [e.childNodes];
            if (r) {
                u.push.apply(u, r)
            }
            Ext.callback(t, n || e, u)
        } else {
            if (e.isLoading()) {
                i.on("load",
                function() {
                    u = [e.childNodes];
                    if (r) {
                        u.push.apply(u, r)
                    }
                    Ext.callback(t, n || e, u)
                },
                i, {
                    single: true,
                    priority: 1001
                })
            } else {
                o = s.getRoot(e.raw || e[e.persistenceProperty]);
                if (o || e.phantom) {
                    if (o) {
                        i.fillNode(e, s.extractData(o))
                    }
                    u = [e.childNodes];
                    if (r) {
                        u.push.apply(u, r)
                    }
                    Ext.callback(t, n || e, u)
                } else {
                    i.read({
                        node: e,
                        internalCallback: function() {
                            delete i.lastOptions.internalCallback;
                            u = [e.childNodes];
                            if (r) {
                                u.push.apply(u, r)
                            }
                            Ext.callback(t, n || e, u)
                        }
                    })
                }
            }
        }
    },
    getNewRecords: function() {
        return Ext.Array.filter(this.tree.flatten(), this.filterNew)
    },
    getUpdatedRecords: function() {
        return Ext.Array.filter(this.tree.flatten(), this.filterUpdated)
    },
    onNodeRemove: function(e, t, n) {
        var r = this;
        t.unjoin(r);
        if (!t.phantom && !n && !r.loading) {
            Ext.Array.include(r.removed, t)
        }
        if (r.autoSync && !r.autoSyncSuspended && !n) {
            r.sync()
        }
    },
    onNodeAdded: function(e, t) {
        var n = this,
        r = n.proxy.getReader(),
        i = t.raw || t[t.persistenceProperty],
        s,
        o;
        if (n.filterFn) {
            o = n.filterFn(t);
            t.set("visible", o);
            if (o) {
                e.set("visible", n.filterFn(e))
            }
        }
        Ext.Array.remove(n.removed, t);
        t.join(n);
        if (!t.isLeaf() && !t.isLoaded() && !n.lazyFill) {
            s = r.getRoot(i);
            if (s) {
                n.fillNode(t, r.extractData(s))
            }
        }
        if (n.autoSync && !n.autoSyncSuspended && (t.phantom || t.dirty)) {
            n.sync()
        }
    },
    onNodeSort: function() {
        if (this.autoSync && !this.autoSyncSuspended) {
            this.sync()
        }
    },
    setRootNode: function(e, t) {
        var n = this,
        r = n.model,
        i = r.prototype.idProperty;
        if (!r.prototype.isNode) {
            Ext.data.NodeInterface.decorate(r)
        }
        if (!e || !e.isNode) {
            e = Ext.apply({
                id: n.defaultRootId,
                text: n.defaultRootText,
                allowDrag: false
            },
            e);
            if (e[i] === undefined) {
                e[i] = n.defaultRootId
            }
            e = Ext.ModelManager.create(e, r)
        }
        n.getProxy().getReader().buildExtractors(true);
        n.onNodeAdded(null, e);
        n.tree.setRootNode(e);
        if (t !== true && !e.isLoaded() && (n.autoLoad === true || e.isExpanded())) {
            e.data.expanded = false;
            e.expand()
        }
        return e
    },
    getRootNode: function() {
        return this.tree.getRootNode()
    },
    getNodeById: function(e) {
        return this.tree.getNodeById(e)
    },
    getById: function(e) {
        return this.getNodeById(e)
    },
    load: function(e) {
        e = e || {};
        e.params = e.params || {};
        var t = this,
        n = e.node || t.tree.getRootNode(),
        r = e.callback,
        i = e.scope,
        s,
        o;
        if (!n) {
            n = t.setRootNode({
                expanded: true
            },
            true)
        }
        if (n.isRoot()) {
            s = n.getOwnerTree();
            if (s && !s.rootVisible) {
                n.data.expanded = true
            }
        }
        if (n.data.expanded) {
            n.data.loaded = false;
            if (t.clearOnLoad) {
                n.data.expanded = false
            }
            e.callback = function(e, s, o) {
                if (!t.clearOnLoad) {
                    n.collapse()
                }
                if (o) {
                    n.expand()
                }
                Ext.callback(r, i, arguments)
            }
        }
        if (e.out) {
            e.params = Wb.apply(Wb.getValue(e.out), e.params)
        }
        e.id = n.getId();
        e = Ext.apply({
            action: "read",
            filters: t.filters.items,
            sorters: t.getSorters(),
            node: e.node || n
        },
        e);
        t.lastOptions = e;
        o = new Ext.data.Operation(e);
        if (t.fireEvent("beforeload", t, o) !== false) {
            t.loading = true;
            if (t.clearOnLoad) {
                if (t.clearRemovedOnLoad) {
                    t.clearRemoved(n)
                }
                n.removeAll(false)
            }
            t.proxy.read(o, t.onProxyLoad, t)
        }
        if (t.loading && n) {
            n.set("loading", true)
        }
        return t
    },
    clearRemoved: function(e) {
        var t = this,
        n = t.removed,
        r = e.id,
        i = n.length,
        s = i,
        o = {},
        u = [],
        a = {},
        f,
        l,
        c;
        if (e === t.getRootNode()) {
            t.removed = [];
            return
        }
        for (; s--;) {
            f = n[s];
            a[f.id] = f
        }
        for (s = i; s--;) {
            f = n[s];
            l = f;
            while (l && l.id !== r) {
                c = l.get("parentId");
                l = l.parentNode || t.getNodeById(c) || a[c]
            }
            if (l) {
                o[f.id] = f
            }
        }
        for (s = 0; s < i; s++) {
            f = n[s];
            if (!o[f.id]) {
                u.push(f)
            }
        }
        t.removed = u
    },
    fillNode: function(e, t) {
        var n = this,
        r = t ? t.length: 0,
        i = n.sorters,
        s,
        o,
        u = false,
        a = n.sortOnLoad && !n.remoteSort && i && i.items && i.items.length,
        f,
        l,
        c;
        if (r) {
            if (n.filterFn) {
                t[0].set("visible", n.filterFn(t[0]))
            }
            for (s = 1; ! u && s < r; s++) {
                f = t[s];
                l = t[s - 1];
                if (n.filterFn) {
                    f.set("visible", n.filterFn(f))
                }
                u = f[f.persistenceProperty].index !== l[l.persistenceProperty].index
            }
            if (a) {
                if (u) {
                    n.sorters.insert(0, n.indexSorter)
                }
                o = new Ext.util.MixedCollection;
                o.addAll(t);
                o.sort(n.sorters.items);
                t = o.items;
                n.sorters.remove(n.indexSorter)
            } else {
                if (u) {
                    Ext.Array.sort(t, n.sortByIndex)
                }
            }
        }
        e.set("loaded", true);
        c = n.fillCount === 0;
        if (c) {
            n.fireEvent("beforefill", n, e, t)
        }++n.fillCount;
        if (t.length) {
            e.appendChild(t, undefined, true)
        }
        if (c) {
            n.fireEvent("fillcomplete", n, e, t)
        }--n.fillCount;
        return t
    },
    sortByIndex: function(e, t) {
        return e[e.persistenceProperty].index - t[t.persistenceProperty].index
    },
    onIdChanged: function(e, t, n, r) {
        this.tree.onNodeIdChanged(e, t, n, r);
        this.callParent(arguments)
    },
    onProxyLoad: function(e) {
        var t = this,
        n = e.wasSuccessful(),
        r = e.getRecords(),
        i = e.node,
        s = e.scope || t,
        o = [r, e, n];
        t.loading = false;
        i.set("loading", false);
        if (n) {
            if (!t.clearOnLoad) {
                r = t.cleanRecords(i, r)
            }
            r = t.fillNode(i, r)
        }
        Ext.callback(e.internalCallback, s, o);
        t.fireEvent("read", t, e.node, r, n);
        t.fireEvent("load", t, e.node, r, n);
        Ext.callback(e.callback, s, o)
    },
    cleanRecords: function(e, t) {
        var n = {},
        r = e.childNodes,
        i = 0,
        s = r.length,
        o = [],
        u;
        for (; i < s; ++i) {
            n[r[i].getId()] = true
        }
        for (i = 0, s = t.length; i < s; ++i) {
            u = t[i];
            if (!n[u.getId()]) {
                o.push(u)
            }
        }
        return o
    },
    removeAll: function() {
        var e = this.getRootNode();
        if (e) {
            e.destroy(true)
        }
        this.fireEvent("clear", this)
    },
    doSort: function(e) {
        var t = this;
        if (t.remoteSort) {
            t.load()
        } else {
            t.tree.sort(e, true);
            t.fireEvent("datachanged", t);
            t.fireEvent("refresh", t)
        }
        t.fireEvent("sort", t, t.sorters.getRange())
    }
},
function() {
    var e = this.prototype;
    e.indexSorter = new Ext.util.Sorter({
        sorterFn: e.sortByIndex
    })
});
Ext.define("Ext.data.UuidGenerator",
function() {
    function i(e, t) {
        var n = e.toString(16);
        if (n.length > t) {
            n = n.substring(n.length - t)
        } else {
            if (n.length < t) {
                n = Ext.String.leftPad(n, t, "0")
            }
        }
        return n
    }
    function s(e, t) {
        var n = Math.random() * (t - e + 1);
        return Math.floor(n) + e
    }
    function o(e) {
        if (typeof e == "number") {
            var t = Math.floor(e / r);
            return {
                lo: Math.floor(e - t * r),
                hi: t
            }
        }
        return e
    }
    var e = Math.pow(2, 14),
    t = Math.pow(2, 16),
    n = Math.pow(2, 28),
    r = Math.pow(2, 32);
    return {
        extend: Ext.data.IdGenerator,
        alias: "idgen.uuid",
        id: "uuid",
        version: 4,
        constructor: function() {
            var e = this;
            e.callParent(arguments);
            e.parts = [];
            e.init()
        },
        generate: function() {
            var e = this,
            t = e.parts,
            n = e.timestamp;
            t[0] = i(n.lo, 8);
            t[1] = i(n.hi & 65535, 4);
            t[2] = i(n.hi >>> 16 & 4095 | e.version << 12, 4);
            t[3] = i(128 | e.clockSeq >>> 8 & 63, 2) + i(e.clockSeq & 255, 2);
            t[4] = i(e.salt.hi, 4) + i(e.salt.lo, 8);
            if (e.version == 4) {
                e.init()
            } else {++n.lo;
                if (n.lo >= r) {
                    n.lo = 0; ++n.hi
                }
            }
            return t.join("-").toLowerCase()
        },
        getRecId: function(e) {
            return e.getId()
        },
        init: function() {
            var i = this,
            u, a;
            if (i.version == 4) {
                i.clockSeq = s(0, e - 1);
                u = i.salt || (i.salt = {});
                a = i.timestamp || (i.timestamp = {});
                u.lo = s(0, r - 1);
                u.hi = s(0, t - 1);
                a.lo = s(0, r - 1);
                a.hi = s(0, n - 1)
            } else {
                i.salt = o(i.salt);
                i.timestamp = o(i.timestamp);
                i.salt.hi |= 256
            }
        },
        reconfigure: function(e) {
            Ext.apply(this, e);
            this.init()
        }
    }
} ());
Ext.define("Ext.data.reader.Xml", {
    extend: Ext.data.reader.Reader,
    alternateClassName: "Ext.data.XmlReader",
    alias: "reader.xml",
    createAccessor: function(e) {
        var t = this;
        if (Ext.isEmpty(e)) {
            return Ext.emptyFn
        }
        if (Ext.isFunction(e)) {
            return e
        }
        return function(n) {
            return t.getNodeValue(Ext.DomQuery.selectNode(e, n))
        }
    },
    getNodeValue: function(e) {
        if (e) {
            if (typeof e.normalize === "function") {
                e.normalize()
            }
            e = e.firstChild;
            if (e) {
                return e.nodeValue
            }
        }
        return undefined
    },
    getResponseData: function(e) {
        var t = e.responseXML,
        n, r;
        if (!t) {
            r = "XML data not found in the response";
            n = new Ext.data.ResultSet({
                total: 0,
                count: 0,
                records: [],
                success: false,
                message: r
            });
            this.fireEvent("exception", this, e, n);
            Ext.Logger.warn(r);
            return n
        }
        return this.readRecords(t)
    },
    getData: function(e) {
        return e.documentElement || e
    },
    getRoot: function(e) {
        var t = e.nodeName,
        n = this.root;
        if (!n || t && t == n) {
            return e
        } else {
            if (Ext.DomQuery.isXml(e)) {
                return Ext.DomQuery.selectNode(n, e)
            }
        }
    },
    extractData: function(e) {
        var t = this.record;
        if (t != e.nodeName) {
            e = Ext.DomQuery.select(t, e)
        } else {
            e = [e]
        }
        return this.callParent([e])
    },
    getAssociatedDataRoot: function(e, t) {
        return Ext.DomQuery.select(t, e)[0]
    },
    readRecords: function(e) {
        if (Ext.isArray(e)) {
            e = e[0]
        }
        this.xmlData = e;
        return this.callParent([e])
    },
    createFieldAccessExpression: function(e, t, n) {
        var r = this.namespace,
        i, s;
        i = e.mapping || (r ? r + "|": "") + e.name;
        if (typeof i === "function") {
            s = t + ".mapping(" + n + ", this)"
        } else {
            s = 'me.getNodeValue(Ext.DomQuery.selectNode("' + i + '", ' + n + "))"
        }
        return s
    }
});
Ext.define("Ext.data.writer.Xml", {
    extend: Ext.data.writer.Writer,
    alternateClassName: "Ext.data.XmlWriter",
    alias: "writer.xml",
    documentRoot: "xmlData",
    defaultDocumentRoot: "xmlData",
    header: "",
    record: "record",
    writeRecords: function(e, t) {
        var n = this,
        r = [],
        i = 0,
        s = t.length,
        o = n.documentRoot,
        u = n.record,
        a = t.length !== 1,
        f,
        l;
        r.push(n.header || "");
        if (!o && a) {
            o = n.defaultDocumentRoot
        }
        if (o) {
            r.push("<", o, ">")
        }
        for (; i < s; ++i) {
            f = t[i];
            r.push("<", u, ">");
            for (l in f) {
                if (f.hasOwnProperty(l)) {
                    r.push("<", l, ">", f[l], "</", l, ">")
                }
            }
            r.push("</", u, ">")
        }
        if (o) {
            r.push("</", o, ">")
        }
        e.xmlData = r.join("");
        return e
    }
});
Ext.define("Ext.data.XmlStore", {
    extend: Ext.data.Store,
    alias: "store.xml",
    constructor: function(e) {
        e = Ext.apply({
            proxy: {
                type: "ajax",
                reader: "xml",
                writer: "xml"
            }
        },
        e);
        this.callParent([e])
    }
});
Ext.define("Ext.data.amf.Encoder", {
    alias: "data.amf.Encoder",
    config: {
        format: 3
    },
    bytes: [],
    constructor: function(e) {
        this.initConfig(e);
        this.clear()
    },
    clear: function() {
        this.bytes = []
    },
    applyFormat: function(e) {
        var t = {
            0 : {
                writeUndefined: this.write0Undefined,
                writeNull: this.write0Null,
                writeBoolean: this.write0Boolean,
                writeNumber: this.write0Number,
                writeString: this.write0String,
                writeXml: this.write0Xml,
                writeDate: this.write0Date,
                writeArray: this.write0Array,
                writeGenericObject: this.write0GenericObject
            },
            3 : {
                writeUndefined: this.write3Undefined,
                writeNull: this.write3Null,
                writeBoolean: this.write3Boolean,
                writeNumber: this.write3Number,
                writeString: this.write3String,
                writeXml: this.write3Xml,
                writeDate: this.write3Date,
                writeArray: this.write3Array,
                writeGenericObject: this.write3GenericObject
            }
        } [e];
        if (t) {
            Ext.apply(this, t);
            return e
        } else {
            return
        }
    },
    writeObject: function(e) {
        var t = typeof e;
        if (t === "undefined") {
            this.writeUndefined()
        } else {
            if (e === null) {
                this.writeNull()
            } else {
                if (Ext.isBoolean(e)) {
                    this.writeBoolean(e)
                } else {
                    if (Ext.isString(e)) {
                        this.writeString(e)
                    } else {
                        if (t === "number" || e instanceof Number) {
                            this.writeNumber(e)
                        } else {
                            if (t === "object") {
                                if (e instanceof Date) {
                                    this.writeDate(e)
                                } else {
                                    if (Ext.isArray(e)) {
                                        this.writeArray(e)
                                    } else {
                                        if (this.isXmlDocument(e)) {
                                            this.writeXml(e)
                                        } else {
                                            this.writeGenericObject(e)
                                        }
                                    }
                                }
                            } else {}
                        }
                    }
                }
            }
        }
    },
    write3Undefined: function() {
        this.writeByte(0)
    },
    write0Undefined: function() {
        this.writeByte(6)
    },
    write3Null: function() {
        this.writeByte(1)
    },
    write0Null: function() {
        this.writeByte(5)
    },
    write3Boolean: function(e) {
        if (e) {
            this.writeByte(3)
        } else {
            this.writeByte(2)
        }
    },
    write0Boolean: function(e) {
        this.writeByte(1);
        if (e) {
            this.writeByte(1)
        } else {
            this.writeByte(0)
        }
    },
    encode29Int: function(e) {
        var t = [],
        n = e,
        r,
        i;
        if (n == 0) {
            return [0]
        }
        if (n > 2097151) {
            r = n & 255;
            t.unshift(r);
            n = n >> 8
        }
        while (n > 0) {
            r = n & 127;
            t.unshift(r);
            n = n >> 7
        }
        for (i = 0; i < t.length - 1; i++) {
            t[i] = t[i] | 128
        }
        return t
    },
    write3Number: function(e) {
        var t;
        var n = 536870911,
        r = -268435455;
        if (e instanceof Number) {
            e = e.valueOf()
        }
        if (e % 1 === 0 && e >= r && e <= n) {
            e = e & n;
            t = this.encode29Int(e);
            t.unshift(4);
            this.writeBytes(t)
        } else {
            t = this.encodeDouble(e);
            t.unshift(5);
            this.writeBytes(t)
        }
    },
    write0Number: function(e) {
        var t;
        if (e instanceof Number) {
            e = e.valueOf()
        }
        t = this.encodeDouble(e);
        t.unshift(0);
        this.writeBytes(t)
    },
    encodeUtf8Char: function(e) {
        var t = [],
        n,
        r,
        i,
        s;
        if (e <= 127) {
            t.push(e)
        } else {
            if (e <= 2047) {
                r = 2
            } else {
                if (e <= 65535) {
                    r = 3
                } else {
                    r = 4
                }
            }
            s = 128;
            for (i = 1; i < r; i++) {
                n = e & 63 | 128;
                t.unshift(n);
                e = e >> 6;
                s = s >> 1 | 128
            }
            n = e | s;
            t.unshift(n)
        }
        return t
    },
    encodeUtf8String: function(e) {
        var t, n = [];
        for (t = 0; t < e.length; t++) {
            var r = this.encodeUtf8Char(e.charCodeAt(t));
            Ext.Array.push(n, r)
        }
        return n
    },
    encode3Utf8StringLen: function(e) {
        var t = e.length,
        n = [];
        if (t <= 268435455) {
            t = t << 1;
            t = t | 1;
            n = this.encode29Int(t)
        } else {}
        return n
    },
    write3String: function(e) {
        if (e == "") {
            this.writeByte(6);
            this.writeByte(1)
        } else {
            var t = this.encodeUtf8String(e);
            var n = this.encode3Utf8StringLen(t);
            this.writeByte(6);
            this.writeBytes(n);
            this.writeBytes(t)
        }
    },
    encodeXInt: function(e, t) {
        var n = [],
        r;
        for (r = 0; r < t; r++) {
            n.unshift(e & 255);
            e = e >> 8
        }
        return n
    },
    write0String: function(e) {
        if (e == "") {
            this.writeByte(2);
            this.writeBytes([0, 0])
        } else {
            var t = this.encodeUtf8String(e);
            var n;
            var r;
            if (t.length <= 65535) {
                n = 2;
                r = this.encodeXInt(t.length, 2)
            } else {
                n = 12;
                r = this.encodeXInt(t.length, 4)
            }
            this.writeByte(n);
            this.writeBytes(r);
            this.writeBytes(t)
        }
    },
    write3XmlWithType: function(e, t) {
        var n = this.convertXmlToString(e);
        if (n == "") {
            this.writeByte(t);
            this.writeByte(1)
        } else {
            var r = this.encodeUtf8String(n);
            var i = this.encode3Utf8StringLen(r);
            this.writeByte(t);
            this.writeBytes(i);
            this.writeBytes(r)
        }
    },
    write3XmlDocument: function(e) {
        this.write3XmlWithType(e, 7)
    },
    write3Xml: function(e) {
        this.write3XmlWithType(e, 11)
    },
    write0Xml: function(e) {
        var t = this.convertXmlToString(e);
        this.writeByte(15);
        var n = this.encodeUtf8String(t);
        var r = this.encodeXInt(n.length, 4);
        this.writeBytes(r);
        this.writeBytes(n)
    },
    write3Date: function(e) {
        this.writeByte(8);
        this.writeBytes(this.encode29Int(1));
        this.writeBytes(this.encodeDouble(new Number(e)))
    },
    write0Date: function(e) {
        this.writeByte(11);
        this.writeBytes(this.encodeDouble(new Number(e)));
        this.writeBytes([0, 0])
    },
    write3Array: function(e) {
        this.writeByte(9);
        var t = e.length;
        t = t << 1;
        t = t | 1;
        this.writeBytes(this.encode29Int(t));
        this.writeByte(1);
        Ext.each(e,
        function(e) {
            this.writeObject(e)
        },
        this)
    },
    write0ObjectProperty: function(e, t) {
        if (! (e instanceof String) && typeof e !== "string") {
            e = e + ""
        }
        var n = this.encodeUtf8String(e);
        var r;
        r = this.encodeXInt(n.length, 2);
        this.writeBytes(r);
        this.writeBytes(n);
        this.writeObject(t)
    },
    write0Array: function(e) {
        var t;
        this.writeByte(8);
        var n = 0;
        for (t in e) {
            n++
        }
        this.writeBytes(this.encodeXInt(n, 4));
        for (t in e) {
            Ext.Array.push(this.write0ObjectProperty(t, e[t]))
        }
        this.writeBytes([0, 0, 9])
    },
    write0StrictArray: function(e) {
        this.writeByte(10);
        var t = e.length;
        this.writeBytes(this.encodeXInt(t, 4));
        Ext.each(e,
        function(e) {
            this.writeObject(e)
        },
        this)
    },
    write3ByteArray: function(e) {
        this.writeByte(12);
        var t = e.length;
        t = t << 1;
        t = t | 1;
        this.writeBytes(this.encode29Int(t));
        this.writeBytes(e)
    },
    write3GenericObject: function(e) {
        var t;
        this.writeByte(10);
        var n = 11;
        this.writeByte(n);
        this.writeByte(1);
        for (t in e) {
            var r = (new String(t)).valueOf();
            if (r == "") {}
            var i = this.encodeUtf8String(t);
            this.writeBytes(this.encode3Utf8StringLen(t));
            this.writeBytes(i);
            this.writeObject(e[t])
        }
        this.writeByte(1)
    },
    write0GenericObject: function(e) {
        var t, n, r;
        t = !!e.$flexType;
        n = t ? 16 : 3;
        this.writeByte(n);
        if (t) {
            this.write0ShortUtf8String(e.$flexType)
        }
        for (r in e) {
            if (r != "$flexType") {
                Ext.Array.push(this.write0ObjectProperty(r, e[r]))
            }
        }
        this.writeBytes([0, 0, 9])
    },
    writeByte: function(e) {
        Ext.Array.push(this.bytes, e)
    },
    writeBytes: function(e) {
        var t;
        Ext.Array.push(this.bytes, e)
    },
    convertXmlToString: function(e) {
        var t;
        if (window.XMLSerializer) {
            t = (new window.XMLSerializer).serializeToString(e)
        } else {
            t = e.xml
        }
        return t
    },
    isXmlDocument: function(e) {
        if (window.DOMParser) {
            if (Ext.isDefined(e.doctype)) {
                return true
            }
        }
        if (Ext.isString(e.xml)) {
            return true
        }
        return false
    },
    encodeDouble: function(e) {
        var t = 11,
        n = 52;
        var r = (1 << t - 1) - 1,
        i,
        s,
        o,
        u,
        a,
        f,
        l,
        c = [];
        var h = [127, 240, 0, 0, 0, 0, 0, 0],
        p = [255, 240, 0, 0, 0, 0, 0, 0],
        d = [255, 248, 0, 0, 0, 0, 0, 0];
        if (isNaN(e)) {
            c = d
        } else {
            if (e === Infinity) {
                c = h
            } else {
                if (e == -Infinity) {
                    c = p
                } else {
                    if (e === 0) {
                        s = 0;
                        o = 0;
                        i = 1 / e === -Infinity ? 1 : 0
                    } else {
                        i = e < 0;
                        e = Math.abs(e);
                        if (e >= Math.pow(2, 1 - r)) {
                            u = Math.min(Math.floor(Math.log(e) / Math.LN2), r);
                            s = u + r;
                            o = Math.round(e * Math.pow(2, n - u) - Math.pow(2, n))
                        } else {
                            s = 0;
                            o = Math.round(e / Math.pow(2, 1 - r - n))
                        }
                    }
                    f = [];
                    for (a = n; a; a -= 1) {
                        f.push(o % 2 ? 1 : 0);
                        o = Math.floor(o / 2)
                    }
                    for (a = t; a; a -= 1) {
                        f.push(s % 2 ? 1 : 0);
                        s = Math.floor(s / 2)
                    }
                    f.push(i ? 1 : 0);
                    f.reverse();
                    l = f.join("");
                    c = [];
                    while (l.length) {
                        c.push(parseInt(l.substring(0, 8), 2));
                        l = l.substring(8)
                    }
                }
            }
        }
        return c
    },
    write0ShortUtf8String: function(e) {
        var t = this.encodeUtf8String(e),
        n;
        n = this.encodeXInt(t.length, 2);
        this.writeBytes(n);
        this.writeBytes(t)
    },
    writeAmfPacket: function(e, t) {
        var n;
        this.writeBytes([0, 0]);
        this.writeBytes(this.encodeXInt(e.length, 2));
        for (n in e) {
            this.writeAmfHeader(e[n].name, e[n].mustUnderstand, e[n].value)
        }
        this.writeBytes(this.encodeXInt(t.length, 2));
        for (n in t) {
            this.writeAmfMessage(t[n].targetUri, t[n].responseUri, t[n].body)
        }
    },
    writeAmfHeader: function(e, t, n) {
        this.write0ShortUtf8String(e);
        var r = t ? 1 : 0;
        this.writeByte(r);
        this.writeBytes(this.encodeXInt( - 1, 4));
        this.writeObject(n)
    },
    writeAmfMessage: function(e, t, n) {
        this.write0ShortUtf8String(e);
        this.write0ShortUtf8String(t);
        this.writeBytes(this.encodeXInt( - 1, 4));
        this.write0StrictArray(n)
    }
});
Ext.define("Ext.data.amf.Packet",
function() {
    var e = Math.pow(2, -52),
    t = Math.pow(2, 8),
    n = 0,
    r,
    i,
    s,
    o;
    return {
        typeMap: {
            0 : {
                0 : "readDouble",
                1 : "readBoolean",
                2 : "readAmf0String",
                3 : "readAmf0Object",
                5 : "readNull",
                6 : "readUndefined",
                7 : "readReference",
                8 : "readEcmaArray",
                10 : "readStrictArray",
                11 : "readAmf0Date",
                12 : "readLongString",
                13 : "readUnsupported",
                15 : "readAmf0Xml",
                16 : "readTypedObject"
            },
            3 : {
                0 : "readUndefined",
                1 : "readNull",
                2 : "readFalse",
                3 : "readTrue",
                4 : "readUInt29",
                5 : "readDouble",
                6 : "readAmf3String",
                7 : "readAmf3Xml",
                8 : "readAmf3Date",
                9 : "readAmf3Array",
                10 : "readAmf3Object",
                11 : "readAmf3Xml",
                12 : "readByteArray"
            }
        },
        decode: function(e) {
            var t = this,
            u = t.headers = [],
            f = t.messages = [],
            l,
            p;
            n = 0;
            r = t.bytes = e;
            i = t.strings = [];
            s = t.objects = [];
            o = t.traits = [];
            t.version = t.readUInt(2);
            for (l = t.readUInt(2); l--;) {
                u.push({
                    name: t.readAmf0String(),
                    mustUnderstand: t.readBoolean(),
                    byteLength: t.readUInt(4),
                    value: t.readValue()
                });
                i = t.strings = [];
                s = t.objects = [];
                o = t.traits = []
            }
            for (p = t.readUInt(2); p--;) {
                f.push({
                    targetURI: t.readAmf0String(),
                    responseURI: t.readAmf0String(),
                    byteLength: t.readUInt(4),
                    body: t.readValue()
                });
                i = t.strings = [];
                s = t.objects = [];
                o = t.traits = []
            }
            n = 0;
            r = i = s = o = t.bytes = t.strings = t.objects = t.traits = null;
            return t
        },
        decodeValue: function(e) {
            var t = this;
            r = t.bytes = e;
            n = 0;
            t.version = 3;
            i = t.strings = [];
            s = t.objects = [];
            o = t.traits = [];
            return t.readValue()
        },
        parseXml: function(e) {
            var t;
            if (window.DOMParser) {
                t = (new DOMParser).parseFromString(e, "text/xml")
            } else {
                t = new ActiveXObject("Microsoft.XMLDOM");
                t.loadXML(e)
            }
            return t
        },
        readAmf0Date: function() {
            var e = new Date(this.readDouble());
            n += 2;
            return e
        },
        readAmf0Object: function(e) {
            var t = this,
            i;
            e = e || {};
            s.push(e);
            while ((i = t.readAmf0String()) || r[n] !== 9) {
                e[i] = t.readValue()
            }
            n++;
            return e
        },
        readAmf0String: function() {
            return this.readUtf8(this.readUInt(2))
        },
        readAmf0Xml: function() {
            return this.parseXml(this.readLongString())
        },
        readAmf3Array: function() {
            var e = this,
            t = e.readUInt29(),
            n,
            r,
            i,
            o;
            if (t & 1) {
                n = t >> 1;
                r = e.readAmf3String();
                if (r) {
                    i = {};
                    s.push(i);
                    do {
                        i[r] = e.readValue()
                    } while ( r = e . readAmf3String ());
                    for (o = 0; o < n; o++) {
                        i[o] = e.readValue()
                    }
                } else {
                    i = [];
                    s.push(i);
                    for (o = 0; o < n; o++) {
                        i.push(e.readValue())
                    }
                }
            } else {
                i = s[t >> 1]
            }
            return i
        },
        readAmf3Date: function() {
            var e = this,
            t = e.readUInt29(),
            n;
            if (t & 1) {
                n = new Date(e.readDouble());
                s.push(n)
            } else {
                n = s[t >> 1]
            }
            return n
        },
        readAmf3Object: function() {
            var e = this,
            t = e.readUInt29(),
            n = [],
            r,
            i,
            u,
            a,
            f,
            l,
            c,
            h,
            p;
            if (t & 1) {
                r = t & 7;
                if (r === 3) {
                    u = e.readAmf3String();
                    a = !!(t & 8);
                    i = t >> 4;
                    for (p = 0; p < i; p++) {
                        n.push(e.readAmf3String())
                    }
                    f = {
                        className: u,
                        dynamic: a,
                        members: n
                    };
                    o.push(f)
                } else {
                    if ((t & 3) === 1) {
                        f = o[t >> 2];
                        u = f.className;
                        a = f.dynamic;
                        n = f.members;
                        i = n.length
                    } else {
                        if (r === 7) {}
                    }
                }
                if (u) {
                    h = Ext.ClassManager.getByAlias("amf." + u);
                    l = h ? new h: {
                        $className: u
                    }
                } else {
                    l = {}
                }
                s.push(l);
                for (p = 0; p < i; p++) {
                    l[n[p]] = e.readValue()
                }
                if (a) {
                    while (c = e.readAmf3String()) {
                        l[c] = e.readValue()
                    }
                }
                if (!h && this.converters[u]) {
                    l = this.converters[u](l)
                }
            } else {
                l = s[t >> 1]
            }
            return l
        },
        readAmf3String: function() {
            var e = this,
            t = e.readUInt29(),
            n;
            if (t & 1) {
                n = e.readUtf8(t >> 1);
                if (n) {
                    i.push(n)
                }
                return n
            } else {
                return i[t >> 1]
            }
        },
        readAmf3Xml: function() {
            var e = this,
            t = e.readUInt29(),
            n;
            if (t & 1) {
                n = e.parseXml(e.readUtf8(t >> 1));
                s.push(n)
            } else {
                n = s[t >> 1]
            }
            return n
        },
        readBoolean: function() {
            return !! r[n++]
        },
        readByteArray: function() {
            var e = this.readUInt29(),
            t,
            i;
            if (e & 1) {
                i = n + (e >> 1);
                t = Array.prototype.slice.call(r, n, i);
                s.push(t);
                n = i
            } else {
                t = s[e >> 1]
            }
            return t
        },
        readDouble: function() {
            var i = r[n++],
            s = r[n++],
            o = i >> 7 ? -1 : 1,
            u = (i & 127) << 4 | s >> 4,
            a = s & 15,
            f = u ? 1 : 0,
            l = 6;
            while (l--) {
                a = a * t + r[n++]
            }
            if (!u) {
                if (!a) {
                    return 0
                }
                u = 1
            }
            if (u === 2047) {
                return a ? NaN: Infinity * o
            }
            return o * Math.pow(2, u - 1023) * (f + e * a)
        },
        readEcmaArray: function() {
            n += 4;
            return this.readAmf0Object()
        },
        readFalse: function() {
            return false
        },
        readLongString: function() {
            return this.readUtf8(this.readUInt(4))
        },
        readNull: function() {
            return null
        },
        readReference: function() {
            return s[this.readUInt(2)]
        },
        readStrictArray: function() {
            var e = this,
            t = e.readUInt(4),
            n = [];
            s.push(n);
            while (t--) {
                n.push(e.readValue())
            }
            return n
        },
        readTrue: function() {
            return true
        },
        readTypedObject: function() {
            var e = this,
            t = e.readAmf0String(),
            n,
            r,
            i;
            n = Ext.ClassManager.getByAlias("amf." + t);
            r = n ? new n: {
                $className: t
            };
            i = e.readAmf0Object(r);
            if (!n && this.converters[t]) {
                i = this.converters[t](r)
            }
            return i
        },
        readUInt: function(e) {
            var t = 1,
            i;
            i = r[n++];
            for (; t < e; ++t) {
                i = i << 8 | r[n++]
            }
            return i
        },
        readUInt29: function() {
            var e = r[n++],
            t;
            if (e & 128) {
                t = r[n++];
                e = (e & 127) << 7 | t & 127;
                if (t & 128) {
                    t = r[n++];
                    e = e << 7 | t & 127;
                    if (t & 128) {
                        t = r[n++];
                        e = e << 8 | t
                    }
                }
            }
            return e
        },
        readUndefined: Ext.emptyFn,
        readUnsupported: Ext.emptyFn,
        readUtf8: function(e) {
            var t = n + e,
            i = [],
            s = 0,
            o = 65535,
            u = 1,
            a = [],
            f = 0,
            l,
            p,
            d;
            l = [i];
            while (n < t) {
                d = r[n++];
                if (d > 127) {
                    if (d > 239) {
                        p = 4;
                        d = d & 7
                    } else {
                        if (d > 223) {
                            p = 3;
                            d = d & 15
                        } else {
                            p = 2;
                            d = d & 31
                        }
                    }
                    while (--p) {
                        d = d << 6 | r[n++] & 63
                    }
                }
                i.push(d);
                if (++s === o) {
                    l.push(i = []);
                    s = 0;
                    u++
                }
            }
            for (; f < u; f++) {
                a.push(String.fromCharCode.apply(String, l[f]))
            }
            return a.join("")
        },
        readValue: function() {
            var e = this,
            t = r[n++];
            if (t === 17) {
                e.version = 3;
                t = r[n++]
            }
            return e[e.typeMap[e.version][t]]()
        },
        converters: {
            "flex.messaging.io.ArrayCollection": function(e) {
                return e.source || []
            }
        }
    }
});
Ext.define("Ext.data.amf.Reader", {
    extend: Ext.data.reader.Json,
    alias: "reader.amf",
    messageIndex: 0,
    read: function(e) {
        var t = this,
        n = e.responseBytes,
        r, i, s;
        if (!n) {
            throw "AMF Reader cannot process the response because it does not contain binary data. Make sure the Proxy's 'binary' config is true."
        }
        r = new Ext.data.amf.Packet,
        r.decode(n);
        i = r.messages;
        if (i.length) {
            s = t.readRecords(i[t.messageIndex].body)
        } else {
            s = t.nullResultSet;
            if (r.invalid) {
                s.success = false
            }
        }
        return s
    }
});
Ext.define("Ext.data.amf.Proxy", {
    extend: Ext.data.proxy.Ajax,
    alias: "proxy.amf",
    binary: true,
    reader: "amf"
});
Ext.define("Ext.data.amf.RemotingMessage", {
    alias: "data.amf.remotingmessage",
    config: {
        $flexType: "flex.messaging.messages.RemotingMessage",
        body: [],
        clientId: "",
        destination: "",
        headers: [],
        messageId: "",
        operation: "",
        source: "",
        timestamp: [],
        timeToLive: []
    },
    constructor: function(e) {
        this.initConfig(e)
    },
    encodeMessage: function() {
        var e = Ext.create("Ext.data.amf.XmlEncoder"),
        t;
        t = Ext.copyTo({},
        this, "$flexType,body,clientId,destination,headers,messageId,operation,source,timestamp,timeToLive", true);
        e.writeObject(t);
        return e.body
    }
});
Ext.define("Ext.data.amf.XmlDecoder", {
    alias: "data.amf.xmldecoder",
    statics: {
        readXml: function(e) {
            var t;
            if (window.DOMParser) {
                t = (new DOMParser).parseFromString(e, "text/xml")
            } else {
                t = new ActiveXObject("Microsoft.XMLDOM");
                t.loadXML(e)
            }
            return t
        },
        readByteArray: function(e) {
            var t = [],
            n,
            r,
            i;
            i = e.firstChild.nodeValue;
            for (r = 0; r < i.length; r = r + 2) {
                n = i.substr(r, 2);
                t.push(parseInt(n, 16))
            }
            return t
        },
        readAMF3Value: function(e) {
            var t;
            t = Ext.create("Ext.data.amf.Packet");
            return t.decodeValue(e)
        },
        decodeTidFromFlexUID: function(e) {
            var t;
            t = e.substr(0, 8);
            return parseInt(t, 16)
        }
    },
    constructor: function(e) {
        this.initConfig(e);
        this.clear()
    },
    clear: function() {
        this.objectReferences = [];
        this.traitsReferences = [];
        this.stringReferences = []
    },
    readAmfxMessage: function(e) {
        var t, n, r, i, s = {};
        this.clear();
        t = Ext.data.amf.XmlDecoder.readXml(e);
        n = t.getElementsByTagName("amfx")[0];
        r = n.getElementsByTagName("body")[0];
        s.targetURI = r.getAttribute("targetURI");
        s.responseURI = r.getAttribute("responseURI");
        for (i = 0; i < r.childNodes.length; i++) {
            if (r.childNodes.item(i).nodeType != 1) {
                continue
            }
            s.message = this.readValue(r.childNodes.item(i));
            break
        }
        return s
    },
    readValue: function(e) {
        var t;
        if (typeof e.normalize === "function") {
            e.normalize()
        }
        if (e.tagName == "null") {
            return null
        } else {
            if (e.tagName == "true") {
                return true
            } else {
                if (e.tagName == "false") {
                    return false
                } else {
                    if (e.tagName == "string") {
                        return this.readString(e)
                    } else {
                        if (e.tagName == "int") {
                            return parseInt(e.firstChild.nodeValue)
                        } else {
                            if (e.tagName == "double") {
                                return parseFloat(e.firstChild.nodeValue)
                            } else {
                                if (e.tagName == "date") {
                                    t = new Date(parseFloat(e.firstChild.nodeValue));
                                    this.objectReferences.push(t);
                                    return t
                                } else {
                                    if (e.tagName == "dictionary") {
                                        return this.readDictionary(e)
                                    } else {
                                        if (e.tagName == "array") {
                                            return this.readArray(e)
                                        } else {
                                            if (e.tagName == "ref") {
                                                return this.readObjectRef(e)
                                            } else {
                                                if (e.tagName == "object") {
                                                    return this.readObject(e)
                                                } else {
                                                    if (e.tagName == "xml") {
                                                        return Ext.data.amf.XmlDecoder.readXml(e.firstChild.nodeValue)
                                                    } else {
                                                        if (e.tagName == "bytearray") {
                                                            return Ext.data.amf.XmlDecoder.readAMF3Value(Ext.data.amf.XmlDecoder.readByteArray(e))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return null
    },
    readString: function(e) {
        var t;
        if (e.getAttributeNode("id")) {
            return this.stringReferences[parseInt(e.getAttribute("id"))]
        }
        t = (e.firstChild ? e.firstChild.nodeValue: "") || "";
        this.stringReferences.push(t);
        return t
    },
    readTraits: function(e) {
        var t = [],
        n,
        r;
        if (e === null) {
            return null
        }
        if (e.getAttribute("externalizable") == "true") {
            return null
        }
        if (e.getAttributeNode("id")) {
            return this.traitsReferences[parseInt(e.getAttributeNode("id").value)]
        }
        r = e.childNodes;
        for (n = 0; n < r.length; n++) {
            if (r.item(n).nodeType != 1) {
                continue
            }
            t.push(this.readValue(r.item(n)))
        }
        this.traitsReferences.push(t);
        return t
    },
    readObjectRef: function(e) {
        var t;
        t = parseInt(e.getAttribute("id"));
        return this.objectReferences[t]
    },
    readObject: function(e) {
        var t, n = [],
        r,
        i,
        s,
        o,
        u,
        a,
        f = null,
        l;
        l = e.getAttribute("type");
        if (l) {
            f = Ext.ClassManager.getByAlias("amfx." + l)
        }
        t = f ? new f: l ? {
            $className: l
        }: {};
        if (!f && this.converters[l]) {
            t = this.converters[l](this, e);
            return t
        }
        r = e.getElementsByTagName("traits")[0];
        n = this.readTraits(r);
        this.objectReferences.push(t);
        s = 0;
        for (i = 0; i < e.childNodes.length; i++) {
            o = e.childNodes.item(i);
            if (o.nodeType != 1) {
                continue
            }
            if (o.tagName == "traits") {
                continue
            }
            u = n[s];
            a = this.readValue(o);
            s = s + 1;
            t[u] = a
        }
        return t
    },
    readArray: function(e) {
        var t = [],
        n,
        r,
        i,
        s,
        o,
        u,
        a,
        f,
        l;
        this.objectReferences.push(t);
        a = parseInt(e.getAttributeNode("length").value);
        r = 0;
        for (s = 0; s < e.childNodes.length; s++) {
            n = e.childNodes.item(s);
            if (n.nodeType != 1) {
                continue
            }
            if (n.tagName == "item") {
                o = n.getAttributeNode("name").value;
                f = n.childNodes;
                for (i = 0; i < f.length; i++) {
                    l = f.item(i);
                    if (l.nodeType != 1) {
                        continue
                    }
                    u = this.readValue(l);
                    break
                }
                t[o] = u
            } else {
                t[r] = this.readValue(n);
                r++
            }
        }
        return t
    },
    readDictionary: function(e) {
        var t = {},
        n, r, i, s, o, u;
        u = parseInt(e.getAttribute("length"));
        this.objectReferences.push(t);
        n = null;
        r = null;
        s = 0;
        for (i = 0; i < e.childNodes.length; i++) {
            o = e.childNodes.item(i);
            if (o.nodeType != 1) {
                continue
            }
            if (!n) {
                n = this.readValue(o);
                continue
            }
            r = this.readValue(o);
            s = s + 1;
            t[n] = r;
            n = null;
            r = null
        }
        return t
    },
    convertObjectWithSourceField: function(e) {
        var t, n, r;
        for (t = 0; t < e.childNodes.length; t++) {
            n = e.childNodes.item(t);
            if (n.tagName == "bytearray") {
                r = this.readValue(n);
                this.objectReferences.push(r);
                return r
            }
        }
        return null
    },
    converters: {
        "flex.messaging.io.ArrayCollection": function(e, t) {
            return e.convertObjectWithSourceField(t)
        },
        "mx.collections.ArrayList": function(e, t) {
            return e.convertObjectWithSourceField(t)
        },
        "mx.collections.ArrayCollection": function(e, t) {
            return e.convertObjectWithSourceField(t)
        }
    }
});
Ext.define("Ext.data.amf.XmlEncoder", {
    alias: "data.amf.xmlencoder",
    body: "",
    statics: {
        generateFlexUID: function(e) {
            var t = "",
            n, r, i;
            if (e === undefined) {
                e = Ext.Number.randomInt(0, 4294967295)
            }
            i = (e + 4294967296).toString(16).toUpperCase();
            t = i.substr(i.length - 8, 8);
            for (r = 0; r < 3; r++) {
                t += "-";
                for (n = 0; n < 4; n++) {
                    t += Ext.Number.randomInt(0, 15).toString(16).toUpperCase()
                }
            }
            t += "-";
            i = (new Number(new Date)).valueOf().toString(16).toUpperCase();
            r = 0;
            if (i.length < 8) {
                for (n = 0; n < i.length - 8; n++) {
                    r++;
                    t += "0"
                }
            }
            t += i.substr( - (8 - r));
            for (n = 0; n < 4; n++) {
                t += Ext.Number.randomInt(0, 15).toString(16).toUpperCase()
            }
            return t
        }
    },
    constructor: function(e) {
        this.initConfig(e);
        this.clear()
    },
    clear: function() {
        this.body = ""
    },
    encodeUndefined: function() {
        return this.encodeNull()
    },
    writeUndefined: function() {
        this.write(this.encodeUndefined())
    },
    encodeNull: function() {
        return "<null />"
    },
    writeNull: function() {
        this.write(this.encodeNull())
    },
    encodeBoolean: function(e) {
        var t;
        if (e) {
            t = "<true />"
        } else {
            t = "<false />"
        }
        return t
    },
    writeBoolean: function(e) {
        this.write(this.encodeBoolean(e))
    },
    encodeString: function(e) {
        var t;
        if (e === "") {
            t = "<string />"
        } else {
            t = "<string>" + e + "</string>"
        }
        return t
    },
    writeString: function(e) {
        this.write(this.encodeString(e))
    },
    encodeInt: function(e) {
        return "<int>" + e.toString() + "</int>"
    },
    writeInt: function(e) {
        this.write(this.encodeInt(e))
    },
    encodeDouble: function(e) {
        return "<double>" + e.toString() + "</double>"
    },
    writeDouble: function(e) {
        this.write(this.encodeDouble(e))
    },
    encodeNumber: function(e) {
        var t = 536870911,
        n = -268435455;
        if (e instanceof Number) {
            e = e.valueOf()
        }
        if (e % 1 === 0 && e >= n && e <= t) {
            return this.encodeInt(e)
        } else {
            return this.encodeDouble(e)
        }
    },
    writeNumber: function(e) {
        this.write(this.encodeNumber(e))
    },
    encodeDate: function(e) {
        return "<date>" + (new Number(e)).toString() + "</date>"
    },
    writeDate: function(e) {
        this.write(this.encodeDate(e))
    },
    encodeEcmaElement: function(e, t) {
        var n = '<item name="' + e.toString() + '">' + this.encodeObject(t) + "</item>";
        return n
    },
    encodeArray: function(e) {
        var t = [],
        n,
        r = [],
        i = e.length,
        s,
        o;
        for (s in e) {
            if (Ext.isNumeric(s) && s % 1 == 0) {
                t[s] = this.encodeObject(e[s])
            } else {
                r.push(this.encodeEcmaElement(s, e[s]))
            }
        }
        n = t.length;
        for (s = 0; s < t.length; s++) {
            if (t[s] === undefined) {
                n = s;
                break
            }
        }
        if (n < t.length) {
            for (s = firstNonOrdinals; s < t.length; s++) {
                if (t[s] !== undefined) {
                    r.push(this.encodeEcmaElement(s, t[s]))
                }
            }
            t = t.slice(0, n)
        }
        o = '<array length="' + t.length + '"';
        if (r.length > 0) {
            o += ' ecma="true"'
        }
        o += ">";
        for (s = 0; s < t.length; s++) {
            o += t[s]
        }
        for (s in r) {
            o += r[s]
        }
        o += "</array>";
        return o
    },
    writeArray: function(e) {
        this.write(this.encodeArray(e))
    },
    encodeXml: function(e) {
        var t = this.convertXmlToString(e);
        return "<xml><![CDATA[" + t + "]]></xml>"
    },
    writeXml: function(e) {
        this.write(this.encodeXml(e))
    },
    encodeGenericObject: function(e) {
        var t = [],
        n = [],
        r = null,
        i,
        s;
        for (i in e) {
            if (i == "$flexType") {
                r = e[i]
            } else {
                t.push(this.encodeString(new String(i)));
                n.push(this.encodeObject(e[i]))
            }
        }
        if (r) {
            s = '<object type="' + r + '">'
        } else {
            s = "<object>"
        }
        if (t.length > 0) {
            s += "<traits>";
            s += t.join("");
            s += "</traits>"
        } else {
            s += "<traits />"
        }
        s += n.join("");
        s += "</object>";
        return s
    },
    writeGenericObject: function(e) {
        this.write(this.encodeGenericObject(e))
    },
    encodeByteArray: function(e) {
        var t, n, r;
        if (e.length > 0) {
            t = "<bytearray>";
            for (n = 0; n < e.length; n++) {
                r = e[n].toString(16).toUpperCase();
                if (e[n] < 16) {
                    r = "0" + r
                }
                t += r
            }
            t += "</bytearray>"
        } else {
            t = "<bytearray />"
        }
        return t
    },
    writeByteArray: function(e) {
        this.write(this.encodeByteArray(e))
    },
    encodeObject: function(e) {
        var t = typeof e;
        if (t === "undefined") {
            return this.encodeUndefined()
        } else {
            if (e === null) {
                return this.encodeNull()
            } else {
                if (Ext.isBoolean(e)) {
                    return this.encodeBoolean(e)
                } else {
                    if (Ext.isString(e)) {
                        return this.encodeString(e)
                    } else {
                        if (t === "number" || e instanceof Number) {
                            return this.encodeNumber(e)
                        } else {
                            if (t === "object") {
                                if (e instanceof Date) {
                                    return this.encodeDate(e)
                                } else {
                                    if (Ext.isArray(e)) {
                                        return this.encodeArray(e)
                                    } else {
                                        if (this.isXmlDocument(e)) {
                                            return this.encodeXml(e)
                                        } else {
                                            return this.encodeGenericObject(e)
                                        }
                                    }
                                }
                            } else {}
                        }
                    }
                }
            }
        }
        return null
    },
    writeObject: function(e) {
        this.write(this.encodeObject(e))
    },
    encodeAmfxRemotingPacket: function(e) {
        var t, n;
        n = '<amfx ver="3" xmlns="http://www.macromedia.com/2005/amfx"><body>';
        n += e.encodeMessage();
        n += "</body></amfx>";
        return n
    },
    writeAmfxRemotingPacket: function(e) {
        this.write(this.encodeAmfxRemotingPacket(e))
    },
    convertXmlToString: function(e) {
        var t;
        if (window.XMLSerializer) {
            t = (new window.XMLSerializer).serializeToString(e)
        } else {
            t = e.xml
        }
        return t
    },
    isXmlDocument: function(e) {
        if (window.DOMParser) {
            if (Ext.isDefined(e.doctype)) {
                return true
            }
        }
        if (Ext.isString(e.xml)) {
            return true
        }
        return false
    },
    write: function(e) {
        this.body += e
    }
});
Ext.define("Ext.data.association.BelongsTo", {
    extend: Ext.data.association.Association,
    alternateClassName: "Ext.data.BelongsToAssociation",
    alias: "association.belongsto",
    constructor: function(e) {
        this.callParent(arguments);
        var t = this,
        n = t.ownerModel.prototype,
        r = t.associatedName,
        i = t.getterName || "get" + r,
        s = t.setterName || "set" + r;
        Ext.applyIf(t, {
            name: r,
            foreignKey: r.toLowerCase() + "_id",
            instanceName: r + "BelongsToInstance",
            associationKey: r.toLowerCase()
        });
        n[i] = t.createGetter();
        n[s] = t.createSetter()
    },
    createSetter: function() {
        var e = this,
        t = e.foreignKey,
        n = e.instanceName;
        return function(e, r, i) {
            var s = e && e.isModel,
            o = s ? e.getId() : e;
            if (s) {
                this[n] = e
            } else {
                if (this[n] instanceof Ext.data.Model && !this.isEqual(this.get(t), o)) {
                    delete this[n]
                }
            }
            this.set(t, o);
            if (Ext.isFunction(r)) {
                r = {
                    callback: r,
                    scope: i || this
                }
            }
            if (Ext.isObject(r)) {
                return this.save(r)
            }
        }
    },
    createGetter: function() {
        var e = this,
        t = e.associatedName,
        n = e.associatedModel,
        r = e.foreignKey,
        i = e.primaryKey,
        s = e.instanceName;
        return function(e, o) {
            e = e || {};
            var u = this,
            f = u.get(r),
            l,
            h,
            p;
            if (e.reload === true || u[s] === undefined) {
                if (Ext.isEmpty(f)) {
                    return null
                }
                h = Ext.ModelManager.create({},
                t);
                h.set(i, f);
                if (typeof e == "function") {
                    e = {
                        callback: e,
                        scope: o || u
                    }
                }
                l = e.success;
                e.success = function(e) {
                    u[s] = e;
                    if (l) {
                        l.apply(this, arguments)
                    }
                };
                n.load(f, e);
                u[s] = h;
                return h
            } else {
                h = u[s];
                p = [h];
                o = o || e.scope || u;
                if (e) {
                    Ext.callback(e, o, p);
                    Ext.callback(e.success, o, p);
                    Ext.callback(e.callback, o, p)
                }
                return h
            }
        }
    },
    read: function(e, t, n) {
        e[this.instanceName] = t.read([n]).records[0]
    }
});
Ext.define("Ext.util.Inflector", {
    singleton: true,
    plurals: [[/(quiz)$/i, "$1zes"], [/^(ox)$/i, "$1en"], [/([m|l])ouse$/i, "$1ice"], [/(matr|vert|ind)ix|ex$/i, "$1ices"], [/(x|ch|ss|sh)$/i, "$1es"], [/([^aeiouy]|qu)y$/i, "$1ies"], [/(hive)$/i, "$1s"], [/(?:([^f])fe|([lr])f)$/i, "$1$2ves"], [/sis$/i, "ses"], [/([ti])um$/i, "$1a"], [/(buffal|tomat|potat)o$/i, "$1oes"], [/(bu)s$/i, "$1ses"], [/(alias|status|sex)$/i, "$1es"], [/(octop|vir)us$/i, "$1i"], [/(ax|test)is$/i, "$1es"], [/^person$/, "people"], [/^man$/, "men"], [/^(child)$/, "$1ren"], [/s$/i, "s"], [/$/, "s"]],
    singulars: [[/(quiz)zes$/i, "$1"], [/(matr)ices$/i, "$1ix"], [/(vert|ind)ices$/i, "$1ex"], [/^(ox)en/i, "$1"], [/(alias|status)es$/i, "$1"], [/(octop|vir)i$/i, "$1us"], [/(cris|ax|test)es$/i, "$1is"], [/(shoe)s$/i, "$1"], [/(o)es$/i, "$1"], [/(bus)es$/i, "$1"], [/([m|l])ice$/i, "$1ouse"], [/(x|ch|ss|sh)es$/i, "$1"], [/(m)ovies$/i, "$1ovie"], [/(s)eries$/i, "$1eries"], [/([^aeiouy]|qu)ies$/i, "$1y"], [/([lr])ves$/i, "$1f"], [/(tive)s$/i, "$1"], [/(hive)s$/i, "$1"], [/([^f])ves$/i, "$1fe"], [/(^analy)ses$/i, "$1sis"], [/((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$/i, "$1$2sis"], [/([ti])a$/i, "$1um"], [/(n)ews$/i, "$1ews"], [/people$/i, "person"], [/s$/i, ""]],
    uncountable: ["sheep", "fish", "series", "species", "money", "rice", "information", "equipment", "grass", "mud", "offspring", "deer", "means"],
    singular: function(e, t) {
        this.singulars.unshift([e, t])
    },
    plural: function(e, t) {
        this.plurals.unshift([e, t])
    },
    clearSingulars: function() {
        this.singulars = []
    },
    clearPlurals: function() {
        this.plurals = []
    },
    isTransnumeral: function(e) {
        return Ext.Array.indexOf(this.uncountable, e) != -1
    },
    pluralize: function(e) {
        if (this.isTransnumeral(e)) {
            return e
        }
        var t = this.plurals,
        n = t.length,
        r, i, s;
        for (s = 0; s < n; s++) {
            r = t[s];
            i = r[0];
            if (i == e || i.test && i.test(e)) {
                return e.replace(i, r[1])
            }
        }
        return e
    },
    singularize: function(e) {
        if (this.isTransnumeral(e)) {
            return e
        }
        var t = this.singulars,
        n = t.length,
        r, i, s;
        for (s = 0; s < n; s++) {
            r = t[s];
            i = r[0];
            if (i == e || i.test && i.test(e)) {
                return e.replace(i, r[1])
            }
        }
        return e
    },
    classify: function(e) {
        return Ext.String.capitalize(this.singularize(e))
    },
    ordinalize: function(e) {
        var t = parseInt(e, 10),
        n = t % 10,
        r = t % 100;
        if (11 <= r && r <= 13) {
            return e + "th"
        } else {
            switch (n) {
            case 1:
                return e + "st";
            case 2:
                return e + "nd";
            case 3:
                return e + "rd";
            default:
                return e + "th"
            }
        }
    }
},
function() {
    var e = {
        alumnus: "alumni",
        cactus: "cacti",
        focus: "foci",
        nucleus: "nuclei",
        radius: "radii",
        stimulus: "stimuli",
        ellipsis: "ellipses",
        paralysis: "paralyses",
        oasis: "oases",
        appendix: "appendices",
        index: "indexes",
        beau: "beaux",
        bureau: "bureaux",
        tableau: "tableaux",
        woman: "women",
        child: "children",
        man: "men",
        corpus: "corpora",
        criterion: "criteria",
        curriculum: "curricula",
        genus: "genera",
        memorandum: "memoranda",
        phenomenon: "phenomena",
        foot: "feet",
        goose: "geese",
        tooth: "teeth",
        antenna: "antennae",
        formula: "formulae",
        nebula: "nebulae",
        vertebra: "vertebrae",
        vita: "vitae"
    },
    t;
    for (t in e) {
        this.plural(t, e[t]);
        this.singular(e[t], t)
    }
});
Ext.define("Ext.data.association.HasMany", {
    extend: Ext.data.association.Association,
    alternateClassName: "Ext.data.HasManyAssociation",
    alias: "association.hasmany",
    constructor: function(e) {
        var t = this,
        n, r;
        t.callParent(arguments);
        t.name = t.name || Ext.util.Inflector.pluralize(t.associatedName.toLowerCase());
        n = t.ownerModel.prototype;
        r = t.name;
        Ext.applyIf(t, {
            storeName: r + "Store",
            foreignKey: t.ownerName.toLowerCase() + "_id"
        });
        n[r] = t.createStore()
    },
    createStore: function() {
        var e = this,
        t = e.associatedModel,
        n = e.storeName,
        r = e.foreignKey,
        i = e.primaryKey,
        s = e.filterProperty,
        o = e.autoLoad,
        u = e.remoteFilter,
        a = e.storeConfig || {};
        return function() {
            var e = this,
            f, l, p = {},
            d;
            if (e[n] === undefined) {
                d = e.get(i);
                if (s) {
                    l = {
                        property: s,
                        value: e.get(s),
                        exactMatch: true
                    }
                } else {
                    if (e.hasId(d)) {
                        l = {
                            property: r,
                            value: d,
                            exactMatch: true
                        }
                    }
                }
                p[r] = e.get(i);
                f = Ext.apply({},
                a, {
                    model: t,
                    filters: l ? [l] : undefined,
                    remoteFilter: u === true,
                    modelDefaults: p,
                    disableMetaChangeEvent: true
                });
                e[n] = Ext.data.AbstractStore.create(f);
                if (o) {
                    e[n].load()
                }
            }
            return e[n]
        }
    },
    read: function(e, t, n) {
        var r = e[this.name](),
        i,
        s,
        o,
        u;
        r.add(t.read(n).records);
        i = this.associatedModel.prototype.associations.findBy(function(t) {
            return t.type === "belongsTo" && t.associatedName === e.$className
        });
        if (i) {
            s = r.data.items;
            o = s.length;
            for (u = 0; u < o; u++) {
                s[u][i.instanceName] = e
            }
        }
    }
});
Ext.define("Ext.data.association.HasOne", {
    extend: Ext.data.association.Association,
    alternateClassName: "Ext.data.HasOneAssociation",
    alias: "association.hasone",
    constructor: function(e) {
        this.callParent(arguments);
        var t = this,
        n = t.ownerModel.prototype,
        r = t.associatedName,
        i = t.getterName || "get" + r,
        s = t.setterName || "set" + r;
        Ext.applyIf(t, {
            name: r,
            foreignKey: r.toLowerCase() + "_id",
            instanceName: r + "HasOneInstance",
            associationKey: r.toLowerCase()
        });
        n[i] = t.createGetter();
        n[s] = t.createSetter()
    },
    createSetter: function() {
        var e = this,
        t = e.foreignKey,
        n = e.instanceName;
        return function(e, r, i) {
            var s = e && e.isModel,
            o = s ? e.getId() : e;
            if (s) {
                this[n] = e
            } else {
                if (this[n] instanceof Ext.data.Model && !this.isEqual(this.get(t), o)) {
                    delete this[n]
                }
            }
            this.set(t, o);
            if (Ext.isFunction(r)) {
                r = {
                    callback: r,
                    scope: i || this
                }
            }
            if (Ext.isObject(r)) {
                return this.save(r)
            }
        }
    },
    createGetter: function() {
        var e = this,
        t = e.ownerModel,
        n = e.associatedName,
        r = e.associatedModel,
        i = e.foreignKey,
        s = e.primaryKey,
        o = e.instanceName;
        return function(e, t) {
            e = e || {};
            var u = this,
            f = u.get(i),
            l,
            p,
            d;
            if (e.reload === true || u[o] === undefined) {
                if (Ext.isEmpty(f)) {
                    return null
                }
                p = Ext.ModelManager.create({},
                n);
                p.set(s, f);
                if (typeof e == "function") {
                    e = {
                        callback: e,
                        scope: t || u
                    }
                }
                l = e.success;
                e.success = function(e) {
                    u[o] = e;
                    if (l) {
                        l.apply(this, arguments)
                    }
                };
                r.load(f, e);
                u[o] = p;
                return p
            } else {
                p = u[o];
                d = [p];
                t = t || e.scope || u;
                if (e) {
                    Ext.callback(e, t, d);
                    Ext.callback(e.success, t, d);
                    Ext.callback(e.callback, t, d)
                }
                return p
            }
        }
    },
    read: function(e, t, n) {
        var r = this.associatedModel.prototype.associations.findBy(function(t) {
            return t.type === "belongsTo" && t.associatedName === e.$className
        }),
        i = t.read([n]).records[0];
        e[this.instanceName] = i;
        if (r) {
            i[r.instanceName] = e
        }
    }
});
Ext.define("Ext.data.proxy.WebStorage", {
    extend: Ext.data.proxy.Client,
    alternateClassName: "Ext.data.WebStorageProxy",
    id: undefined,
    constructor: function(e) {
        this.callParent(arguments);
        this.cache = {};
        this.id = this.id || (this.store ? this.store.storeId: undefined);
        this.initialize()
    },
    create: function(e, t, n) {
        var r = this,
        i = e.records,
        s = i.length,
        o = r.getIds(),
        u,
        a,
        f;
        e.setStarted();
        if (r.isHierarchical === undefined) {
            r.isHierarchical = !!i[0].isNode;
            if (r.isHierarchical) {
                r.getStorageObject().setItem(r.getTreeKey(), true)
            }
        }
        for (f = 0; f < s; f++) {
            a = i[f];
            if (a.phantom) {
                a.phantom = false;
                u = r.getNextId()
            } else {
                u = a.getId()
            }
            r.setRecord(a, u);
            a.commit();
            o.push(u)
        }
        r.setIds(o);
        e.setCompleted();
        e.setSuccessful();
        if (typeof t == "function") {
            t.call(n || r, e)
        }
    },
    read: function(e, t, n) {
        var r = this,
        i = [],
        s = 0,
        o = true,
        u = r.model,
        a,
        f,
        l,
        c,
        h;
        e.setStarted();
        if (r.isHierarchical) {
            i = r.getTreeData()
        } else {
            a = r.getIds();
            f = a.length;
            h = e.id;
            if (h) {
                c = r.getRecord(h);
                if (c !== null) {
                    l = new u(c, h, c)
                }
                if (l) {
                    i.push(l)
                } else {
                    o = false
                }
            } else {
                for (; s < f; s++) {
                    h = a[s];
                    c = r.getRecord(h);
                    i.push(new u(c, h, c))
                }
            }
        }
        if (o) {
            e.setSuccessful()
        }
        e.setCompleted();
        e.resultSet = Ext.create("Ext.data.ResultSet", {
            records: i,
            total: i.length,
            loaded: true
        });
        if (typeof t == "function") {
            t.call(n || r, e)
        }
    },
    update: function(e, t, n) {
        var r = e.records,
        i = r.length,
        s = this.getIds(),
        o,
        u,
        a;
        e.setStarted();
        for (a = 0; a < i; a++) {
            o = r[a];
            this.setRecord(o);
            o.commit();
            u = o.getId();
            if (u !== undefined && Ext.Array.indexOf(s, u) == -1) {
                s.push(u)
            }
        }
        this.setIds(s);
        e.setCompleted();
        e.setSuccessful();
        if (typeof t == "function") {
            t.call(n || this, e)
        }
    },
    destroy: function(e, t, n) {
        var r = this,
        i = e.records,
        s = r.getIds(),
        o = s.length,
        u = [],
        a = {},
        f = i.length,
        l;
        e.setStarted();
        for (; f--;) {
            Ext.apply(a, r.removeRecord(i[f]))
        }
        for (f = 0; f < o; f++) {
            l = s[f];
            if (!a[l]) {
                u.push(l)
            }
        }
        r.setIds(u);
        e.setCompleted();
        e.setSuccessful();
        if (typeof t == "function") {
            t.call(n || r, e)
        }
    },
    getRecord: function(e) {
        var t = this,
        n = t.cache,
        r = !n[e] ? Ext.decode(t.getStorageObject().getItem(t.getRecordKey(e))) : n[e];
        if (!r) {
            return null
        }
        n[e] = r;
        r[t.model.prototype.idProperty] = e;
        return r
    },
    setRecord: function(e, t) {
        if (t) {
            e.setId(t)
        } else {
            t = e.getId()
        }
        var n = this,
        r = e.data,
        i = {},
        s = n.model,
        o = s.prototype.fields.items,
        u = o.length,
        a = 0,
        f, l, c, h;
        for (; a < u; a++) {
            f = o[a];
            l = f.name;
            if (f.persist) {
                i[l] = r[l]
            }
        }
        delete i[n.model.prototype.idProperty];
        if (e.isNode && e.get("depth") === 1) {
            delete i.parentId
        }
        c = n.getStorageObject();
        h = n.getRecordKey(t);
        n.cache[t] = i;
        c.removeItem(h);
        c.setItem(h, Ext.encode(i))
    },
    removeRecord: function(e) {
        var t = this,
        n = e.getId(),
        r = {},
        i,
        s;
        r[n] = e;
        t.getStorageObject().removeItem(t.getRecordKey(n));
        delete t.cache[n];
        if (e.childNodes) {
            s = e.childNodes;
            for (i = s.length; i--;) {
                Ext.apply(r, t.removeRecord(s[i]))
            }
        }
        return r
    },
    getRecordKey: function(e) {
        if (e.isModel) {
            e = e.getId()
        }
        return Ext.String.format("{0}-{1}", this.id, e)
    },
    getRecordCounterKey: function() {
        return Ext.String.format("{0}-counter", this.id)
    },
    getTreeKey: function() {
        return Ext.String.format("{0}-tree", this.id)
    },
    getIds: function() {
        var e = this,
        t = (e.getStorageObject().getItem(e.id) || "").split(","),
        n = e.model,
        r = t.length,
        i = n.prototype.fields.get(n.prototype.idProperty).type.type === "string",
        s;
        if (r == 1 && t[0] === "") {
            t = []
        } else {
            for (s = 0; s < r; s++) {
                t[s] = i ? t[s] : +t[s]
            }
        }
        return t
    },
    setIds: function(e) {
        var t = this.getStorageObject(),
        n = e.join(",");
        t.removeItem(this.id);
        if (!Ext.isEmpty(n)) {
            t.setItem(this.id, n)
        }
    },
    getNextId: function() {
        var e = this,
        t = e.getStorageObject(),
        n = e.getRecordCounterKey(),
        r = e.model,
        i = r.prototype.fields.get(r.prototype.idProperty).type.type === "string",
        s;
        s = e.idGenerator.generate();
        t.setItem(n, s);
        if (!i) {
            s = +s
        }
        return s
    },
    getTreeData: function() {
        var e = this,
        t = e.getIds(),
        n = t.length,
        r = [],
        i = {},
        s = [],
        o = 0,
        u = e.model,
        a = u.prototype.idProperty,
        f,
        l,
        c,
        h,
        p,
        d;
        for (; o < n; o++) {
            d = t[o];
            l = e.getRecord(d);
            r.push(l);
            i[d] = l;
            if (!l.parentId) {
                s.push(l)
            }
        }
        f = s.length;
        Ext.Array.sort(r, e.sortByParentId);
        for (o = f; o < n; o++) {
            l = r[o];
            h = l.parentId;
            if (!c || c[a] !== h) {
                c = i[h];
                c.children = p = []
            }
            p.push(l)
        }
        for (o = n; o--;) {
            l = r[o];
            if (!l.children && !l.leaf) {
                l.loaded = true
            }
        }
        for (o = f; o--;) {
            l = s[o];
            s[o] = new u(l, l[a], l)
        }
        return s
    },
    sortByParentId: function(e, t) {
        return (e.parentId || 0) - (t.parentId || 0)
    },
    initialize: function() {
        var e = this,
        t = e.getStorageObject(),
        n = +t.getItem(e.getRecordCounterKey());
        t.setItem(e.id, t.getItem(e.id) || "");
        if (t.getItem(e.getTreeKey())) {
            e.isHierarchical = true
        }
        e.idGenerator = new Ext.data.SequentialIdGenerator({
            seed: n ? n + 1 : 1
        })
    },
    clear: function() {
        var e = this,
        t = e.getStorageObject(),
        n = e.getIds(),
        r = n.length,
        i;
        for (i = 0; i < r; i++) {
            t.removeItem(e.getRecordKey(n[i]))
        }
        t.removeItem(e.getRecordCounterKey());
        t.removeItem(e.getTreeKey());
        t.removeItem(e.id);
        e.cache = {}
    },
    getStorageObject: function() {}
});
Ext.define("Ext.data.proxy.LocalStorage", {
    extend: Ext.data.proxy.WebStorage,
    alias: "proxy.localstorage",
    alternateClassName: "Ext.data.LocalStorageProxy",
    getStorageObject: function() {
        return window.localStorage
    }
});
Ext.define("Ext.data.proxy.Rest", {
    extend: Ext.data.proxy.Ajax,
    alternateClassName: "Ext.data.RestProxy",
    alias: "proxy.rest",
    actionMethods: {
        create: "POST",
        read: "GET",
        update: "PUT",
        destroy: "DELETE"
    },
    defaultActionMethods: {
        create: "POST",
        read: "GET",
        update: "PUT",
        destroy: "DELETE"
    },
    appendId: true,
    batchActions: false,
    buildUrl: function(e) {
        var t = this,
        n = e.operation,
        r = n.records || [],
        i = r[0],
        s = t.format,
        o = t.getUrl(e),
        u = i ? i.getId() : n.id;
        if (t.appendId && t.isValidId(u)) {
            if (!o.match(/\/$/)) {
                o += "/"
            }
            o += u
        }
        if (s) {
            if (!o.match(/\.$/)) {
                o += "."
            }
            o += s
        }
        e.url = o;
        return t.callParent(arguments)
    },
    isValidId: function(e) {
        return e || e === 0
    }
});
Ext.define("Ext.data.proxy.SessionStorage", {
    extend: Ext.data.proxy.WebStorage,
    alias: "proxy.sessionstorage",
    alternateClassName: "Ext.data.SessionStorageProxy",
    getStorageObject: function() {
        return window.sessionStorage
    }
});
Ext.define("Ext.data.soap.Reader", {
    extend: Ext.data.reader.Xml,
    alias: "reader.soap",
    getData: function(e) {
        var t = e.documentElement,
        n = t.prefix;
        return Ext.DomQuery.selectNode(n + "|Body", e)
    }
});
Ext.define("Ext.data.soap.Proxy", {
    extend: Ext.data.proxy.Ajax,
    alias: "proxy.soap",
    operationParam: "op",
    reader: "soap",
    envelopeTpl: ['<?xml version="1.0" encoding="utf-8" ?>', '<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">', "{[values.bodyTpl.apply(values)]}", "</soap:Envelope>"],
    readBodyTpl: ["<soap:Body>", '<{operation} xmlns="{targetNamespace}">', '<tpl foreach="params">', "<{$}>{.}</{$}>", "</tpl>", "</{operation}>", "</soap:Body>"],
    writeBodyTpl: ["<soap:Body>", '<{operation} xmlns="{targetNamespace}">', '<tpl for="records">', '{% var recordName=values.modelName.split(".").pop(); %}', "<{[recordName]}>", '<tpl for="fields">', "<{name}>{[parent.get(values.name)]}</{name}>", "</tpl>", "</{[recordName]}>", "</tpl>", "</{operation}>", "</soap:Body>"],
    constructor: function(e) {
        this.callParent(arguments);
        this.api = e.api || {};
        this.soapAction = e.soapAction || {}
    },
    doRequest: function(e, t, n) {
        var r = this,
        i = Ext.XTemplate,
        s = e.action,
        o = r.api[s],
        u = Ext.applyIf(e.params || {},
        r.extraParams || {}),
        a = s + "BodyTpl",
        f = i.getTpl(r, "envelopeTpl").apply({
            operation: o,
            targetNamespace: r.targetNamespace,
            params: u,
            records: e.records,
            bodyTpl: i.getTpl(r, r[a] ? a: "writeBodyTpl")
        }),
        l = new Ext.data.Request({
            url: r.url + "?" + r.operationParam + "=" + o,
            method: "POST",
            action: s,
            operation: e,
            xmlData: f,
            headers: Ext.apply({
                SOAPAction: r.soapAction[s]
            },
            r.headers),
            timeout: r.timeout,
            scope: r,
            disableCaching: false
        });
        l.callback = r.createRequestCallback(l, e, t, n);
        Ext.Ajax.request(l);
        return l
    }
});
Ext.define("Ext.dd.DDTarget", {
    extend: Ext.dd.DragDrop,
    constructor: function(e, t, n) {
        if (e) {
            this.initTarget(e, t, n)
        }
    },
    getDragEl: Ext.emptyFn,
    isValidHandleChild: Ext.emptyFn,
    startDrag: Ext.emptyFn,
    endDrag: Ext.emptyFn,
    onDrag: Ext.emptyFn,
    onDragDrop: Ext.emptyFn,
    onDragEnter: Ext.emptyFn,
    onDragOut: Ext.emptyFn,
    onDragOver: Ext.emptyFn,
    onInvalidDrop: Ext.emptyFn,
    onMouseDown: Ext.emptyFn,
    onMouseUp: Ext.emptyFn,
    setXConstraint: Ext.emptyFn,
    setYConstraint: Ext.emptyFn,
    resetConstraints: Ext.emptyFn,
    clearConstraints: Ext.emptyFn,
    clearTicks: Ext.emptyFn,
    setInitPosition: Ext.emptyFn,
    setDragElId: Ext.emptyFn,
    setHandleElId: Ext.emptyFn,
    setOuterHandleElId: Ext.emptyFn,
    addInvalidHandleClass: Ext.emptyFn,
    addInvalidHandleId: Ext.emptyFn,
    addInvalidHandleType: Ext.emptyFn,
    removeInvalidHandleClass: Ext.emptyFn,
    removeInvalidHandleId: Ext.emptyFn,
    removeInvalidHandleType: Ext.emptyFn,
    toString: function() {
        return "DDTarget " + this.id
    }
});
Ext.define("Ext.dd.DragTracker", {
    mixins: {
        observable: Ext.util.Observable
    },
    active: false,
    trackOver: false,
    tolerance: 5,
    autoStart: false,
    constructor: function(e) {
        var t = this;
        Ext.apply(t, e);
        t.addEvents("mouseover", "mouseout", "mousedown", "mouseup", "mousemove", "beforedragstart", "dragstart", "dragend", "drag");
        t.dragRegion = new Ext.util.Region(0, 0, 0, 0);
        if (t.el) {
            t.initEl(t.el)
        }
        t.mixins.observable.constructor.call(t);
        if (t.disabled) {
            t.disable()
        }
    },
    initEl: function(e) {
        var t = this;
        t.el = Ext.get(e);
        t.handle = Ext.get(t.delegate);
        t.delegate = t.handle ? undefined: t.delegate;
        if (!t.handle) {
            t.handle = t.el
        }
        t.handleListeners = {
            scope: t,
            delegate: t.delegate,
            mousedown: t.onMouseDown
        };
        if (t.trackOver || t.overCls) {
            Ext.apply(t.handleListeners, {
                mouseover: t.onMouseOver,
                mouseout: t.onMouseOut
            })
        }
        t.mon(t.handle, t.handleListeners)
    },
    disable: function() {
        this.disabled = true
    },
    enable: function() {
        this.disabled = false
    },
    destroy: function() {
        var e = this;
        if (e.active) {
            e.endDrag({})
        }
        e.clearListeners();
        e.mun(e.handle, e.handleListeners);
        e.el = e.handle = null
    },
    onMouseOver: function(e, t) {
        var n = this,
        r, i, s, o, u;
        if (!n.disabled) {
            if (e.within(t, true, true) || n.delegate) {
                r = n.handleCls;
                n.mouseIsOut = false;
                if (r) {
                    for (s = 0, o = n.handleEls.length; s < o; s++) {
                        i = n.handleEls[s];
                        u = i.delegateCls;
                        if (!u) {
                            u = i.delegateCls = [r, "-", i.region, "-over"].join("")
                        }
                        i.addCls([u, n.overCls])
                    }
                }
                n.fireEvent("mouseover", n, e, n.delegate ? e.getTarget(n.delegate, t) : n.handle)
            }
        }
    },
    onMouseOut: function(e) {
        var t = this,
        n, r, i;
        if (t.mouseIsDown) {
            t.mouseIsOut = true
        } else {
            if (t.handleCls) {
                for (r = 0, i = t.handleEls.length; r < i; r++) {
                    n = t.handleEls[r];
                    n.removeCls([n.delegateCls, t.overCls])
                }
            }
            t.fireEvent("mouseout", t, e)
        }
    },
    onMouseDown: function(e, t) {
        var n = this,
        r;
        if (n.disabled || e.dragTracked) {
            return
        }
        n.dragTarget = n.delegate ? t: n.handle.dom;
        n.startXY = n.lastXY = e.getXY();
        n.startRegion = Ext.fly(n.dragTarget).getRegion();
        if (n.fireEvent("mousedown", n, e) === false || n.fireEvent("beforedragstart", n, e) === false || n.onBeforeStart(e) === false) {
            return
        }
        n.mouseIsDown = true;
        e.dragTracked = true;
        r = n.el.dom;
        if (Ext.isIE && r.setCapture) {
            r.setCapture()
        }
        if (n.preventDefault !== false) {
            e.preventDefault()
        }
        Ext.getDoc().on({
            scope: n,
            mouseup: n.onMouseUp,
            mousemove: n.onMouseMove,
            selectstart: n.stopSelect
        });
        n.dragEnded = false;
        if (!n.tolerance) {
            n.triggerStart()
        } else {
            if (n.autoStart) {
                n.timer = Ext.defer(n.triggerStart, n.autoStart === true ? 1e3: n.autoStart, n, [e])
            }
        }
    },
    onMouseMove: function(e, t) {
        var n = this,
        r = e.getXY(),
        i = n.startXY;
        if (n.dragEnded) {
            return
        }
        n.lastXY = r;
        if (!n.active) {
            if (Math.max(Math.abs(i[0] - r[0]), Math.abs(i[1] - r[1])) > n.tolerance) {
                n.triggerStart(e)
            } else {
                return
            }
        }
        if (n.fireEvent("mousemove", n, e) === false) {
            n.onMouseUp(e)
        } else {
            n.onDrag(e);
            n.fireEvent("drag", n, e)
        }
    },
    onMouseUp: function(e) {
        var t = this;
        t.mouseIsDown = false;
        if (t.mouseIsOut) {
            t.mouseIsOut = false;
            t.onMouseOut(e)
        }
        e.preventDefault();
        if (Ext.isIE && document.releaseCapture) {
            document.releaseCapture()
        }
        t.fireEvent("mouseup", t, e);
        t.endDrag(e)
    },
    endDrag: function(e) {
        var t = this,
        n = t.active;
        Ext.getDoc().un({
            mousemove: t.onMouseMove,
            mouseup: t.onMouseUp,
            selectstart: t.stopSelect,
            scope: t
        });
        t.clearStart();
        t.active = false;
        if (n) {
            t.dragEnded = true;
            t.onEnd(e);
            t.fireEvent("dragend", t, e)
        }
        t._constrainRegion = Ext.EventObject.dragTracked = null
    },
    triggerStart: function(e) {
        var t = this;
        t.clearStart();
        t.active = true;
        t.onStart(e);
        t.fireEvent("dragstart", t, e)
    },
    clearStart: function() {
        var e = this.timer;
        if (e) {
            clearTimeout(e);
            this.timer = null
        }
    },
    stopSelect: function(e) {
        e.stopEvent();
        return false
    },
    onBeforeStart: function(e) {},
    onStart: function(e) {},
    onDrag: function(e) {},
    onEnd: function(e) {},
    getDragTarget: function() {
        return this.dragTarget
    },
    getDragCt: function() {
        return this.el
    },
    getConstrainRegion: function() {
        var e = this;
        if (e.constrainTo) {
            if (e.constrainTo instanceof Ext.util.Region) {
                return e.constrainTo
            }
            if (!e._constrainRegion) {
                e._constrainRegion = Ext.fly(e.constrainTo).getViewRegion()
            }
        } else {
            if (!e._constrainRegion) {
                e._constrainRegion = e.getDragCt().getViewRegion()
            }
        }
        return e._constrainRegion
    },
    getXY: function(e) {
        return e ? this.constrainModes[e](this, this.lastXY) : this.lastXY
    },
    getOffset: function(e) {
        var t = this.getXY(e),
        n = this.startXY;
        return [t[0] - n[0], t[1] - n[1]]
    },
    constrainModes: {
        point: function(e, t) {
            var n = e.dragRegion,
            r = e.getConstrainRegion();
            if (!r) {
                return t
            }
            n.x = n.left = n[0] = n.right = t[0];
            n.y = n.top = n[1] = n.bottom = t[1];
            n.constrainTo(r);
            return [n.left, n.top]
        },
        dragTarget: function(e, t) {
            var n = e.startXY,
            r = e.startRegion.copy(),
            i = e.getConstrainRegion(),
            s;
            if (!i) {
                return t
            }
            r.translateBy(t[0] - n[0], t[1] - n[1]);
            if (r.right > i.right) {
                t[0] += s = i.right - r.right;
                r.left += s
            }
            if (r.left < i.left) {
                t[0] += i.left - r.left
            }
            if (r.bottom > i.bottom) {
                t[1] += s = i.bottom - r.bottom;
                r.top += s
            }
            if (r.top < i.top) {
                t[1] += i.top - r.top
            }
            return t
        }
    }
});
Ext.define("Ext.dd.DragZone", {
    extend: Ext.dd.DragSource,
    constructor: function(e, t) {
        var n = this,
        r = n.containerScroll;
        n.callParent([e, t]);
        if (r) {
            e = n.scrollEl || e;
            e = Ext.get(e);
            if (Ext.isObject(r)) {
                e.ddScrollConfig = r
            }
            Ext.dd.ScrollManager.register(e)
        }
    },
    getDragData: function(e) {
        return Ext.dd.Registry.getHandleFromEvent(e)
    },
    onInitDrag: function(e, t) {
        this.proxy.update(this.dragData.ddel.cloneNode(true));
        this.onStartDrag(e, t);
        return true
    },
    getRepairXY: function(e) {
        return Ext.fly(this.dragData.ddel).getXY()
    },
    destroy: function() {
        this.callParent();
        if (this.containerScroll) {
            Ext.dd.ScrollManager.unregister(this.scrollEl || this.el)
        }
    }
});
Ext.define("Ext.dd.ScrollManager", {
    singleton: true,
    constructor: function() {
        var e = Ext.dd.DragDropManager;
        e.fireEvents = Ext.Function.createSequence(e.fireEvents, this.onFire, this);
        e.stopDrag = Ext.Function.createSequence(e.stopDrag, this.onStop, this);
        this.doScroll = Ext.Function.bind(this.doScroll, this);
        this.ddmInstance = e;
        this.els = {};
        this.dragEl = null;
        this.proc = {}
    },
    onStop: function(e) {
        var t = Ext.dd.ScrollManager;
        t.dragEl = null;
        t.clearProc()
    },
    triggerRefresh: function() {
        if (this.ddmInstance.dragCurrent) {
            this.ddmInstance.refreshCache(this.ddmInstance.dragCurrent.groups)
        }
    },
    doScroll: function() {
        if (this.ddmInstance.dragCurrent) {
            var e = this.proc,
            t = e.el,
            n = e.el.ddScrollConfig,
            r = n && n.increment ? n.increment: this.increment,
            i = n && "animate" in n ? n.animate: this.animate;
            if (!i) {
                if (t.scroll(e.dir, r)) {
                    this.triggerRefresh()
                }
            } else {
                t.scroll(e.dir, r, true, this.animDuration, this.triggerRefresh)
            }
        }
    },
    clearProc: function() {
        var e = this.proc;
        if (e.id) {
            clearInterval(e.id)
        }
        e.id = 0;
        e.el = null;
        e.dir = ""
    },
    startProc: function(e, t) {
        this.clearProc();
        this.proc.el = e;
        this.proc.dir = t;
        var n = e.ddScrollConfig ? e.ddScrollConfig.ddGroup: undefined,
        r = e.ddScrollConfig && e.ddScrollConfig.frequency ? e.ddScrollConfig.frequency: this.frequency;
        if (n === undefined || this.ddmInstance.dragCurrent.ddGroup == n) {
            this.proc.id = setInterval(this.doScroll, r)
        }
    },
    onFire: function(e, t) {
        if (t || !this.ddmInstance.dragCurrent) {
            return
        }
        if (!this.dragEl || this.dragEl != this.ddmInstance.dragCurrent) {
            this.dragEl = this.ddmInstance.dragCurrent;
            this.refreshCache()
        }
        var n = e.getPoint(),
        r = this.proc,
        i = this.els,
        s,
        o,
        u,
        a;
        for (s in i) {
            o = i[s];
            u = o._region;
            a = o.ddScrollConfig ? o.ddScrollConfig: this;
            if (u && u.contains(n) && o.isScrollable()) {
                if (u.bottom - n.y <= a.vthresh) {
                    if (r.el != o) {
                        this.startProc(o, "down")
                    }
                    return
                } else {
                    if (u.right - n.x <= a.hthresh) {
                        if (r.el != o) {
                            this.startProc(o, "right")
                        }
                        return
                    } else {
                        if (n.y - u.top <= a.vthresh) {
                            if (r.el != o) {
                                this.startProc(o, "up")
                            }
                            return
                        } else {
                            if (n.x - u.left <= a.hthresh) {
                                if (r.el != o) {
                                    this.startProc(o, "left")
                                }
                                return
                            }
                        }
                    }
                }
            }
        }
        this.clearProc()
    },
    register: function(e) {
        if (Ext.isArray(e)) {
            for (var t = 0,
            n = e.length; t < n; t++) {
                this.register(e[t])
            }
        } else {
            e = Ext.get(e);
            this.els[e.id] = e
        }
    },
    unregister: function(e) {
        if (Ext.isArray(e)) {
            for (var t = 0,
            n = e.length; t < n; t++) {
                this.unregister(e[t])
            }
        } else {
            e = Ext.get(e);
            delete this.els[e.id]
        }
    },
    vthresh: 25,
    hthresh: 25,
    increment: 100,
    frequency: 500,
    animate: true,
    animDuration: .4,
    ddGroup: undefined,
    refreshCache: function() {
        var e = this.els,
        t;
        for (t in e) {
            if (typeof e[t] == "object") {
                e[t]._region = e[t].getRegion()
            }
        }
    }
});
Ext.define("Ext.dd.DropTarget", {
    extend: Ext.dd.DDTarget,
    constructor: function(e, t) {
        this.el = Ext.get(e);
        Ext.apply(this, t);
        if (this.containerScroll) {
            Ext.dd.ScrollManager.register(this.el)
        }
        this.callParent([this.el.dom, this.ddGroup || this.group, {
            isTarget: true
        }])
    },
    dropAllowed: Ext.baseCSSPrefix + "dd-drop-ok",
    dropNotAllowed: Ext.baseCSSPrefix + "dd-drop-nodrop",
    isTarget: true,
    isNotifyTarget: true,
    notifyEnter: function(e, t, n) {
        if (this.overClass) {
            this.el.addCls(this.overClass)
        }
        return this.dropAllowed
    },
    notifyOver: function(e, t, n) {
        return this.dropAllowed
    },
    notifyOut: function(e, t, n) {
        if (this.overClass) {
            this.el.removeCls(this.overClass)
        }
    },
    notifyDrop: function(e, t, n) {
        return false
    },
    destroy: function() {
        this.callParent();
        if (this.containerScroll) {
            Ext.dd.ScrollManager.unregister(this.el)
        }
    }
});
Ext.define("Ext.dd.Registry", {
    singleton: true,
    constructor: function() {
        this.elements = {};
        this.handles = {};
        this.autoIdSeed = 0
    },
    getId: function(e, t) {
        if (typeof e == "string") {
            return e
        }
        var n = e.id;
        if (!n && t !== false) {
            n = "extdd-" + ++this.autoIdSeed;
            e.id = n
        }
        return n
    },
    register: function(e, t) {
        t = t || {};
        if (typeof e == "string") {
            e = document.getElementById(e)
        }
        t.ddel = e;
        this.elements[this.getId(e)] = t;
        if (t.isHandle !== false) {
            this.handles[t.ddel.id] = t
        }
        if (t.handles) {
            var n = t.handles,
            r, i;
            for (r = 0, i = n.length; r < i; r++) {
                this.handles[this.getId(n[r])] = t
            }
        }
    },
    unregister: function(e) {
        var t = this.getId(e, false),
        n = this.elements[t],
        r,
        i,
        s;
        if (n) {
            delete this.elements[t];
            if (n.handles) {
                r = n.handles;
                for (i = 0, s = r.length; i < s; i++) {
                    delete this.handles[this.getId(r[i], false)]
                }
            }
        }
    },
    getHandle: function(e) {
        if (typeof e != "string") {
            e = e.id
        }
        return this.handles[e]
    },
    getHandleFromEvent: function(e) {
        var t = e.getTarget();
        return t ? this.handles[t.id] : null
    },
    getTarget: function(e) {
        if (typeof e != "string") {
            e = e.id
        }
        return this.elements[e]
    },
    getTargetFromEvent: function(e) {
        var t = e.getTarget();
        return t ? this.elements[t.id] || this.handles[t.id] : null
    }
});
Ext.define("Ext.dd.DropZone", {
    extend: Ext.dd.DropTarget,
    getTargetFromEvent: function(e) {
        return Ext.dd.Registry.getTargetFromEvent(e)
    },
    onNodeEnter: function(e, t, n, r) {},
    onNodeOver: function(e, t, n, r) {
        return this.dropAllowed
    },
    onNodeOut: function(e, t, n, r) {},
    onNodeDrop: function(e, t, n, r) {
        return false
    },
    onContainerOver: function(e, t, n) {
        return this.dropNotAllowed
    },
    onContainerDrop: function(e, t, n) {
        return false
    },
    notifyEnter: function(e, t, n) {
        return this.dropNotAllowed
    },
    notifyOver: function(e, t, n) {
        var r = this.getTargetFromEvent(t);
        if (!r) {
            if (this.lastOverNode) {
                this.onNodeOut(this.lastOverNode, e, t, n);
                this.lastOverNode = null
            }
            return this.onContainerOver(e, t, n)
        }
        if (this.lastOverNode != r) {
            if (this.lastOverNode) {
                this.onNodeOut(this.lastOverNode, e, t, n)
            }
            this.onNodeEnter(r, e, t, n);
            this.lastOverNode = r
        }
        return this.onNodeOver(r, e, t, n)
    },
    notifyOut: function(e, t, n) {
        if (this.lastOverNode) {
            this.onNodeOut(this.lastOverNode, e, t, n);
            this.lastOverNode = null
        }
    },
    notifyDrop: function(e, t, n) {
        var r = this,
        i = r.getTargetFromEvent(t),
        s = i ? r.onNodeDrop(i, e, t, n) : r.onContainerDrop(e, t, n);
        if (r.lastOverNode) {
            r.onNodeOut(r.lastOverNode, e, t, n);
            r.lastOverNode = null
        }
        return s
    },
    triggerCacheRefresh: function() {
        Ext.dd.DDM.refreshCache(this.groups)
    }
});
Ext.define("Ext.direct.Transaction", {
    alias: "direct.transaction",
    alternateClassName: "Ext.Direct.Transaction",
    statics: {
        TRANSACTION_ID: 0
    },
    constructor: function(e) {
        var t = this;
        Ext.apply(t, e);
        t.id = t.tid = ++t.self.TRANSACTION_ID;
        t.retryCount = 0
    },
    send: function() {
        var e = this;
        e.provider.queueTransaction(e)
    },
    retry: function() {
        var e = this;
        e.retryCount++;
        e.send()
    },
    getProvider: function() {
        return this.provider
    }
});
Ext.define("Ext.direct.RemotingMethod", {
    constructor: function(e) {
        var t = this,
        n = Ext.isDefined(e.params) ? e.params: e.len,
        r,
        i,
        s,
        o;
        t.name = e.name;
        t.formHandler = e.formHandler;
        if (Ext.isNumeric(n)) {
            t.len = n;
            t.ordered = true
        } else {
            t.strict = e.strict !== undefined ? e.strict: true;
            t.params = {};
            i = n.length;
            for (s = 0; s < i; s++) {
                o = n[s];
                r = Ext.isObject(o) ? o.name: o;
                t.params[r] = true
            }
        }
    },
    getArgs: function(e, t, n) {
        var r = this,
        i = [],
        s,
        o;
        if (r.ordered) {
            if (r.len > 0) {
                if (t) {
                    for (s = 0, o = t.length; s < o; s++) {
                        i.push(e[t[s]])
                    }
                } else {
                    if (n) {
                        i.push(e)
                    }
                }
            }
        } else {
            i.push(e)
        }
        return i
    },
    getCallData: function(e) {
        var t = this,
        n = null,
        r = t.len,
        i = t.params,
        s = t.strict,
        o, u, a, f;
        if (t.ordered) {
            o = e[r];
            u = e[r + 1];
            f = e[r + 2];
            if (r !== 0) {
                n = e.slice(0, r)
            }
        } else {
            n = Ext.apply({},
            e[0]);
            o = e[1];
            u = e[2];
            f = e[3];
            if (s) {
                for (a in n) {
                    if (n.hasOwnProperty(a) && !i[a]) {
                        delete n[a]
                    }
                }
            }
        }
        return {
            data: n,
            callback: o,
            scope: u,
            options: f
        }
    }
});
Ext.define("Ext.direct.Event", {
    alias: "direct.event",
    status: true,
    constructor: function(e) {
        Ext.apply(this, e)
    },
    getName: function() {
        return this.name
    },
    getData: function() {
        return this.data
    }
});
Ext.define("Ext.direct.RemotingEvent", {
    extend: Ext.direct.Event,
    alias: "direct.rpc",
    getTransaction: function() {
        var e = this;
        return e.transaction || Ext.direct.Manager.getTransaction(e.tid)
    }
});
Ext.define("Ext.direct.ExceptionEvent", {
    extend: Ext.direct.RemotingEvent,
    alias: "direct.exception",
    status: false
});
Ext.define("Ext.direct.AmfRemotingProvider", {
    alias: "direct.amfremotingprovider",
    extend: Ext.direct.Provider,
    binary: false,
    maxRetries: 1,
    timeout: undefined,
    constructor: function(e) {
        var t = this;
        t.callParent(arguments);
        t.addEvents("beforecall", "call");
        t.namespace = Ext.isString(t.namespace) ? Ext.ns(t.namespace) : t.namespace || window;
        t.transactions = new Ext.util.MixedCollection;
        t.callBuffer = []
    },
    initAPI: function() {
        var e = this.actions,
        t = this.namespace,
        n, r, i, s, o, u;
        for (n in e) {
            if (e.hasOwnProperty(n)) {
                r = t[n];
                if (!r) {
                    r = t[n] = {}
                }
                i = e[n];
                for (s = 0, o = i.length; s < o; ++s) {
                    u = new Ext.direct.RemotingMethod(i[s]);
                    r[u.name] = this.createHandler(n, u)
                }
            }
        }
    },
    createHandler: function(e, t) {
        var n = this,
        r;
        if (!t.formHandler) {
            r = function() {
                n.configureRequest(e, t, Array.prototype.slice.call(arguments, 0))
            }
        } else {
            r = function(r, i, s) {
                n.configureFormRequest(e, t, r, i, s)
            }
        }
        r.directCfg = {
            action: e,
            method: t
        };
        return r
    },
    isConnected: function() {
        return !! this.connected
    },
    connect: function() {
        var e = this;
        if (e.url) {
            e.clientId = Ext.data.amf.XmlEncoder.generateFlexUID();
            e.initAPI();
            e.connected = true;
            e.fireEvent("connect", e);
            e.DSId = null
        } else {
            if (!e.url) {}
        }
    },
    disconnect: function() {
        var e = this;
        if (e.connected) {
            e.connected = false;
            e.fireEvent("disconnect", e)
        }
    },
    runCallback: function(e, t) {
        var n = !!t.status,
        r = n ? "success": "failure",
        i,
        s;
        if (e && e.callback) {
            i = e.callback;
            s = Ext.isDefined(t.result) ? t.result: t.data;
            if (Ext.isFunction(i)) {
                i(s, t, n)
            } else {
                Ext.callback(i[r], i.scope, [s, t, n]);
                Ext.callback(i.callback, i.scope, [s, t, n])
            }
        }
    },
    onData: function(e, t, n) {
        var r = this,
        i = 0,
        s, o, u, a, f;
        if (t) {
            o = r.createEvents(n);
            for (s = o.length; i < s; ++i) {
                u = o[i];
                a = r.getTransaction(u);
                r.fireEvent("data", r, u);
                if (a) {
                    r.runCallback(a, u, true);
                    Ext.direct.Manager.removeTransaction(a)
                }
            }
        } else {
            f = [].concat(e.transaction);
            for (s = f.length; i < s; ++i) {
                a = r.getTransaction(f[i]);
                if (a && a.retryCount < r.maxRetries) {
                    a.retry()
                } else {
                    u = new Ext.direct.ExceptionEvent({
                        data: null,
                        transaction: a,
                        code: Ext.direct.Manager.exceptions.TRANSPORT,
                        message: "Unable to connect to the server.",
                        xhr: n
                    });
                    r.fireEvent("data", r, u);
                    if (a) {
                        r.runCallback(a, u, false);
                        Ext.direct.Manager.removeTransaction(a)
                    }
                }
            }
        }
    },
    getTransaction: function(e) {
        return e && e.tid ? Ext.direct.Manager.getTransaction(e.tid) : null
    },
    configureRequest: function(e, t, n) {
        var r = this,
        i = t.getCallData(n),
        s = i.data,
        o = i.callback,
        u = i.scope,
        a;
        a = new Ext.direct.Transaction({
            provider: r,
            args: n,
            action: e,
            method: t.name,
            data: s,
            callback: u && Ext.isFunction(o) ? Ext.Function.bind(o, u) : o
        });
        if (r.fireEvent("beforecall", r, a, t) !== false) {
            Ext.direct.Manager.addTransaction(a);
            r.queueTransaction(a);
            r.fireEvent("call", r, a, t)
        }
    },
    getCallData: function(e) {
        if (this.binary) {
            return {
                targetUri: e.action + "." + e.method,
                responseUri: "/" + e.id,
                body: e.data || []
            }
        } else {
            return new Ext.data.amf.RemotingMessage({
                body: e.data || [],
                clientId: this.clientId,
                destination: e.action,
                headers: {
                    DSEndpoint: this.endpoint,
                    DSId: this.DSId || "nil"
                },
                messageId: Ext.data.amf.XmlEncoder.generateFlexUID(e.id),
                operation: e.method,
                timestamp: 0,
                timeToLive: 0
            })
        }
    },
    sendRequest: function(e) {
        var t = this,
        n = {
            url: t.url,
            callback: t.onData,
            scope: t,
            transaction: e,
            timeout: t.timeout
        },
        r,
        i = 0,
        s,
        o,
        u,
        a = [],
        f = [];
        if (Ext.isArray(e)) {
            for (s = e.length; i < s; ++i) {
                a.push(t.getCallData(e[i]))
            }
        } else {
            a.push(t.getCallData(e))
        }
        if (t.binary) {
            u = new Ext.data.amf.Encoder({
                format: 0
            });
            u.writeAmfPacket(f, a);
            n.binaryData = u.bytes;
            n.binary = true;
            n.headers = {
                "Content-Type": "application/x-amf"
            }
        } else {
            u = new Ext.data.amf.XmlEncoder;
            u.writeAmfxRemotingPacket(a[0]);
            n.xmlData = u.body
        }
        Ext.Ajax.request(n)
    },
    queueTransaction: function(e) {
        var t = this,
        n = false;
        if (e.form) {
            t.sendFormRequest(e);
            return
        }
        t.callBuffer.push(e);
        if (n) {
            if (!t.callTask) {
                t.callTask = new Ext.util.DelayedTask(t.combineAndSend, t)
            }
            t.callTask.delay(Ext.isNumber(n) ? n: 10)
        } else {
            t.combineAndSend()
        }
    },
    combineAndSend: function() {
        var e = this.callBuffer,
        t = e.length;
        if (t > 0) {
            this.sendRequest(t == 1 ? e[0] : e);
            this.callBuffer = []
        }
    },
    configureFormRequest: function(e, t, n, r, i) {},
    sendFormRequest: function(e) {},
    createEvents: function(e) {
        var t = null,
        n = [],
        r = [],
        i,
        s = 0,
        o,
        u;
        try {
            if (this.binary) {
                u = new Ext.data.amf.Packet;
                t = u.decode(e.responseBytes)
            } else {
                u = new Ext.data.amf.XmlDecoder;
                t = u.readAmfxMessage(e.responseText)
            }
        } catch(a) {
            i = new Ext.direct.ExceptionEvent({
                data: a,
                xhr: e,
                code: Ext.direct.Manager.exceptions.PARSE,
                message: "Error parsing AMF response: \n\n " + t
            });
            return [i]
        }
        if (this.binary) {
            for (s = 0; s < t.messages.length; s++) {
                r.push(this.createEvent(t.messages[s]))
            }
        } else {
            r.push(this.createEvent(t))
        }
        return r
    },
    createEvent: function(e) {
        var t = e.targetURI.split("/"),
        n,
        r,
        i,
        s,
        o = this;
        if (o.binary) {
            n = t[1];
            s = 2
        } else {
            n = Ext.data.amf.XmlDecoder.decodeTidFromFlexUID(e.message.correlationId);
            s = 1
        }
        if (t[s] == "onStatus") {
            i = {
                tid: n,
                data: o.binary ? e.body: e.message
            };
            r = Ext.create("direct.exception", i)
        } else {
            if (t[s] == "onResult") {
                i = {
                    tid: n,
                    data: o.binary ? e.body: e.message.body
                };
                r = Ext.create("direct.rpc", i)
            } else {}
        }
        return r
    }
});
Ext.define("Ext.direct.JsonProvider", {
    extend: Ext.direct.Provider,
    alias: "direct.jsonprovider",
    parseResponse: function(e) {
        if (!Ext.isEmpty(e.responseText)) {
            if (Ext.isObject(e.responseText)) {
                return e.responseText
            }
            return Ext.decode(e.responseText)
        }
        return null
    },
    createEvents: function(e) {
        var t = this,
        n = null,
        r = [],
        i,
        s,
        o;
        try {
            n = t.parseResponse(e)
        } catch(u) {
            i = new Ext.direct.ExceptionEvent({
                data: u,
                xhr: e,
                code: Ext.direct.Manager.exceptions.PARSE,
                message: "Error parsing json response: \n\n " + u
            });
            return [i]
        }
        if (Ext.isArray(n)) {
            for (s = 0, o = n.length; s < o; ++s) {
                r.push(t.createEvent(n[s]))
            }
        } else {
            if (Ext.isObject(n)) {
                r.push(t.createEvent(n))
            }
        }
        return r
    },
    createEvent: function(e) {
        if (typeof e !== "object" || !("type" in e)) {
            return new Ext.direct.ExceptionEvent({
                data: e,
                code: Ext.direct.Manager.exceptions.DATA,
                message: "Invalid data: event type is not specified"
            })
        }
        return Ext.create("direct." + e.type, e)
    }
});
Ext.define("Ext.direct.PollingProvider", {
    extend: Ext.direct.JsonProvider,
    alias: "direct.pollingprovider",
    interval: 3e3,
    constructor: function(e) {
        var t = this;
        t.callParent(arguments);
        t.addEvents("beforepoll", "poll")
    },
    isConnected: function() {
        return !! this.pollTask
    },
    connect: function() {
        var e = this,
        t = e.url;
        if (t && !e.pollTask) {
            e.pollTask = Ext.TaskManager.start({
                run: e.runPoll,
                interval: e.interval,
                scope: e
            });
            e.fireEvent("connect", e)
        }
    },
    disconnect: function() {
        var e = this;
        if (e.pollTask) {
            Ext.TaskManager.stop(e.pollTask);
            delete e.pollTask;
            e.fireEvent("disconnect", e)
        }
    },
    runPoll: function() {
        var e = this,
        t = e.url;
        if (e.fireEvent("beforepoll", e) !== false) {
            if (Ext.isFunction(t)) {
                t(e.baseParams)
            } else {
                Ext.Ajax.request({
                    url: t,
                    callback: e.onData,
                    scope: e,
                    params: e.baseParams
                })
            }
            e.fireEvent("poll", e)
        }
    },
    onData: function(e, t, n) {
        var r = this,
        i, s, o;
        if (t) {
            o = r.createEvents(n);
            for (i = 0, s = o.length; i < s; ++i) {
                r.fireEvent("data", r, o[i])
            }
        } else {
            o = new Ext.direct.ExceptionEvent({
                data: null,
                code: Ext.direct.Manager.exceptions.TRANSPORT,
                message: "Unable to connect to the server.",
                xhr: n
            });
            r.fireEvent("data", r, o)
        }
    }
});
Ext.define("Ext.direct.RemotingProvider", {
    extend: Ext.direct.JsonProvider,
    alias: "direct.remotingprovider",
    enableBuffer: 10,
    maxRetries: 1,
    constructor: function(e) {
        var t = this;
        t.callParent(arguments);
        t.addEvents("beforecall", "call", "beforecallback");
        t.namespace = Ext.isString(t.namespace) ? Ext.ns(t.namespace) : t.namespace || Ext.global;
        t.transactions = new Ext.util.MixedCollection;
        t.callBuffer = []
    },
    getNamespace: function(e, t) {
        var n, r, i, s;
        e = e || Ext.global;
        n = t.toString().split(".");
        for (i = 0, s = n.length; i < s; i++) {
            r = n[i];
            e = e[r];
            if (typeof e === "undefined") {
                return e
            }
        }
        return e
    },
    createNamespaces: function(e, t) {
        var n, r;
        e = e || Ext.global;
        n = t.toString().split(".");
        for (var i = 0,
        s = n.length; i < s; i++) {
            r = n[i];
            e[r] = e[r] || {};
            e = e[r]
        }
        return e
    },
    initAPI: function() {
        var e = this,
        t = e.actions,
        n = e.namespace,
        r, i, s, o, u, a;
        for (r in t) {
            if (t.hasOwnProperty(r)) {
                if (e.disableNestedActions) {
                    i = n[r];
                    if (!i) {
                        i = n[r] = {}
                    }
                } else {
                    i = e.getNamespace(n, r);
                    if (!i) {
                        i = e.createNamespaces(n, r)
                    }
                }
                s = t[r];
                for (o = 0, u = s.length; o < u; ++o) {
                    a = new Ext.direct.RemotingMethod(s[o]);
                    i[a.name] = e.createHandler(r, a)
                }
            }
        }
    },
    createHandler: function(e, t) {
        var n = this,
        r = Array.prototype.slice,
        i;
        if (!t.formHandler) {
            i = function() {
                n.configureRequest(e, t, r.call(arguments, 0))
            }
        } else {
            i = function() {
                n.configureFormRequest(e, t, r.call(arguments, 0))
            }
        }
        i.directCfg = {
            action: e,
            method: t
        };
        return i
    },
    isConnected: function() {
        return !! this.connected
    },
    connect: function() {
        var e = this;
        if (e.url) {
            e.initAPI();
            e.connected = true;
            e.fireEvent("connect", e)
        }
    },
    disconnect: function() {
        var e = this;
        if (e.connected) {
            e.connected = false;
            e.fireEvent("disconnect", e)
        }
    },
    runCallback: function(e, t) {
        var n = !!t.status,
        r = n ? "success": "failure",
        i,
        s,
        o;
        if (e && e.callback) {
            i = e.callback;
            s = e.callbackOptions;
            o = typeof t.result !== "undefined" ? t.result: t.data;
            if (Ext.isFunction(i)) {
                i(o, t, n, s)
            } else {
                Ext.callback(i[r], i.scope, [o, t, n, s]);
                Ext.callback(i.callback, i.scope, [o, t, n, s])
            }
        }
    },
    onData: function(e, t, n) {
        var r = this,
        i, s, o, u, a, f;
        if (t) {
            o = r.createEvents(n);
            for (i = 0, s = o.length; i < s; ++i) {
                u = o[i];
                a = r.getTransaction(u);
                r.fireEvent("data", r, u);
                if (a && r.fireEvent("beforecallback", r, u, a) !== false) {
                    r.runCallback(a, u, true);
                    Ext.direct.Manager.removeTransaction(a)
                }
            }
        } else {
            f = [].concat(e.transaction);
            for (i = 0, s = f.length; i < s; ++i) {
                a = r.getTransaction(f[i]);
                if (a && a.retryCount < r.maxRetries) {
                    a.retry()
                } else {
                    u = new Ext.direct.ExceptionEvent({
                        data: null,
                        transaction: a,
                        code: Ext.direct.Manager.exceptions.TRANSPORT,
                        message: "Unable to connect to the server.",
                        xhr: n
                    });
                    r.fireEvent("data", r, u);
                    if (a && r.fireEvent("beforecallback", r, a) !== false) {
                        r.runCallback(a, u, false);
                        Ext.direct.Manager.removeTransaction(a)
                    }
                }
            }
        }
    },
    getTransaction: function(e) {
        return e && e.tid ? Ext.direct.Manager.getTransaction(e.tid) : null
    },
    configureRequest: function(e, t, n) {
        var r = this,
        i, s, o, u, a, f, l;
        i = t.getCallData(n);
        s = i.data;
        o = i.callback;
        u = i.scope;
        a = i.options || {};
        l = Ext.apply({},
        {
            provider: r,
            args: n,
            action: e,
            method: t.name,
            data: s,
            callbackOptions: a,
            callback: u && Ext.isFunction(o) ? Ext.Function.bind(o, u) : o
        });
        if (a.timeout) {
            Ext.applyIf(l, {
                timeout: a.timeout
            })
        }
        f = new Ext.direct.Transaction(l);
        if (r.fireEvent("beforecall", r, f, t) !== false) {
            Ext.direct.Manager.addTransaction(f);
            r.queueTransaction(f);
            r.fireEvent("call", r, f, t)
        }
    },
    getCallData: function(e) {
        return {
            action: e.action,
            method: e.method,
            data: e.data,
            type: "rpc",
            tid: e.id
        }
    },
    sendRequest: function(e) {
        var t = this,
        n, r, i, s = t.enableUrlEncode,
        o, u;
        n = {
            url: t.url,
            callback: t.onData,
            scope: t,
            transaction: e,
            timeout: t.timeout
        };
        if (e.timeout) {
            n.timeout = e.timeout
        }
        if (Ext.isArray(e)) {
            r = [];
            for (o = 0, u = e.length; o < u; ++o) {
                r.push(t.getCallData(e[o]))
            }
        } else {
            r = t.getCallData(e)
        }
        if (s) {
            i = {};
            i[Ext.isString(s) ? s: "data"] = Ext.encode(r);
            n.params = i
        } else {
            n.jsonData = r
        }
        Ext.Ajax.request(n)
    },
    queueTransaction: function(e) {
        var t = this,
        n = t.enableBuffer;
        if (e.form) {
            t.sendFormRequest(e);
            return
        }
        if (n === false || typeof e.timeout !== "undefined") {
            t.sendRequest(e);
            return
        }
        t.callBuffer.push(e);
        if (n) {
            if (!t.callTask) {
                t.callTask = new Ext.util.DelayedTask(t.combineAndSend, t)
            }
            t.callTask.delay(Ext.isNumber(n) ? n: 10)
        } else {
            t.combineAndSend()
        }
    },
    combineAndSend: function() {
        var e = this,
        t = e.callBuffer,
        n = t.length;
        if (n > 0) {
            e.sendRequest(n == 1 ? t[0] : t);
            e.callBuffer = []
        }
    },
    configureFormRequest: function(e, t, n) {
        var r = this,
        i = n[0],
        s = n[1],
        o = n[2],
        u,
        a,
        f;
        u = new Ext.direct.Transaction({
            provider: r,
            action: e,
            method: t.name,
            args: [i, s, o],
            callback: o && Ext.isFunction(s) ? Ext.Function.bind(s, o) : s,
            isForm: true
        });
        if (r.fireEvent("beforecall", r, u, t) !== false) {
            Ext.direct.Manager.addTransaction(u);
            a = String(i.getAttribute("enctype")).toLowerCase() == "multipart/form-data";
            f = {
                extTID: u.id,
                extAction: e,
                extMethod: t.name,
                extType: "rpc",
                extUpload: String(a)
            };
            Ext.apply(u, {
                form: Ext.getDom(i),
                isUpload: a,
                params: s && Ext.isObject(s.params) ? Ext.apply(f, s.params) : f
            });
            r.fireEvent("call", r, u, t);
            r.sendFormRequest(u)
        }
    },
    sendFormRequest: function(e) {
        var t = this;
        Ext.Ajax.request({
            url: t.url,
            params: e.params,
            callback: t.onData,
            scope: t,
            form: e.form,
            isUpload: e.isUpload,
            transaction: e
        })
    }
});
Ext.define("Ext.dom.Layer", {
    extend: Ext.Element,
    alternateClassName: "Ext.Layer",
    statics: {
        shims: []
    },
    isLayer: true,
    localXYNames: {
        get: "getLocalXY",
        set: "setLocalXY"
    },
    constructor: function(e, t) {
        e = e || {};
        var n = this,
        r = Ext.DomHelper,
        i = e.parentEl,
        s = i ? Ext.getDom(i) : document.body,
        o = e.hideMode,
        u = Ext.baseCSSPrefix + (e.fixed && !(Ext.isIE6 || Ext.isIEQuirks) ? "fixed-layer": "layer");
        n.el = n;
        if (t) {
            n.dom = Ext.getDom(t)
        }
        if (!n.dom) {
            n.dom = r.append(s, e.dh || {
                tag: "div",
                cls: u
            })
        } else {
            n.addCls(u);
            if (!n.dom.parentNode) {
                s.appendChild(n.dom)
            }
        }
        if (e.preventSync) {
            n.preventSync = true
        }
        if (e.id) {
            n.id = n.dom.id = e.id
        } else {
            n.id = Ext.id(n.dom)
        }
        Ext.Element.addToCache(n);
        if (e.cls) {
            n.addCls(e.cls)
        }
        n.constrain = e.constrain !== false;
        if (o) {
            n.setVisibilityMode(Ext.Element[o.toUpperCase()]);
            if (n.visibilityMode == Ext.Element.ASCLASS) {
                n.visibilityCls = e.visibilityCls
            }
        } else {
            if (e.useDisplay) {
                n.setVisibilityMode(Ext.Element.DISPLAY)
            } else {
                n.setVisibilityMode(Ext.Element.VISIBILITY)
            }
        }
        if (e.shadow) {
            n.shadowOffset = e.shadowOffset || 4;
            n.shadow = new Ext.Shadow({
                offset: n.shadowOffset,
                mode: e.shadow,
                fixed: e.fixed
            });
            n.disableShadow()
        } else {
            n.shadowOffset = 0
        }
        n.useShim = e.shim !== false && Ext.useShims;
        if (e.hidden === true) {
            n.hide()
        } else {
            if (e.hidden === false) {
                n.show()
            }
        }
    },
    getZIndex: function() {
        return parseInt((this.getShim() || this).getStyle("z-index"), 10)
    },
    getShim: function() {
        var e = this,
        t, n;
        if (!e.useShim) {
            return null
        }
        if (!e.shim) {
            t = e.self.shims.shift();
            if (!t) {
                t = e.createShim();
                t.enableDisplayMode("block");
                t.hide()
            }
            n = e.dom.parentNode;
            if (t.dom.parentNode != n) {
                n.insertBefore(t.dom, e.dom)
            }
            e.shim = t
        }
        return e.shim
    },
    hideShim: function() {
        var e = this;
        if (e.shim) {
            e.shim.setDisplayed(false);
            e.self.shims.push(e.shim);
            delete e.shim
        }
    },
    disableShadow: function() {
        var e = this;
        if (e.shadow && !e.shadowDisabled) {
            e.shadowDisabled = true;
            e.shadow.hide();
            e.lastShadowOffset = e.shadowOffset;
            e.shadowOffset = 0
        }
    },
    enableShadow: function(e) {
        var t = this;
        if (t.shadow && t.shadowDisabled) {
            t.shadowDisabled = false;
            t.shadowOffset = t.lastShadowOffset;
            delete t.lastShadowOffset;
            if (e) {
                t.sync(true)
            }
        }
    },
    sync: function(e) {
        var t = this,
        n = t.shadow,
        r, i, s, o, u, a, f, l, c, h;
        if (t.preventSync) {
            return
        }
        if (!t.updating && t.isVisible() && (n || t.useShim)) {
            o = t.getShim();
            u = t[t.localXYNames.get]();
            a = u[0];
            f = u[1];
            l = t.dom.offsetWidth;
            c = t.dom.offsetHeight;
            if (n && !t.shadowDisabled) {
                if (e && !n.isVisible()) {
                    n.show(t)
                } else {
                    n.realign(a, f, l, c)
                }
                if (o) {
                    h = o.getStyle("z-index");
                    if (h > t.zindex) {
                        t.shim.setStyle("z-index", t.zindex - 2)
                    }
                    o.show();
                    if (n.isVisible()) {
                        r = n.el.getXY();
                        i = o.dom.style;
                        s = n.el.getSize();
                        if (Ext.supports.CSS3BoxShadow) {
                            s.height += 6;
                            s.width += 4;
                            r[0] -= 2;
                            r[1] -= 4
                        }
                        i.left = r[0] + "px";
                        i.top = r[1] + "px";
                        i.width = s.width + "px";
                        i.height = s.height + "px"
                    } else {
                        o.setSize(l, c);
                        o[t.localXYNames.set](a, f)
                    }
                }
            } else {
                if (o) {
                    h = o.getStyle("z-index");
                    if (h > t.zindex) {
                        t.shim.setStyle("z-index", t.zindex - 2)
                    }
                    o.show();
                    o.setSize(l, c);
                    o[t.localXYNames.set](a, f)
                }
            }
        }
        return t
    },
    remove: function() {
        this.hideUnders();
        this.callParent()
    },
    beginUpdate: function() {
        this.updating = true
    },
    endUpdate: function() {
        this.updating = false;
        this.sync(true)
    },
    hideUnders: function() {
        if (this.shadow) {
            this.shadow.hide()
        }
        this.hideShim()
    },
    constrainXY: function() {
        if (this.constrain) {
            var e = Ext.Element.getViewWidth(),
            t = Ext.Element.getViewHeight(),
            n = Ext.getDoc().getScroll(),
            r = this.getXY(),
            i = r[0],
            s = r[1],
            o = this.shadowOffset,
            u = this.dom.offsetWidth + o,
            a = this.dom.offsetHeight + o,
            f = false;
            if (i + u > e + n.left) {
                i = e - u - o;
                f = true
            }
            if (s + a > t + n.top) {
                s = t - a - o;
                f = true
            }
            if (i < n.left) {
                i = n.left;
                f = true
            }
            if (s < n.top) {
                s = n.top;
                f = true
            }
            if (f) {
                Ext.Layer.superclass.setXY.call(this, [i, s]);
                this.sync()
            }
        }
        return this
    },
    getConstrainOffset: function() {
        return this.shadowOffset
    },
    setVisible: function(e, t, n, r, i) {
        var s = this,
        o;
        o = function() {
            if (e) {
                s.sync(true)
            }
            if (r) {
                r()
            }
        };
        if (!e) {
            s.hideUnders(true)
        }
        s.callParent([e, t, n, r, i]);
        if (!t) {
            o()
        }
        return s
    },
    beforeFx: function() {
        this.beforeAction();
        return this.callParent(arguments)
    },
    afterFx: function() {
        this.callParent(arguments);
        this.sync(this.isVisible())
    },
    beforeAction: function() {
        if (!this.updating && this.shadow) {
            this.shadow.hide()
        }
    },
    setLeft: function(e) {
        this.callParent(arguments);
        return this.sync()
    },
    setTop: function(e) {
        this.callParent(arguments);
        return this.sync()
    },
    setLeftTop: function(e, t) {
        this.callParent(arguments);
        return this.sync()
    },
    setLocalX: function() {
        this.callParent(arguments);
        return this.sync()
    },
    setLocalXY: function() {
        this.callParent(arguments);
        return this.sync()
    },
    setLocalY: function() {
        this.callParent(arguments);
        return this.sync()
    },
    setXY: function(e, t, n, r, i) {
        var s = this;
        r = s.createCB(r);
        s.fixDisplay();
        s.beforeAction();
        s.callParent([e, t, n, r, i]);
        if (!t) {
            r()
        }
        return s
    },
    createCB: function(e) {
        var t = this,
        n = t.shadow && t.shadow.isVisible();
        return function() {
            t.constrainXY();
            t.sync(n);
            if (e) {
                e()
            }
        }
    },
    setX: function(e, t, n, r, i) {
        this.setXY([e, this.getY()], t, n, r, i);
        return this
    },
    setY: function(e, t, n, r, i) {
        this.setXY([this.getX(), e], t, n, r, i);
        return this
    },
    setSize: function(e, t, n, r, i, s) {
        var o = this;
        i = o.createCB(i);
        o.beforeAction();
        o.callParent([e, t, n, r, i, s]);
        if (!n) {
            i()
        }
        return o
    },
    setWidth: function(e, t, n, r, i) {
        var s = this;
        r = s.createCB(r);
        s.beforeAction();
        s.callParent([e, t, n, r, i]);
        if (!t) {
            r()
        }
        return s
    },
    setHeight: function(e, t, n, r, i) {
        var s = this;
        r = s.createCB(r);
        s.beforeAction();
        s.callParent([e, t, n, r, i]);
        if (!t) {
            r()
        }
        return s
    },
    setBounds: function(e, t, n, r, i, s, o, u) {
        var a = this;
        o = a.createCB(o);
        a.beforeAction();
        if (!i) {
            Ext.Layer.superclass.setXY.call(a, [e, t]);
            Ext.Layer.superclass.setSize.call(a, n, r);
            o()
        } else {
            a.callParent([e, t, n, r, i, s, o, u])
        }
        return a
    },
    setZIndex: function(e) {
        var t = this;
        t.zindex = e;
        if (t.getShim()) {
            t.shim.setStyle("z-index", e++)
        }
        if (t.shadow) {
            t.shadow.setZIndex(e++)
        }
        return t.setStyle("z-index", e)
    },
    onOpacitySet: function(e) {
        var t = this.shadow;
        if (t) {
            t.setOpacity(e)
        }
    }
});
Ext.define("Ext.draw.Matrix", {
    constructor: function(e, t, n, r, i, s) {
        if (e != null) {
            this.matrix = [[e, n, i], [t, r, s], [0, 0, 1]]
        } else {
            this.matrix = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
        }
    },
    add: function(e, t, n, r, i, s) {
        var o = this,
        u = [[], [], []],
        a = [[e, n, i], [t, r, s], [0, 0, 1]],
        f,
        l,
        c,
        h;
        for (f = 0; f < 3; f++) {
            for (l = 0; l < 3; l++) {
                h = 0;
                for (c = 0; c < 3; c++) {
                    h += o.matrix[f][c] * a[c][l]
                }
                u[f][l] = h
            }
        }
        o.matrix = u
    },
    prepend: function(e, t, n, r, i, s) {
        var o = this,
        u = [[], [], []],
        a = [[e, n, i], [t, r, s], [0, 0, 1]],
        f,
        l,
        c,
        h;
        for (f = 0; f < 3; f++) {
            for (l = 0; l < 3; l++) {
                h = 0;
                for (c = 0; c < 3; c++) {
                    h += a[f][c] * o.matrix[c][l]
                }
                u[f][l] = h
            }
        }
        o.matrix = u
    },
    invert: function() {
        var e = this.matrix,
        t = e[0][0],
        n = e[1][0],
        r = e[0][1],
        i = e[1][1],
        s = e[0][2],
        o = e[1][2],
        u = t * i - n * r;
        return new Ext.draw.Matrix(i / u, -n / u, -r / u, t / u, (r * o - i * s) / u, (n * s - t * o) / u)
    },
    clone: function() {
        var e = this.matrix,
        t = e[0][0],
        n = e[1][0],
        r = e[0][1],
        i = e[1][1],
        s = e[0][2],
        o = e[1][2];
        return new Ext.draw.Matrix(t, n, r, i, s, o)
    },
    translate: function(e, t) {
        this.prepend(1, 0, 0, 1, e, t)
    },
    scale: function(e, t, n, r) {
        var i = this;
        if (t == null) {
            t = e
        }
        i.add(e, 0, 0, t, n * (1 - e), r * (1 - t))
    },
    rotate: function(e, t, n) {
        e = Ext.draw.Draw.rad(e);
        var r = this,
        i = +Math.cos(e).toFixed(9),
        s = +Math.sin(e).toFixed(9);
        r.add(i, s, -s, i, t - i * t + s * n, -(s * t) + n - i * n)
    },
    x: function(e, t) {
        var n = this.matrix;
        return e * n[0][0] + t * n[0][1] + n[0][2]
    },
    y: function(e, t) {
        var n = this.matrix;
        return e * n[1][0] + t * n[1][1] + n[1][2]
    },
    get: function(e, t) {
        return + this.matrix[e][t].toFixed(4)
    },
    toString: function() {
        var e = this;
        return [e.get(0, 0), e.get(0, 1), e.get(1, 0), e.get(1, 1), 0, 0].join()
    },
    toSvg: function() {
        var e = this;
        return "matrix(" + [e.get(0, 0), e.get(1, 0), e.get(0, 1), e.get(1, 1), e.get(0, 2), e.get(1, 2)].join() + ")"
    },
    toFilter: function(e, t) {
        var n = this;
        e = e || 0;
        t = t || 0;
        return "progid:DXImageTransform.Microsoft.Matrix(sizingMethod='auto expand', filterType='bilinear', M11=" + n.get(0, 0) + ", M12=" + n.get(0, 1) + ", M21=" + n.get(1, 0) + ", M22=" + n.get(1, 1) + ", Dx=" + (n.get(0, 2) + e) + ", Dy=" + (n.get(1, 2) + t) + ")"
    },
    offset: function() {
        var e = this.matrix;
        return [(e[0][2] || 0).toFixed(4), (e[1][2] || 0).toFixed(4)]
    },
    split: function() {
        function e(e) {
            return e[0] * e[0] + e[1] * e[1]
        }
        function t(t) {
            var n = Math.sqrt(e(t));
            t[0] /= n;
            t[1] /= n
        }
        var n = this.matrix,
        r = {
            translateX: n[0][2],
            translateY: n[1][2]
        },
        i;
        i = [[n[0][0], n[0][1]], [n[1][1], n[1][1]]];
        r.scaleX = Math.sqrt(e(i[0]));
        t(i[0]);
        r.shear = i[0][0] * i[1][0] + i[0][1] * i[1][1];
        i[1] = [i[1][0] - i[0][0] * r.shear, i[1][1] - i[0][1] * r.shear];
        r.scaleY = Math.sqrt(e(i[1]));
        t(i[1]);
        r.shear /= r.scaleY;
        r.rotate = Math.asin( - i[0][1]);
        r.isSimple = !+r.shear.toFixed(9) && (r.scaleX.toFixed(9) == r.scaleY.toFixed(9) || !r.rotate);
        return r
    }
});
Ext.define("Ext.draw.SpriteDD", {
    extend: Ext.dd.DragSource,
    constructor: function(e, t) {
        var n = this,
        r = e.el;
        n.sprite = e;
        n.el = r;
        n.dragData = {
            el: r,
            sprite: e
        };
        n.callParent([r, t]);
        n.sprite.setStyle("cursor", "move")
    },
    showFrame: Ext.emptyFn,
    createFrame: Ext.emptyFn,
    getDragEl: function(e) {
        return this.el
    },
    getRegion: function() {
        var e = this,
        t = e.el,
        n, r, i, s, o, u, a, f, l, c, h;
        h = e.sprite;
        c = h.getBBox();
        try {
            n = Ext.Element.getXY(t)
        } catch(p) {}
        if (!n) {
            return null
        }
        r = n[0];
        i = r + c.width;
        s = n[1];
        o = s + c.height;
        return new Ext.util.Region(s, i, o, r)
    },
    startDrag: function(e, t) {
        var n = this,
        r = n.sprite.attr;
        n.prev = n.sprite.surface.transformToViewBox(e, t)
    },
    onDrag: function(e) {
        var t = e.getXY(),
        n = this,
        r = n.sprite,
        i = r.attr,
        s,
        o;
        t = n.sprite.surface.transformToViewBox(t[0], t[1]);
        s = t[0] - n.prev[0];
        o = t[1] - n.prev[1];
        r.setAttributes({
            translate: {
                x: i.translation.x + s,
                y: i.translation.y + o
            }
        },
        true);
        n.prev = t
    },
    setDragElPos: function() {
        return false
    }
});
Ext.define("Ext.draw.Sprite", {
    mixins: {
        observable: Ext.util.Observable,
        animate: Ext.util.Animate
    },
    dirty: false,
    dirtyHidden: false,
    dirtyTransform: false,
    dirtyPath: true,
    dirtyFont: true,
    zIndexDirty: true,
    isSprite: true,
    zIndex: 0,
    fontProperties: ["font", "font-size", "font-weight", "font-style", "font-family", "text-anchor", "text"],
    pathProperties: ["x", "y", "d", "path", "height", "width", "radius", "r", "rx", "ry", "cx", "cy"],
    constructor: function(e) {
        var t = this;
        e = Ext.merge({},
        e || {});
        t.id = Ext.id(null, "ext-sprite-");
        t.transformations = [];
        Ext.copyTo(this, e, "surface,group,type,draggable");
        t.bbox = {};
        t.attr = {
            zIndex: 0,
            translation: {
                x: null,
                y: null
            },
            rotation: {
                degrees: null,
                x: null,
                y: null
            },
            scaling: {
                x: null,
                y: null,
                cx: null,
                cy: null
            }
        };
        delete e.surface;
        delete e.group;
        delete e.type;
        delete e.draggable;
        t.setAttributes(e);
        t.addEvents("beforedestroy", "destroy", "render", "mousedown", "mouseup", "mouseover", "mouseout", "mousemove", "click");
        t.mixins.observable.constructor.apply(this, arguments)
    },
    initDraggable: function() {
        var e = this;
        if (!e.el) {
            e.surface.createSpriteElement(e)
        }
        e.dd = new Ext.draw.SpriteDD(e, Ext.isBoolean(e.draggable) ? null: e.draggable);
        e.on("beforedestroy", e.dd.destroy, e.dd)
    },
    setAttributes: function(e, t) {
        var n = this,
        r = n.fontProperties,
        i = r.length,
        s = n.pathProperties,
        o = s.length,
        u = !!n.surface,
        a = u && n.surface.customAttributes || {},
        f = n.attr,
        l = false,
        c, h, p, d, v, m, g, y;
        e = Ext.apply({},
        e);
        for (c in a) {
            if (e.hasOwnProperty(c) && typeof a[c] == "function") {
                Ext.apply(e, a[c].apply(n, [].concat(e[c])))
            }
        }
        if ( !! e.hidden !== !!f.hidden) {
            n.dirtyHidden = true
        }
        for (h = 0; h < o; h++) {
            c = s[h];
            if (c in e && e[c] !== f[c]) {
                n.dirtyPath = true;
                l = true;
                break
            }
        }
        if ("zIndex" in e) {
            n.zIndexDirty = true
        }
        if ("text" in e) {
            n.dirtyFont = true;
            l = true;
            e.text = n.transformText(e.text)
        }
        for (h = 0; h < i; h++) {
            c = r[h];
            if (c in e && e[c] !== f[c]) {
                n.dirtyFont = true;
                l = true;
                break
            }
        }
        p = e.translation || e.translate;
        delete e.translate;
        delete e.translation;
        d = f.translation;
        if (p) {
            if ("x" in p && p.x !== d.x || "y" in p && p.y !== d.y) {
                n.dirtyTransform = true;
                d.x = p.x;
                d.y = p.y
            }
        }
        v = e.rotation || e.rotate;
        m = f.rotation;
        delete e.rotate;
        delete e.rotation;
        if (v) {
            if ("x" in v && v.x !== m.x || "y" in v && v.y !== m.y || "degrees" in v && v.degrees !== m.degrees) {
                n.dirtyTransform = true;
                m.x = v.x;
                m.y = v.y;
                m.degrees = v.degrees
            }
        }
        g = e.scaling || e.scale;
        y = f.scaling;
        delete e.scale;
        delete e.scaling;
        if (g) {
            if ("x" in g && g.x !== y.x || "y" in g && g.y !== y.y || "cx" in g && g.cx !== y.cx || "cy" in g && g.cy !== y.cy) {
                n.dirtyTransform = true;
                y.x = g.x;
                y.y = g.y;
                y.cx = g.cx;
                y.cy = g.cy
            }
        }
        if (!n.dirtyTransform && l) {
            if (f.scaling.x === null || f.scaling.y === null || f.rotation.y === null || f.rotation.y === null) {
                n.dirtyTransform = true
            }
        }
        Ext.apply(f, e);
        n.dirty = true;
        if (t === true && u) {
            n.redraw()
        }
        return this
    },
    transformText: Ext.identityFn,
    getBBox: function() {
        return this.surface.getBBox(this)
    },
    setText: function(e) {
        this.attr.text = e;
        this.surface.applyAttrs(this);
        return this
    },
    hide: function(e) {
        this.setAttributes({
            hidden: true
        },
        e);
        return this
    },
    show: function(e) {
        this.setAttributes({
            hidden: false
        },
        e);
        return this
    },
    remove: function() {
        if (this.surface) {
            this.surface.remove(this);
            return true
        }
        return false
    },
    onRemove: function() {
        this.surface.onRemove(this)
    },
    destroy: function() {
        var e = this;
        if (e.fireEvent("beforedestroy", e) !== false) {
            e.remove();
            e.surface.onDestroy(e);
            e.clearListeners();
            e.fireEvent("destroy")
        }
    },
    redraw: function() {
        var e = this,
        t = !e.el || e.dirty,
        n = e.surface,
        r;
        n.renderItem(e);
        if (t) {
            r = n.owner;
            if (!e.isBackground && r && (r.viewBox || r.autoSize)) {
                r.configureSurfaceSize()
            }
        }
        return this
    },
    setStyle: function() {
        this.el.setStyle.apply(this.el, arguments);
        return this
    },
    addCls: function(e) {
        this.surface.addCls(this, e);
        return this
    },
    removeCls: function(e) {
        this.surface.removeCls(this, e);
        return this
    }
});
Ext.define("Ext.draw.Text", {
    extend: Ext.draw.Component,
    alias: "widget.text",
    text: "",
    focusable: false,
    viewBox: false,
    autoSize: true,
    baseCls: Ext.baseCSSPrefix + "surface " + Ext.baseCSSPrefix + "draw-text",
    initComponent: function() {
        var e = this;
        e.textConfig = Ext.apply({
            type: "text",
            text: e.text,
            rotate: {
                degrees: e.degrees || 0
            }
        },
        e.textStyle);
        Ext.apply(e.textConfig, e.getStyles(e.styleSelectors || e.styleSelector));
        e.initialConfig.items = [e.textConfig];
        e.callParent(arguments)
    },
    getStyles: function(e) {
        e = Ext.Array.from(e);
        var t = 0,
        n = e.length,
        r, i, s, o = {};
        for (; t < n; t++) {
            r = Ext.util.CSS.getRule(e[t]);
            if (r) {
                i = r.style;
                if (i) {
                    Ext.apply(o, {
                        "font-family": i.fontFamily,
                        "font-weight": i.fontWeight,
                        "line-height": i.lineHeight,
                        "font-size": i.fontSize,
                        fill: i.color
                    })
                }
            }
        }
        return o
    },
    setAngle: function(e) {
        var t = this,
        n, r;
        if (t.rendered) {
            n = t.surface;
            r = n.items.items[0];
            t.degrees = e;
            r.setAttributes({
                rotate: {
                    degrees: e
                }
            },
            true);
            if (t.autoSize || t.viewBox) {
                t.updateLayout()
            }
        } else {
            t.degrees = e
        }
    },
    setText: function(e) {
        var t = this,
        n, r;
        if (t.rendered) {
            n = t.surface;
            r = n.items.items[0];
            t.text = e || "";
            n.remove(r);
            t.textConfig.type = "text";
            t.textConfig.text = t.text;
            r = n.add(t.textConfig);
            r.setAttributes({
                rotate: {
                    degrees: t.degrees
                }
            },
            true);
            if (t.autoSize || t.viewBox) {
                t.updateLayout()
            }
        } else {
            t.on({
                render: function() {
                    t.setText(e)
                },
                single: true
            })
        }
    }
});
Ext.define("Ext.draw.engine.ImageExporter", {
    singleton: true,
    defaultUrl: "http://svg.sencha.io",
    supportedTypes: ["image/png", "image/jpeg"],
    widthParam: "width",
    heightParam: "height",
    typeParam: "type",
    svgParam: "svg",
    formCls: Ext.baseCSSPrefix + "hide-display",
    generate: function(e, t) {
        t = t || {};
        var n = this,
        r = t.type,
        i;
        if (Ext.Array.indexOf(n.supportedTypes, r) === -1) {
            return false
        }
        i = Ext.getBody().createChild({
            tag: "form",
            method: "POST",
            action: t.url || n.defaultUrl,
            cls: n.formCls,
            children: [{
                tag: "input",
                type: "hidden",
                name: t.widthParam || n.widthParam,
                value: t.width || e.width
            },
            {
                tag: "input",
                type: "hidden",
                name: t.heightParam || n.heightParam,
                value: t.height || e.height
            },
            {
                tag: "input",
                type: "hidden",
                name: t.typeParam || n.typeParam,
                value: r
            },
            {
                tag: "input",
                type: "hidden",
                name: t.svgParam || n.svgParam
            }]
        });
        i.last(null, true).value = Ext.draw.engine.SvgExporter.generate(e);
        i.dom.submit();
        i.remove();
        return true
    }
});
Ext.define("Ext.draw.engine.Svg", {
    extend: Ext.draw.Surface,
    engine: "Svg",
    trimRe: /^\s+|\s+$/g,
    spacesRe: /\s+/,
    xlink: "http://www.w3.org/1999/xlink",
    translateAttrs: {
        radius: "r",
        radiusX: "rx",
        radiusY: "ry",
        path: "d",
        lineWidth: "stroke-width",
        fillOpacity: "fill-opacity",
        strokeOpacity: "stroke-opacity",
        strokeLinejoin: "stroke-linejoin"
    },
    parsers: {},
    minDefaults: {
        circle: {
            cx: 0,
            cy: 0,
            r: 0,
            fill: "none",
            stroke: null,
            "stroke-width": null,
            opacity: null,
            "fill-opacity": null,
            "stroke-opacity": null
        },
        ellipse: {
            cx: 0,
            cy: 0,
            rx: 0,
            ry: 0,
            fill: "none",
            stroke: null,
            "stroke-width": null,
            opacity: null,
            "fill-opacity": null,
            "stroke-opacity": null
        },
        rect: {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            rx: 0,
            ry: 0,
            fill: "none",
            stroke: null,
            "stroke-width": null,
            opacity: null,
            "fill-opacity": null,
            "stroke-opacity": null
        },
        text: {
            x: 0,
            y: 0,
            "text-anchor": "start",
            "font-family": null,
            "font-size": null,
            "font-weight": null,
            "font-style": null,
            fill: "#000",
            stroke: null,
            "stroke-width": null,
            opacity: null,
            "fill-opacity": null,
            "stroke-opacity": null
        },
        path: {
            d: "M0,0",
            fill: "none",
            stroke: null,
            "stroke-width": null,
            opacity: null,
            "fill-opacity": null,
            "stroke-opacity": null
        },
        image: {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            preserveAspectRatio: "none",
            opacity: null
        }
    },
    createSvgElement: function(e, t) {
        var n = this.domRef.createElementNS("http://www.w3.org/2000/svg", e),
        r;
        if (t) {
            for (r in t) {
                n.setAttribute(r, String(t[r]))
            }
        }
        return n
    },
    createSpriteElement: function(e) {
        var t = this.createSvgElement(e.type);
        t.id = e.id;
        if (t.style) {
            t.style.webkitTapHighlightColor = "rgba(0,0,0,0)"
        }
        e.el = Ext.get(t);
        this.applyZIndex(e);
        e.matrix = new Ext.draw.Matrix;
        e.bbox = {
            plain: 0,
            transform: 0
        };
        this.applyAttrs(e);
        this.applyTransformations(e);
        e.fireEvent("render", e);
        return t
    },
    getBBoxText: function(e) {
        var t = {},
        n, r, i, s, o, u;
        if (e && e.el) {
            u = e.el.dom;
            try {
                t = u.getBBox();
                return t
            } catch(a) {}
            t = {
                x: t.x,
                y: Infinity,
                width: 0,
                height: 0
            };
            o = u.getNumberOfChars();
            for (s = 0; s < o; s++) {
                n = u.getExtentOfChar(s);
                t.y = Math.min(n.y, t.y);
                r = n.y + n.height - t.y;
                t.height = Math.max(t.height, r);
                i = n.x + n.width - t.x;
                t.width = Math.max(t.width, i)
            }
            return t
        }
    },
    hide: function() {
        Ext.get(this.el).hide()
    },
    show: function() {
        Ext.get(this.el).show()
    },
    hidePrim: function(e) {
        this.addCls(e, Ext.baseCSSPrefix + "hide-visibility")
    },
    showPrim: function(e) {
        this.removeCls(e, Ext.baseCSSPrefix + "hide-visibility")
    },
    getDefs: function() {
        return this._defs || (this._defs = this.createSvgElement("defs"))
    },
    transform: function(e, t) {
        var n = this,
        r = new Ext.draw.Matrix,
        i = e.transformations,
        s = i.length,
        o = 0,
        u, a;
        for (; o < s; o++) {
            u = i[o];
            a = u.type;
            if (a == "translate") {
                r.translate(u.x, u.y)
            } else {
                if (a == "rotate") {
                    r.rotate(u.degrees, u.x, u.y)
                } else {
                    if (a == "scale") {
                        r.scale(u.x, u.y, u.centerX, u.centerY)
                    }
                }
            }
        }
        e.matrix = r;
        if (!t) {
            e.el.set({
                transform: r.toSvg()
            })
        }
    },
    setSize: function(e, t) {
        var n = this,
        r = n.el;
        e = +e || n.width;
        t = +t || n.height;
        n.width = e;
        n.height = t;
        r.setSize(e, t);
        r.set({
            width: e,
            height: t
        });
        n.callParent([e, t])
    },
    getRegion: function() {
        var e = this.el.getXY(),
        t = this.bgRect.getXY(),
        n = Math.max,
        r = n(e[0], t[0]),
        i = n(e[1], t[1]);
        return {
            left: r,
            top: i,
            right: r + this.width,
            bottom: i + this.height
        }
    },
    onRemove: function(e) {
        if (e.el) {
            e.el.destroy();
            delete e.el
        }
        this.callParent(arguments)
    },
    setViewBox: function(e, t, n, r) {
        if (isFinite(e) && isFinite(t) && isFinite(n) && isFinite(r)) {
            this.callParent(arguments);
            this.el.dom.setAttribute("viewBox", [e, t, n, r].join(" "))
        }
    },
    render: function(e) {
        var t = this,
        n, r, i, s, o;
        if (!t.el) {
            n = {
                xmlns: "http://www.w3.org/2000/svg",
                version: 1.1,
                width: t.width || 0,
                height: t.height || 0
            };
            if (t.forceLtr) {
                n.direction = "ltr"
            }
            r = t.createSvgElement("svg", n);
            i = t.getDefs();
            s = t.createSvgElement("rect", {
                width: "100%",
                height: "100%",
                fill: "#000",
                stroke: "none",
                opacity: 0
            });
            if (Ext.isSafari3) {
                o = t.createSvgElement("rect", {
                    x: -10,
                    y: -10,
                    width: "110%",
                    height: "110%",
                    fill: "none",
                    stroke: "#000"
                })
            }
            r.appendChild(i);
            if (Ext.isSafari3) {
                r.appendChild(o)
            }
            r.appendChild(s);
            e.appendChild(r);
            t.el = Ext.get(r);
            t.bgRect = Ext.get(s);
            if (Ext.isSafari3) {
                t.webkitRect = Ext.get(o);
                t.webkitRect.hide()
            }
            t.el.on({
                scope: t,
                mouseup: t.onMouseUp,
                mousedown: t.onMouseDown,
                mouseover: t.onMouseOver,
                mouseout: t.onMouseOut,
                mousemove: t.onMouseMove,
                mouseenter: t.onMouseEnter,
                mouseleave: t.onMouseLeave,
                click: t.onClick,
                dblclick: t.onDblClick
            })
        }
        t.renderAll()
    },
    onMouseEnter: function(e) {
        if (this.el.parent().getRegion().contains(e.getPoint())) {
            this.fireEvent("mouseenter", e)
        }
    },
    onMouseLeave: function(e) {
        if (!this.el.parent().getRegion().contains(e.getPoint())) {
            this.fireEvent("mouseleave", e)
        }
    },
    processEvent: function(e, t) {
        var n = t.getTarget(),
        r = this.surface,
        i;
        this.fireEvent(e, t);
        if (n.nodeName == "tspan" && n.parentNode) {
            n = n.parentNode
        }
        i = this.items.get(n.id);
        if (i) {
            i.fireEvent(e, i, t)
        }
    },
    tuneText: function(e, t) {
        var n = e.el.dom,
        r = [],
        i,
        s,
        o,
        u,
        a,
        f,
        l,
        c;
        if (t.hasOwnProperty("text")) {
            o = e.tspans && Ext.Array.map(e.tspans,
            function(e) {
                return e.textContent
            }).join("");
            if (!e.tspans || t.text != o) {
                r = this.setText(e, t.text);
                e.tspans = r
            } else {
                r = e.tspans || []
            }
        }
        if (r.length) {
            i = this.getBBoxText(e).height;
            c = e.el.dom.getAttribute("x");
            for (u = 0, a = r.length; u < a; u++) {
                l = Ext.isFF3_0 || Ext.isFF3_5 ? 2 : 4;
                r[u].setAttribute("x", c);
                r[u].setAttribute("dy", u ? i * 1.2 : i / l)
            }
            e.dirty = true
        }
    },
    setText: function(e, t) {
        var n = this,
        r = e.el.dom,
        i = [],
        s,
        o,
        u,
        a,
        f,
        l;
        while (r.firstChild) {
            r.removeChild(r.firstChild)
        }
        l = String(t).split("\n");
        for (a = 0, f = l.length; a < f; a++) {
            u = l[a];
            if (u) {
                o = n.createSvgElement("tspan");
                o.appendChild(document.createTextNode(Ext.htmlDecode(u)));
                r.appendChild(o);
                i[a] = o
            }
        }
        return i
    },
    renderAll: function() {
        this.items.each(this.renderItem, this)
    },
    renderItem: function(e) {
        if (!this.el) {
            return
        }
        if (!e.el) {
            this.createSpriteElement(e)
        }
        if (e.zIndexDirty) {
            this.applyZIndex(e)
        }
        if (e.dirty) {
            this.applyAttrs(e);
            if (e.dirtyTransform) {
                this.applyTransformations(e)
            }
        }
    },
    redraw: function(e) {
        e.dirty = e.zIndexDirty = true;
        this.renderItem(e)
    },
    applyAttrs: function(e) {
        var t = this,
        n = e.el,
        r = e.group,
        i = e.attr,
        s = t.parsers,
        o = t.gradientsMap || {},
        u = Ext.isSafari && !Ext.isStrict,
        a, f, l, c, h, p, d, v, m;
        if (r) {
            a = [].concat(r);
            l = a.length;
            for (f = 0; f < l; f++) {
                r = a[f];
                t.getGroup(r).add(e)
            }
            delete e.group
        }
        c = t.scrubAttrs(e) || {};
        e.bbox.plain = 0;
        e.bbox.transform = 0;
        if (e.type == "circle" || e.type == "ellipse") {
            c.cx = c.cx || c.x;
            c.cy = c.cy || c.y
        } else {
            if (e.type == "rect") {
                c.rx = c.ry = c.r
            } else {
                if (e.type == "path" && c.d) {
                    c.d = Ext.draw.Draw.pathToString(Ext.draw.Draw.pathToAbsolute(c.d))
                }
            }
        }
        e.dirtyPath = false;
        if (c["clip-rect"]) {
            t.setClip(e, c);
            delete c["clip-rect"]
        }
        if (e.type == "text" && c.font && e.dirtyFont) {
            n.set({
                style: "font: " + c.font
            })
        }
        if (e.type == "image") {
            n.dom.setAttributeNS(t.xlink, "href", c.src)
        }
        Ext.applyIf(c, t.minDefaults[e.type]);
        if (e.dirtyHidden) {
            i.hidden ? t.hidePrim(e) : t.showPrim(e);
            e.dirtyHidden = false
        }
        for (p in c) {
            if (c.hasOwnProperty(p) && c[p] != null) {
                if (u && "color|stroke|fill".indexOf(p) > -1 && c[p] in o) {
                    c[p] = o[c[p]]
                }
                if (p == "hidden" && e.type == "text") {
                    continue
                }
                if (p in s) {
                    n.dom.setAttribute(p, s[p](c[p], e, t))
                } else {
                    n.dom.setAttribute(p, c[p])
                }
            }
        }
        if (e.type == "text") {
            t.tuneText(e, c)
        }
        e.dirtyFont = false;
        d = i.style;
        if (d) {
            n.setStyle(d)
        }
        e.dirty = false;
        if (Ext.isSafari3) {
            t.webkitRect.show();
            setTimeout(function() {
                t.webkitRect.hide()
            })
        }
    },
    setClip: function(e, t) {
        var n = this,
        r = t["clip-rect"],
        i,
        s;
        if (r) {
            if (e.clip) {
                e.clip.parentNode.parentNode.removeChild(e.clip.parentNode)
            }
            i = n.createSvgElement("clipPath");
            s = n.createSvgElement("rect");
            i.id = Ext.id(null, "ext-clip-");
            s.setAttribute("x", r.x);
            s.setAttribute("y", r.y);
            s.setAttribute("width", r.width);
            s.setAttribute("height", r.height);
            i.appendChild(s);
            n.getDefs().appendChild(i);
            e.el.dom.setAttribute("clip-path", "url(#" + i.id + ")");
            e.clip = s
        }
    },
    applyZIndex: function(e) {
        var t = this,
        n = t.items,
        r = n.indexOf(e),
        i = e.el,
        s;
        if (t.el.dom.childNodes[r + 2] !== i.dom) {
            if (r > 0) {
                do {
                    s = n.getAt(--r).el
                } while (! s && r > 0 )
            }
            i.insertAfter(s || t.bgRect)
        }
        e.zIndexDirty = false
    },
    createItem: function(e) {
        var t = new Ext.draw.Sprite(e);
        t.surface = this;
        return t
    },
    addGradient: function(e) {
        e = Ext.draw.Draw.parseGradient(e);
        var t = this,
        n = e.stops.length,
        r = e.vector,
        i = Ext.isSafari && !Ext.isStrict,
        s, o, u, a, f;
        f = t.gradientsMap || {};
        if (!i) {
            if (e.type == "linear") {
                s = t.createSvgElement("linearGradient");
                s.setAttribute("x1", r[0]);
                s.setAttribute("y1", r[1]);
                s.setAttribute("x2", r[2]);
                s.setAttribute("y2", r[3])
            } else {
                s = t.createSvgElement("radialGradient");
                s.setAttribute("cx", e.centerX);
                s.setAttribute("cy", e.centerY);
                s.setAttribute("r", e.radius);
                if (Ext.isNumber(e.focalX) && Ext.isNumber(e.focalY)) {
                    s.setAttribute("fx", e.focalX);
                    s.setAttribute("fy", e.focalY)
                }
            }
            s.id = e.id;
            t.getDefs().appendChild(s);
            for (a = 0; a < n; a++) {
                o = e.stops[a];
                u = t.createSvgElement("stop");
                u.setAttribute("offset", o.offset + "%");
                u.setAttribute("stop-color", o.color);
                u.setAttribute("stop-opacity", o.opacity);
                s.appendChild(u)
            }
        } else {
            f["url(#" + e.id + ")"] = e.stops[0].color
        }
        t.gradientsMap = f
    },
    hasCls: function(e, t) {
        return t && (" " + (e.el.dom.getAttribute("class") || "") + " ").indexOf(" " + t + " ") != -1
    },
    addCls: function(e, t) {
        var n = e.el,
        r, i, s, o = [],
        u = n.getAttribute("class") || "";
        if (!Ext.isArray(t)) {
            if (typeof t == "string" && !this.hasCls(e, t)) {
                n.set({
                    "class": u + " " + t
                })
            }
        } else {
            for (r = 0, i = t.length; r < i; r++) {
                s = t[r];
                if (typeof s == "string" && (" " + u + " ").indexOf(" " + s + " ") == -1) {
                    o.push(s)
                }
            }
            if (o.length) {
                n.set({
                    "class": " " + o.join(" ")
                })
            }
        }
    },
    removeCls: function(e, t) {
        var n = this,
        r = e.el,
        i = r.getAttribute("class") || "",
        s,
        o,
        u,
        a,
        f;
        if (!Ext.isArray(t)) {
            t = [t]
        }
        if (i) {
            f = i.replace(n.trimRe, " ").split(n.spacesRe);
            for (s = 0, u = t.length; s < u; s++) {
                a = t[s];
                if (typeof a == "string") {
                    a = a.replace(n.trimRe, "");
                    o = Ext.Array.indexOf(f, a);
                    if (o != -1) {
                        Ext.Array.erase(f, o, 1)
                    }
                }
            }
            r.set({
                "class": f.join(" ")
            })
        }
    },
    destroy: function() {
        var e = this;
        e.callParent();
        if (e.el) {
            e.el.remove()
        }
        if (e._defs) {
            Ext.get(e._defs).destroy()
        }
        if (e.bgRect) {
            Ext.get(e.bgRect).destroy()
        }
        if (e.webkitRect) {
            Ext.get(e.webkitRect).destroy()
        }
        delete e.el
    }
});
Ext.define("Ext.draw.engine.SvgExporter",
function() {
    var e = /,/g,
    t = /(-?\d*\.?\d*){1}(em|ex|px|in|cm|mm|pt|pc|%)\s('*.*'*)/,
    n = /rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/g,
    r = /rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,([\d\.]+)\)/g,
    i, s, o, u, a = function(e) {
        i = e;
        s = i.length;
        o = i.width;
        u = i.height
    },
    f = {
        path: function(t) {
            var n = t.attr,
            r = n.path,
            i = "",
            s, o, u;
            if (Ext.isArray(r[0])) {
                u = r.length;
                for (o = 0; o < u; o++) {
                    i += r[o].join(" ")
                }
            } else {
                if (Ext.isArray(r)) {
                    i = r.join(" ")
                } else {
                    i = r.replace(e, " ")
                }
            }
            s = h({
                d: i,
                fill: n.fill || "none",
                stroke: n.stroke,
                "fill-opacity": n.opacity,
                "stroke-width": n["stroke-width"],
                "stroke-opacity": n["stroke-opacity"],
                "z-index": n.zIndex,
                transform: t.matrix.toSvg()
            });
            return "<path " + s + "/>"
        },
        text: function(e) {
            var n = e.attr,
            r = t.exec(n.font),
            i = r && r[1] || "12",
            s = r && r[3] || "Arial",
            o = n.text,
            u = Ext.isFF3_0 || Ext.isFF3_5 ? 2 : 4,
            a = "",
            f;
            e.getBBox();
            a += '<tspan x="' + (n.x || "") + '" dy="';
            a += i / u + '">';
            a += Ext.htmlEncode(o) + "</tspan>";
            f = h({
                x: n.x,
                y: n.y,
                "font-size": i,
                "font-family": s,
                "font-weight": n["font-weight"],
                "text-anchor": n["text-anchor"],
                fill: n.fill || "#000",
                "fill-opacity": n.opacity,
                transform: e.matrix.toSvg()
            });
            return "<text " + f + ">" + a + "</text>"
        },
        rect: function(e) {
            var t = e.attr,
            n = h({
                x: t.x,
                y: t.y,
                rx: t.rx,
                ry: t.ry,
                width: t.width,
                height: t.height,
                fill: t.fill || "none",
                "fill-opacity": t.opacity,
                stroke: t.stroke,
                "stroke-opacity": t["stroke-opacity"],
                "stroke-width": t["stroke-width"],
                transform: e.matrix && e.matrix.toSvg()
            });
            return "<rect " + n + "/>"
        },
        circle: function(e) {
            var t = e.attr,
            n = h({
                cx: t.x,
                cy: t.y,
                r: t.radius,
                fill: t.translation.fill || t.fill || "none",
                "fill-opacity": t.opacity,
                stroke: t.stroke,
                "stroke-opacity": t["stroke-opacity"],
                "stroke-width": t["stroke-width"],
                transform: e.matrix.toSvg()
            });
            return "<circle " + n + " />"
        },
        image: function(e) {
            var t = e.attr,
            n = h({
                x: t.x - (t.width / 2 >> 0),
                y: t.y - (t.height / 2 >> 0),
                width: t.width,
                height: t.height,
                "xlink:href": t.src,
                transform: e.matrix.toSvg()
            });
            return "<image " + n + " />"
        }
    },
    l = function() {
        var e = '<?xml version="1.0" standalone="yes"?>';
        e += '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">';
        return e
    },
    c = function() {
        var e = '<svg width="' + o + 'px" height="' + u + 'px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1">',
        t = "",
        s, a, l, c, h, p, d, v, m, y, b, w, E, S, x, T, N, C, L, A;
        l = i.items.items;
        a = l.length;
        h = function(e) {
            var t = e.childNodes,
            n = t.length,
            r = 0,
            i, s, o = "",
            u, a, f, l;
            for (; r < n; r++) {
                u = t[r];
                a = u.attributes;
                f = u.tagName;
                o += "<" + f;
                for (s = 0, i = a.length; s < i; s++) {
                    l = a.item(s);
                    o += " " + l.name + '="' + l.value + '"'
                }
                o += ">";
                if (u.childNodes.length > 0) {
                    o += h(u)
                }
                o += "</" + f + ">"
            }
            return o
        };
        if (i.getDefs) {
            t = h(i.getDefs())
        } else {
            v = i.gradientsColl;
            if (v) {
                m = v.keys;
                y = v.items;
                b = 0;
                w = m.length
            }
            for (; b < w; b++) {
                E = m[b];
                S = y[b];
                c = i.gradientsColl.getByKey(E);
                t += '<linearGradient id="' + E + '" x1="0" y1="0" x2="1" y2="1">';
                var O = c.colors.replace(n, "rgb($1|$2|$3)");
                O = O.replace(r, "rgba($1|$2|$3|$4)");
                p = O.split(",");
                for (x = 0, N = p.length; x < N; x++) {
                    d = p[x].split(" ");
                    O = Ext.draw.Color.fromString(d[1].replace(/\|/g, ","));
                    t += '<stop offset="' + d[0] + '" stop-color="' + O.toString() + '" stop-opacity="1"></stop>'
                }
                t += "</linearGradient>"
            }
        }
        e += "<defs>" + t + "</defs>";
        e += f.rect({
            attr: {
                width: "100%",
                height: "100%",
                fill: "#fff",
                stroke: "none",
                opacity: "0"
            }
        });
        C = new Array(a);
        for (x = 0; x < a; x++) {
            C[x] = x
        }
        C.sort(function(e, t) {
            L = l[e].attr.zIndex || 0;
            A = l[t].attr.zIndex || 0;
            if (L == A) {
                return e - t
            }
            return L - A
        });
        for (x = 0; x < a; x++) {
            s = l[C[x]];
            if (!s.attr.hidden) {
                e += f[s.type](s)
            }
        }
        e += "</svg>";
        return e
    },
    h = function(e) {
        var t = "",
        n;
        for (n in e) {
            if (e.hasOwnProperty(n) && e[n] != null) {
                t += n + '="' + e[n] + '" '
            }
        }
        return t
    };
    return {
        singleton: true,
        generate: function(e, t) {
            t = t || {};
            a(e);
            return l() + c()
        }
    }
});
Ext.define("Ext.draw.engine.Vml", {
    extend: Ext.draw.Surface,
    engine: "Vml",
    map: {
        M: "m",
        L: "l",
        C: "c",
        Z: "x",
        m: "t",
        l: "r",
        c: "v",
        z: "x"
    },
    bitesRe: /([clmz]),?([^clmz]*)/gi,
    valRe: /-?[^,\s\-]+/g,
    fillUrlRe: /^url\(\s*['"]?([^\)]+?)['"]?\s*\)$/i,
    pathlike: /^(path|rect)$/,
    NonVmlPathRe: /[ahqstv]/ig,
    partialPathRe: /[clmz]/g,
    fontFamilyRe: /^['"]+|['"]+$/g,
    baseVmlCls: Ext.baseCSSPrefix + "vml-base",
    vmlGroupCls: Ext.baseCSSPrefix + "vml-group",
    spriteCls: Ext.baseCSSPrefix + "vml-sprite",
    measureSpanCls: Ext.baseCSSPrefix + "vml-measure-span",
    zoom: 21600,
    coordsize: 1e3,
    coordorigin: "0 0",
    zIndexShift: 0,
    orderSpritesByZIndex: false,
    path2vml: function(e) {
        var t = this,
        n = t.NonVmlPathRe,
        r = t.map,
        i = t.valRe,
        s = t.zoom,
        o = t.bitesRe,
        u = Ext.Function.bind(Ext.draw.Draw.pathToAbsolute, Ext.draw.Draw),
        a,
        f,
        l,
        c,
        h,
        p,
        d,
        v;
        if (String(e).match(n)) {
            u = Ext.Function.bind(Ext.draw.Draw.path2curve, Ext.draw.Draw)
        } else {
            if (!String(e).match(t.partialPathRe)) {
                a = String(e).replace(o,
                function(e, t, n) {
                    var o = [],
                    u = t.toLowerCase() == "m",
                    a = r[t];
                    n.replace(i,
                    function(e) {
                        if (u && o.length === 2) {
                            a += o + r[t == "m" ? "l": "L"];
                            o = []
                        }
                        o.push(Math.round(e * s))
                    });
                    return a + o
                });
                return a
            }
        }
        f = u(e);
        a = [];
        for (h = 0, p = f.length; h < p; h++) {
            l = f[h];
            c = f[h][0].toLowerCase();
            if (c == "z") {
                c = "x"
            }
            for (d = 1, v = l.length; d < v; d++) {
                c += Math.round(l[d] * t.zoom) + (d != v - 1 ? ",": "")
            }
            a.push(c)
        }
        return a.join(" ")
    },
    translateAttrs: {
        radius: "r",
        radiusX: "rx",
        radiusY: "ry",
        lineWidth: "stroke-width",
        fillOpacity: "fill-opacity",
        strokeOpacity: "stroke-opacity",
        strokeLinejoin: "stroke-linejoin"
    },
    minDefaults: {
        circle: {
            fill: "none",
            stroke: null,
            "stroke-width": null,
            opacity: null,
            "fill-opacity": null,
            "stroke-opacity": null
        },
        ellipse: {
            cx: 0,
            cy: 0,
            rx: 0,
            ry: 0,
            fill: "none",
            stroke: null,
            "stroke-width": null,
            opacity: null,
            "fill-opacity": null,
            "stroke-opacity": null
        },
        rect: {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            rx: 0,
            ry: 0,
            fill: "none",
            stroke: null,
            "stroke-width": null,
            opacity: null,
            "fill-opacity": null,
            "stroke-opacity": null
        },
        text: {
            x: 0,
            y: 0,
            "text-anchor": "start",
            font: '10px "Arial"',
            fill: "#000",
            stroke: null,
            "stroke-width": null,
            opacity: null,
            "fill-opacity": null,
            "stroke-opacity": null
        },
        path: {
            d: "M0,0",
            fill: "none",
            stroke: null,
            "stroke-width": null,
            opacity: null,
            "fill-opacity": null,
            "stroke-opacity": null
        },
        image: {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            preserveAspectRatio: "none",
            opacity: null
        }
    },
    onMouseEnter: function(e) {
        this.fireEvent("mouseenter", e)
    },
    onMouseLeave: function(e) {
        this.fireEvent("mouseleave", e)
    },
    processEvent: function(e, t) {
        var n = t.getTarget(),
        r = this.surface,
        i;
        this.fireEvent(e, t);
        i = this.items.get(n.id);
        if (i) {
            i.fireEvent(e, i, t)
        }
    },
    createSpriteElement: function(e) {
        var t = this,
        n = e.attr,
        r = e.type,
        i = t.zoom,
        s = e.vml || (e.vml = {}),
        o = Math.round,
        u = r === "image" ? t.createNode("image") : t.createNode("shape"),
        a,
        f,
        l;
        u.coordsize = i + " " + i;
        u.coordorigin = n.coordorigin || "0 0";
        Ext.get(u).addCls(t.spriteCls);
        if (r == "text") {
            s.path = a = t.createNode("path");
            a.textpathok = true;
            s.textpath = l = t.createNode("textpath");
            l.on = true;
            u.appendChild(l);
            u.appendChild(a)
        }
        u.id = e.id;
        e.el = Ext.get(u);
        e.el.setStyle("zIndex", -t.zIndexShift);
        t.el.appendChild(u);
        if (r !== "image") {
            f = t.createNode("skew");
            f.on = true;
            u.appendChild(f);
            e.skew = f
        }
        e.matrix = new Ext.draw.Matrix;
        e.bbox = {
            plain: null,
            transform: null
        };
        this.applyAttrs(e);
        this.applyTransformations(e);
        e.fireEvent("render", e);
        return e.el
    },
    getBBoxText: function(e) {
        var t = e.vml;
        return {
            x: t.X + (t.bbx || 0) - t.W / 2,
            y: t.Y - t.H / 2,
            width: t.W,
            height: t.H
        }
    },
    applyAttrs: function(e) {
        var t = this,
        n = e.vml,
        r = e.group,
        i = e.attr,
        s = e.el,
        o = s.dom,
        u, a, f, l, c, h, p, d, v, m, g, y;
        if (r) {
            f = [].concat(r);
            c = f.length;
            for (l = 0; l < c; l++) {
                r = f[l];
                t.getGroup(r).add(e)
            }
            delete e.group
        }
        h = t.scrubAttrs(e) || {};
        if (e.zIndexDirty) {
            t.setZIndex(e)
        }
        Ext.applyIf(h, t.minDefaults[e.type]);
        if (e.type == "image") {
            Ext.apply(e.attr, {
                x: h.x,
                y: h.y,
                width: h.width,
                height: h.height
            });
            s.setStyle({
                width: h.width + "px",
                height: h.height + "px"
            });
            o.src = h.src
        }
        if (o.href) {
            o.href = h.href
        }
        if (o.title) {
            o.title = h.title
        }
        if (o.target) {
            o.target = h.target
        }
        if (o.cursor) {
            o.cursor = h.cursor
        }
        if (e.dirtyHidden) {
            h.hidden ? t.hidePrim(e) : t.showPrim(e);
            e.dirtyHidden = false
        }
        if (e.dirtyPath) {
            if (e.type == "circle" || e.type == "ellipse") {
                v = h.x;
                m = h.y;
                g = h.rx || h.r || 0;
                y = h.ry || h.r || 0;
                o.path = Ext.String.format("ar{0},{1},{2},{3},{4},{1},{4},{1}", Math.round((v - g) * t.zoom), Math.round((m - y) * t.zoom), Math.round((v + g) * t.zoom), Math.round((m + y) * t.zoom), Math.round(v * t.zoom));
                e.dirtyPath = false
            } else {
                e.attr.path = h.path = t.setPaths(e, h) || h.path;
                o.path = t.path2vml(h.path);
                e.dirtyPath = false
            }
        }
        if ("clip-rect" in h) {
            t.setClip(e, h)
        }
        if (e.type == "text") {
            t.setTextAttributes(e, h)
        }
        if (h.opacity || h["stroke-opacity"] || h.fill) {
            t.setFill(e, h)
        }
        if (h.stroke || h["stroke-opacity"] || h.fill) {
            t.setStroke(e, h)
        }
        u = i.style;
        if (u) {
            s.setStyle(u)
        }
        e.dirty = false
    },
    setZIndex: function(e) {
        var t = this,
        n = e.attr.zIndex,
        r = t.zIndexShift,
        i, s, o, u;
        if (n < r) {
            i = t.items.items;
            s = i.length;
            for (u = 0; u < s; u++) {
                if ((n = i[u].attr.zIndex) && n < r) {
                    r = n
                }
            }
            t.zIndexShift = r;
            for (u = 0; u < s; u++) {
                o = i[u];
                if (o.el) {
                    o.el.setStyle("zIndex", o.attr.zIndex - r)
                }
                o.zIndexDirty = false
            }
        } else {
            if (e.el) {
                e.el.setStyle("zIndex", n - r);
                e.zIndexDirty = false
            }
        }
    },
    setPaths: function(e, t) {
        var n = e.attr,
        r = e.attr["stroke-width"] || 1;
        e.bbox.plain = null;
        e.bbox.transform = null;
        if (e.type == "circle") {
            n.rx = n.ry = t.r;
            return Ext.draw.Draw.ellipsePath(e)
        } else {
            if (e.type == "ellipse") {
                n.rx = t.rx;
                n.ry = t.ry;
                return Ext.draw.Draw.ellipsePath(e)
            } else {
                if (e.type == "rect") {
                    n.rx = n.ry = t.r;
                    return Ext.draw.Draw.rectPath(e)
                } else {
                    if (e.type == "path" && n.path) {
                        return Ext.draw.Draw.pathToAbsolute(n.path)
                    }
                }
            }
        }
        return false
    },
    setFill: function(e, t) {
        var n = this,
        r = e.el.dom,
        i = r.fill,
        s = false,
        o, u, a, f, l;
        if (!i) {
            i = r.fill = n.createNode("fill");
            s = true
        }
        if (Ext.isArray(t.fill)) {
            t.fill = t.fill[0]
        }
        if (t.fill == "none") {
            i.on = false
        } else {
            if (typeof t.opacity == "number") {
                i.opacity = t.opacity
            }
            if (typeof t["fill-opacity"] == "number") {
                i.opacity = t["fill-opacity"]
            }
            i.on = true;
            if (typeof t.fill == "string") {
                a = t.fill.match(n.fillUrlRe);
                if (a) {
                    a = a[1];
                    if (a.charAt(0) == "#") {
                        u = n.gradientsColl.getByKey(a.substring(1))
                    }
                    if (u) {
                        f = t.rotation;
                        l = -(u.angle + 270 + (f ? f.degrees: 0)) % 360;
                        if (l === 0) {
                            l = 180
                        }
                        i.angle = l;
                        i.type = "gradient";
                        i.method = "sigma";
                        if (i.colors) {
                            i.colors.value = u.colors
                        } else {
                            i.colors = u.colors
                        }
                    } else {
                        i.src = a;
                        i.type = "tile"
                    }
                } else {
                    i.color = Ext.draw.Color.toHex(t.fill);
                    i.src = "";
                    i.type = "solid"
                }
            }
        }
        if (s) {
            r.appendChild(i)
        }
    },
    setStroke: function(e, t) {
        var n = this,
        r = e.el.dom,
        i = e.strokeEl,
        s = false,
        o, u;
        if (!i) {
            i = e.strokeEl = n.createNode("stroke");
            s = true
        }
        if (Ext.isArray(t.stroke)) {
            t.stroke = t.stroke[0]
        }
        if (!t.stroke || t.stroke == "none" || t.stroke == 0 || t["stroke-width"] == 0) {
            i.on = false
        } else {
            i.on = true;
            if (t.stroke && !t.stroke.match(n.fillUrlRe)) {
                i.color = Ext.draw.Color.toHex(t.stroke)
            }
            i.dashstyle = t["stroke-dasharray"] ? "dash": "solid";
            i.joinstyle = t["stroke-linejoin"];
            i.endcap = t["stroke-linecap"] || "round";
            i.miterlimit = t["stroke-miterlimit"] || 8;
            o = parseFloat(t["stroke-width"] || 1) * .75;
            u = t["stroke-opacity"] || 1;
            if (Ext.isNumber(o) && o < 1) {
                i.weight = 1;
                i.opacity = u * o
            } else {
                i.weight = o;
                i.opacity = u
            }
        }
        if (s) {
            r.appendChild(i)
        }
    },
    setClip: function(e, t) {
        var n = this,
        r = e.el,
        i = e.clipEl,
        s = String(t["clip-rect"]).split(n.separatorRe);
        if (!i) {
            i = e.clipEl = n.el.insertFirst(Ext.getDoc().dom.createElement("div"));
            i.addCls(Ext.baseCSSPrefix + "vml-sprite")
        }
        if (s.length == 4) {
            s[2] = +s[2] + +s[0];
            s[3] = +s[3] + +s[1];
            i.setStyle("clip", Ext.String.format("rect({1}px {2}px {3}px {0}px)", s[0], s[1], s[2], s[3]));
            i.setSize(n.el.width, n.el.height)
        } else {
            i.setStyle("clip", "")
        }
    },
    setTextAttributes: function(e, t) {
        var n = this,
        r = e.vml,
        i = r.textpath.style,
        s = n.span.style,
        o = n.zoom,
        u = Math.round,
        a = {
            fontSize: "font-size",
            fontWeight: "font-weight",
            fontStyle: "font-style"
        },
        f,
        l;
        if (e.dirtyFont) {
            if (t.font) {
                i.font = s.font = t.font
            }
            if (t["font-family"]) {
                i.fontFamily = '"' + t["font-family"].split(",")[0].replace(n.fontFamilyRe, "") + '"';
                s.fontFamily = t["font-family"]
            }
            for (f in a) {
                l = t[a[f]];
                if (l) {
                    i[f] = s[f] = l
                }
            }
            n.setText(e, t.text);
            if (r.textpath.string) {
                n.span.innerHTML = String(r.textpath.string).replace(/</g, "&#60;").replace(/&/g, "&#38;").replace(/\n/g, "<br/>")
            }
            r.W = n.span.offsetWidth;
            r.H = n.span.offsetHeight + 2;
            if (t["text-anchor"] == "middle") {
                i["v-text-align"] = "center"
            } else {
                if (t["text-anchor"] == "end") {
                    i["v-text-align"] = "right";
                    r.bbx = -Math.round(r.W / 2)
                } else {
                    i["v-text-align"] = "left";
                    r.bbx = Math.round(r.W / 2)
                }
            }
        }
        r.X = t.x;
        r.Y = t.y;
        r.path.v = Ext.String.format("m{0},{1}l{2},{1}", Math.round(r.X * o), Math.round(r.Y * o), Math.round(r.X * o) + 1);
        e.bbox.plain = null;
        e.bbox.transform = null;
        e.dirtyFont = false
    },
    setText: function(e, t) {
        e.vml.textpath.string = Ext.htmlDecode(t)
    },
    hide: function() {
        this.el.hide()
    },
    show: function() {
        this.el.show()
    },
    hidePrim: function(e) {
        e.el.addCls(Ext.baseCSSPrefix + "hide-visibility")
    },
    showPrim: function(e) {
        e.el.removeCls(Ext.baseCSSPrefix + "hide-visibility")
    },
    setSize: function(e, t) {
        var n = this;
        e = e || n.width;
        t = t || n.height;
        n.width = e;
        n.height = t;
        if (n.el) {
            if (e != undefined) {
                n.el.setWidth(e)
            }
            if (t != undefined) {
                n.el.setHeight(t)
            }
        }
        n.callParent(arguments)
    },
    applyViewBox: function() {
        var e = this,
        t = e.viewBox,
        n = e.width,
        r = e.height,
        i, s, o;
        e.callParent();
        if (t && (n || r)) {
            i = e.items.items;
            s = i.length;
            for (o = 0; o < s; o++) {
                e.applyTransformations(i[o])
            }
        }
    },
    onAdd: function(e) {
        this.callParent(arguments);
        if (this.el) {
            this.renderItem(e)
        }
    },
    onRemove: function(e) {
        if (e.el) {
            e.el.remove();
            delete e.el
        }
        this.callParent(arguments)
    },
    render: function(e) {
        var t = this,
        n = Ext.getDoc().dom,
        r;
        if (!t.createNode) {
            try {
                if (!n.namespaces.rvml) {
                    n.namespaces.add("rvml", "urn:schemas-microsoft-com:vml")
                }
                t.createNode = function(e) {
                    return n.createElement("<rvml:" + e + ' class="rvml">')
                }
            } catch(i) {
                t.createNode = function(e) {
                    return n.createElement("<" + e + ' xmlns="urn:schemas-microsoft.com:vml" class="rvml">')
                }
            }
        }
        if (!t.el) {
            r = n.createElement("div");
            t.el = Ext.get(r);
            t.el.addCls(t.baseVmlCls);
            t.span = n.createElement("span");
            Ext.get(t.span).addCls(t.measureSpanCls);
            r.appendChild(t.span);
            t.el.setSize(t.width || 0, t.height || 0);
            e.appendChild(r);
            t.el.on({
                scope: t,
                mouseup: t.onMouseUp,
                mousedown: t.onMouseDown,
                mouseover: t.onMouseOver,
                mouseout: t.onMouseOut,
                mousemove: t.onMouseMove,
                mouseenter: t.onMouseEnter,
                mouseleave: t.onMouseLeave,
                click: t.onClick,
                dblclick: t.onDblClick
            })
        }
        t.renderAll()
    },
    renderAll: function() {
        this.items.each(this.renderItem, this)
    },
    redraw: function(e) {
        e.dirty = true;
        this.renderItem(e)
    },
    renderItem: function(e) {
        if (!this.el) {
            return
        }
        if (!e.el) {
            this.createSpriteElement(e)
        }
        if (e.dirty) {
            this.applyAttrs(e);
            if (e.dirtyTransform) {
                this.applyTransformations(e)
            }
        }
    },
    rotationCompensation: function(e, t, n) {
        var r = new Ext.draw.Matrix;
        r.rotate( - e, .5, .5);
        return {
            x: r.x(t, n),
            y: r.y(t, n)
        }
    },
    transform: function(e, t) {
        var n = this,
        r = n.getBBox(e, true),
        i = r.x + r.width * .5,
        s = r.y + r.height * .5,
        o = new Ext.draw.Matrix,
        u = e.transformations,
        a = u.length,
        f = 0,
        l = 0,
        c = 1,
        h = 1,
        p = "",
        d = e.el,
        v = d.dom,
        m = v.style,
        g = n.zoom,
        y = e.skew,
        b = n.viewBoxShift,
        w,
        E,
        S,
        x,
        T,
        N,
        C,
        k,
        L,
        A,
        O,
        M;
        for (; f < a; f++) {
            S = u[f];
            x = S.type;
            if (x == "translate") {
                o.translate(S.x, S.y)
            } else {
                if (x == "rotate") {
                    o.rotate(S.degrees, S.x, S.y);
                    l += S.degrees
                } else {
                    if (x == "scale") {
                        o.scale(S.x, S.y, S.centerX, S.centerY);
                        c *= S.x;
                        h *= S.y
                    }
                }
            }
        }
        e.matrix = o.clone();
        if (t) {
            return
        }
        if (b) {
            o.prepend(b.scale, 0, 0, b.scale, b.dx * b.scale, b.dy * b.scale)
        }
        if (e.type != "image" && y) {
            y.origin = "0,0";
            y.matrix = o.toString();
            M = o.offset();
            if (M[0] > 32767) {
                M[0] = 32767
            } else {
                if (M[0] < -32768) {
                    M[0] = -32768
                }
            }
            if (M[1] > 32767) {
                M[1] = 32767
            } else {
                if (M[1] < -32768) {
                    M[1] = -32768
                }
            }
            y.offset = M
        } else {
            m.filter = o.toFilter();
            m.left = Math.min(o.x(r.x, r.y), o.x(r.x + r.width, r.y), o.x(r.x, r.y + r.height), o.x(r.x + r.width, r.y + r.height)) + "px";
            m.top = Math.min(o.y(r.x, r.y), o.y(r.x + r.width, r.y), o.y(r.x, r.y + r.height), o.y(r.x + r.width, r.y + r.height)) + "px"
        }
    },
    createItem: function(e) {
        return Ext.create("Ext.draw.Sprite", e)
    },
    getRegion: function() {
        return this.el.getRegion()
    },
    addCls: function(e, t) {
        if (e && e.el) {
            e.el.addCls(t)
        }
    },
    removeCls: function(e, t) {
        if (e && e.el) {
            e.el.removeCls(t)
        }
    },
    addGradient: function(e) {
        var t = this.gradientsColl || (this.gradientsColl = Ext.create("Ext.util.MixedCollection")),
        n = [],
        r = Ext.create("Ext.util.MixedCollection"),
        i,
        s,
        o,
        u,
        a,
        f;
        r.addAll(e.stops);
        r.sortByKey("ASC",
        function(e, t) {
            e = parseInt(e, 10);
            t = parseInt(t, 10);
            return e > t ? 1 : e < t ? -1 : 0
        });
        i = r.keys;
        s = r.items;
        o = i.length;
        for (f = 0; f < o; f++) {
            u = i[f];
            a = s[f];
            n.push(u + "% " + a.color)
        }
        t.add(e.id, {
            colors: n.join(","),
            angle: e.angle
        })
    },
    destroy: function() {
        var e = this;
        e.callParent(arguments);
        if (e.el) {
            e.el.remove()
        }
        delete e.el
    }
});
Ext.define("Ext.env.Browser", {
    statics: {
        browserNames: {
            ie: "IE",
            firefox: "Firefox",
            safari: "Safari",
            chrome: "Chrome",
            opera: "Opera",
            other: "Other"
        },
        engineNames: {
            webkit: "WebKit",
            gecko: "Gecko",
            presto: "Presto",
            trident: "Trident",
            other: "Other"
        },
        enginePrefixes: {
            webkit: "AppleWebKit/",
            gecko: "Gecko/",
            presto: "Presto/",
            trident: "Trident/"
        },
        browserPrefixes: {
            ie: "MSIE ",
            firefox: "Firefox/",
            chrome: "Chrome/",
            safari: "Version/",
            opera: "Opera/"
        }
    },
    isSecure: false,
    isStrict: false,
    is: Ext.emptyFn,
    name: null,
    version: null,
    engineName: null,
    engineVersion: null,
    constructor: function() {
        var e = this.userAgent = Ext.global.navigator.userAgent,
        t = this.statics(),
        n = e.match(new RegExp("((?:" + Ext.Object.getValues(t.browserPrefixes).join(")|(?:") + "))([\\d\\._]+)")),
        r = e.match(new RegExp("((?:" + Ext.Object.getValues(t.enginePrefixes).join(")|(?:") + "))([\\d\\._]+)")),
        i = t.browserNames.other,
        s = "",
        o = t.engineNames.other,
        u = "",
        a,
        f;
        this.is = function(e) {
            return this.is[e] === true
        };
        if (n) {
            i = t.browserNames[Ext.Object.getKey(t.browserPrefixes, n[1])];
            s = n[2]
        }
        if (r) {
            o = t.engineNames[Ext.Object.getKey(t.enginePrefixes, r[1])];
            u = r[2]
        }
        if (o === "Trident" && i !== "IE") {
            i = "IE";
            var l = e.match(/.*rv:(\d+.\d+)/);
            if (l && l.length) {
                l = l[1];
                s = new Ext.Version(l)
            }
        }
        Ext.apply(this, {
            engineName: o,
            engineVersion: new Ext.Version(u),
            name: i,
            version: new Ext.Version(s)
        });
        this.is[this.name] = true;
        this.is[this.name + (this.version.getMajor() || "")] = true;
        this.is[this.name + this.version.getShortVersion()] = true;
        for (a in t.browserNames) {
            if (t.browserNames.hasOwnProperty(a)) {
                f = t.browserNames[a];
                this.is[f] = this.name === f
            }
        }
        this.is[this.name] = true;
        this.is[this.engineName + (this.engineVersion.getMajor() || "")] = true;
        this.is[this.engineName + this.engineVersion.getShortVersion()] = true;
        for (a in t.engineNames) {
            if (t.engineNames.hasOwnProperty(a)) {
                f = t.engineNames[a];
                this.is[f] = this.engineNames === f
            }
        }
        this.isSecure = /^https/i.test(Ext.global.location.protocol);
        this.isStrict = Ext.global.document.compatMode === "CSS1Compat";
        return this
    }
},
function() {
    Ext.browser = new Ext.env.Browser
});
Ext.define("Ext.env.FeatureDetector", {
    statics: {
        defaultTests: {
            Canvas: function() {
                var e = this.getTestElement("canvas");
                return !! (e && e.getContext && e.getContext("2d"))
            },
            SVG: function() {
                var e = Ext.global.document;
                return !! (e.createElementNS && !!e.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGRect)
            },
            VML: function() {
                var e = this.getTestElement(),
                t = false;
                e.innerHTML = "<!--[if vml]><br/><br/><![endif]-->";
                t = e.childNodes.length === 2;
                e.innerHTML = "";
                return t
            },
            Touch: function() {
                return "ontouchstart" in Ext.global && !(Ext.platform && Ext.platform.name.match(/Windows|MacOSX|Linux/))
            },
            Orientation: function() {
                return "orientation" in Ext.global
            },
            Geolocation: function() {
                return !! Ext.global.navigator.geolocation
            },
            SqlDatabase: function() {
                return !! Ext.global.openDatabase
            },
            Websockets: function() {
                return "WebSocket" in Ext.global
            },
            History: function() {
                return !! (Ext.global.history && Ext.global.history.pushState)
            },
            CSSTransforms: function() {
                return this.isStyleSupported("transform")
            },
            CSS3DTransforms: function() {
                return this.has("csstransforms") && this.isStyleSupported("perspective")
            },
            CSSAnimations: function() {
                return this.isStyleSupported("animationName")
            },
            CSSTransitions: function() {
                return this.isStyleSupported("transitionProperty")
            },
            Audio: function() {
                return !! this.getTestElement("audio").canPlayType
            },
            Video: function() {
                return !! this.getTestElement("video").canPlayType
            }
        },
        stylePrefixes: ["Webkit", "Moz", "O", "ms"]
    },
    constructor: function() {
        this.tests = {};
        this.testElements = {};
        this.registerTests(this.self.defaultTests, true);
        return this
    },
    has: function(e) {
        if (!this.hasTest(e)) {
            return false
        } else {
            if (this.has.hasOwnProperty(e)) {
                return this.has[e]
            } else {
                return this.getTestResult(e)
            }
        }
    },
    getTestResult: function(e) {
        return !! this.getTest(e).call(this)
    },
    getTestElement: function(e) {
        if (!e) {
            e = "div"
        }
        if (!this.testElements[e]) {
            this.testElements[e] = Ext.global.document.createElement(e)
        }
        return this.testElements[e]
    },
    registerTest: function(e, t, n) {
        this.tests[e] = t;
        if (n) {
            this.has[e] = this.getTestResult(e)
        }
        return this
    },
    registerTests: function(e, t) {
        var n;
        for (n in e) {
            if (e.hasOwnProperty(n)) {
                this.registerTest(n, e[n], t)
            }
        }
        return this
    },
    hasTest: function(e) {
        return this.tests.hasOwnProperty(e)
    },
    getTest: function(e) {
        return this.tests[e]
    },
    getTests: function() {
        return this.tests
    },
    isStyleSupported: function(e, t) {
        var n = this.getTestElement(t).style,
        r = Ext.String.capitalize(e),
        i = this.self.stylePrefixes.length;
        if (n[e] !== undefined) {
            return true
        }
        while (i--) {
            if (n[this.self.stylePrefixes[i] + r] !== undefined) {
                return true
            }
        }
        return false
    },
    isEventSupported: function(e, t) {
        var n = this.getTestElement(t),
        r = "on" + e,
        i = false;
        i = r in n;
        if (!i) {
            if (n.setAttribute && n.removeAttribute) {
                n.setAttribute(r, "");
                i = typeof n[r] === "function";
                if (typeof n[r] !== "undefined") {
                    n[r] = undefined
                }
                n.removeAttribute(r)
            }
        }
        return i
    }
},
function() {
    Ext.features = new Ext.env.FeatureDetector
});
Ext.define("Ext.env.OS", {
    statics: {
        osNames: {
            ios: "iOS",
            android: "Android",
            webos: "WebOS",
            blackberry: "BlackBerry",
            mac: "MacOSX",
            win: "Windows",
            linux: "Linux",
            other: "Other"
        },
        osPrefixes: {
            ios: "iPhone OS ",
            android: "Android ",
            blackberry: "BlackBerry ",
            webos: "webOS/"
        }
    },
    is: Ext.emptyFn,
    name: null,
    version: null,
    constructor: function() {
        var e = Ext.global.navigator.userAgent,
        t = Ext.global.navigator.platform,
        n = this.statics(),
        r = e.match(new RegExp("((?:" + Ext.Object.getValues(n.osPrefixes).join(")|(?:") + "))([^\\s;]+)")),
        i = "other",
        s = "",
        o,
        u,
        a;
        if (r) {
            i = n.osNames[Ext.Object.getKey(n.osPrefixes, r[1])];
            s = r[2];
            if (i === "BlackBerry") {
                o = e.match(/Version\/([\d\._]+)/);
                if (o) {
                    s = o[1]
                }
            }
        } else {
            i = n.osNames[(e.toLowerCase().match(/mac|win|linux/i) || ["other"])[0]]
        }
        Ext.apply(this, {
            name: i,
            version: new Ext.Version(s)
        });
        this.is = function(e) {
            return this.is[e] === true
        };
        if (i === "iOS") {
            this.is[t] = true
        }
        this.is[this.name] = true;
        this.is[this.name + (this.version.getMajor() || "")] = true;
        this.is[this.name + this.version.getShortVersion()] = true;
        for (u in n.osNames) {
            if (n.osNames.hasOwnProperty(u)) {
                a = n.osNames[u];
                this.is[a] = this.name === a
            }
        }
        return this
    }
},
function() {
    Ext.os = new Ext.env.OS
});
Ext.define("Ext.flash.Component", {
    extend: Ext.Component,
    alternateClassName: "Ext.FlashComponent",
    alias: "widget.flash",
    flashVersion: "9.0.115",
    backgroundColor: "#ffffff",
    wmode: "opaque",
    swfWidth: "100%",
    swfHeight: "100%",
    expressInstall: false,
    renderTpl: ['<div id="{swfId}" role="presentation"></div>'],
    initComponent: function() {
        this.callParent();
        this.addEvents("success", "failure")
    },
    beforeRender: function() {
        this.callParent();
        Ext.applyIf(this.renderData, {
            swfId: this.getSwfId()
        })
    },
    afterRender: function() {
        var e = this,
        t = Ext.apply({},
        e.flashParams),
        n = Ext.apply({},
        e.flashVars);
        e.callParent();
        t = Ext.apply({
            allowScriptAccess: "always",
            bgcolor: e.backgroundColor,
            wmode: e.wmode
        },
        t);
        n = Ext.apply({
            allowedDomain: document.location.hostname
        },
        n);
        new swfobject.embedSWF(e.url, e.getSwfId(), e.swfWidth, e.swfHeight, e.flashVersion, e.expressInstall ? e.statics.EXPRESS_INSTALL_URL: undefined, n, t, e.flashAttributes, Ext.bind(e.swfCallback, e))
    },
    swfCallback: function(e) {
        var t = this;
        if (e.success) {
            t.swf = Ext.get(e.ref);
            t.onSuccess();
            t.fireEvent("success", t)
        } else {
            t.onFailure();
            t.fireEvent("failure", t)
        }
    },
    getSwfId: function() {
        return this.swfId || (this.swfId = "extswf" + this.getAutoId())
    },
    onSuccess: function() {
        this.swf.setStyle("visibility", "inherit")
    },
    onFailure: Ext.emptyFn,
    beforeDestroy: function() {
        var e = this,
        t = e.swf;
        if (t) {
            swfobject.removeSWF(e.getSwfId());
            Ext.destroy(t);
            delete e.swf
        }
        e.callParent()
    },
    statics: {
        EXPRESS_INSTALL_URL: "http://swfobject.googlecode.com/svn/trunk/swfobject/expressInstall.swf"
    }
});
Ext.define("Ext.form.action.Action", {
    alternateClassName: "Ext.form.Action",
    submitEmptyText: true,
    constructor: function(e) {
        if (e) {
            Ext.apply(this, e)
        }
        var t = e.params;
        if (Ext.isString(t)) {
            this.params = Ext.Object.fromQueryString(t)
        }
    },
    run: Ext.emptyFn,
    onFailure: function(e) {
        this.response = e;
        this.failureType = Ext.form.action.Action.CONNECT_FAILURE;
        this.form.afterAction(this, false)
    },
    processResponse: function(e) {
        this.response = e;
        if (!e.responseText && !e.responseXML) {
            return true
        }
        return this.result = this.handleResponse(e)
    },
    getUrl: function() {
        return this.url || this.form.url
    },
    getMethod: function() {
        return (this.method || this.form.method || "POST").toUpperCase()
    },
    getParams: function() {
        return Ext.apply({},
        this.params, this.form.baseParams)
    },
    createCallback: function() {
        var e = this,
        t, n = e.form;
        return {
            success: e.onSuccess,
            failure: e.onFailure,
            scope: e,
            timeout: this.timeout * 1e3 || n.timeout * 1e3,
            upload: n.fileUpload ? e.onSuccess: t
        }
    },
    statics: {
        CLIENT_INVALID: "client",
        SERVER_INVALID: "server",
        CONNECT_FAILURE: "connect",
        LOAD_FAILURE: "load"
    }
});
Ext.define("Ext.form.action.Load", {
    extend: Ext.form.action.Action,
    alternateClassName: "Ext.form.Action.Load",
    alias: "formaction.load",
    type: "load",
    run: function() {
        Ext.Ajax.request(Ext.apply(this.createCallback(), {
            method: this.getMethod(),
            url: this.getUrl(),
            headers: this.headers,
            params: this.getParams()
        }))
    },
    onSuccess: function(e) {
        var t = this.processResponse(e),
        n = this.form;
        if (t === true || !t.success || !t.data) {
            this.failureType = Ext.form.action.Action.LOAD_FAILURE;
            n.afterAction(this, false);
            return
        }
        n.clearInvalid();
        n.setValues(t.data);
        n.afterAction(this, true)
    },
    handleResponse: function(e) {
        var t = this.form.reader,
        n, r;
        if (t) {
            n = t.read(e);
            r = n.records && n.records[0] ? n.records[0].data: null;
            return {
                success: n.success,
                data: r
            }
        }
        return Ext.decode(e.responseText)
    }
});
Ext.define("Ext.form.action.Submit", {
    extend: Ext.form.action.Action,
    alternateClassName: "Ext.form.Action.Submit",
    alias: "formaction.submit",
    type: "submit",
    run: function() {
        var e = this,
        t = e.form;
        if (e.clientValidation === false || t.isValid()) {
            e.doSubmit()
        } else {
            e.failureType = Ext.form.action.Action.CLIENT_INVALID;
            t.afterAction(e, false)
        }
    },
    doSubmit: function() {
        var e = this,
        t = Ext.apply(e.createCallback(), {
            url: e.getUrl(),
            method: e.getMethod(),
            headers: e.headers
        }),
        n = e.form,
        r = e.jsonSubmit || n.jsonSubmit,
        i = r ? "jsonData": "params",
        s;
        if (e.isUpload || n.hasUpload()) {
            s = e.buildForm();
            t.form = s.formEl;
            t.isUpload = true
        } else {
            t[i] = e.getParams(r)
        }
        Ext.Ajax.request(t);
        if (s) {
            e.cleanup(s)
        }
    },
    cleanup: function(e) {
        var t = e.formEl,
        n = e.uploadEls,
        r = e.uploadFields,
        i = r.length,
        s, o;
        for (s = 0; s < i; ++s) {
            o = r[s];
            if (!o.clearOnSubmit) {
                o.restoreInput(n[s])
            }
        }
        if (t) {
            Ext.removeNode(t)
        }
    },
    getParams: function(e) {
        var t = false,
        n = this.callParent(),
        r = this.form.getValues(t, t, this.submitEmptyText !== t, e, true);
        return Ext.apply({},
        r, n)
    },
    buildForm: function() {
        var e = this,
        t = [],
        n,
        r,
        i = e.form,
        s = e.getParams(),
        o = [],
        u = [],
        a = i.getFields().items,
        f,
        l = a.length,
        c,
        h,
        p,
        d;
        for (f = 0; f < l; ++f) {
            c = a[f];
            if (c.isFileUpload()) {
                o.push(c)
            }
        }
        for (h in s) {
            if (s.hasOwnProperty(h)) {
                p = s[h];
                t.push(e.getFieldConfig(h, p))
            }
        }
        n = {
            tag: "form",
            role: "presentation",
            action: e.getUrl(),
            method: e.getMethod(),
            target: e.target || "_self",
            style: "display:none",
            cn: t
        };
        if (o.length) {
            n.encoding = n.enctype = "multipart/form-data"
        }
        r = Ext.DomHelper.append(Ext.getBody(), n);
        l = o.length;
        for (f = 0; f < l; ++f) {
            d = o[f].extractFileInput();
            r.appendChild(d);
            u.push(d)
        }
        return {
            formEl: r,
            uploadFields: o,
            uploadEls: u
        }
    },
    getFieldConfig: function(e, t) {
        if (Ext.isDate(t)) {
            t = Ext.Date.toString(t)
        } else {
            if (Ext.isObject(t) || Ext.isArray(t)) {
                t = Ext.encode(t)
            }
        }
        return {
            tag: "input",
            type: "hidden",
            name: e,
            value: Ext.String.htmlEncode(t)
        }
    },
    onSuccess: function(e) {
        var t = this.form,
        n = true,
        r = this.processResponse(e);
        if (r !== true && !r.success) {
            if (r.errors) {
                t.markInvalid(r.errors)
            }
            this.failureType = Ext.form.action.Action.SERVER_INVALID;
            n = false
        }
        t.afterAction(this, n)
    },
    handleResponse: function(e) {
        var t = this.form,
        n = t.errorReader,
        r, i, s, o, u, a;
        if (n) {
            r = n.read(e);
            u = r.records;
            i = [];
            if (u) {
                for (s = 0, o = u.length; s < o; s++) {
                    i[s] = u[s].data
                }
            }
            if (i.length < 1) {
                i = null
            }
            a = {
                success: r.success,
                errors: i
            }
        } else {
            try {
                a = Ext.decode(e.responseText)
            } catch(f) {
                a = {
                    success: false,
                    errors: []
                }
            }
        }
        return a
    }
});
Ext.define("Ext.util.ComponentDragger", {
    extend: Ext.dd.DragTracker,
    autoStart: 500,
    constructor: function(e, t) {
        this.comp = e;
        this.initialConstrainTo = t.constrainTo;
        this.callParent([t])
    },
    onStart: function(e) {
        var t = this,
        n = t.comp;
        t.startPosition = n.getXY();
        if (n.ghost && !n.liveDrag) {
            t.proxy = n.ghost();
            t.dragTarget = t.proxy.header.el
        }
        if (t.constrain || t.constrainDelegate) {
            t.constrainTo = t.calculateConstrainRegion()
        }
        if (n.beginDrag) {
            n.beginDrag()
        }
    },
    calculateConstrainRegion: function() {
        var e = this,
        t = e.comp,
        n = e.initialConstrainTo,
        r = t.constraintInsets,
        i, s, o, u = e.proxy ? e.proxy.el: t.el,
        a = !e.constrainDelegate && u.shadow && t.constrainShadow && !u.shadowDisabled ? u.shadow.getShadowSize() : 0;
        if (! (n instanceof Ext.util.Region)) {
            i = Ext.fly(n);
            n = i.getViewRegion();
            n.right = n.left + i.dom.clientWidth
        } else {
            n = n.copy()
        }
        if (r) {
            r = Ext.isObject(r) ? r: Ext.Element.parseBox(r);
            n.adjust(r.top, r.right, r.bottom, r.length)
        }
        if (a) {
            n.adjust(a[0], -a[1], -a[2], a[3])
        }
        if (!e.constrainDelegate) {
            s = Ext.fly(e.dragTarget).getRegion();
            o = u.getRegion();
            n.adjust(s.top - o.top, s.right - o.right, s.bottom - o.bottom, s.left - o.left)
        }
        return n
    },
    onDrag: function(e) {
        var t = this,
        n = t.proxy && !t.comp.liveDrag ? t.proxy: t.comp,
        r = t.getOffset(t.constrain || t.constrainDelegate ? "dragTarget": null);
        n.setPagePosition(t.startPosition[0] + r[0], t.startPosition[1] + r[1])
    },
    onEnd: function(e) {
        var t = this.comp;
        if (t.isDestroyed || t.destroying) {
            return
        }
        if (this.proxy && !t.liveDrag) {
            t.unghost()
        }
        if (t.endDrag) {
            t.endDrag()
        }
    }
});
Ext.define("Ext.window.Window", {
    extend: Ext.panel.Panel,
    alternateClassName: "Ext.Window",
    alias: "widget.window",
    baseCls: Ext.baseCSSPrefix + "window",
    resizable: true,
    draggable: true,
    constrain: false,
    constrainHeader: true,
    plain: false,
    minimizable: false,
    maximizable: false,
    minHeight: 50,
    minWidth: 50,
    expandOnShow: true,
    collapsible: false,
    closable: true,
    dialog: false,
    hidden: true,
    autoRender: true,
    hideMode: "offsets",
    floating: true,
    itemCls: Ext.baseCSSPrefix + "window-item",
    initialAlphaNum: /^[a-z0-9]/,
    overlapHeader: true,
    ignoreHeaderBorderManagement: true,
    alwaysFramed: true,
    isRootCfg: {
        isRoot: true
    },
    isWindow: true,
    ariaRole: "dialog",
    initComponent: function() {
        var e = this;
        if (e.dialog) {
            var t = e.initialConfig || {};
            if (t.modal === undefined) {
                e.modal = true
            }
            if (t.resizable === undefined) {
                e.resizable = false
            }
            e.onEnter = function() {
                if (Wb.verify(e)) {
                    e.fireEvent("ok", e)
                }
            };
            e.onEsc = function() {
                if (e.fireEvent("cancel", e) !== false) {
                    e.close()
                }
            };
            if (e.listeners && e.listeners.cancel && t.closable === undefined) {
                e.closable = false
            }
            if (!e.buttons) {
                e.buttons = [{
                    text: Str.ok,
                    iconCls: "ok_icon",
                    handler: e.onEnter
                },
                {
                    text: Str.cancel,
                    iconCls: "cancel_icon",
                    handler: e.onEsc
                }]
            }
        }
        e.frame = false;
        e.callParent();
        e.addEvents("resize", "maximize", "minimize", "restore");
        if (e.plain) {
            e.addClsWithUI("plain")
        }
        e.addStateEvents(["maximize", "restore", "resize", "dragend"])
    },
    getElConfig: function() {
        var e = this,
        t;
        t = e.callParent();
        t.tabIndex = -1;
        return t
    },
    onEnterRoot: function(e, t) {
        var n = this,
        r = t.target;
        if (n.el.isMasked() || Ext.getBody().isMasked()) {
            return
        }
        if (r && r.type == "textarea") {
            return
        }
        t.stopEvent();
        if (n.onEnter) {
            n.onEnter(n, e, t)
        }
    },
    getState: function() {
        var e = this,
        t = e.callParent() || {},
        n = !!e.maximized,
        r = e.ghostBox,
        i;
        t.maximized = n;
        if (n) {
            i = e.restorePos
        } else {
            if (r) {
                i = [r.x, r.y]
            } else {
                i = e.getPosition()
            }
        }
        Ext.apply(t, {
            size: n ? e.restoreSize: e.getSize(),
            pos: i
        });
        return t
    },
    applyState: function(e) {
        var t = this;
        if (e) {
            t.maximized = e.maximized;
            if (t.maximized) {
                t.hasSavedRestore = true;
                t.restoreSize = e.size;
                t.restorePos = e.pos
            } else {
                Ext.apply(t, {
                    width: e.size.width,
                    height: e.size.height,
                    x: e.pos[0],
                    y: e.pos[1]
                })
            }
        }
    },
    onRender: function(e, t) {
        var n = this;
        n.callParent(arguments);
        n.focusEl = n.el;
        if (n.maximizable) {
            n.header.on({
                scope: n,
                dblclick: n.toggleMaximize
            })
        }
    },
    afterRender: function() {
        var e = this,
        t = e.header,
        n;
        e.callParent();
        if (e.maximized) {
            e.maximized = false;
            e.maximize();
            if (t) {
                t.removeCls(t.indicateDragCls)
            }
        }
        n = e.getKeyMap();
        if (e.closable) {
            n.on(27, e.onEsc, e)
        }
        n.on(13, e.onEnterRoot, e);
        if (n && e.hidden) {
            n.disable()
        }
    },
    initDraggable: function() {
        this.initSimpleDraggable()
    },
    initResizable: function() {
        this.callParent(arguments);
        if (this.maximized) {
            this.resizer.disable()
        }
    },
    onEsc: function(e, t) {
        var n = Ext.FocusManager;
        if (!Ext.enableFocusManager || n.focusedCmp === this) {
            t.stopEvent();
            this.close()
        }
    },
    beforeDestroy: function() {
        var e = this;
        if (e.rendered) {
            delete e.animateTarget;
            e.hide();
            Ext.destroy(e.keyMap)
        }
        e.callParent()
    },
    addTools: function() {
        var e = this,
        t = e.tools,
        n = [];
        e.callParent();
        if (e.minimizable) {
            t.push({
                type: "minimize",
                handler: Ext.Function.bind(e.minimize, e, n)
            })
        }
        if (e.maximizable) {
            t.push({
                type: "maximize",
                handler: Ext.Function.bind(e.toggleMaximize, e, n)
            })
        }
    },
    getFocusEl: function() {
        return this.getDefaultFocus()
    },
    getDefaultFocus: function() {
        var e = this,
        t, n = e.defaultButton || e.defaultFocus,
        r;
        if (n !== undefined) {
            if (Ext.isNumber(n)) {
                t = e.query("button")[n]
            } else {
                if (Ext.isString(n)) {
                    r = n;
                    t = e.queryById(r);
                    if (!t) {
                        t = e.down(r)
                    }
                } else {
                    if (n.focus) {
                        t = n
                    }
                }
            }
        }
        return t || e.el
    },
    onFocus: function() {
        var e = this,
        t;
        if (Ext.enableFocusManager || (t = e.getDefaultFocus()) === e) {
            e.callParent(arguments)
        } else {
            t.focus()
        }
    },
    onShow: function() {
        var e = this;
        e.callParent(arguments);
        if (e.expandOnShow) {
            e.expand(false)
        }
        e.syncMonitorWindowResize();
        if (e.keyMap) {
            e.keyMap.enable()
        }
    },
    doClose: function() {
        var e = this;
        if (e.hidden) {
            e.fireEvent("close", e);
            if (e.closeAction == "destroy") {
                e.destroy()
            }
        } else {
            e.hide(e.animateTarget, e.doClose, e)
        }
    },
    afterHide: function() {
        var e = this;
        e.syncMonitorWindowResize();
        if (e.keyMap) {
            e.keyMap.disable()
        }
        e.callParent(arguments)
    },
    onWindowResize: function() {
        var e = this,
        t;
        if (e.maximized) {
            e.fitContainer()
        } else {
            t = e.getSizeModel();
            if (t.width.natural || t.height.natural) {
                e.updateLayout()
            }
            e.doConstrain()
        }
    },
    minimize: function() {
        this.fireEvent("minimize", this);
        return this
    },
    resumeHeaderLayout: function(e) {
        this.header.resumeLayouts(e ? this.isRootCfg: null)
    },
    afterCollapse: function() {
        var e = this,
        t = e.header,
        n = e.tools;
        if (t && e.maximizable) {
            t.suspendLayouts();
            n.maximize.hide();
            this.resumeHeaderLayout(true)
        }
        if (e.resizer) {
            e.resizer.disable()
        }
        e.callParent(arguments)
    },
    afterExpand: function() {
        var e = this,
        t = e.header,
        n = e.tools,
        r;
        if (t) {
            t.suspendLayouts();
            if (e.maximizable) {
                n.maximize.show();
                r = true
            }
            this.resumeHeaderLayout(r)
        }
        if (e.resizer) {
            e.resizer.enable()
        }
        e.callParent(arguments)
    },
    maximize: function(e) {
        var t = this,
        n = t.header,
        r = t.tools,
        i = t.width,
        s = t.height,
        o, u;
        if (!t.maximized) {
            t.expand(false);
            if (!t.hasSavedRestore) {
                o = t.restoreSize = {
                    width: Ext.isNumber(i) ? i: null,
                    height: Ext.isNumber(s) ? s: null
                };
                t.restorePos = t.getPosition(true)
            }
            if (n) {
                n.suspendLayouts();
                if (r.maximize) {
                    r.maximize.setType("restore")
                }
                if (t.collapseTool) {
                    t.collapseTool.hide();
                    u = true
                }
                t.resumeHeaderLayout(u)
            }
            t.el.disableShadow();
            if (t.dd) {
                t.dd.disable();
                if (n) {
                    n.removeCls(n.indicateDragCls)
                }
            }
            if (t.resizer) {
                t.resizer.disable()
            }
            t.el.addCls(Ext.baseCSSPrefix + "window-maximized");
            t.container.addCls(Ext.baseCSSPrefix + "window-maximized-ct");
            t.syncMonitorWindowResize();
            t.fitContainer(e = e || !!t.animateTarget ? {
                callback: function() {
                    t.maximized = true;
                    t.fireEvent("maximize", t)
                }
            }: null);
            if (!e) {
                t.maximized = true;
                t.fireEvent("maximize", t)
            }
        }
        return t
    },
    restore: function(e) {
        var t = this,
        n = t.tools,
        r = t.header,
        i = t.restoreSize,
        s;
        if (t.maximized) {
            t.hasSavedRestore = null;
            t.removeCls(Ext.baseCSSPrefix + "window-maximized");
            if (r) {
                r.suspendLayouts();
                if (n.maximize) {
                    n.maximize.setType("maximize")
                }
                if (t.collapseTool) {
                    t.collapseTool.show();
                    s = true
                }
                t.resumeHeaderLayout(s)
            }
            i.x = t.restorePos[0];
            i.y = t.restorePos[1];
            t.setBox(i, e = e || !!t.animateTarget ? {
                callback: function() {
                    t.el.enableShadow(true);
                    t.maximized = false;
                    t.fireEvent("restore", t)
                }
            }: null);
            t.restorePos = t.restoreSize = null;
            if (t.dd) {
                t.dd.enable();
                if (r) {
                    r.addCls(r.indicateDragCls)
                }
            }
            if (t.resizer) {
                t.resizer.enable()
            }
            t.container.removeCls(Ext.baseCSSPrefix + "window-maximized-ct");
            t.syncMonitorWindowResize();
            if (!e) {
                t.el.enableShadow(true);
                t.maximized = false;
                t.fireEvent("restore", t)
            }
        }
        return t
    },
    syncMonitorWindowResize: function() {
        var e = this,
        t = e._monitoringResize,
        n = e.monitorResize || e.constrain || e.constrainHeader || e.maximized,
        r = e.hidden || e.destroying || e.isDestroyed;
        if (n && !r) {
            if (!t) {
                Ext.EventManager.onWindowResize(e.onWindowResize, e, {
                    buffer: 1
                });
                e._monitoringResize = true
            }
        } else {
            if (t) {
                Ext.EventManager.removeResizeListener(e.onWindowResize, e);
                e._monitoringResize = false
            }
        }
    },
    toggleMaximize: function() {
        return this[this.maximized ? "restore": "maximize"]()
    },
    createGhost: function() {
        var e = this.callParent(arguments);
        e.xtype = "window";
        return e
    }
});
Ext.define("Ext.form.Labelable", {
    isLabelable: true,
    autoEl: {
        tag: "table",
        cellpadding: 0,
        role: "presentation"
    },
    childEls: ["labelCell", "labelEl", "bodyEl", "sideErrorCell", "errorEl", "inputRow"],
    labelableRenderTpl: ['<tr role="presentation" id="{id}-inputRow" <tpl if="inFormLayout">id="{id}"</tpl> class="{inputRowCls}">', '<tpl if="labelOnLeft">', '<td role="presentation" id="{id}-labelCell" style="{labelCellStyle}" {labelCellAttrs}>', "{beforeLabelTpl}", '<label id="{id}-labelEl" {labelAttrTpl}', '<tpl if="inputId && !(boxLabel && !fieldLabel)"> for="{inputId}"</tpl>', ' class="{labelCls}"', '<tpl if="labelStyle"> style="{labelStyle}"</tpl>', ' unselectable="on"', ">", "{beforeLabelTextTpl}", '<tpl if="fieldLabel">{fieldLabel}', '<tpl if="labelSeparator">', '<span role="separator">{labelSeparator}</span>', "</tpl>", "</tpl>", "{afterLabelTextTpl}", "</label>", "{afterLabelTpl}", "</td>", "</tpl>", '<td role="presentation" class="{baseBodyCls} {fieldBodyCls} {extraFieldBodyCls}" id="{id}-bodyEl" colspan="{bodyColspan}" role="presentation">', "{beforeBodyEl}", "<tpl if=\"labelAlign=='top'\">", "{beforeLabelTpl}", '<div role="presentation" id="{id}-labelCell" style="{labelCellStyle}">', '<label id="{id}-labelEl" {labelAttrTpl}<tpl if="inputId"> for="{inputId}"</tpl> class="{labelCls}"', '<tpl if="labelStyle"> style="{labelStyle}"</tpl>', ' unselectable="on"', ">", "{beforeLabelTextTpl}", '<tpl if="fieldLabel">{fieldLabel}', '<tpl if="labelSeparator">', '<span role="separator">{labelSeparator}</span>', "</tpl>", "</tpl>", "{afterLabelTextTpl}", "</label>", "</div>", "{afterLabelTpl}", "</tpl>", "{beforeSubTpl}", "{[values.$comp.getSubTplMarkup(values)]}", "{afterSubTpl}", "<tpl if=\"msgTarget==='side'\">", "{afterBodyEl}", "</td>", "<td role=\"presentation\" id=\"{id}-sideErrorCell\" vAlign=\"{[values.labelAlign==='top' && !values.hideLabel ? 'bottom' : 'middle']}\" style=\"{[values.autoFitErrors ? 'display:none' : '']}\" width=\"{errorIconWidth}\">", '<div role="alert" aria-live="polite" id="{id}-errorEl" class="{errorMsgCls}" style="display:none"></div>', "</td>", "<tpl elseif=\"msgTarget=='under'\">", '<div role="alert" aria-live="polite" id="{id}-errorEl" class="{errorMsgClass}" colspan="2" style="display:none"></div>', "{afterBodyEl}", "</td>", "</tpl>", "</tr>", {
        disableFormats: true
    }],
    activeErrorsTpl: undefined,
    htmlActiveErrorsTpl: ['<tpl if="errors && errors.length">', '<ul class="{listCls}">', '<tpl if="Ext.enableAria">', '<tpl if="fieldLabel"><div>{fieldLabel}</div></tpl>', "</tpl>", '<tpl for="errors"><li>{.}</li></tpl>', "</ul>", "</tpl>"],
    plaintextActiveErrorsTpl: ['<tpl if="errors && errors.length">', '<tpl if="Ext.enableAria">', '<tpl if="fieldLabel">{fieldLabel}\n</tpl>', "</tpl>", '<tpl for="errors"><tpl if="xindex &gt; 1">\n</tpl>{.}</tpl>', "</tpl>"],
    isFieldLabelable: true,
    formItemCls: Ext.baseCSSPrefix + "form-item",
    labelCls: Ext.baseCSSPrefix + "form-item-label",
    errorMsgCls: Ext.baseCSSPrefix + "form-error-msg",
    baseBodyCls: Ext.baseCSSPrefix + "form-item-body",
    inputRowCls: Ext.baseCSSPrefix + "form-item-input-row",
    fieldBodyCls: "",
    clearCls: Ext.baseCSSPrefix + "clear",
    invalidCls: Ext.baseCSSPrefix + "form-invalid",
    fieldLabel: undefined,
    labelAlign: "left",
    labelWidth: 100,
    labelPad: 5,
    labelSeparator: ":",
    hideLabel: false,
    hideEmptyLabel: true,
    preventMark: false,
    autoFitErrors: true,
    msgTarget: "qtip",
    noWrap: true,
    labelableInsertions: ["beforeBodyEl", "afterBodyEl", "beforeLabelTpl", "afterLabelTpl", "beforeSubTpl", "afterSubTpl", "beforeLabelTextTpl", "afterLabelTextTpl", "labelAttrTpl"],
    labelableRenderProps: ["allowBlank", "id", "labelAlign", "fieldBodyCls", "extraFieldBodyCls", "baseBodyCls", "clearCls", "labelSeparator", "msgTarget", "inputRowCls"],
    initLabelable: function() {
        var e = this,
        t = e.padding;
        if (t) {
            e.padding = undefined;
            e.extraMargins = Ext.Element.parseBox(t)
        }
        if (!e.activeErrorsTpl) {
            if (e.msgTarget == "title") {
                e.activeErrorsTpl = e.plaintextActiveErrorsTpl
            } else {
                e.activeErrorsTpl = e.htmlActiveErrorsTpl
            }
        }
        e.addCls(Ext.plainTableCls);
        e.addCls(e.formItemCls);
        e.lastActiveError = "";
        e.addEvents("errorchange");
        e.enableBubble("errorchange")
    },
    setLabelWidth: function(e) {
        var t = this,
        n = e + t.labelPad;
        t.labelCell.setWidth(n);
        t.labelEl.setWidth(n);
        t.labelWidth = e
    },
    trimLabelSeparator: function() {
        var e = this,
        t = e.labelSeparator,
        n = e.fieldLabel || "",
        r = n.substr(n.length - 1);
        return r === t ? n.slice(0, -1) : n
    },
    getFieldLabel: function() {
        return this.trimLabelSeparator()
    },
    setFieldLabel: function(e) {
        e = e || "";
        var t = this,
        n = t.labelSeparator,
        r = t.labelEl;
        t.fieldLabel = e;
        if (t.rendered) {
            if (Ext.isEmpty(e) && t.hideEmptyLabel) {
                r.parent().setDisplayed("none")
            } else {
                if (n) {
                    e = t.trimLabelSeparator() + n
                }
                r.update(e);
                r.parent().setDisplayed("")
            }
            t.updateLayout()
        }
    },
    getInsertionRenderData: function(e, t) {
        var n = t.length,
        r, i;
        while (n--) {
            r = t[n];
            i = this[r];
            if (i) {
                if (typeof i != "string") {
                    if (!i.isTemplate) {
                        i = Ext.XTemplate.getTpl(this, r)
                    }
                    i = i.apply(e)
                }
            }
            e[r] = i || ""
        }
        return e
    },
    getLabelableRenderData: function() {
        var e = this,
        t, n, r = e.labelAlign === "top";
        if (!Ext.form.Labelable.errorIconWidth) {
            n = Ext.getBody().createChild({
                style: "position:absolute",
                cls: Ext.baseCSSPrefix + "form-invalid-icon"
            });
            Ext.form.Labelable.errorIconWidth = n.getWidth() + n.getMargin("l");
            n.remove()
        }
        t = Ext.copyTo({
            inFormLayout: e.ownerLayout && e.ownerLayout.type === "form",
            inputId: e.getInputId(),
            labelOnLeft: !r,
            hideLabel: !e.hasVisibleLabel(),
            fieldLabel: e.getFieldLabel(),
            labelCellStyle: e.getLabelCellStyle(),
            labelCellAttrs: e.getLabelCellAttrs(),
            labelCls: e.getLabelCls(),
            labelStyle: e.getLabelStyle(),
            bodyColspan: e.getBodyColspan(),
            externalError: !e.autoFitErrors,
            errorMsgCls: e.getErrorMsgCls(),
            errorIconWidth: Ext.form.Labelable.errorIconWidth,
            boxLabel: e.boxLabel
        },
        e, e.labelableRenderProps, true);
        e.getInsertionRenderData(t, e.labelableInsertions);
        return t
    },
    xhooks: {
        beforeRender: function() {
            var e = this;
            e.setFieldDefaults(e.getHierarchyState().fieldDefaults);
            if (e.ownerLayout) {
                e.addCls(Ext.baseCSSPrefix + e.ownerLayout.type + "-form-item")
            }
        },
        onRender: function() {
            var e = this,
            t, n, r = {};
            if (e.extraMargins) {
                t = e.el.getMargin();
                for (n in t) {
                    if (t.hasOwnProperty(n)) {
                        r["margin-" + n] = t[n] + e.extraMargins[n] + "px"
                    }
                }
                e.el.setStyle(r)
            }
        }
    },
    hasVisibleLabel: function() {
        if (this.hideLabel) {
            return false
        }
        return ! (this.hideEmptyLabel && !this.getFieldLabel())
    },
    getLabelWidth: function() {
        var e = this;
        if (!e.hasVisibleLabel()) {
            return 0
        }
        return e.labelWidth + e.labelPad
    },
    getBodyColspan: function() {
        var e = this,
        t;
        if (e.msgTarget === "side" && (!e.autoFitErrors || e.hasActiveError())) {
            t = 1
        } else {
            t = 2
        }
        if (e.labelAlign !== "top" && !e.hasVisibleLabel()) {
            t++
        }
        return t
    },
    getLabelCls: function() {
        var e = this.labelCls + " " + Ext.dom.Element.unselectableCls,
        t = this.labelClsExtra;
        return t ? e + " " + t: e
    },
    getLabelCellStyle: function() {
        var e = this,
        t = e.hideLabel || !e.getFieldLabel() && e.hideEmptyLabel;
        return t ? "display:none;": ""
    },
    getErrorMsgCls: function() {
        var e = this,
        t = e.hideLabel || !e.fieldLabel && e.hideEmptyLabel;
        return e.errorMsgCls + (!t && e.labelAlign === "top" ? " " + Ext.baseCSSPrefix + "lbl-top-err-icon": "")
    },
    getLabelCellAttrs: function() {
        var e = this,
        t = e.labelAlign,
        n = "";
        if (t !== "top") {
            n = 'valign="top" halign="' + t + '" width="' + (e.labelWidth + e.labelPad) + '"'
        }
        return n + ' class="' + Ext.baseCSSPrefix + 'field-label-cell"'
    },
    getLabelStyle: function() {
        var e = this,
        t = e.labelPad,
        n = e.labelWidth,
        r = "";
        if (e.labelAlign !== "top") {
            if (n) {
                r = "width:" + n + "px;"
            }
            if (t) {
                r += e.getLabelStyleMarginProp() + t + "px;"
            }
        } else {
            if (t) {
                r = "margin-bottom:" + t + "px;"
            }
        }
        return r + (e.labelStyle || "")
    },
    getLabelStyleMarginProp: function() {
        return "margin-right:"
    },
    getSubTplMarkup: function() {
        return ""
    },
    getInputId: function() {
        return ""
    },
    getActiveError: function() {
        return this.activeError || ""
    },
    hasActiveError: function() {
        return !! this.getActiveError()
    },
    setActiveError: function(e) {
        this.setActiveErrors(e)
    },
    getActiveErrors: function() {
        return this.activeErrors || []
    },
    setActiveErrors: function(e) {
        var t = this,
        n;
        e = Ext.Array.from(e);
        n = t.getTpl("activeErrorsTpl");
        t.activeErrors = e;
        t.activeError = n.apply({
            fieldLabel: t.fieldLabel,
            errors: e,
            listCls: Ext.plainListCls
        });
        t.renderActiveError()
    },
    unsetActiveError: function() {
        delete this.activeError;
        delete this.activeErrors;
        this.renderActiveError()
    },
    renderActiveError: function() {
        var e = this,
        t = e.getActiveError(),
        n = !!t;
        if (t !== e.lastActiveError) {
            e.fireEvent("errorchange", e, t);
            e.lastActiveError = t
        }
        if (e.rendered && !e.isDestroyed && !e.preventMark) {
            e.el[n ? "addCls": "removeCls"](e.invalidCls);
            if (e.errorEl) {
                e.errorEl.dom.innerHTML = t
            }
        }
    },
    setFieldDefaults: function(e) {
        var t;
        for (t in e) {
            if (!this.hasOwnProperty(t)) {
                this[t] = e[t]
            }
        }
    }
});
Ext.define("Ext.form.field.Field", {
    isFormField: true,
    disabled: false,
    submitValue: false,
    validateOnChange: true,
    suspendCheckChange: 0,
    initField: function() {
        this.addEvents("change", "validitychange", "dirtychange");
        this.initValue()
    },
    initValue: function() {
        var e = this;
        e.value = e.transformOriginalValue(e.value);
        e.originalValue = e.lastValue = e.value;
        e.suspendCheckChange++;
        e.setValue(e.value);
        e.suspendCheckChange--
    },
    transformOriginalValue: Ext.identityFn,
    getFieldIdentifier: function() {
        return this.isEditorComponent ? this.dataIndex: this.name
    },
    getName: function() {
        return this.name
    },
    getValue: function() {
        return this.value
    },
    setValue: function(e) {
        var t = this;
        t.value = e;
        t.checkChange();
        return t
    },
    isEqual: function(e, t) {
        return String(e) === String(t)
    },
    isEqualAsString: function(e, t) {
        return String(Ext.value(e, "")) === String(Ext.value(t, ""))
    },
    getSubmitData: function() {
        var e = this,
        t = null;
        if (!e.disabled && e.submitValue) {
            t = {};
            t[e.getName()] = "" + e.getValue()
        }
        return t
    },
    getModelData: function(e, t) {
        var n = this,
        r = null;
        if (!n.disabled && (n.submitValue || !t)) {
            r = {};
            r[n.getFieldIdentifier()] = n.getValue()
        }
        return r
    },
    reset: function() {
        var e = this;
        e.beforeReset();
        e.setValue(e.originalValue);
        e.clearInvalid();
        delete e.wasValid
    },
    beforeReset: Ext.emptyFn,
    resetOriginalValue: function() {
        this.originalValue = this.getValue();
        this.checkDirty()
    },
    checkChange: function() {
        var e = this,
        t, n;
        if (!e.suspendCheckChange) {
            t = e.getValue();
            n = e.lastValue;
            if (!e.isDestroyed && e.didValueChange(t, n)) {
                e.lastValue = t;
                e.fireEvent("change", e, t, n);
                e.onChange(t, n)
            }
        }
    },
    didValueChange: function(e, t) {
        return ! this.isEqual(e, t)
    },
    onChange: function(e, t) {
        if (this.validateOnChange) {
            this.validate()
        }
        this.checkDirty()
    },
    isDirty: function() {
        var e = this;
        return ! e.disabled && !e.isEqual(e.getValue(), e.originalValue)
    },
    checkDirty: function() {
        var e = this,
        t = e.isDirty();
        if (t !== e.wasDirty) {
            e.fireEvent("dirtychange", e, t);
            e.onDirtyChange(t);
            e.wasDirty = t
        }
    },
    onDirtyChange: Ext.emptyFn,
    getErrors: function(e) {
        return []
    },
    isValid: function() {
        var e = this;
        return e.disabled || Ext.isEmpty(e.getErrors())
    },
    validate: function() {
        var e = this,
        t = e.isValid();
        if (t !== e.wasValid) {
            e.wasValid = t;
            e.fireEvent("validitychange", e, t)
        }
        return t
    },
    batchChanges: function(e) {
        try {
            this.suspendCheckChange++;
            e()
        } catch(t) {
            throw t
        } finally {
            this.suspendCheckChange--
        }
        this.checkChange()
    },
    isFileUpload: function() {
        return false
    },
    extractFileInput: function() {
        return null
    },
    markInvalid: Ext.emptyFn,
    clearInvalid: Ext.emptyFn
});
Ext.define("Ext.layout.component.field.Field", {
    extend: Ext.layout.component.Auto,
    alias: "layout.field",
    type: "field",
    naturalSizingProp: "size",
    beginLayout: function(e) {
        var t = this,
        n = t.owner;
        t.callParent(arguments);
        e.labelStrategy = t.getLabelStrategy();
        e.errorStrategy = t.getErrorStrategy();
        e.labelContext = e.getEl("labelEl");
        e.bodyCellContext = e.getEl("bodyEl");
        e.inputContext = e.getEl("inputEl");
        e.errorContext = e.getEl("errorEl");
        if (Ext.isIE7m && Ext.isStrict && e.inputContext) {
            t.ieInputWidthAdjustment = e.inputContext.getPaddingInfo().width + e.inputContext.getBorderInfo().width
        }
        e.labelStrategy.prepare(e, n);
        e.errorStrategy.prepare(e, n)
    },
    beginLayoutCycle: function(e) {
        var t = this,
        n = t.owner,
        r = e.widthModel,
        i = n[t.naturalSizingProp],
        s;
        t.callParent(arguments);
        if (r.shrinkWrap) {
            t.beginLayoutShrinkWrap(e)
        } else {
            if (r.natural) {
                if (typeof i == "number" && !n.inputWidth) {
                    t.beginLayoutFixed(e, s = i * 6.5 + 20, "px")
                } else {
                    t.beginLayoutShrinkWrap(e)
                }
                e.setWidth(s, false)
            } else {
                t.beginLayoutFixed(e, "100", "%")
            }
        }
    },
    beginLayoutFixed: function(e, t, n) {
        var r = e.target,
        i = r.inputEl,
        s = r.inputWidth;
        r.el.setStyle("table-layout", "fixed");
        r.bodyEl.setStyle("width", t + n);
        if (i) {
            if (s) {
                i.setStyle("width", s + "px")
            } else {
                i.setStyle("width", r.stretchInputElFixed ? "100%": "")
            }
        }
        e.isFixed = true
    },
    beginLayoutShrinkWrap: function(e) {
        var t = e.target,
        n = t.inputEl,
        r = t.inputWidth;
        if (n && n.dom) {
            n.dom.removeAttribute("size");
            if (r) {
                n.setStyle("width", r + "px")
            } else {
                n.setStyle("width", "")
            }
        }
        t.el.setStyle("table-layout", "auto");
        t.bodyEl.setStyle("width", "")
    },
    finishedLayout: function(e) {
        var t = this.owner;
        this.callParent(arguments);
        e.labelStrategy.finishedLayout(e, t);
        e.errorStrategy.finishedLayout(e, t)
    },
    calculateOwnerHeightFromContentHeight: function(e, t) {
        return t
    },
    measureContentHeight: function(e) {
        return e.el.getHeight()
    },
    measureContentWidth: function(e) {
        return e.el.getWidth()
    },
    measureLabelErrorHeight: function(e) {
        return e.labelStrategy.getHeight(e) + e.errorStrategy.getHeight(e)
    },
    onFocus: function() {
        this.getErrorStrategy().onFocus(this.owner)
    },
    getLabelStrategy: function() {
        var e = this,
        t = e.labelStrategies,
        n = e.owner.labelAlign;
        return t[n] || t.base
    },
    getErrorStrategy: function() {
        var e = this,
        t = e.owner,
        n = e.errorStrategies,
        r = t.msgTarget;
        return ! t.preventMark && Ext.isString(r) ? n[r] || n.elementId: n.none
    },
    labelStrategies: function() {
        var e = {
            prepare: function(e, t) {
                var n = t.labelCls + "-" + t.labelAlign,
                r = t.labelEl;
                if (r) {
                    r.addCls(n)
                }
            },
            getHeight: function() {
                return 0
            },
            finishedLayout: Ext.emptyFn
        };
        return {
            base: e,
            top: Ext.applyIf({
                getHeight: function(e) {
                    var t = e.labelContext,
                    n = t.props,
                    r = n.height;
                    if (r === undefined) {
                        n.height = r = t.el.getHeight() + t.getMarginInfo().height
                    }
                    return r
                }
            },
            e),
            left: e,
            right: e
        }
    } (),
    errorStrategies: function() {
        function e(e) {
            var t = Ext.layout.component.field.Field.tip,
            n;
            if (t && t.isVisible()) {
                n = t.activeTarget;
                if (n && n.el === e.getActionEl().dom) {
                    t.toFront(true)
                }
            }
        }
        var t = Ext.applyIf,
        n = Ext.emptyFn,
        r = Ext.baseCSSPrefix + "form-invalid-icon",
        i, s = {
            prepare: function(e, t) {
                var n = t.errorEl;
                if (n) {
                    n.setDisplayed(false)
                }
            },
            getHeight: function() {
                return 0
            },
            onFocus: n,
            finishedLayout: n
        };
        return {
            none: s,
            side: t({
                prepare: function(e, t) {
                    var n = t.errorEl,
                    s = t.sideErrorCell,
                    o = t.hasActiveError(),
                    u;
                    if (!i) {
                        i = (u = Ext.getBody().createChild({
                            style: "position:absolute",
                            cls: r
                        })).getWidth();
                        u.remove()
                    }
                    n.addCls(r);
                    n.set({
                        "data-errorqtip": t.getActiveError() || ""
                    });
                    if (t.autoFitErrors) {
                        n.setDisplayed(o)
                    } else {
                        n.setVisible(o)
                    }
                    if (s && t.autoFitErrors) {
                        s.setDisplayed(o)
                    }
                    t.bodyEl.dom.colSpan = t.getBodyColspan();
                    Ext.layout.component.field.Field.initTip()
                },
                onFocus: e
            },
            s),
            under: t({
                prepare: function(e, t) {
                    var n = t.errorEl,
                    r = Ext.baseCSSPrefix + "form-invalid-under";
                    n.addCls(r);
                    n.setDisplayed(t.hasActiveError())
                },
                getHeight: function(e) {
                    var t = 0,
                    n, r;
                    if (e.target.hasActiveError()) {
                        n = e.errorContext;
                        r = n.props;
                        t = r.height;
                        if (t === undefined) {
                            r.height = t = n.el.getHeight()
                        }
                    }
                    return t
                }
            },
            s),
            qtip: t({
                prepare: function(e, t) {
                    Ext.layout.component.field.Field.initTip();
                    t.getActionEl().dom.setAttribute("data-errorqtip", t.getActiveError() || "")
                },
                onFocus: e
            },
            s),
            title: t({
                prepare: function(e, t) {
                    t.getActionEl().dom.setAttribute("title", t.getActiveError() || "")
                }
            },
            s),
            elementId: t({
                prepare: function(e, t) {
                    var n = Ext.fly(t.msgTarget);
                    if (n) {
                        n.dom.innerHTML = t.getActiveError() || "";
                        n.setDisplayed(t.hasActiveError())
                    }
                }
            },
            s)
        }
    } (),
    statics: {
        initTip: function() {
            var e = this.tip;
            if (!e) {
                e = this.tip = Ext.create("Ext.tip.QuickTip", {
                    ui: "form-invalid"
                });
                e.tagConfig = Ext.apply({},
                {
                    attribute: "errorqtip"
                },
                e.tagConfig)
            }
        },
        destroyTip: function() {
            var e = this.tip;
            if (e) {
                e.destroy();
                delete this.tip
            }
        }
    }
});
Ext.define("Ext.form.field.Base", {
    extend: Ext.Component,
    mixins: {
        labelable: Ext.form.Labelable,
        field: Ext.form.field.Field
    },
    alias: "widget.field",
    alternateClassName: ["Ext.form.Field", "Ext.form.BaseField"],
    fieldSubTpl: ['<input id="{id}" type="{type}" role="{role}" {inputAttrTpl}', ' size="1"', '<tpl if="name"> name="{name}"</tpl>', '<tpl if="value"> value="{[Ext.util.Format.htmlEncode(values.value)]}"</tpl>', '<tpl if="placeholder"> placeholder="{placeholder}"</tpl>', '{%if (values.maxLength !== undefined){%} maxlength="{maxLength}"{%}%}', '<tpl if="readOnly"> readonly="readonly"</tpl>', '<tpl if="disabled"> disabled="disabled"</tpl>', '<tpl if="tabIdx"> tabIndex="{tabIdx}"</tpl>', '<tpl if="fieldStyle"> style="{fieldStyle}"</tpl>', ' class="{fieldCls} {typeCls} {editableCls} {inputCls}" autocomplete="off"/>', {
        disableFormats: true
    }],
    subTplInsertions: ["inputAttrTpl"],
    inputType: "text",
    invalidText: "The value in this field is invalid",
    fieldCls: Ext.baseCSSPrefix + "form-field",
    focusCls: "form-focus",
    dirtyCls: Ext.baseCSSPrefix + "form-dirty",
    checkChangeEvents: Ext.isIE && (!document.documentMode || document.documentMode < 9) ? ["change", "propertychange", "keyup"] : ["change", "input", "textInput", "keyup", "dragdrop"],
    ignoreChangeRe: /data\-errorqtip|style\.|className/,
    checkChangeBuffer: 50,
    componentLayout: "field",
    readOnly: false,
    readOnlyCls: Ext.baseCSSPrefix + "form-readonly",
    validateOnBlur: true,
    hasFocus: false,
    baseCls: Ext.baseCSSPrefix + "field",
    maskOnDisable: false,
    stretchInputElFixed: true,
    initComponent: function() {
        var e = this;
        e.callParent();
        e.subTplData = e.subTplData || {};
        e.addEvents("specialkey", "writeablechange");
        e.initLabelable();
        e.initField();
        if (!e.name) {
            e.name = e.getInputId()
        }
        if (e.readOnly) {
            e.addCls(e.readOnlyCls)
        }
        e.addCls(Ext.baseCSSPrefix + "form-type-" + e.inputType)
    },
    getInputId: function() {
        return this.inputId || (this.inputId = this.id + "-inputEl")
    },
    getSubTplData: function() {
        var e = this,
        t = e.inputType,
        n = e.getInputId(),
        r;
        r = Ext.apply({
            id: n,
            cmpId: e.id,
            name: e.name || n,
            disabled: e.disabled,
            readOnly: e.readOnly,
            value: e.getRawValue(),
            type: t,
            fieldCls: e.fieldCls,
            fieldStyle: e.getFieldStyle(),
            tabIdx: e.tabIndex,
            inputCls: e.inputCls,
            typeCls: Ext.baseCSSPrefix + "form-" + (t === "password" ? "text": t),
            role: e.ariaRole
        },
        e.subTplData);
        e.getInsertionRenderData(r, e.subTplInsertions);
        return r
    },
    applyRenderSelectors: function() {
        var e = this;
        e.callParent();
        e.addChildEls("inputEl");
        e.inputEl = e.el.getById(e.getInputId())
    },
    getSubTplMarkup: function() {
        return this.getTpl("fieldSubTpl").apply(this.getSubTplData())
    },
    initRenderTpl: function() {
        var e = this;
        if (!e.hasOwnProperty("renderTpl")) {
            e.renderTpl = e.getTpl("labelableRenderTpl")
        }
        return e.callParent()
    },
    initRenderData: function() {
        return Ext.applyIf(this.callParent(), this.getLabelableRenderData())
    },
    setFieldStyle: function(e) {
        var t = this,
        n = t.inputEl;
        if (n) {
            n.applyStyles(e)
        }
        t.fieldStyle = e
    },
    getFieldStyle: function() {
        var e = this.fieldStyle;
        return Ext.isObject(e) ? Ext.DomHelper.generateStyles(e, null, true) : e || ""
    },
    onRender: function() {
        this.callParent(arguments);
        this.renderActiveError()
    },
    getFocusEl: function() {
        return this.inputEl
    },
    isFileUpload: function() {
        return this.inputType === "file"
    },
    getSubmitData: function() {
        var e = this,
        t = null,
        n;
        if (!e.disabled && e.submitValue) {
            n = e.getSubmitValue();
            if (n !== null) {
                t = {};
                t[e.getName()] = n
            }
        }
        return t
    },
    getSubmitValue: function() {
        return this.processRawValue(this.getRawValue())
    },
    getRawValue: function() {
        var e = this,
        t = e.inputEl ? e.inputEl.getValue() : Ext.value(e.rawValue, "");
        e.rawValue = t;
        return t
    },
    setRawValue: function(e) {
        var t = this;
        e = Ext.value(t.transformRawValue(e), "");
        t.rawValue = e;
        if (t.inputEl) {
            t.bindPropertyChange(false);
            t.inputEl.dom.value = e;
            t.bindPropertyChange(true)
        }
        return e
    },
    transformRawValue: Ext.identityFn,
    valueToRaw: function(e) {
        return "" + Ext.value(e, "")
    },
    rawToValue: Ext.identityFn,
    processRawValue: Ext.identityFn,
    getValue: function() {
        var e = this,
        t = e.rawToValue(e.processRawValue(e.getRawValue()));
        e.value = t;
        return t
    },
    setValue: function(e) {
        var t = this;
        t.setRawValue(t.valueToRaw(e));
        return t.mixins.field.setValue.call(t, e)
    },
    onBoxReady: function() {
        var e = this;
        e.callParent(arguments);
        if (e.setReadOnlyOnBoxReady) {
            e.setReadOnly(e.readOnly)
        }
    },
    onDisable: function() {
        var e = this,
        t = e.inputEl;
        e.callParent();
        if (t) {
            t.dom.disabled = true;
            if (e.hasActiveError()) {
                e.clearInvalid();
                e.needsValidateOnEnable = true
            }
        }
    },
    onEnable: function() {
        var e = this,
        t = e.inputEl;
        e.callParent();
        if (t) {
            t.dom.disabled = false;
            if (e.needsValidateOnEnable) {
                delete e.needsValidateOnEnable;
                e.forceValidation = true;
                e.isValid();
                delete e.forceValidation
            }
        }
    },
    setReadOnly: function(e) {
        var t = this,
        n = t.inputEl;
        e = !!e;
        t[e ? "addCls": "removeCls"](t.readOnlyCls);
        t.readOnly = e;
        if (n) {
            n[e ? "addCls": "removeCls"]("wb-disabled");
            n.dom.readOnly = e
        } else {
            if (t.rendering) {
                t.setReadOnlyOnBoxReady = true
            }
        }
        t.fireEvent("writeablechange", t, e)
    },
    fireKey: function(e) {
        if (e.isSpecialKey()) {
            this.fireEvent("specialkey", this, new Ext.EventObjectImpl(e))
        }
    },
    initEvents: function() {
        var e = this,
        t = e.inputEl,
        n, r, i = e.checkChangeEvents,
        s = e.ignoreChangeRe,
        o = i.length,
        u, a;
        if (t) {
            e.mon(t, Ext.EventManager.getKeyEvent(), e.fireKey, e);
            n = new Ext.util.DelayedTask(e.checkChange, e);
            e.onChangeEvent = r = function(t) {
                if (! (t.type == "propertychange" && s.test(t.browserEvent.propertyName))) {
                    n.delay(e.checkChangeBuffer)
                }
            };
            for (u = 0; u < o; u++) {
                a = i[u];
                if (a === "propertychange") {
                    e.usesPropertychange = true
                }
                e.mon(t, a, r)
            }
        }
        e.callParent()
    },
    doComponentLayout: function() {
        this.bindPropertyChange(false);
        this.callParent(arguments);
        this.bindPropertyChange(true)
    },
    bindPropertyChange: function(e) {
        var t = this,
        n = t.usesPropertychange;
        if (n) {
            t[e ? "mon": "mun"](t.inputEl, "propertychange", t.onChangeEvent)
        }
    },
    onDirtyChange: function(e) {
        this[e ? "addCls": "removeCls"](this.dirtyCls)
    },
    isValid: function() {
        var e = this,
        t = e.disabled,
        n = e.forceValidation || !t;
        return n ? e.validateValue(e.processRawValue(e.getRawValue())) : t
    },
    validateValue: function(e) {
        var t = this,
        n = t.getErrors(e),
        r = Ext.isEmpty(n);
        if (!t.preventMark) {
            if (r) {
                t.clearInvalid()
            } else {
                t.markInvalid(n)
            }
        }
        return r
    },
    markInvalid: function(e) {
        var t = this,
        n = t.getActiveError(),
        r;
        t.setActiveErrors(Ext.Array.from(e));
        r = t.getActiveError();
        if (n !== r) {
            t.setError(r)
        }
    },
    clearInvalid: function() {
        var e = this,
        t = e.hasActiveError();
        delete e.needsValidateOnEnable;
        e.unsetActiveError();
        if (t) {
            e.setError("")
        }
    },
    setError: function(e) {
        var t = this,
        n = t.msgTarget,
        r;
        if (t.rendered) {
            if (n == "title" || n == "qtip") {
                if (t.rendered) {
                    r = n == "qtip" ? "data-errorqtip": "title"
                }
                t.getActionEl().dom.setAttribute(r, e || "")
            } else {
                t.updateLayout()
            }
        }
    },
    renderActiveError: function() {
        var e = this,
        t = e.hasActiveError();
        if (e.inputEl) {
            e.inputEl[t ? "addCls": "removeCls"](e.invalidCls + "-field")
        }
        e.mixins.labelable.renderActiveError.call(e)
    },
    getActionEl: function() {
        return this.inputEl || this.el
    }
});
Ext.define("Ext.form.field.VTypes",
function() {
    var e = /^[a-zA-Z_]+$/,
    t = /^[a-zA-Z0-9_]+$/,
    n = /^(")?(?:[^\."])(?:(?:[\.])?(?:[\w\-!#$%&'*+/ = ?^_` { |
    }~])) * \1@ (\w[\ - \w] * \.) {
        1,
        5
    } ([A - Za - z]) {
        2,
        6
    }
    $ / ,
    r = /(((^https?)|(^ftp)):\/\/((([\-\w]+\.)+\w{2,3}(\/[%\-\w]+(\.\w{2,})?)*(([\w\-\.\?\\\/+@&#;`~=%!]*)(\.\w{2,})?)*)|(localhost|LOCALHOST))\/?)/i;
    return {
        singleton: true,
        alternateClassName: "Ext.form.VTypes",
        email: function(e) {
            return n.test(e)
        },
        emailText: 'This field should be an e-mail address in the format "user@example.com"',
        emailMask: /[\w.\-@'"!#$%&'*+/ = ?^_` { |
        }~] / i,
        url: function(e) {
            return r.test(e)
        },
        urlText: 'This field should be a URL in the format "http://www.example.com"',
        alpha: function(t) {
            return e.test(t)
        },
        alphaText: "This field should only contain letters and _",
        alphaMask: /[a-z_]/i,
        alphanum: function(e) {
            return t.test(e)
        },
        alphanumText: "This field should only contain letters, numbers and _",
        alphanumMask: /[a-z0-9_]/i
    }
} ());Ext.define("Ext.layout.component.field.Text", {
    extend: Ext.layout.component.field.Field,
    alias: "layout.textfield",
    type: "textfield",
    setWidthInDom: true,
    canGrowWidth: true,
    beginLayoutCycle: function(e) {
        this.callParent(arguments);
        if (e.heightModel.shrinkWrap) {
            e.inputContext.el.setStyle("height", "")
        }
    },
    measureContentWidth: function(e) {
        var t = this,
        n = t.owner,
        r = t.callParent(arguments),
        i = e.inputContext,
        s,
        o,
        u,
        a,
        f;
        if (n.grow && t.canGrowWidth && !e.state.growHandled) {
            s = n.inputEl;
            o = Ext.util.Format.htmlEncode(s.dom.value || (n.hasFocus ? "": n.emptyText) || "");
            o += n.growAppend;
            u = s.getTextWidth(o) + i.getFrameInfo().width;
            a = n.growMax;
            f = Math.min(a, r);
            a = Math.max(n.growMin, a, f);
            u = Ext.Number.constrain(u, n.growMin, a);
            i.setWidth(u);
            e.state.growHandled = true;
            i.domBlock(t, "width");
            r = NaN
        }
        return r
    },
    publishInnerHeight: function(e, t) {
        e.inputContext.setHeight(t - this.measureLabelErrorHeight(e))
    },
    beginLayoutFixed: function(e, t, n) {
        var r = this,
        i = r.ieInputWidthAdjustment;
        if (i) {
            r.adjustIEInputPadding(e);
            if (n === "px") {
                t -= i
            }
        }
        r.callParent(arguments)
    },
    adjustIEInputPadding: function(e) {
        this.owner.bodyEl.setStyle("padding-right", this.ieInputWidthAdjustment + "px")
    }
});Ext.define("Ext.form.field.Text", {
    extend: Ext.form.field.Base,
    alias: "widget.textfield",
    alternateClassName: ["Ext.form.TextField", "Ext.form.Text"],
    size: 20,
    growMin: 30,
    growMax: 800,
    growAppend: "W",
    allowBlank: true,
    validateBlank: false,
    allowOnlyWhitespace: true,
    minLength: 0,
    maxLength: Number.MAX_VALUE,
    minLengthText: "The minimum length for this field is {0}",
    maxLengthText: "The maximum length for this field is {0}",
    blankText: "This field is required",
    regexText: "",
    emptyCls: Ext.baseCSSPrefix + "form-empty-field",
    requiredCls: Ext.baseCSSPrefix + "form-required-field",
    componentLayout: "textfield",
    valueContainsPlaceholder: false,
    ariaRole: "textbox",
    initComponent: function() {
        var e = this;
        if (e.allowOnlyWhitespace === false) {
            e.allowBlank = false
        }
        e.callParent();
        e.addEvents("autosize", "keydown", "keyup", "keypress");
        if (e.readOnly) {
            e.fieldCls = "wb-disabled " + e.fieldCls
        }
        e.addStateEvents("change");
        e.setGrowSizePolicy()
    },
    setGrowSizePolicy: function() {
        if (this.grow) {
            this.shrinkWrap |= 1
        }
    },
    initEvents: function() {
        var e = this,
        t = e.inputEl;
        e.callParent();
        if (e.selectOnFocus || e.emptyText) {
            e.mon(t, "mousedown", e.onMouseDown, e)
        }
        if (e.maskRe || e.vtype && e.disableKeyFilter !== true && (e.maskRe = Ext.form.field.VTypes[e.vtype + "Mask"])) {
            e.mon(t, "keypress", e.filterKeys, e)
        }
        if (e.enableKeyEvents) {
            e.mon(t, {
                scope: e,
                keyup: e.onKeyUp,
                keydown: e.onKeyDown,
                keypress: e.onKeyPress
            })
        }
    },
    isEqual: function(e, t) {
        return this.isEqualAsString(e, t)
    },
    onChange: function(e, t) {
        this.callParent(arguments);
        this.autoSize()
    },
    getSubTplData: function() {
        var e = this,
        t = e.getRawValue(),
        n = e.emptyText && t.length < 1,
        r = e.maxLength,
        i;
        if (e.enforceMaxLength) {
            if (r === Number.MAX_VALUE) {
                r = undefined
            }
        } else {
            r = undefined
        }
        if (n) {
            if (Ext.supports.Placeholder) {
                i = e.emptyText
            } else {
                t = e.emptyText;
                e.valueContainsPlaceholder = true
            }
        }
        return Ext.apply(e.callParent(), {
            maxLength: r,
            readOnly: e.readOnly,
            placeholder: i,
            value: t,
            fieldCls: e.fieldCls + (n && (i || t) ? " " + e.emptyCls: "") + (e.allowBlank ? "": " " + e.requiredCls)
        })
    },
    afterRender: function() {
        this.autoSize();
        this.callParent()
    },
    onMouseDown: function(e) {
        var t = this;
        if (!t.hasFocus) {
            t.mon(t.inputEl, "mouseup", Ext.emptyFn, t, {
                single: true,
                preventDefault: true
            })
        }
    },
    processRawValue: function(e) {
        var t = this,
        n = t.stripCharsRe,
        r;
        if (n) {
            r = e.replace(n, "");
            if (r !== e) {
                t.setRawValue(r);
                e = r
            }
        }
        return e
    },
    onDisable: function() {
        this.callParent();
        if (Ext.isIE) {
            this.inputEl.dom.unselectable = "on"
        }
    },
    onEnable: function() {
        this.callParent();
        if (Ext.isIE) {
            this.inputEl.dom.unselectable = ""
        }
    },
    onKeyDown: function(e) {
        this.fireEvent("keydown", this, e)
    },
    onKeyUp: function(e) {
        this.fireEvent("keyup", this, e)
    },
    onKeyPress: function(e) {
        this.fireEvent("keypress", this, e)
    },
    reset: function() {
        this.callParent();
        this.applyEmptyText()
    },
    applyEmptyText: function() {
        var e = this,
        t = e.emptyText,
        n;
        if (e.rendered && t) {
            n = e.getRawValue().length < 1 && !e.hasFocus;
            if (Ext.supports.Placeholder) {
                e.inputEl.dom.placeholder = t
            } else {
                if (n) {
                    e.setRawValue(t);
                    e.valueContainsPlaceholder = true
                }
            }
            if (n) {
                e.inputEl.addCls(e.emptyCls)
            }
            e.autoSize()
        }
    },
    afterFirstLayout: function() {
        this.callParent();
        if (Ext.isIE && this.disabled) {
            var e = this.inputEl;
            if (e) {
                e.dom.unselectable = "on"
            }
        }
    },
    beforeFocus: function() {
        var e = this,
        t = e.inputEl,
        n = e.emptyText,
        r;
        e.callParent(arguments);
        if (n && !Ext.supports.Placeholder && t.dom.value === e.emptyText && e.valueContainsPlaceholder) {
            e.setRawValue("");
            r = true;
            t.removeCls(e.emptyCls);
            e.valueContainsPlaceholder = false
        } else {
            if (Ext.supports.Placeholder) {
                t.removeCls(e.emptyCls)
            }
        }
        if (e.selectOnFocus || r) {
            if (Ext.isWebKit) {
                if (!e.inputFocusTask) {
                    e.inputFocusTask = new Ext.util.DelayedTask(e.focusInput, e)
                }
                e.inputFocusTask.delay(1)
            } else {
                e.focusInput()
            }
        }
    },
    focusInput: function() {
        var e = this.inputEl;
        if (e) {
            e = e.dom;
            if (e) {
                e.select()
            }
        }
    },
    onFocus: function() {
        var e = this;
        e.callParent(arguments);
        if (e.emptyText) {
            e.autoSize()
        }
    },
    postBlur: function() {
        var e = this.inputFocusTask;
        this.callParent(arguments);
        this.applyEmptyText();
        if (e) {
            e.cancel()
        }
    },
    filterKeys: function(e) {
        if (e.ctrlKey && !e.altKey) {
            return
        }
        var t = e.getKey(),
        n = String.fromCharCode(e.getCharCode());
        if ((Ext.isGecko || Ext.isOpera) && (e.isNavKeyPress() || t === e.BACKSPACE || t === e.DELETE && e.button === -1)) {
            return
        }
        if (!Ext.isGecko && !Ext.isOpera && e.isSpecialKey() && !n) {
            return
        }
        if (!this.maskRe.test(n)) {
            e.stopEvent()
        }
    },
    getState: function() {
        return this.addPropertyToState(this.callParent(), "value")
    },
    applyState: function(e) {
        this.callParent(arguments);
        if (e.hasOwnProperty("value")) {
            this.setValue(e.value)
        }
    },
    getRawValue: function() {
        var e = this,
        t = e.callParent();
        if (t === e.emptyText && e.valueContainsPlaceholder) {
            t = ""
        }
        return t
    },
    setValue: function(e) {
        var t = this,
        n = t.inputEl;
        if (n && t.emptyText && !Ext.isEmpty(e)) {
            n.removeCls(t.emptyCls);
            t.valueContainsPlaceholder = false
        }
        t.callParent(arguments);
        t.applyEmptyText();
        return t
    },
    getErrors: function(e) {
        var t = this,
        n = t.callParent(arguments),
        r = t.validator,
        i = t.vtype,
        s = Ext.form.field.VTypes,
        o = t.regex,
        u = Ext.String.format,
        a,
        f,
        l;
        e = e || t.processRawValue(t.getRawValue());
        if (Ext.isFunction(r)) {
            a = r.call(t, e);
            if (a !== true) {
                n.push(a)
            }
        }
        f = t.allowOnlyWhitespace ? e: Ext.String.trim(e);
        if (f.length < 1 || e === t.emptyText && t.valueContainsPlaceholder) {
            if (!t.allowBlank) {
                n.push(t.blankText)
            }
            if (!t.validateBlank) {
                return n
            }
            l = true
        }
        if (!l && e.length < t.minLength) {
            n.push(u(t.minLengthText, t.minLength))
        }
        if (e.length > t.maxLength) {
            n.push(u(t.maxLengthText, t.maxLength))
        }
        if (i) {
            if (!s[i](e, t)) {
                n.push(t.vtypeText || s[i + "Text"])
            }
        }
        if (o && !o.test(e)) {
            n.push(t.regexText || t.invalidText)
        }
        return n
    },
    selectText: function(e, t) {
        var n = this,
        r = n.getRawValue(),
        i = true,
        s = n.inputEl.dom,
        o,
        u;
        if (r.length > 0) {
            e = e === o ? 0 : e;
            t = t === o ? r.length: t;
            if (s.setSelectionRange) {
                s.setSelectionRange(e, t)
            } else {
                if (s.createTextRange) {
                    u = s.createTextRange();
                    u.moveStart("character", e);
                    u.moveEnd("character", t - r.length);
                    u.select()
                }
            }
            i = Ext.isGecko || Ext.isOpera
        }
        if (i) {
            n.focus()
        }
    },
    autoSize: function() {
        var e = this;
        if (e.grow && e.rendered) {
            e.autoSizing = true;
            e.updateLayout()
        }
    },
    afterComponentLayout: function() {
        var e = this,
        t;
        e.callParent(arguments);
        if (e.autoSizing) {
            t = e.inputEl.getWidth();
            if (t !== e.lastInputWidth) {
                e.fireEvent("autosize", e, t);
                e.lastInputWidth = t;
                delete e.autoSizing
            }
        }
    },
    onDestroy: function() {
        var e = this;
        e.callParent();
        if (e.inputFocusTask) {
            e.inputFocusTask.cancel();
            e.inputFocusTask = null
        }
    }
});Ext.define("Ext.layout.component.field.TextArea", {
    extend: Ext.layout.component.field.Text,
    alias: "layout.textareafield",
    type: "textareafield",
    canGrowWidth: false,
    naturalSizingProp: "cols",
    beginLayout: function(e) {
        this.callParent(arguments);
        e.target.inputEl.setStyle("height", "")
    },
    measureContentHeight: function(e) {
        var t = this,
        n = t.owner,
        r = t.callParent(arguments),
        i,
        s,
        o,
        u,
        a,
        f;
        if (n.grow && !e.state.growHandled) {
            i = e.inputContext;
            s = n.inputEl;
            a = s.getWidth(true);
            o = Ext.util.Format.htmlEncode(s.dom.value) || "&#160;";
            o += n.growAppend;
            o = o.replace(/\n/g, "<br/>");
            f = Ext.util.TextMetrics.measure(s, o, a).height + i.getBorderInfo().height + i.getPaddingInfo().height;
            f = Ext.Number.constrain(f, n.growMin, n.growMax);
            i.setHeight(f);
            e.state.growHandled = true;
            i.domBlock(t, "height");
            r = NaN
        }
        return r
    }
});Ext.define("Ext.form.field.TextArea", {
    extend: Ext.form.field.Text,
    alias: ["widget.textareafield", "widget.textarea"],
    alternateClassName: "Ext.form.TextArea",
    fieldSubTpl: ['<textarea id="{id}" role="{role}" {inputAttrTpl}', '<tpl if="name"> name="{name}"</tpl>', '<tpl if="rows"> rows="{rows}" </tpl>', '<tpl if="cols"> cols="{cols}" </tpl>', '<tpl if="placeholder"> placeholder="{placeholder}"</tpl>', '<tpl if="size"> size="{size}"</tpl>', '<tpl if="maxLength !== undefined"> maxlength="{maxLength}"</tpl>', '<tpl if="readOnly"> readonly="readonly"</tpl>', '<tpl if="disabled"> disabled="disabled"</tpl>', '<tpl if="tabIdx"> tabIndex="{tabIdx}"</tpl>', ' class="{fieldCls} {typeCls} {inputCls}" ', '<tpl if="fieldStyle"> style="{fieldStyle}"</tpl>', ' autocomplete="off">\n', '<tpl if="value">{[Ext.util.Format.htmlEncode(values.value)]}</tpl>', "</textarea>", {
        disableFormats: true
    }],
    growMin: 60,
    growMax: 1e3,
    growAppend: "\n-",
    cols: 20,
    rows: 4,
    enterIsSpecial: false,
    preventScrollbars: false,
    componentLayout: "textareafield",
    setGrowSizePolicy: Ext.emptyFn,
    returnRe: /\r/g,
    inputCls: Ext.baseCSSPrefix + "form-textarea",
    getSubTplData: function() {
        var e = this,
        t = e.getFieldStyle(),
        n = e.callParent();
        if (e.grow) {
            if (e.preventScrollbars) {
                n.fieldStyle = (t || "") + ";overflow:hidden;height:" + e.growMin + "px"
            }
        }
        Ext.applyIf(n, {
            cols: e.cols,
            rows: e.rows
        });
        return n
    },
    afterRender: function() {
        var e = this;
        e.callParent(arguments);
        e.needsMaxCheck = e.enforceMaxLength && e.maxLength !== Number.MAX_VALUE && !Ext.supports.TextAreaMaxLength;
        if (e.needsMaxCheck) {
            e.inputEl.on("paste", e.onPaste, e)
        }
    },
    transformRawValue: function(e) {
        return this.stripReturns(e)
    },
    transformOriginalValue: function(e) {
        return this.stripReturns(e)
    },
    getValue: function() {
        return this.stripReturns(this.callParent())
    },
    valueToRaw: function(e) {
        e = this.stripReturns(e);
        return this.callParent([e])
    },
    stripReturns: function(e) {
        if (e && typeof e === "string") {
            e = e.replace(this.returnRe, "")
        }
        return e
    },
    onPaste: function(e) {
        var t = this;
        if (!t.pasteTask) {
            t.pasteTask = new Ext.util.DelayedTask(t.pasteCheck, t)
        }
        t.pasteTask.delay(1)
    },
    pasteCheck: function() {
        var e = this,
        t = e.getValue(),
        n = e.maxLength;
        if (t.length > n) {
            t = t.substr(0, n);
            e.setValue(t)
        }
    },
    fireKey: function(e) {
        var t = this,
        n = e.getKey(),
        r;
        if (e.isSpecialKey() && (t.enterIsSpecial || n !== e.ENTER || e.hasModifier())) {
            t.fireEvent("specialkey", t, e)
        }
        if (t.needsMaxCheck && n !== e.BACKSPACE && n !== e.DELETE && !e.isNavKeyPress() && !t.isCutCopyPasteSelectAll(e, n)) {
            r = t.getValue();
            if (r.length >= t.maxLength) {
                e.stopEvent()
            }
        }
    },
    isCutCopyPasteSelectAll: function(e, t) {
        if (e.ctrlKey) {
            return t === e.A || t === e.C || t === e.V || t === e.X
        }
        return false
    },
    autoSize: function() {
        var e = this,
        t;
        if (e.grow && e.rendered) {
            e.updateLayout();
            t = e.inputEl.getHeight();
            if (t !== e.lastInputHeight) {
                e.fireEvent("autosize", e, t);
                e.lastInputHeight = t
            }
        }
    },
    beforeDestroy: function() {
        var e = this.pasteTask;
        if (e) {
            e.cancel();
            this.pasteTask = null
        }
        this.callParent()
    }
});Ext.define("Ext.form.field.Display", {
    extend: Ext.form.field.Base,
    alias: "widget.displayfield",
    alternateClassName: ["Ext.form.DisplayField", "Ext.form.Display"],
    ariaRole: "textbox",
    fieldSubTpl: ['<div id="{id}" role="{role}" {inputAttrTpl}', '<tpl if="fieldStyle"> style="{fieldStyle}"</tpl>', ' class="{fieldCls}">{value}</div>', {
        compiled: true,
        disableFormats: true
    }],
    readOnly: true,
    fieldCls: Ext.baseCSSPrefix + "form-display-field",
    fieldBodyCls: Ext.baseCSSPrefix + "form-display-field-body",
    htmlEncode: false,
    noWrap: false,
    validateOnChange: false,
    initEvents: Ext.emptyFn,
    submitValue: false,
    valueToRaw: function(e) {
        if (!e && e !== 0) {
            return ""
        } else {
            return e
        }
    },
    isDirty: function() {
        return false
    },
    isValid: function() {
        return true
    },
    validate: function() {
        return true
    },
    getRawValue: function() {
        return this.rawValue
    },
    setRawValue: function(e) {
        var t = this;
        e = Ext.value(e, "");
        t.rawValue = e;
        if (t.rendered) {
            t.inputEl.dom.innerHTML = t.getDisplayValue();
            t.updateLayout()
        }
        return e
    },
    getDisplayValue: function() {
        var e = this,
        t = this.getRawValue(),
        n;
        if (e.renderer) {
            n = e.renderer.call(e.scope || e, t, e)
        } else {
            n = e.htmlEncode ? Ext.util.Format.htmlEncode(t) : t
        }
        return n
    },
    getSubTplData: function() {
        var e = this.callParent(arguments);
        e.value = this.getDisplayValue();
        return e
    }
});Ext.define("Ext.layout.container.Anchor", {
    alias: "layout.anchor",
    extend: Ext.layout.container.Auto,
    alternateClassName: "Ext.layout.AnchorLayout",
    type: "anchor",
    defaultAnchor: "100%",
    parseAnchorRE: /^(r|right|b|bottom)$/i,
    manageOverflow: true,
    beginLayoutCycle: function(e) {
        var t = this,
        n = 0,
        r, i, s, o, u, a;
        t.callParent(arguments);
        s = e.childItems;
        u = s.length;
        for (o = 0; o < u; ++o) {
            i = s[o];
            r = i.target.anchorSpec;
            if (r) {
                if (i.widthModel.calculated && r.right) {
                    n |= 1
                }
                if (i.heightModel.calculated && r.bottom) {
                    n |= 2
                }
                if (n == 3) {
                    break
                }
            }
        }
        e.anchorDimensions = n
    },
    calculateItems: function(e, t) {
        var n = this,
        r = e.childItems,
        i = r.length,
        s = t.gotHeight,
        o = t.gotWidth,
        u = t.height,
        a = t.width,
        f = (o ? 1 : 0) | (s ? 2 : 0),
        l = e.anchorDimensions,
        c,
        h,
        p,
        d,
        v,
        m;
        if (!l) {
            return true
        }
        for (v = 0; v < i; v++) {
            h = r[v];
            p = h.getMarginInfo();
            c = h.target.anchorSpec;
            if (o && h.widthModel.calculated) {
                m = c.right(a) - p.width;
                m = n.adjustWidthAnchor(m, h);
                h.setWidth(m)
            }
            if (s && h.heightModel.calculated) {
                d = c.bottom(u) - p.height;
                d = n.adjustHeightAnchor(d, h);
                h.setHeight(d)
            }
        }
        return (f & l) === l
    },
    anchorFactory: {
        offset: function(e) {
            return function(t) {
                return t + e
            }
        },
        ratio: function(e) {
            return function(t) {
                return Math.floor(t * e)
            }
        },
        standard: function(e) {
            return function(t) {
                return t - e
            }
        }
    },
    parseAnchor: function(e, t, n) {
        if (e && e != "none") {
            var r = this.anchorFactory,
            i;
            if (this.parseAnchorRE.test(e)) {
                return r.standard(n - t)
            }
            if (e.indexOf("%") != -1) {
                return r.ratio(parseFloat(e.replace("%", "")) * .01)
            }
            i = parseInt(e, 10);
            if (!isNaN(i)) {
                return r.offset(i)
            }
        }
        return null
    },
    adjustWidthAnchor: function(e, t) {
        return e
    },
    adjustHeightAnchor: function(e, t) {
        return e
    },
    configureItem: function(e) {
        var t = this,
        n = t.owner,
        r = e.anchor,
        i, s, o;
        t.callParent(arguments);
        if (!e.anchor && e.items && !Ext.isNumber(e.width) && !(Ext.isIE6 && Ext.isStrict)) {
            e.anchor = r = t.defaultAnchor
        }
        if (n.anchorSize) {
            if (typeof n.anchorSize == "number") {
                s = n.anchorSize
            } else {
                s = n.anchorSize.width;
                o = n.anchorSize.height
            }
        } else {
            s = n.initialConfig.width;
            o = n.initialConfig.height
        }
        if (r) {
            i = r.split(" ");
            e.anchorSpec = {
                right: t.parseAnchor(i[0], e.initialConfig.width, s),
                bottom: t.parseAnchor(i[1], e.initialConfig.height, o)
            }
        }
    },
    sizePolicy: {
        $: {
            readsWidth: 1,
            readsHeight: 1,
            setsWidth: 0,
            setsHeight: 0
        },
        b: {
            readsWidth: 1,
            readsHeight: 0,
            setsWidth: 0,
            setsHeight: 1
        },
        r: {
            $: {
                readsWidth: 0,
                readsHeight: 1,
                setsWidth: 1,
                setsHeight: 0
            },
            b: {
                readsWidth: 0,
                readsHeight: 0,
                setsWidth: 1,
                setsHeight: 1
            }
        }
    },
    getItemSizePolicy: function(e) {
        var t = e.anchorSpec,
        n = "$",
        r = this.sizePolicy,
        i;
        if (t) {
            i = this.owner.getSizeModel();
            if (t.right && !i.width.shrinkWrap) {
                r = r.r
            }
            if (t.bottom && !i.height.shrinkWrap) {
                n = "b"
            }
        }
        return r[n]
    }
});Ext.define("Ext.window.MessageBox", {
    extend: Ext.window.Window,
    alias: "widget.messagebox",
    OK: 1,
    YES: 2,
    NO: 4,
    CANCEL: 8,
    OKCANCEL: 9,
    YESNO: 6,
    YESNOCANCEL: 14,
    INFO: Ext.baseCSSPrefix + "message-box-info",
    WARNING: Ext.baseCSSPrefix + "message-box-warning",
    QUESTION: Ext.baseCSSPrefix + "message-box-question",
    ERROR: Ext.baseCSSPrefix + "message-box-error",
    hideMode: "offsets",
    closeAction: "hide",
    resizable: false,
    title: "&#160;",
    defaultMinWidth: 250,
    defaultMaxWidth: 600,
    defaultMinHeight: 110,
    defaultMaxHeight: 500,
    minWidth: null,
    maxWidth: null,
    minHeight: null,
    maxHeight: null,
    constrain: true,
    cls: [Ext.baseCSSPrefix + "message-box", Ext.baseCSSPrefix + "hide-offsets"],
    layout: {
        type: "vbox",
        align: "stretch"
    },
    shrinkWrapDock: true,
    defaultTextHeight: 75,
    minProgressWidth: 250,
    minPromptWidth: 250,
    buttonText: {
        ok: "OK",
        yes: "Yes",
        no: "No",
        cancel: "Cancel"
    },
    buttonIds: ["ok", "yes", "no", "cancel"],
    titleText: {
        confirm: "Confirm",
        prompt: "Prompt",
        wait: "Loading...",
        alert: "Attention"
    },
    iconHeight: 35,
    iconWidth: 50,
    ariaRole: "alertdialog",
    makeButton: function(e) {
        var t = this.buttonIds[e];
        return new Ext.button.Button({
            handler: this.btnCallback,
            itemId: t,
            scope: this,
            text: this.buttonText[t],
            minWidth: 75
        })
    },
    btnCallback: function(e) {
        var t = this,
        n, r;
        if (t.cfg.prompt || t.cfg.multiline) {
            if (t.cfg.multiline) {
                r = t.textArea
            } else {
                r = t.textField
            }
            n = r.getValue();
            r.reset()
        }
        t.hide();
        t.userCallback(e.itemId, n, t.cfg)
    },
    hide: function() {
        var e = this,
        t = e.cfg ? e.cfg.cls: "";
        e.progressBar.reset();
        if (t) {
            e.removeCls(t)
        }
        e.callParent(arguments)
    },
    constructor: function(e) {
        var t = this;
        t.callParent(arguments);
        t.minWidth = t.defaultMinWidth = t.minWidth || t.defaultMinWidth;
        t.maxWidth = t.defaultMaxWidth = t.maxWidth || t.defaultMaxWidth;
        t.minHeight = t.defaultMinHeight = t.minHeight || t.defaultMinHeight;
        t.maxHeight = t.defaultMaxHeight = t.maxHeight || t.defaultMaxHeight
    },
    initComponent: function(e) {
        var t = this,
        n = t.id,
        r, i;
        t.title = t.title || "&#160;";
        t.iconCls = t.iconCls || "";
        t.topContainer = new Ext.container.Container({
            layout: "hbox",
            padding: 10,
            style: {
                overflow: "hidden"
            },
            items: [t.iconComponent = new Ext.Component({
                width: t.iconWidth,
                height: t.iconHeight
            }), t.promptContainer = new Ext.container.Container({
                flex: 1,
                layout: "anchor",
                items: [t.msg = new Ext.form.field.Display({
                    id: n + "-displayfield",
                    cls: t.baseCls + "-text"
                }), t.textField = new Ext.form.field.Text({
                    id: n + "-textfield",
                    anchor: "100%",
                    enableKeyEvents: true,
                    listeners: {
                        keydown: t.onPromptKey,
                        scope: t
                    }
                }), t.textArea = new Ext.form.field.TextArea({
                    id: n + "-textarea",
                    anchor: "100%",
                    height: 75
                })]
            })]
        });
        t.progressBar = new Ext.ProgressBar({
            id: n + "-progressbar",
            margin: "0 10 10 10"
        });
        t.items = [t.topContainer, t.progressBar];
        t.msgButtons = [];
        for (r = 0; r < 4; r++) {
            i = t.makeButton(r);
            t.msgButtons[i.itemId] = i;
            t.msgButtons.push(i)
        }
        t.bottomTb = new Ext.toolbar.Toolbar({
            id: n + "-toolbar",
            ui: "footer",
            dock: "bottom",
            layout: {
                pack: "center"
            },
            items: [t.msgButtons[0], t.msgButtons[1], t.msgButtons[2], t.msgButtons[3]]
        });
        t.dockedItems = [t.bottomTb];
        t.on("close", t.onClose, t);
        t.callParent()
    },
    onClose: function() {
        var e = this.header.child("[type=close]");
        e.itemId = "cancel";
        this.btnCallback(e);
        delete e.itemId
    },
    onEnter: function(e, t, n) {
        var e = this;
        if (e.msgButtons.ok.isVisible()) {
            e.msgButtons.ok.handler.call(e, e.msgButtons.ok)
        } else {
            if (e.msgButtons.yes.isVisible()) {
                e.msgButtons.yes.handler.call(e, e.msgButtons.yes)
            }
        }
    },
    onPromptKey: function(e, t) {
        var n = this;
        if (t.keyCode === t.RETURN || t.keyCode === 10) {
            if (n.msgButtons.ok.isVisible()) {
                n.msgButtons.ok.handler.call(n, n.msgButtons.ok)
            } else {
                if (n.msgButtons.yes.isVisible()) {
                    n.msgButtons.yes.handler.call(n, n.msgButtons.yes)
                }
            }
        }
    },
    reconfigure: function(e) {
        var t = this,
        n = 0,
        r = true,
        i = t.buttonText,
        s = t.resizer,
        o = t.header,
        u = o && !o.isHeader,
        a, f, l, c, h, p, d, v, m, g;
        t.updateButtonText();
        e = e || {};
        t.cfg = e;
        if (e.width) {
            l = e.width
        }
        if (e.height) {
            c = e.height
        }
        t.minWidth = e.minWidth || t.defaultMinWidth;
        t.maxWidth = e.maxWidth || t.defaultMaxWidth;
        t.minHeight = e.minHeight || t.defaultMinHeight;
        t.maxHeight = e.maxHeight || t.defaultMaxHeight;
        if (s) {
            a = s.resizeTracker;
            s.minWidth = a.minWidth = t.minWidth;
            s.maxWidth = a.maxWidth = t.maxWidth;
            s.minHeight = a.minHeight = t.minHeight;
            s.maxHeight = a.maxHeight = t.maxHeight
        }
        delete t.defaultFocus;
        if (e.defaultFocus) {
            t.defaultFocus = e.defaultFocus
        }
        t.animateTarget = e.animateTarget || undefined;
        t.modal = e.modal !== false;
        t.setTitle(e.title || u && o.title || t.title);
        t.setIconCls(e.iconCls || u && o.iconCls || t.iconCls);
        if (Ext.isObject(e.buttons)) {
            t.buttonText = e.buttons;
            n = 0
        } else {
            t.buttonText = e.buttonText || t.buttonText;
            n = Ext.isNumber(e.buttons) ? e.buttons: 0
        }
        n = n | t.updateButtonText();
        t.buttonText = i;
        Ext.suspendLayouts();
        delete t.width;
        delete t.height;
        if (l || c) {
            if (l) {
                t.setWidth(l)
            }
            if (c) {
                t.setHeight(c)
            }
        }
        t.hidden = false;
        if (!t.rendered) {
            t.render(Ext.getBody())
        }
        t.closable = e.closable !== false && !e.wait;
        o = t.header;
        if (o) {
            o.child("[type=close]").setVisible(t.closable);
            if (!e.title && !t.closable && !e.iconCls) {
                o.hide()
            } else {
                o.show()
            }
        }
        t.liveDrag = !e.proxyDrag;
        t.userCallback = Ext.Function.bind(e.callback || e.fn || Ext.emptyFn, e.scope || Ext.global);
        t.setIcon(e.icon, e.iconWidth, e.iconHeight);
        v = t.msg;
        if (e.msg) {
            v.setValue(e.msg);
            v.show()
        } else {
            v.hide()
        }
        p = t.textArea;
        d = t.textField;
        if (e.prompt || e.multiline) {
            t.multiline = e.multiline;
            if (e.multiline) {
                p.setValue(e.value);
                p.setHeight(e.defaultTextHeight || t.defaultTextHeight);
                p.show();
                d.hide();
                t.defaultFocus = p
            } else {
                d.setValue(e.value);
                p.hide();
                d.show();
                t.defaultFocus = d
            }
        } else {
            p.hide();
            d.hide()
        }
        m = t.progressBar;
        if (e.progress || e.wait) {
            m.show();
            t.updateProgress(0, e.progressText);
            if (e.wait === true) {
                m.wait(e.waitConfig)
            }
        } else {
            m.hide()
        }
        g = t.msgButtons;
        for (h = 0; h < 4; h++) {
            if (n & Math.pow(2, h)) {
                if (!t.defaultFocus) {
                    t.defaultFocus = g[h]
                }
                g[h].show();
                r = false
            } else {
                g[h].hide()
            }
        }
        if (r) {
            t.bottomTb.hide()
        } else {
            t.bottomTb.show()
        }
        Ext.resumeLayouts(true)
    },
    updateButtonText: function() {
        var e = this,
        t = e.buttonText,
        n = 0,
        r, i;
        for (r in t) {
            if (t.hasOwnProperty(r)) {
                i = e.msgButtons[r];
                if (i) {
                    if (e.cfg && e.cfg.buttonText) {
                        n = n | Math.pow(2, Ext.Array.indexOf(e.buttonIds, r))
                    }
                    if (i.text != t[r]) {
                        i.setText(t[r])
                    }
                }
            }
        }
        return n
    },
    show: function(e) {
        var t = this,
        n;
        e = e || {};
        if (Ext.AbstractComponent.layoutSuspendCount) {
            Ext.on({
                resumelayouts: function() {
                    t.show(e)
                },
                single: true
            });
            return t
        }
        t.reconfigure(e);
        if (e.cls) {
            t.addCls(e.cls)
        }
        n = t.query("textfield:not([hidden]),textarea:not([hidden]),button:not([hidden])");
        t.preventFocusOnActivate = !n.length;
        t.hidden = true;
        t.callParent();
        return t
    },
    onShow: function() {
        this.callParent(arguments);
        this.center()
    },
    updateText: function(e) {
        this.msg.setValue(e)
    },
    setIcon: function(e, t, n) {
        var r = this,
        i = r.iconComponent,
        s = r.messageIconCls;
        if (s) {
            i.removeCls(s)
        }
        if (e) {
            i.show();
            i.setSize(t || r.iconWidth, n || r.iconHeight);
            i.addCls(Ext.baseCSSPrefix + "dlg-icon");
            i.addCls(r.messageIconCls = e)
        } else {
            i.removeCls(Ext.baseCSSPrefix + "dlg-icon");
            i.hide()
        }
        return r
    },
    updateProgress: function(e, t, n) {
        this.progressBar.updateProgress(e, t);
        if (n) {
            this.updateText(n)
        }
        return this
    },
    onEsc: function() {
        if (this.closable !== false) {
            this.callParent(arguments)
        }
    },
    confirm: function(e, t, n, r) {
        if (Ext.isString(e)) {
            e = {
                title: e,
                icon: this.QUESTION,
                msg: t,
                buttons: this.YESNO,
                callback: n,
                scope: r
            }
        }
        return this.show(e)
    },
    prompt: function(e, t, n, r, i, s) {
        if (Ext.isString(e)) {
            e = {
                prompt: true,
                title: e,
                minWidth: this.minPromptWidth,
                msg: t,
                buttons: this.OKCANCEL,
                callback: n,
                scope: r,
                multiline: i,
                value: s
            }
        }
        return this.show(e)
    },
    wait: function(e, t, n) {
        if (Ext.isString(e)) {
            e = {
                title: t,
                msg: e,
                closable: false,
                wait: true,
                modal: true,
                minWidth: this.minProgressWidth,
                waitConfig: n
            }
        }
        return this.show(e)
    },
    alert: function(e, t, n, r) {
        if (Ext.isString(e)) {
            e = {
                title: e,
                msg: t,
                buttons: this.OK,
                fn: n,
                scope: r,
                minWidth: this.minWidth
            }
        }
        return this.show(e)
    },
    progress: function(e, t, n) {
        if (Ext.isString(e)) {
            e = {
                title: e,
                msg: t,
                progress: true,
                progressText: n
            }
        }
        return this.show(e)
    }
},
function() {
    Ext.MessageBox = Ext.Msg = new this
});Ext.define("Ext.form.Basic", {
    extend: Ext.util.Observable,
    alternateClassName: "Ext.form.BasicForm",
    taskDelay: 10,
    constructor: function(e, t) {
        var n = this,
        r;
        n.owner = e;
        n.checkValidityTask = new Ext.util.DelayedTask(n.checkValidity, n);
        n.checkDirtyTask = new Ext.util.DelayedTask(n.checkDirty, n);
        n.monitor = new Ext.container.Monitor({
            selector: "[isFormField]:not([excludeForm])",
            scope: n,
            addHandler: n.onFieldAdd,
            removeHandler: n.onFieldRemove,
            invalidateHandler: n.onMonitorInvalidate
        });
        n.monitor.bind(e);
        Ext.apply(n, t);
        if (Ext.isString(n.paramOrder)) {
            n.paramOrder = n.paramOrder.split(/[\s,|]/)
        }
        r = n.reader;
        if (r && !r.isReader) {
            if (typeof r === "string") {
                r = {
                    type: r
                }
            }
            n.reader = Ext.createByAlias("reader." + r.type, r)
        }
        r = n.errorReader;
        if (r && !r.isReader) {
            if (typeof r === "string") {
                r = {
                    type: r
                }
            }
            n.errorReader = Ext.createByAlias("reader." + r.type, r)
        }
        n.addEvents("beforeaction", "actionfailed", "actioncomplete", "validitychange", "dirtychange");
        n.callParent()
    },
    initialize: function() {
        this.initialized = true;
        this.onValidityChange(!this.hasInvalidField())
    },
    timeout: 30,
    paramsAsHash: false,
    waitTitle: "Please Wait...",
    trackResetOnLoad: false,
    wasDirty: false,
    destroy: function() {
        var e = this,
        t = e.monitor;
        if (t) {
            t.unbind();
            e.monitor = null
        }
        e.clearListeners();
        e.checkValidityTask.cancel();
        e.checkDirtyTask.cancel();
        e.isDestroyed = true
    },
    onFieldAdd: function(e) {
        var t = this;
        t.mon(e, "validitychange", t.checkValidityDelay, t);
        t.mon(e, "dirtychange", t.checkDirtyDelay, t);
        t.onMonitorInvalidate()
    },
    onFieldRemove: function(e) {
        var t = this;
        t.mun(e, "validitychange", t.checkValidityDelay, t);
        t.mun(e, "dirtychange", t.checkDirtyDelay, t);
        t.onMonitorInvalidate()
    },
    onMonitorInvalidate: function() {
        if (this.initialized) {
            this.checkValidityDelay()
        }
    },
    getFields: function() {
        return this.monitor.getItems()
    },
    getBoundItems: function() {
        var e = this._boundItems;
        if (!e || e.getCount() === 0) {
            e = this._boundItems = new Ext.util.MixedCollection;
            e.addAll(this.owner.query("[formBind]"))
        }
        return e
    },
    hasInvalidField: function() {
        return !! this.getFields().findBy(function(e) {
            var t = e.preventMark,
            n;
            e.preventMark = true;
            n = e.isValid();
            e.preventMark = t;
            return ! n
        })
    },
    isValid: function() {
        var e = this,
        t;
        Ext.suspendLayouts();
        t = e.getFields().filterBy(function(e) {
            return ! e.validate()
        });
        Ext.resumeLayouts(true);
        return t.length < 1
    },
    checkValidity: function() {
        var e = this,
        t;
        if (e.isDestroyed) {
            return
        }
        t = !e.hasInvalidField();
        if (t !== e.wasValid) {
            e.onValidityChange(t);
            e.fireEvent("validitychange", e, t);
            e.wasValid = t
        }
    },
    checkValidityDelay: function() {
        var e = this.taskDelay;
        if (e) {
            this.checkValidityTask.delay(e)
        } else {
            this.checkValidity()
        }
    },
    onValidityChange: function(e) {
        var t = this.getBoundItems(),
        n,
        r,
        i,
        s;
        if (t) {
            n = t.items;
            i = n.length;
            for (r = 0; r < i; r++) {
                s = n[r];
                if (s.disabled === e) {
                    s.setDisabled(!e)
                }
            }
        }
    },
    isDirty: function() {
        return !! this.getFields().findBy(function(e) {
            return e.isDirty()
        })
    },
    checkDirtyDelay: function() {
        var e = this.taskDelay;
        if (e) {
            this.checkDirtyTask.delay(e)
        } else {
            this.checkDirty()
        }
    },
    checkDirty: function() {
        var e = this,
        t;
        if (e.isDestroyed) {
            return
        }
        t = this.isDirty();
        if (t !== this.wasDirty) {
            this.fireEvent("dirtychange", this, t);
            this.wasDirty = t
        }
    },
    hasUpload: function() {
        return !! this.getFields().findBy(function(e) {
            return e.isFileUpload()
        })
    },
    doAction: function(e, t) {
        if (Ext.isString(e)) {
            e = Ext.ClassManager.instantiateByAlias("formaction." + e, Ext.apply({},
            t, {
                form: this
            }))
        }
        if (this.fireEvent("beforeaction", this, e) !== false) {
            this.beforeAction(e);
            Ext.defer(e.run, 100, e)
        }
        return this
    },
    submit: function(e) {
        e = e || {};
        var t = this,
        n;
        if (e.standardSubmit || t.standardSubmit) {
            n = "standardsubmit"
        } else {
            n = t.api ? "directsubmit": "submit"
        }
        return t.doAction(n, e)
    },
    load: function(e) {
        return this.doAction(this.api ? "directload": "load", e)
    },
    updateRecord: function(e) {
        e = e || this._record;
        if (!e) {
            return this
        }
        var t = e.fields.items,
        n = this.getFieldValues(),
        r = {},
        i = 0,
        s = t.length,
        o;
        for (; i < s; ++i) {
            o = t[i].name;
            if (n.hasOwnProperty(o)) {
                r[o] = n[o]
            }
        }
        e.beginEdit();
        e.set(r);
        e.endEdit();
        return this
    },
    loadRecord: function(e) {
        this._record = e;
        return this.setValues(e.getData())
    },
    getRecord: function() {
        return this._record
    },
    beforeAction: function(e) {
        var t = this,
        n = e.waitMsg,
        r = Ext.baseCSSPrefix + "mask-loading",
        i = t.getFields().items,
        s,
        o = i.length,
        u,
        a;
        for (s = 0; s < o; s++) {
            u = i[s];
            if (u.isFormField && u.syncValue) {
                u.syncValue()
            }
        }
        if (e.showProgress) {
            e.showMask = false;
            e.needUpdateProgress = true;
            Wb.progress(0, e.message);
            e.progressTimer = setInterval(function() {
                if (e.isGetProgress) {
                    return
                }
                e.isGetProgress = true;
                Ext.Ajax.request({
                    url: "m?xwl=sys/service/get-progress",
                    timeout: 5e3,
                    params: {
                        progressId: e.progressId
                    },
                    callback: function() {
                        e.isGetProgress = false
                    },
                    success: function(t) {
                        if (e.needUpdateProgress) {
                            Wb.progress(parseFloat(t.responseText))
                        }
                    }
                })
            },
            1e3)
        }
        if (e.showMask) {
            Wb.mask(e.mask, e.message)
        }
        if (n) {
            a = t.waitMsgTarget;
            if (a === true) {
                t.owner.el.mask(n, r)
            } else {
                if (a) {
                    a = t.waitMsgTarget = Ext.get(a);
                    a.mask(n, r)
                } else {
                    t.floatingAncestor = t.owner.up("[floating]");
                    if (t.floatingAncestor) {
                        t.savePreventFocusOnActivate = t.floatingAncestor.preventFocusOnActivate;
                        t.floatingAncestor.preventFocusOnActivate = true
                    }
                    Ext.MessageBox.wait(n, e.waitTitle || t.waitTitle)
                }
            }
        }
    },
    afterAction: function(e, t) {
        var n = this,
        r;
        if (e.waitMsg) {
            var i = Ext.MessageBox,
            s = n.waitMsgTarget;
            if (s === true) {
                n.owner.el.unmask()
            } else {
                if (s) {
                    s.unmask()
                } else {
                    i.hide()
                }
            }
        }
        if (n.floatingAncestor) {
            n.floatingAncestor.preventFocusOnActivate = n.savePreventFocusOnActivate
        }
        if (e.progressTimer) {
            clearInterval(e.progressTimer);
            delete e.progressTimer
        }
        if (e.showProgress) {
            delete e.needUpdateProgress;
            Ext.MessageBox.hide();
            delete e.progressId
        }
        if (e.showMask) {
            Wb.unmask(e.mask, e.message)
        }
        if (e.result) {
            r = e.result.data
        } else {
            r = null
        }
        if (Ext.callback(e.callback, e.scope || e, [n, e, r, t]) === false) {
            return
        }
        if (t) {
            if (e.reset) {
                n.reset()
            }
            Ext.callback(e.success, e.scope || e, [n, e, r]);
            n.fireEvent("actioncomplete", n, e)
        } else {
            if (e.showError) {
                Wb.error(e.result.message)
            }
            Ext.callback(e.failure, e.scope || e, [n, e, r]);
            n.fireEvent("actionfailed", n, e)
        }
    },
    findField: function(e) {
        return this.getFields().findBy(function(t) {
            return t.id === e || t.name === e || t.dataIndex === e
        })
    },
    markInvalid: function(e) {
        function u(e, n) {
            var r = t.findField(e);
            if (r) {
                r.markInvalid(n)
            }
        }
        var t = this,
        n, r, i, s, o;
        if (Ext.isArray(e)) {
            r = e.length;
            for (n = 0; n < r; n++) {
                i = e[n];
                u(i.id, i.msg)
            }
        } else {
            if (e instanceof Ext.data.Errors) {
                r = e.items.length;
                for (n = 0; n < r; n++) {
                    i = e.items[n];
                    u(i.field, i.message)
                }
            } else {
                for (o in e) {
                    if (e.hasOwnProperty(o)) {
                        s = e[o];
                        u(o, s, e)
                    }
                }
            }
        }
        return this
    },
    setValues: function(e) {
        function o(e, n) {
            var r = t.findField(e);
            if (r) {
                r.setValue(n);
                if (t.trackResetOnLoad) {
                    r.resetOriginalValue()
                }
            }
        }
        var t = this,
        n, r, i, s;
        Ext.suspendLayouts();
        if (Ext.isArray(e)) {
            r = e.length;
            for (n = 0; n < r; n++) {
                i = e[n];
                o(i.id, i.value)
            }
        } else {
            Ext.iterate(e, o)
        }
        Ext.resumeLayouts(true);
        return this
    },
    getValues: function(e, t, n, r, i) {
        var s = {},
        o = this.getFields().items,
        u = o.length,
        a = Ext.isArray,
        f,
        l,
        c,
        h,
        p,
        d;
        for (d = 0; d < u; d++) {
            f = o[d];
            if (!t || f.isDirty()) {
                l = f[r ? "getModelData": "getSubmitData"](n, i);
                if (Ext.isObject(l)) {
                    for (p in l) {
                        if (l.hasOwnProperty(p)) {
                            c = l[p];
                            if (n && c === "") {
                                c = f.emptyText || ""
                            }
                            if (!f.isRadio) {
                                if (s.hasOwnProperty(p)) {
                                    h = s[p];
                                    if (!a(h)) {
                                        h = s[p] = [h]
                                    }
                                    if (a(c)) {
                                        s[p] = h.concat(c)
                                    } else {
                                        h.push(c)
                                    }
                                } else {
                                    s[p] = c
                                }
                            } else {
                                s[p] = s[p] || c
                            }
                        }
                    }
                }
            }
        }
        if (e) {
            s = Ext.Object.toQueryString(s)
        }
        return s
    },
    getFieldValues: function(e) {
        return this.getValues(false, e, false, true)
    },
    clearInvalid: function() {
        Ext.suspendLayouts();
        var e = this,
        t = e.getFields().items,
        n,
        r = t.length;
        for (n = 0; n < r; n++) {
            t[n].clearInvalid()
        }
        Ext.resumeLayouts(true);
        return e
    },
    reset: function(e) {
        Ext.suspendLayouts();
        var t = this,
        n = t.getFields().items,
        r,
        i = n.length;
        for (r = 0; r < i; r++) {
            n[r].reset()
        }
        Ext.resumeLayouts(true);
        if (e === true) {
            delete t._record
        }
        return t
    },
    applyToFields: function(e) {
        var t = this.getFields().items,
        n,
        r = t.length;
        for (n = 0; n < r; n++) {
            Ext.apply(t[n], e)
        }
        return this
    },
    applyIfToFields: function(e) {
        var t = this.getFields().items,
        n,
        r = t.length;
        for (n = 0; n < r; n++) {
            Ext.applyIf(t[n], e)
        }
        return this
    }
});Ext.define("Ext.form.FieldAncestor", {
    xhooks: {
        initHierarchyState: function(e) {
            if (this.fieldDefaults) {
                if (e.fieldDefaults) {
                    e.fieldDefaults = Ext.apply(Ext.Object.chain(e.fieldDefaults), this.fieldDefaults)
                } else {
                    e.fieldDefaults = this.fieldDefaults
                }
            }
        }
    },
    initFieldAncestor: function() {
        var e = this;
        e.addEvents("fieldvaliditychange", "fielderrorchange");
        e.monitor = new Ext.container.Monitor({
            scope: e,
            selector: "[isFormField]:not([excludeForm])",
            addHandler: e.onChildFieldAdd,
            removeHandler: e.onChildFieldRemove
        });
        e.initFieldDefaults()
    },
    initMonitor: function() {
        this.monitor.bind(this)
    },
    onChildFieldAdd: function(e) {
        var t = this;
        t.mon(e, "errorchange", t.handleFieldErrorChange, t);
        t.mon(e, "validitychange", t.handleFieldValidityChange, t)
    },
    onChildFieldRemove: function(e) {
        var t = this;
        t.mun(e, "errorchange", t.handleFieldErrorChange, t);
        t.mun(e, "validitychange", t.handleFieldValidityChange, t)
    },
    initFieldDefaults: function() {
        if (!this.fieldDefaults) {
            this.fieldDefaults = {}
        }
    },
    handleFieldValidityChange: function(e, t) {
        var n = this;
        if (e !== n) {
            n.fireEvent("fieldvaliditychange", n, e, t);
            n.onFieldValidityChange(e, t)
        }
    },
    handleFieldErrorChange: function(e, t) {
        var n = this;
        if (e !== n) {
            n.fireEvent("fielderrorchange", n, e, t);
            n.onFieldErrorChange(e, t)
        }
    },
    onFieldValidityChange: Ext.emptyFn,
    onFieldErrorChange: Ext.emptyFn,
    beforeDestroy: function() {
        this.monitor.unbind();
        this.callParent()
    }
});Ext.define("Ext.layout.component.field.FieldContainer", {
    extend: Ext.layout.component.field.Field,
    alias: "layout.fieldcontainer",
    type: "fieldcontainer",
    waitForOuterHeightInDom: true,
    waitForOuterWidthInDom: true,
    beginLayout: function(e) {
        var t = this.owner;
        this.callParent(arguments);
        e.hasRawContent = true;
        t.bodyEl.setStyle("height", "");
        t.containerEl.setStyle("height", "");
        e.containerElContext = e.getEl("containerEl")
    },
    measureContentHeight: function(e) {
        return e.hasDomProp("containerLayoutDone") ? this.callParent(arguments) : NaN
    },
    measureContentWidth: function(e) {
        return e.hasDomProp("containerLayoutDone") ? this.callParent(arguments) : NaN
    },
    publishInnerWidth: function(e, t) {
        var n = e.bodyCellContext,
        r = n.el.getWidth() - n.getPaddingInfo().width;
        n.setWidth(r, false);
        e.containerElContext.setWidth(r, false)
    },
    publishInnerHeight: function(e, t) {
        var n = e.bodyCellContext,
        r = e.containerElContext;
        t -= this.measureLabelErrorHeight(e) + n.getPaddingInfo().height;
        n.setHeight(t);
        r.setHeight(t)
    }
});Ext.define("Ext.form.FieldContainer", {
    extend: Ext.container.Container,
    mixins: {
        labelable: Ext.form.Labelable,
        fieldAncestor: Ext.form.FieldAncestor
    },
    alias: "widget.fieldcontainer",
    componentLayout: "fieldcontainer",
    componentCls: Ext.baseCSSPrefix + "form-fieldcontainer",
    customOverflowEl: "containerEl",
    childEls: ["containerEl"],
    combineLabels: false,
    labelConnector: ", ",
    combineErrors: false,
    maskOnDisable: false,
    invalidCls: "",
    fieldSubTpl: ['<div id="{id}-containerEl" class="{containerElCls}" role="presentation">', "{%this.renderContainer(out,values)%}", "</div>"],
    initComponent: function() {
        var e = this;
        e.initLabelable();
        e.initFieldAncestor();
        e.callParent();
        e.initMonitor()
    },
    getOverflowEl: function() {
        return this.containerEl
    },
    onAdd: function(e) {
        var t = this;
        if (e.isLabelable && Ext.isGecko && t.layout.type === "absolute" && !t.hideLabel && t.labelAlign !== "top") {
            e.x += t.labelWidth + t.labelPad
        }
        t.callParent(arguments);
        if (e.isLabelable && t.combineLabels) {
            e.oldHideLabel = e.hideLabel;
            e.hideLabel = true
        }
        t.updateLabel()
    },
    onRemove: function(e, t) {
        var n = this;
        n.callParent(arguments);
        if (!t) {
            if (e.isLabelable && n.combineLabels) {
                e.hideLabel = e.oldHideLabel
            }
            n.updateLabel()
        }
    },
    initRenderTpl: function() {
        var e = this;
        if (!e.hasOwnProperty("renderTpl")) {
            e.renderTpl = e.getTpl("labelableRenderTpl")
        }
        return e.callParent()
    },
    initRenderData: function() {
        var e = this,
        t = e.callParent();
        t.containerElCls = e.containerElCls;
        return Ext.applyIf(t, e.getLabelableRenderData())
    },
    getFieldLabel: function() {
        var e = this.fieldLabel || "";
        if (!e && this.combineLabels) {
            e = Ext.Array.map(this.query("[isFieldLabelable]"),
            function(e) {
                return e.getFieldLabel()
            }).join(this.labelConnector)
        }
        return e
    },
    getSubTplData: function() {
        var e = this.initRenderData();
        Ext.apply(e, this.subTplData);
        return e
    },
    getSubTplMarkup: function() {
        var e = this,
        t = e.getTpl("fieldSubTpl"),
        n;
        if (!t.renderContent) {
            e.setupRenderTpl(t)
        }
        n = t.apply(e.getSubTplData());
        return n
    },
    updateLabel: function() {
        var e = this,
        t = e.labelEl;
        if (t) {
            e.setFieldLabel(e.getFieldLabel())
        }
    },
    onFieldErrorChange: function(e, t) {
        if (this.combineErrors) {
            var n = this,
            r = n.getActiveError(),
            i = Ext.Array.filter(n.query("[isFormField]"),
            function(e) {
                return e.hasActiveError()
            }),
            s = n.getCombinedErrors(i);
            if (s) {
                n.setActiveErrors(s)
            } else {
                n.unsetActiveError()
            }
            if (r !== n.getActiveError()) {
                n.doComponentLayout()
            }
        }
    },
    getCombinedErrors: function(e) {
        var t = [],
        n,
        r = e.length,
        i,
        s,
        o,
        u,
        a,
        f;
        for (n = 0; n < r; n++) {
            i = e[n];
            s = i.getActiveErrors();
            u = s.length;
            for (o = 0; o < u; o++) {
                a = s[o];
                f = i.getFieldLabel();
                t.push((f ? f + ": ": "") + a)
            }
        }
        return t
    },
    getTargetEl: function() {
        return this.containerEl
    },
    applyTargetCls: function(e) {
        var t = this.containerElCls;
        this.containerElCls = t ? t + " " + e: e
    }
});Ext.define("Ext.layout.container.CheckboxGroup", {
    extend: Ext.layout.container.Container,
    alias: ["layout.checkboxgroup"],
    autoFlex: true,
    type: "checkboxgroup",
    createsInnerCt: true,
    childEls: ["innerCt"],
    renderTpl: ['<table id="{ownerId}-innerCt" class="' + Ext.plainTableCls + '" cellpadding="0"', 'role="presentation" style="{tableStyle}">', '<tbody role="presentation"><tr role="presentation">', '<tpl for="columns">', '<td class="{parent.colCls}" valign="top" style="{style}" role="presentation">', "{% this.renderColumn(out,parent,xindex-1) %}", "</td>", "</tpl>", "</tr></tbody></table>"],
    lastOwnerItemsGeneration: null,
    beginLayout: function(e) {
        var t = this,
        n, r, i, s, o, u = 0,
        a = 0,
        f = t.autoFlex,
        l = t.innerCt.dom.style;
        t.callParent(arguments);
        n = t.columnNodes;
        e.innerCtContext = e.getEl("innerCt", t);
        if (!e.widthModel.shrinkWrap) {
            r = n.length;
            if (t.columnsArray) {
                for (i = 0; i < r; i++) {
                    s = t.owner.columns[i];
                    if (s < 1) {
                        u += s;
                        a++
                    }
                }
                for (i = 0; i < r; i++) {
                    s = t.owner.columns[i];
                    if (s < 1) {
                        o = s / u * 100 + "%"
                    } else {
                        o = s + "px"
                    }
                    n[i].style.width = o
                }
            } else {
                for (i = 0; i < r; i++) {
                    o = f ? 1 / r * 100 + "%": "";
                    n[i].style.width = o;
                    a++
                }
            }
            if (!a) {
                l.tableLayout = "fixed";
                l.width = ""
            } else {
                if (a < r) {
                    l.tableLayout = "fixed";
                    l.width = "100%"
                } else {
                    l.tableLayout = "auto";
                    if (f) {
                        l.width = "100%"
                    } else {
                        l.width = ""
                    }
                }
            }
        } else {
            l.tableLayout = "auto";
            l.width = ""
        }
    },
    cacheElements: function() {
        var e = this;
        e.callParent();
        e.rowEl = e.innerCt.down("tr");
        e.columnNodes = e.rowEl.dom.childNodes
    },
    calculate: function(e) {
        var t = this,
        n, r, i, s, o, u;
        if (!e.getDomProp("containerChildrenSizeDone")) {
            t.done = false
        } else {
            n = e.innerCtContext;
            r = e.widthModel.shrinkWrap;
            i = e.heightModel.shrinkWrap;
            s = i || r;
            o = n.el.dom;
            u = s && n.getPaddingInfo();
            if (r) {
                e.setContentWidth(o.offsetWidth + u.width, true)
            }
            if (i) {
                e.setContentHeight(o.offsetHeight + u.height, true)
            }
        }
    },
    doRenderColumn: function(e, t, n) {
        var r = t.$layout,
        i = r.owner,
        s = t.columnCount,
        o = i.items.items,
        u = o.length,
        a, f, l, c, h;
        if (i.vertical) {
            l = Math.ceil(u / s);
            f = n * l;
            u = Math.min(u, f + l);
            c = 1
        } else {
            f = n;
            c = s
        }
        for (; f < u; f += c) {
            a = o[f];
            r.configureItem(a);
            h = a.getRenderTree();
            Ext.DomHelper.generateMarkup(h, e)
        }
    },
    getColumnCount: function() {
        var e = this,
        t = e.owner,
        n = t.columns;
        if (e.columnsArray) {
            return n.length
        }
        if (Ext.isNumber(n)) {
            return n
        }
        return t.items.length
    },
    getItemSizePolicy: function(e) {
        return this.autoSizePolicy
    },
    getRenderData: function() {
        var e = this,
        t = e.callParent(),
        n = e.owner,
        r,
        i = e.getColumnCount(),
        s,
        o,
        u,
        a = e.autoFlex,
        f = 0,
        l = 0;
        if (e.columnsArray) {
            for (r = 0; r < i; r++) {
                s = e.owner.columns[r];
                if (s < 1) {
                    f += s;
                    l++
                }
            }
        }
        t.colCls = n.groupCls;
        t.columnCount = i;
        t.columns = [];
        for (r = 0; r < i; r++) {
            o = t.columns[r] = {};
            if (e.columnsArray) {
                s = e.owner.columns[r];
                if (s < 1) {
                    u = s / f * 100 + "%"
                } else {
                    u = s + "px"
                }
                o.style = "width:" + u
            } else {
                o.style = "width:" + 1 / i * 100 + "%";
                l++
            }
        }
        t.tableStyle = !l ? "table-layout:fixed;": l < i ? "table-layout:fixed;width:100%": a ? "table-layout:auto;width:100%": "table-layout:auto;";
        return t
    },
    initLayout: function() {
        var e = this,
        t = e.owner;
        e.columnsArray = Ext.isArray(t.columns);
        e.autoColumns = !t.columns || t.columns === "auto";
        e.vertical = t.vertical;
        e.callParent()
    },
    isValidParent: function() {
        return true
    },
    setupRenderTpl: function(e) {
        this.callParent(arguments);
        e.renderColumn = this.doRenderColumn
    },
    renderChildren: function() {
        var e = this,
        t = e.owner.items.generation;
        if (e.lastOwnerItemsGeneration !== t) {
            e.lastOwnerItemsGeneration = t;
            e.renderItems(e.getLayoutItems())
        }
    },
    renderItems: function(e) {
        var t = this,
        n = e.length,
        r, i, s, o, u, a;
        if (n) {
            Ext.suspendLayouts();
            if (t.autoColumns) {
                t.addMissingColumns(n)
            }
            o = t.columnNodes.length;
            s = Math.ceil(n / o);
            for (r = 0; r < n; r++) {
                i = e[r];
                u = t.getRenderRowIndex(r, s, o);
                a = t.getRenderColumnIndex(r, s, o);
                if (!i.rendered) {
                    t.renderItem(i, u, a)
                } else {
                    if (!t.isItemAtPosition(i, u, a)) {
                        t.moveItem(i, u, a)
                    }
                }
            }
            if (t.autoColumns) {
                t.removeExceedingColumns(n)
            }
            Ext.resumeLayouts(true)
        }
    },
    isItemAtPosition: function(e, t, n) {
        return e.el.dom === this.getNodeAt(t, n)
    },
    getRenderColumnIndex: function(e, t, n) {
        if (this.vertical) {
            return Math.floor(e / t)
        } else {
            return e % n
        }
    },
    getRenderRowIndex: function(e, t, n) {
        var r = this;
        if (r.vertical) {
            return e % t
        } else {
            return Math.floor(e / n)
        }
    },
    getNodeAt: function(e, t) {
        return this.columnNodes[t].childNodes[e]
    },
    addMissingColumns: function(e) {
        var t = this,
        n = t.columnNodes.length,
        r, i, s, o;
        if (n < e) {
            r = e - n;
            i = t.rowEl;
            s = t.owner.groupCls;
            for (o = 0; o < r; o++) {
                i.createChild({
                    cls: s,
                    tag: "td",
                    vAlign: "top",
                    role: "presentation"
                })
            }
        }
    },
    removeExceedingColumns: function(e) {
        var t = this,
        n = t.columnNodes.length,
        r, i, s;
        if (n > e) {
            r = n - e;
            i = t.rowEl;
            for (s = 0; s < r; s++) {
                i.last().remove()
            }
        }
    },
    renderItem: function(e, t, n) {
        var r = this;
        r.configureItem(e);
        e.render(Ext.get(r.columnNodes[n]), t);
        r.afterRenderItem(e)
    },
    moveItem: function(e, t, n) {
        var r = this,
        i = r.columnNodes[n],
        s = i.childNodes[t];
        i.insertBefore(e.el.dom, s || null)
    }
});Ext.define("Ext.form.CheckboxManager", {
    extend: Ext.util.MixedCollection,
    singleton: true,
    getByName: function(e, t) {
        return this.filterBy(function(n) {
            return n.name == e && n.getFormId() == t
        })
    }
});Ext.define("Ext.form.field.Checkbox", {
    extend: Ext.form.field.Base,
    alias: ["widget.checkboxfield", "widget.checkbox"],
    alternateClassName: "Ext.form.Checkbox",
    componentLayout: "field",
    stretchInputElFixed: false,
    childEls: ["boxLabelEl"],
    fieldSubTpl: ['<div class="{wrapInnerCls} {noBoxLabelCls}" role="presentation">', '<tpl if="labelAlignedBefore">', "{beforeBoxLabelTpl}", '<label id="{cmpId}-boxLabelEl" {boxLabelAttrTpl} class="{boxLabelCls} {boxLabelCls}-{boxLabelAlign}" for="{id}">', "{beforeBoxLabelTextTpl}", "{boxLabel}", "{afterBoxLabelTextTpl}", "</label>", "{afterBoxLabelTpl}", "</tpl>", '<input type="button" id="{id}" role="{role}" {inputAttrTpl}', '<tpl if="tabIdx"> tabIndex="{tabIdx}"</tpl>', '<tpl if="disabled"> disabled="disabled"</tpl>', '<tpl if="fieldStyle"> style="{fieldStyle}"</tpl>', ' class="{fieldCls} {typeCls} {inputCls} {childElCls} {afterLabelCls}" autocomplete="off" hidefocus="true" />', '<tpl if="boxLabel && !labelAlignedBefore">', "{beforeBoxLabelTpl}", '<label id="{cmpId}-boxLabelEl" {boxLabelAttrTpl} class="{boxLabelCls} {boxLabelCls}-{boxLabelAlign}" for="{id}">', "{beforeBoxLabelTextTpl}", "{boxLabel}", "{afterBoxLabelTextTpl}", "</label>", "{afterBoxLabelTpl}", "</tpl>", "</div>", {
        disableFormats: true,
        compiled: true
    }],
    subTplInsertions: ["beforeBoxLabelTpl", "afterBoxLabelTpl", "beforeBoxLabelTextTpl", "afterBoxLabelTextTpl", "boxLabelAttrTpl", "inputAttrTpl"],
    isCheckbox: true,
    focusCls: "form-checkbox-focus",
    extraFieldBodyCls: Ext.baseCSSPrefix + "form-cb-wrap",
    checked: false,
    checkedCls: Ext.baseCSSPrefix + "form-cb-checked",
    boxLabelCls: Ext.baseCSSPrefix + "form-cb-label",
    boxLabelAlign: "after",
    afterLabelCls: Ext.baseCSSPrefix + "form-cb-after",
    wrapInnerCls: Ext.baseCSSPrefix + "form-cb-wrap-inner",
    noBoxLabelCls: Ext.baseCSSPrefix + "form-cb-wrap-inner-no-box-label",
    inputValue: "on",
    checkChangeEvents: [],
    inputType: "checkbox",
    ariaRole: "checkbox",
    onRe: /^on$/i,
    inputCls: Ext.baseCSSPrefix + "form-cb",
    initComponent: function() {
        var e = this,
        t = e.value;
        if (t !== undefined) {
            e.checked = e.isChecked(t, e.inputValue)
        }
        e.callParent(arguments);
        e.getManager().add(e)
    },
    initValue: function() {
        var e = this,
        t = !!e.checked;
        e.originalValue = e.lastValue = t;
        e.setValue(t)
    },
    getElConfig: function() {
        var e = this;
        if (e.isChecked(e.rawValue, e.inputValue)) {
            e.addCls(e.checkedCls)
        }
        return e.callParent()
    },
    getSubTplData: function() {
        var e = this,
        t = e.boxLabel,
        n = e.boxLabelAlign,
        r = t && n === "before";
        return Ext.apply(e.callParent(), {
            disabled: e.readOnly || e.disabled,
            wrapInnerCls: e.wrapInnerCls,
            boxLabel: t,
            boxLabelCls: e.boxLabelCls,
            boxLabelAlign: n,
            labelAlignedBefore: r,
            afterLabelCls: r ? e.afterLabelCls: "",
            noBoxLabelCls: !t ? e.noBoxLabelCls: "",
            role: e.ariaRole
        })
    },
    initEvents: function() {
        var e = this;
        e.callParent();
        e.mon(e.inputEl, "click", e.onBoxClick, e)
    },
    setBoxLabel: function(e) {
        var t = this;
        t.boxLabel = e;
        if (t.rendered) {
            t.boxLabelEl.update(e)
        }
    },
    onBoxClick: function(e) {
        var t = this;
        if (!t.disabled && !t.readOnly) {
            this.setValue(!this.checked)
        }
    },
    getRawValue: function() {
        return this.checked
    },
    getValue: function() {
        return this.checked
    },
    getSubmitValue: function() {
        var e = this.uncheckedValue,
        t = Ext.isDefined(e) ? e: null;
        return this.checked ? this.inputValue: t
    },
    isChecked: function(e, t) {
        return e === true || e === "true" || e === "1" || e === 1 || ((Ext.isString(e) || Ext.isNumber(e)) && t ? e == t: this.onRe.test(e))
    },
    setRawValue: function(e) {
        var t = this,
        n = t.inputEl,
        r = t.isChecked(e, t.inputValue);
        if (n) {
            t[r ? "addCls": "removeCls"](t.checkedCls)
        }
        t.checked = t.rawValue = r;
        if (!t.duringSetValue) {
            t.lastValue = r
        }
        return r
    },
    setValue: function(e) {
        var t = this,
        n, r, i, s;
        if (Ext.isArray(e)) {
            n = t.getManager().getByName(t.name, t.getFormId()).items;
            i = n.length;
            for (r = 0; r < i; ++r) {
                s = n[r];
                s.setValue(Ext.Array.contains(e, s.inputValue))
            }
        } else {
            t.duringSetValue = true;
            t.callParent(arguments);
            delete t.duringSetValue
        }
        return t
    },
    valueToRaw: Ext.identityFn,
    onChange: function(e, t) {
        var n = this,
        r = n.handler;
        if (r) {
            r.call(n.scope || n, n, e)
        }
        n.callParent(arguments)
    },
    resetOriginalValue: function(e) {
        var t = this,
        n, r, i, s;
        if (!e) {
            n = t.getManager().getByName(t.name, t.getFormId()).items;
            i = n.length;
            for (s = 0; s < i; ++s) {
                r = n[s];
                if (r !== t) {
                    n[s].resetOriginalValue(true)
                }
            }
        }
        t.callParent()
    },
    beforeDestroy: function() {
        this.callParent();
        this.getManager().removeAtKey(this.id)
    },
    getManager: function() {
        return Ext.form.CheckboxManager
    },
    onEnable: function() {
        var e = this,
        t = e.inputEl;
        e.callParent();
        if (t) {
            t.dom.disabled = e.readOnly
        }
    },
    setReadOnly: function(e) {
        var t = this,
        n = t.inputEl;
        if (n) {
            n.dom.disabled = !!e || t.disabled
        }
        t.callParent(arguments)
    },
    getFormId: function() {
        var e = this,
        t;
        if (!e.formId) {
            t = e.up("form");
            if (t) {
                e.formId = t.id
            }
        }
        return e.formId
    }
});Ext.define("Ext.form.CheckboxGroup", {
    extend: Ext.form.FieldContainer,
    mixins: {
        field: Ext.form.field.Field
    },
    alias: "widget.checkboxgroup",
    columns: "auto",
    vertical: false,
    allowBlank: true,
    blankText: "You must select at least one item in this group",
    defaultType: "checkboxfield",
    groupCls: Ext.baseCSSPrefix + "form-check-group",
    extraFieldBodyCls: Ext.baseCSSPrefix + "form-checkboxgroup-body",
    layout: "checkboxgroup",
    componentCls: Ext.baseCSSPrefix + "form-checkboxgroup",
    ariaRole: "group",
    initComponent: function() {
        var e = this;
        e.callParent();
        e.initField()
    },
    initValue: function() {
        var e = this,
        t = e.value;
        e.originalValue = e.lastValue = t || e.getValue();
        if (t) {
            e.setValue(t)
        }
    },
    onAdd: function(e) {
        var t = this,
        n, r, i;
        if (e.isCheckbox) {
            t.mon(e, "change", t.checkChange, t)
        } else {
            if (e.isContainer) {
                n = e.items.items;
                for (i = 0, r = n.length; i < r; i++) {
                    t.onAdd(n[i])
                }
            }
        }
        t.callParent(arguments)
    },
    onRemove: function(e) {
        var t = this,
        n, r, i;
        if (e.isCheckbox) {
            t.mun(e, "change", t.checkChange, t)
        } else {
            if (e.isContainer) {
                n = e.items.items;
                for (i = 0, r = n.length; i < r; i++) {
                    t.onRemove(n[i])
                }
            }
        }
        t.callParent(arguments)
    },
    isEqual: function(e, t) {
        var n = Ext.Object.toQueryString;
        return n(e) === n(t)
    },
    getErrors: function() {
        var e = [];
        if (!this.allowBlank && Ext.isEmpty(this.getChecked())) {
            e.push(this.blankText)
        }
        return e
    },
    getBoxes: function(e) {
        return this.query("[isCheckbox]" + (e || ""))
    },
    eachBox: function(e, t) {
        Ext.Array.forEach(this.getBoxes(), e, t || this)
    },
    getChecked: function() {
        return this.getBoxes("[checked]")
    },
    isDirty: function() {
        var e = this.getBoxes(),
        t,
        n = e.length;
        for (t = 0; t < n; t++) {
            if (e[t].isDirty()) {
                return true
            }
        }
    },
    setReadOnly: function(e) {
        var t = this.getBoxes(),
        n,
        r = t.length;
        for (n = 0; n < r; n++) {
            t[n].setReadOnly(e)
        }
        this.readOnly = e
    },
    reset: function() {
        var e = this,
        t = e.hasActiveError(),
        n = e.preventMark;
        e.preventMark = true;
        e.batchChanges(function() {
            var t = e.getBoxes(),
            n,
            r = t.length;
            for (n = 0; n < r; n++) {
                t[n].reset()
            }
        });
        e.preventMark = n;
        e.unsetActiveError();
        if (t) {
            e.updateLayout()
        }
    },
    resetOriginalValue: function() {
        var e = this,
        t = e.getBoxes(),
        n,
        r = t.length;
        for (n = 0; n < r; n++) {
            t[n].resetOriginalValue()
        }
        e.originalValue = e.getValue();
        e.checkDirty()
    },
    setValue: function(e) {
        var t = this,
        n = t.getBoxes(),
        r,
        i = n.length,
        s,
        o,
        u;
        t.batchChanges(function() {
            for (r = 0; r < i; r++) {
                s = n[r];
                o = s.getName();
                u = false;
                if (e && e.hasOwnProperty(o)) {
                    if (Ext.isArray(e[o])) {
                        u = Ext.Array.contains(e[o], s.inputValue)
                    } else {
                        u = e[o]
                    }
                }
                s.setValue(u)
            }
        });
        return t
    },
    getValue: function() {
        var e = {},
        t = this.getBoxes(),
        n,
        r = t.length,
        i,
        s,
        o,
        u;
        for (n = 0; n < r; n++) {
            i = t[n];
            s = i.getName();
            o = i.inputValue;
            if (i.getValue()) {
                if (e.hasOwnProperty(s)) {
                    u = e[s];
                    if (!Ext.isArray(u)) {
                        u = e[s] = [u]
                    }
                    u.push(o)
                } else {
                    e[s] = o
                }
            }
        }
        return e
    },
    getSubmitData: function() {
        return null
    },
    getModelData: function() {
        return null
    },
    validate: function() {
        var e = this,
        t, n, r;
        if (e.disabled) {
            n = true
        } else {
            t = e.getErrors();
            n = Ext.isEmpty(t);
            r = e.wasValid;
            if (n) {
                e.unsetActiveError()
            } else {
                e.setActiveError(t)
            }
        }
        if (n !== r) {
            e.wasValid = n;
            e.fireEvent("validitychange", e, n);
            e.updateLayout()
        }
        return n
    }
},
function() {
    this.borrow(Ext.form.field.Base, ["markInvalid", "clearInvalid", "setError"])
});Ext.define("Ext.form.FieldSet", {
    extend: Ext.container.Container,
    mixins: {
        fieldAncestor: Ext.form.FieldAncestor
    },
    alias: "widget.fieldset",
    collapsed: false,
    toggleOnTitleClick: true,
    baseCls: Ext.baseCSSPrefix + "fieldset",
    layout: "anchor",
    componentLayout: "fieldset",
    ariaRole: null,
    autoEl: "fieldset",
    childEls: ["body"],
    renderTpl: ["{%this.renderLegend(out,values);%}", '<div id="{id}-body" class="{baseCls}-body {bodyTargetCls}" role="presentation"<tpl if="bodyStyle"> style="{bodyStyle}"</tpl>>', "{%this.renderContainer(out,values);%}", "</div>"],
    stateEvents: ["collapse", "expand"],
    maskOnDisable: false,
    beforeDestroy: function() {
        var e = this,
        t = e.legend;
        if (t) {
            delete t.ownerCt;
            t.destroy();
            e.legend = null
        }
        e.callParent()
    },
    initComponent: function() {
        var e = this,
        t = e.baseCls;
        e.initFieldAncestor();
        e.callParent();
        e.layout.managePadding = e.layout.manageOverflow = false;
        e.addEvents("beforeexpand", "beforecollapse", "expand", "collapse");
        if (e.collapsed) {
            e.addCls(t + "-collapsed");
            e.collapse()
        }
        if (e.title || e.checkboxToggle || e.collapsible) {
            e.addTitleClasses();
            e.legend = Ext.widget(e.createLegendCt())
        }
        e.initMonitor()
    },
    initPadding: function(e) {
        var t = this,
        n = t.getProtoBody(),
        r = t.padding,
        i;
        if (r !== undefined) {
            if (Ext.isIEQuirks || Ext.isIE8m) {
                r = t.parseBox(r);
                i = Ext.Element.parseBox(0);
                i.top = r.top;
                r.top = 0;
                n.setStyle("padding", t.unitizeBox(i))
            }
            e.setStyle("padding", t.unitizeBox(r))
        }
    },
    getProtoBody: function() {
        var e = this,
        t = e.protoBody;
        if (!t) {
            e.protoBody = t = new Ext.util.ProtoElement({
                styleProp: "bodyStyle",
                styleIsText: true
            })
        }
        return t
    },
    initRenderData: function() {
        var e = this,
        t = e.callParent();
        t.bodyTargetCls = e.bodyTargetCls;
        e.protoBody.writeTo(t);
        delete e.protoBody;
        return t
    },
    getState: function() {
        var e = this.callParent();
        e = this.addPropertyToState(e, "collapsed");
        return e
    },
    afterCollapse: Ext.emptyFn,
    afterExpand: Ext.emptyFn,
    collapsedHorizontal: function() {
        return true
    },
    collapsedVertical: function() {
        return true
    },
    createLegendCt: function() {
        var e = this,
        t = [],
        n = {
            xtype: "container",
            baseCls: e.baseCls + "-header",
            id: e.id + "-legend",
            autoEl: "legend",
            ariaRole: null,
            ariaLabelledBy: "." + e.baseCls + "-header-text",
            items: t,
            ownerCt: e,
            shrinkWrap: true,
            ownerLayout: e.componentLayout
        };
        if (e.checkboxToggle) {
            t.push(e.createCheckboxCmp())
        } else {
            if (e.collapsible) {
                t.push(e.createToggleCmp())
            }
        }
        t.push(e.createTitleCmp());
        return n
    },
    createTitleCmp: function() {
        var e = this,
        t = {
            xtype: "component",
            html: e.title,
            cls: e.baseCls + "-header-text",
            id: e.id + "-legendTitle"
        };
        if (e.collapsible && e.toggleOnTitleClick) {
            t.listeners = {
                click: {
                    element: "el",
                    scope: e,
                    fn: e.toggle
                }
            };
            t.cls += " " + e.baseCls + "-header-text-collapsible"
        }
        return e.titleCmp = Ext.widget(t)
    },
    createCheckboxCmp: function() {
        var e = this,
        t = "-checkbox";
        e.checkboxCmp = Ext.widget({
            xtype: "checkbox",
            hideEmptyLabel: true,
            name: e.checkboxName || e.id + t,
            cls: e.baseCls + "-header" + t,
            id: e.id + "-legendChk",
            checked: !e.collapsed,
            msgTarget: "none",
            listeners: {
                change: e.onCheckChange,
                scope: e
            }
        });
        return e.checkboxCmp
    },
    createToggleCmp: function() {
        var e = this;
        e.toggleCmp = Ext.widget({
            xtype: "tool",
            height: 15,
            width: 15,
            type: "toggle",
            handler: e.toggle,
            id: e.id + "-legendToggle",
            scope: e
        });
        return e.toggleCmp
    },
    doRenderLegend: function(e, t) {
        var n = t.$comp,
        r = n.legend,
        i;
        if (r) {
            r.ownerLayout.configureItem(r);
            i = r.getRenderTree();
            Ext.DomHelper.generateMarkup(i, e)
        }
    },
    finishRender: function() {
        var e = this.legend;
        this.callParent();
        if (e) {
            e.finishRender()
        }
    },
    getCollapsed: function() {
        return this.collapsed ? "top": false
    },
    getCollapsedDockedItems: function() {
        var e = this.legend;
        return e ? [e] : []
    },
    setTitle: function(e) {
        var t = this,
        n = t.legend,
        r = t.baseCls;
        t.title = e;
        if (t.rendered) {
            if (!n) {
                t.legend = n = Ext.widget(t.createLegendCt());
                t.addTitleClasses();
                n.ownerLayout.configureItem(n);
                n.render(t.el, 0)
            }
            t.titleCmp.update(e)
        } else {
            if (n) {
                t.titleCmp.update(e)
            } else {
                t.addTitleClasses();
                t.legend = Ext.widget(t.createLegendCt())
            }
        }
        return t
    },
    addTitleClasses: function() {
        var e = this,
        t = e.title,
        n = e.baseCls;
        if (t) {
            e.addCls(n + "-with-title")
        }
        if (t || e.checkboxToggle || e.collapsible) {
            e.addCls(n + "-with-legend")
        }
    },
    applyTargetCls: function(e) {
        this.bodyTargetCls = e
    },
    getTargetEl: function() {
        return this.body || this.frameBody || this.el
    },
    getDefaultContentTarget: function() {
        return this.body
    },
    expand: function() {
        return this.setExpanded(true)
    },
    collapse: function() {
        return this.setExpanded(false)
    },
    setExpanded: function(e) {
        var t = this,
        n = t.checkboxCmp,
        r = e ? "expand": "collapse";
        if (!t.rendered || t.fireEvent("before" + r, t) !== false) {
            e = !!e;
            if (n) {
                n.setValue(e)
            }
            if (e) {
                t.removeCls(t.baseCls + "-collapsed")
            } else {
                t.addCls(t.baseCls + "-collapsed")
            }
            t.collapsed = !e;
            if (e) {
                delete t.getHierarchyState().collapsed
            } else {
                t.getHierarchyState().collapsed = true
            }
            if (t.rendered) {
                t.updateLayout({
                    isRoot: false
                });
                t.fireEvent(r, t)
            }
        }
        return t
    },
    getRefItems: function(e) {
        var t = this.callParent(arguments),
        n = this.legend;
        if (n) {
            t.unshift(n);
            if (e) {
                t.unshift.apply(t, n.getRefItems(true))
            }
        }
        return t
    },
    toggle: function() {
        this.setExpanded( !! this.collapsed)
    },
    onCheckChange: function(e, t) {
        this.setExpanded(t)
    },
    setupRenderTpl: function(e) {
        this.callParent(arguments);
        e.renderLegend = this.doRenderLegend
    }
});Ext.define("Ext.form.Label", {
    extend: Ext.Component,
    alias: "widget.label",
    cls: "x-form-item-label",
    labelAlign: "",
    autoEl: "label",
    maskOnDisable: false,
    getElConfig: function() {
        var e = this;
        e.html = e.text ? Ext.util.Format.htmlEncode(e.text) : e.html || "";
        return Ext.apply(e.callParent(), {
            htmlFor: e.forId || ""
        })
    },
    afterRender: function() {
        var e = this;
        if (e.labelAlign) {
            e.el.setStyle("text-align", e.labelAlign)
        }
    },
    setText: function(e, t) {
        var n = this;
        t = t !== false;
        if (t) {
            n.text = e;
            delete n.html
        } else {
            n.html = e;
            delete n.text
        }
        if (n.rendered) {
            n.el.dom.innerHTML = t !== false ? Ext.util.Format.htmlEncode(e) : e;
            n.updateLayout()
        }
        return n
    }
});Ext.define("Ext.form.Panel", {
    extend: Ext.panel.Panel,
    mixins: {
        fieldAncestor: Ext.form.FieldAncestor
    },
    alias: "widget.form",
    alternateClassName: ["Ext.FormPanel", "Ext.form.FormPanel"],
    layout: "anchor",
    ariaRole: "form",
    basicFormConfigs: ["api", "baseParams", "errorReader", "jsonSubmit", "method", "paramOrder", "paramsAsHash", "reader", "standardSubmit", "timeout", "trackResetOnLoad", "url", "waitMsgTarget", "waitTitle"],
    initComponent: function() {
        var e = this;
        if (e.frame) {
            e.border = false
        }
        e.initFieldAncestor();
        e.callParent();
        e.relayEvents(e.form, ["beforeaction", "actionfailed", "actioncomplete", "validitychange", "dirtychange"]);
        if (e.pollForChanges) {
            e.startPolling(e.pollInterval || 500)
        }
    },
    initItems: function() {
        this.callParent();
        this.initMonitor();
        this.form = this.createForm()
    },
    afterFirstLayout: function() {
        this.callParent(arguments);
        this.form.initialize()
    },
    createForm: function() {
        var e = {},
        t = this.basicFormConfigs,
        n = t.length,
        r = 0,
        i;
        for (; r < n; ++r) {
            i = t[r];
            e[i] = this[i]
        }
        return new Ext.form.Basic(this, e)
    },
    getForm: function() {
        return this.form
    },
    loadRecord: function(e) {
        return this.getForm().loadRecord(e)
    },
    getRecord: function() {
        return this.getForm().getRecord()
    },
    updateRecord: function(e) {
        return this.getForm().updateRecord(e)
    },
    getValues: function(e, t, n, r) {
        return this.getForm().getValues(e, t, n, r)
    },
    isDirty: function() {
        return this.form.isDirty()
    },
    isValid: function() {
        return this.form.isValid()
    },
    hasInvalidField: function() {
        return this.form.hasInvalidField()
    },
    beforeDestroy: function() {
        this.stopPolling();
        this.form.destroy();
        this.callParent()
    },
    load: function(e) {
        this.form.load(e)
    },
    submit: function(e) {
        this.form.submit(e)
    },
    startPolling: function(e) {
        this.stopPolling();
        var t = new Ext.util.TaskRunner(e);
        t.start({
            interval: 0,
            run: this.checkChange,
            scope: this
        });
        this.pollTask = t
    },
    stopPolling: function() {
        var e = this.pollTask;
        if (e) {
            e.stopAll();
            delete this.pollTask
        }
    },
    checkChange: function() {
        var e = this.form.getFields().items,
        t,
        n = e.length;
        for (t = 0; t < n; t++) {
            e[t].checkChange()
        }
    }
});Ext.define("Ext.form.RadioManager", {
    extend: Ext.util.MixedCollection,
    singleton: true,
    getByName: function(e, t) {
        return this.filterBy(function(n) {
            return n.name == e && n.getFormId() == t
        })
    },
    getWithValue: function(e, t, n) {
        return this.filterBy(function(r) {
            return r.name == e && r.inputValue == t && r.getFormId() == n
        })
    },
    getChecked: function(e, t) {
        return this.findBy(function(n) {
            return n.name == e && n.checked && n.getFormId() == t
        })
    }
});Ext.define("Ext.form.field.Radio", {
    extend: Ext.form.field.Checkbox,
    alias: ["widget.radiofield", "widget.radio"],
    alternateClassName: "Ext.form.Radio",
    isRadio: true,
    focusCls: "form-radio-focus",
    inputType: "radio",
    ariaRole: "radio",
    formId: null,
    getGroupValue: function() {
        var e = this.getManager().getChecked(this.name, this.getFormId());
        return e ? e.inputValue: null
    },
    onBoxClick: function(e) {
        var t = this;
        if (!t.disabled && !t.readOnly) {
            this.setValue(true)
        }
    },
    onRemoved: function() {
        this.callParent(arguments);
        this.formId = null
    },
    setValue: function(e) {
        var t = this,
        n;
        if (Ext.isBoolean(e)) {
            t.callParent(arguments)
        } else {
            n = t.getManager().getWithValue(t.name, e, t.getFormId()).getAt(0);
            if (n) {
                n.setValue(true)
            }
        }
        return t
    },
    getSubmitValue: function() {
        return this.checked ? this.inputValue: null
    },
    getModelData: function() {
        var e = this.callParent(arguments);
        if (e) {
            e[this.getName()] = this.getSubmitValue()
        }
        return e
    },
    onChange: function(e, t) {
        var n = this,
        r, i, s, o;
        n.callParent(arguments);
        if (e) {
            o = n.getManager().getByName(n.name, n.getFormId()).items;
            i = o.length;
            for (r = 0; r < i; r++) {
                s = o[r];
                if (s !== n) {
                    s.setValue(false)
                }
            }
        }
    },
    getManager: function() {
        return Ext.form.RadioManager
    }
});Ext.define("Ext.form.RadioGroup", {
    extend: Ext.form.CheckboxGroup,
    alias: "widget.radiogroup",
    allowBlank: true,
    blankText: "You must select one item in this group",
    defaultType: "radiofield",
    groupCls: Ext.baseCSSPrefix + "form-radio-group",
    ariaRole: "radiogroup",
    getBoxes: function(e) {
        return this.query("[isRadio]" + (e || ""))
    },
    checkChange: function() {
        var e = this.getValue(),
        t = Ext.Object.getKeys(e)[0];
        if (Ext.isArray(e[t])) {
            return
        }
        this.callParent(arguments)
    },
    setValue: function(e) {
        var t, n, r, i, s, o, u;
        if (Ext.isObject(e)) {
            for (u in e) {
                if (e.hasOwnProperty(u)) {
                    t = e[u];
                    n = this.items.first();
                    r = n ? n.getFormId() : null;
                    i = Ext.form.RadioManager.getWithValue(u, t, r).items;
                    o = i.length;
                    for (s = 0; s < o; ++s) {
                        i[s].setValue(true)
                    }
                }
            }
        }
        return this
    }
});Ext.define("Ext.form.action.DirectLoad", {
    extend: Ext.form.action.Load,
    alternateClassName: "Ext.form.Action.DirectLoad",
    alias: "formaction.directload",
    type: "directload",
    run: function() {
        var e = this,
        t = e.form,
        n = t.api,
        r = n.load,
        i, s;
        if (typeof r !== "function") {
            n.load = r = Ext.direct.Manager.parseMethod(r)
        }
        i = r.directCfg.method;
        s = i.getArgs(e.getParams(), t.paramOrder, t.paramsAsHash);
        s.push(e.onComplete, e);
        r.apply(window, s)
    },
    processResponse: function(e) {
        return this.result = e
    },
    onComplete: function(e, t) {
        if (e) {
            this.onSuccess(e)
        } else {
            this.onFailure(null)
        }
    }
});Ext.define("Ext.form.action.DirectSubmit", {
    extend: Ext.form.action.Submit,
    alternateClassName: "Ext.form.Action.DirectSubmit",
    alias: "formaction.directsubmit",
    type: "directsubmit",
    doSubmit: function() {
        var e = this,
        t = e.form,
        n = t.api,
        r = n.submit,
        i, s, o;
        o;
        if (typeof r !== "function") {
            n.submit = r = Ext.direct.Manager.parseMethod(r)
        }
        if (e.timeout || t.timeout) {
            o = {
                timeout: e.timeout * 1e3 || t.timeout * 1e3
            }
        }
        s = e.buildForm();
        r.call(window, s.formEl, e.onComplete, e, o);
        e.cleanup(s)
    },
    processResponse: function(e) {
        return this.result = e
    },
    onComplete: function(e, t) {
        if (e) {
            this.onSuccess(e)
        } else {
            this.onFailure(null)
        }
    }
});Ext.define("Ext.form.action.StandardSubmit", {
    extend: Ext.form.action.Submit,
    alias: "formaction.standardsubmit",
    doSubmit: function() {
        var e = this.buildForm();
        e.formEl.submit();
        this.cleanup(e)
    }
});Ext.define("Ext.layout.component.field.Trigger", {
    alias: "layout.triggerfield",
    extend: Ext.layout.component.field.Field,
    type: "triggerfield",
    setWidthInDom: true,
    borderWidths: {},
    beginLayout: function(e) {
        var t = this,
        n = t.owner,
        r;
        e.triggerWrap = e.getEl("triggerWrap");
        t.callParent(arguments);
        r = n.getTriggerStateFlags();
        if (r != n.lastTriggerStateFlags) {
            n.lastTriggerStateFlags = r;
            t.updateEditState()
        }
    },
    beginLayoutCycle: function(e) {
        this.callParent(arguments);
        if (e.widthModel.shrinkWrap && !this.owner.inputWidth) {
            e.inputContext.el.setStyle("width", "")
        }
    },
    beginLayoutFixed: function(e, t, n) {
        var r = this,
        i = e.target,
        s = r.ieInputWidthAdjustment || 0,
        o = "100%",
        u = i.triggerWrap;
        r.callParent(arguments);
        i.inputCell.setStyle("width", "100%");
        if (s) {
            r.adjustIEInputPadding(e);
            if (n === "px") {
                if (i.inputWidth) {
                    o = i.inputWidth - r.getExtraWidth(e)
                } else {
                    o = t - s - r.getExtraWidth(e)
                }
                o += "px"
            }
        }
        i.inputEl.setStyle("width", o);
        o = i.inputWidth;
        if (o) {
            u.setStyle("width", o + s + "px")
        } else {
            u.setStyle("width", t + n)
        }
        u.setStyle("table-layout", "fixed")
    },
    adjustIEInputPadding: function(e) {
        this.owner.inputCell.setStyle("padding-right", this.ieInputWidthAdjustment + "px")
    },
    getExtraWidth: function(e) {
        var t = this,
        n = t.owner,
        r = t.borderWidths,
        i = n.ui + n.triggerEl.getCount();
        if (! (i in r)) {
            r[i] = e.triggerWrap.getBorderInfo().width
        }
        return r[i] + n.getTriggerWidth()
    },
    beginLayoutShrinkWrap: function(e) {
        var t = e.target,
        n = "",
        r = t.inputWidth,
        i = t.triggerWrap;
        this.callParent(arguments);
        if (r) {
            i.setStyle("width", r + "px");
            r = r - this.getExtraWidth(e) + "px";
            t.inputEl.setStyle("width", r);
            t.inputCell.setStyle("width", r)
        } else {
            t.inputCell.setStyle("width", n);
            t.inputEl.setStyle("width", n);
            i.setStyle("width", n);
            i.setStyle("table-layout", "auto")
        }
    },
    getTextWidth: function() {
        var e = this,
        t = e.owner,
        n = t.inputEl,
        r;
        r = (n.dom.value || (t.hasFocus ? "": t.emptyText) || "") + t.growAppend;
        return n.getTextWidth(r)
    },
    publishOwnerWidth: function(e, t) {
        var n = this.owner;
        this.callParent(arguments);
        if (!n.grow && !n.inputWidth) {
            t -= this.getExtraWidth(e);
            if (n.labelAlign != "top") {
                t -= n.getLabelWidth()
            }
            e.inputContext.setWidth(t)
        }
    },
    publishInnerHeight: function(e, t) {
        e.inputContext.setHeight(t - this.measureLabelErrorHeight(e))
    },
    measureContentWidth: function(e) {
        var t = this,
        n = t.owner,
        r = t.callParent(arguments),
        i = e.inputContext,
        s,
        o,
        u;
        if (n.grow && !e.state.growHandled) {
            s = t.getTextWidth() + e.inputContext.getFrameInfo().width;
            o = n.growMax;
            u = Math.min(o, r);
            o = Math.max(n.growMin, o, u);
            s = Ext.Number.constrain(s, n.growMin, o);
            i.setWidth(s);
            e.state.growHandled = true;
            i.domBlock(t, "width");
            r = NaN
        } else {
            if (!n.inputWidth) {
                r -= t.getExtraWidth(e)
            }
        }
        return r
    },
    updateEditState: function() {
        var e = this,
        t = e.owner,
        n = t.inputEl,
        r = Ext.baseCSSPrefix + "trigger-noedit",
        i, s;
        if (e.owner.readOnly) {
            n.addCls(r);
            s = true;
            i = false
        } else {
            if (e.owner.editable) {
                n.removeCls(r);
                s = false
            } else {
                n.addCls(r);
                s = true
            }
            i = !e.owner.hideTrigger
        }
        t.triggerCell.setDisplayed(i);
        n.dom.readOnly = s
    }
});Ext.define("Ext.form.field.Trigger", {
    extend: Ext.form.field.Text,
    alias: ["widget.triggerfield", "widget.trigger"],
    alternateClassName: ["Ext.form.TriggerField", "Ext.form.TwinTriggerField", "Ext.form.Trigger"],
    childEls: [{
        name: "triggerCell",
        select: "." + Ext.baseCSSPrefix + "trigger-cell"
    },
    {
        name: "triggerEl",
        select: "." + Ext.baseCSSPrefix + "form-trigger"
    },
    "triggerWrap", "inputCell"],
    triggerBaseCls: Ext.baseCSSPrefix + "form-trigger",
    triggerWrapCls: Ext.baseCSSPrefix + "form-trigger-wrap",
    triggerNoEditCls: Ext.baseCSSPrefix + "trigger-noedit",
    hideTrigger: false,
    editable: true,
    readOnly: false,
    repeatTriggerClick: false,
    autoSize: Ext.emptyFn,
    monitorTab: true,
    mimicing: false,
    triggerIndexRe: /trigger-index-(\d+)/,
    extraTriggerCls: "",
    componentLayout: "triggerfield",
    initComponent: function() {
        this.wrapFocusCls = this.triggerWrapCls + "-focus";
        this.callParent(arguments)
    },
    initEvents: function() {
        this.mon(Ext.globalEvents, "beforefocus", this.onOtherFocus, this);
        this.callParent()
    },
    getSubTplMarkup: function(e) {
        var t = this,
        n = e.childElCls,
        r = t.callParent(arguments);
        return ['<table id="', t.id, '-triggerWrap" class="', Ext.baseCSSPrefix, "form-trigger-wrap", n, '" cellpadding="0" cellspacing="0" role="presentation">', '<tbody role="presentation">', '<tr role="presentation">', '<td id="', t.id, '-inputCell" class="', Ext.baseCSSPrefix, "form-trigger-input-cell", n, '" role="presentation">', r, "</td>", t.getTriggerMarkup(), "</tr>", "</tbody>", "</table>"].join("")
    },
    getSubTplData: function() {
        var e = this,
        t = e.callParent(),
        n = e.readOnly === true,
        r = e.editable !== false;
        return Ext.apply(t, {
            editableCls: n || !r ? " " + e.triggerNoEditCls: "",
            readOnly: !r || n
        })
    },
    getLabelableRenderData: function() {
        var e = this,
        t = e.triggerWrapCls,
        n = e.callParent(arguments);
        return Ext.applyIf(n, {
            triggerWrapCls: t,
            triggerMarkup: e.getTriggerMarkup()
        })
    },
    getTriggerMarkup: function() {
        var e = this,
        t = 0,
        n = e.readOnly || e.hideTrigger,
        r, i = e.triggerBaseCls,
        s = [],
        o = Ext.dom.Element.unselectableCls,
        u = "width:" + e.triggerWidth + "px;" + (n ? "display:none;": ""),
        a = e.extraTriggerCls + " " + Ext.baseCSSPrefix + "trigger-cell " + o;
        if (!e.trigger1Cls) {
            e.trigger1Cls = e.triggerCls
        }
        for (t = 0; (r = e["trigger" + (t + 1) + "Cls"]) || t < 1; t++) {
            s.push({
                tag: "td",
                role: "presentation",
                valign: "top",
                cls: a,
                style: u,
                cn: {
                    cls: [Ext.baseCSSPrefix + "trigger-index-" + t, i, r].join(" "),
                    role: "presentation"
                }
            })
        }
        s[0].cn.cls += " " + i + "-first";
        return Ext.DomHelper.markup(s)
    },
    disableCheck: function() {
        return ! this.disabled
    },
    beforeRender: function() {
        var e = this,
        t = e.triggerBaseCls,
        n;
        if (!e.triggerWidth) {
            n = Ext.getBody().createChild({
                role: "presentation",
                style: "position: absolute;",
                cls: Ext.baseCSSPrefix + "form-trigger"
            });
            Ext.form.field.Trigger.prototype.triggerWidth = n.getWidth();
            n.remove()
        }
        e.callParent();
        if (t !== Ext.baseCSSPrefix + "form-trigger") {
            e.addChildEls({
                name: "triggerEl",
                select: "." + t
            })
        }
        e.lastTriggerStateFlags = e.getTriggerStateFlags()
    },
    onRender: function() {
        var e = this;
        e.callParent(arguments);
        e.doc = Ext.getDoc();
        e.initTrigger()
    },
    getTriggerWidth: function() {
        var e = this,
        t = 0;
        if (e.triggerWrap && !e.hideTrigger && !e.readOnly) {
            t = e.triggerEl.getCount() * e.triggerWidth
        }
        return t
    },
    setHideTrigger: function(e) {
        if (e != this.hideTrigger) {
            this.hideTrigger = e;
            this.updateLayout()
        }
    },
    setEditable: function(e) {
        if (e != this.editable) {
            this.editable = e;
            this.updateLayout()
        }
    },
    setReadOnly: function(e) {
        var t = this,
        n = t.readOnly;
        t.callParent(arguments);
        if (e != n) {
            t.updateLayout()
        }
    },
    initTrigger: function() {
        var e = this,
        t = e.triggerWrap,
        n = e.triggerEl,
        r = e.disableCheck,
        i, s, o, u, a, f;
        if (e.repeatTriggerClick) {
            e.triggerRepeater = new Ext.util.ClickRepeater(t, {
                preventDefault: true,
                handler: e.onTriggerWrapClick,
                listeners: {
                    mouseup: e.onTriggerWrapMouseup,
                    scope: e
                },
                scope: e
            })
        } else {
            e.mon(t, {
                click: e.onTriggerWrapClick,
                mouseup: e.onTriggerWrapMouseup,
                scope: e
            })
        }
        n.setVisibilityMode(Ext.Element.DISPLAY);
        n.addClsOnOver(e.triggerBaseCls + "-over", r, e);
        i = n.elements;
        s = i.length;
        for (u = 0; u < s; u++) {
            o = i[u];
            a = u + 1;
            f = e["trigger" + a + "Cls"];
            if (f) {
                o.addClsOnOver(f + "-over", r, e);
                o.addClsOnClick(f + "-click", r, e)
            }
        }
        n.addClsOnClick(e.triggerBaseCls + "-click", r, e)
    },
    onDestroy: function() {
        var e = this;
        Ext.destroyMembers(e, "triggerRepeater", "triggerWrap", "triggerEl");
        delete e.doc;
        e.callParent()
    },
    onFocus: function() {
        var e = this;
        e.otherFocused = false;
        e.callParent(arguments);
        if (!e.mimicing) {
            e.bodyEl.addCls(e.wrapFocusCls);
            e.mimicing = true;
            e.mon(e.doc, "mousedown", e.mimicBlur, e, {
                delay: 10
            });
            if (e.monitorTab) {
                e.on("specialkey", e.checkTab, e)
            }
        }
    },
    checkTab: function(e, t) {
        if (!this.ignoreMonitorTab && t.getKey() === t.TAB) {
            this.triggerBlur()
        }
    },
    getTriggerStateFlags: function() {
        var e = this,
        t = 0;
        if (e.readOnly) {
            t += 1
        }
        if (e.editable) {
            t += 2
        }
        if (e.hideTrigger) {
            t += 4
        }
        return t
    },
    onOtherFocus: function(e) {
        this.otherFocused = this.hasFocus && !this.bodyEl.contains(e)
    },
    onBlur: function() {
        if (this.blurring || this.otherFocused) {
            this.triggerBlur();
            this.otherFocused = false
        }
    },
    mimicBlur: function(e) {
        if (!this.isDestroyed && !this.bodyEl.contains(e.target)) {
            this.triggerBlur(e)
        }
    },
    triggerBlur: function(e) {
        var t = this;
        t.mimicing = false;
        t.mun(t.doc, "mousedown", t.mimicBlur, t);
        if (t.monitorTab && t.inputEl) {
            t.un("specialkey", t.checkTab, t)
        }
        Ext.form.field.Trigger.superclass.onBlur.call(t, e);
        if (t.bodyEl) {
            t.bodyEl.removeCls(t.wrapFocusCls)
        }
    },
    onTriggerWrapClick: function() {
        var e = this,
        t, n, r, i;
        i = arguments[e.triggerRepeater ? 1 : 0];
        if (i && !e.readOnly && !e.disabled) {
            t = i.getTarget("." + e.triggerBaseCls, null);
            n = t && t.className.match(e.triggerIndexRe);
            if (n) {
                r = e["onTrigger" + (parseInt(n[1], 10) + 1) + "Click"] || e.onTriggerClick;
                if (r) {
                    r.call(e, i)
                }
            }
        }
    },
    onTriggerWrapMouseup: Ext.emptyFn,
    onTriggerClick: Ext.emptyFn
});Ext.define("Ext.form.field.Picker", {
    extend: Ext.form.field.Trigger,
    alias: "widget.pickerfield",
    alternateClassName: "Ext.form.Picker",
    matchFieldWidth: true,
    pickerAlign: "tl-bl?",
    openCls: Ext.baseCSSPrefix + "pickerfield-open",
    editable: true,
    initComponent: function() {
        this.callParent();
        this.addEvents("expand", "collapse", "select")
    },
    initEvents: function() {
        var e = this;
        e.callParent();
        e.keyNav = new Ext.util.KeyNav(e.inputEl, {
            down: e.onDownArrow,
            esc: {
                handler: e.onEsc,
                scope: e,
                defaultEventAction: false
            },
            scope: e,
            forceKeyDown: true
        });
        if (!e.editable) {
            e.mon(e.inputEl, "click", e.onTriggerClick, e)
        }
        if (Ext.isGecko) {
            e.inputEl.dom.setAttribute("autocomplete", "off")
        }
    },
    onEsc: function(e) {
        if (Ext.isIE) {
            e.preventDefault()
        }
        if (this.isExpanded) {
            this.collapse();
            e.stopEvent()
        }
    },
    onDownArrow: function(e) {
        if (!this.isExpanded && !this.enterKeyTriggerClick) {
            this.onTriggerClick()
        }
    },
    expand: function() {
        var e = this,
        t, n, r;
        if (e.rendered && !e.isExpanded && !e.isDestroyed) {
            e.expanding = true;
            t = e.bodyEl;
            n = e.getPicker();
            r = e.collapseIf;
            n.show();
            e.isExpanded = true;
            e.alignPicker();
            t.addCls(e.openCls);
            e.mon(Ext.getDoc(), {
                mousewheel: r,
                mousedown: r,
                scope: e
            });
            Ext.EventManager.onWindowResize(e.alignPicker, e);
            e.fireEvent("expand", e);
            e.onExpand();
            delete e.expanding
        }
    },
    onExpand: Ext.emptyFn,
    alignPicker: function() {
        var e = this,
        t = e.getPicker();
        if (e.isExpanded) {
            if (e.matchFieldWidth) {
                t.setWidth(e.bodyEl.getWidth())
            }
            if (t.isFloating()) {
                e.doAlign()
            }
        }
    },
    doAlign: function() {
        var e = this,
        t = e.picker,
        n = "-above",
        r;
        e.picker.alignTo(e.triggerWrap, e.pickerAlign, e.pickerOffset);
        r = t.el.getY() < e.inputEl.getY();
        e.bodyEl[r ? "addCls": "removeCls"](e.openCls + n);
        t[r ? "addCls": "removeCls"](t.baseCls + n)
    },
    collapse: function() {
        var e = this;
        if (e.isExpanded && !e.isDestroyed && !e.destroying) {
            var t = e.openCls,
            n = e.picker,
            r = Ext.getDoc(),
            i = e.collapseIf,
            s = "-above";
            n.hide();
            e.isExpanded = false;
            e.bodyEl.removeCls([t, t + s]);
            n.el.removeCls(n.baseCls + s);
            r.un("mousewheel", i, e);
            r.un("mousedown", i, e);
            Ext.EventManager.removeResizeListener(e.alignPicker, e);
            e.fireEvent("collapse", e);
            e.onCollapse()
        }
    },
    onCollapse: Ext.emptyFn,
    collapseIf: function(e) {
        var t = this;
        if (!t.isDestroyed && !e.within(t.bodyEl, false, true) && (!t.picker || !e.within(t.picker.el, false, true)) && !t.owns(e.target)) {
            t.collapse()
        }
    },
    getPicker: function() {
        var e = this,
        t = e.picker;
        if (!t) {
            e.picker = t = e.createPicker();
            t.ownerCmp = e
        }
        return t
    },
    getRefItems: function() {
        var e = [];
        if (this.picker) {
            e[0] = this.picker
        }
        return e
    },
    createPicker: Ext.emptyFn,
    onTriggerClick: function() {
        var e = this;
        if (!e.readOnly && !e.disabled) {
            if (e.isExpanded) {
                e.collapse()
            } else {
                e.expand()
            }
            e.inputEl.focus()
        }
    },
    onOtherFocus: function(e) {
        if (this.hasFocus && !this.owns(e)) {
            this.callParent([e])
        }
    },
    triggerBlur: function() {
        var e = this.picker;
        this.callParent(arguments);
        this.collapse()
    },
    mimicBlur: function(e) {
        var t = this,
        n = t.picker;
        if (!n || !e.within(n.el, false, true)) {
            t.callParent(arguments)
        } else {
            t.inputEl.focus()
        }
    },
    onDestroy: function() {
        var e = this,
        t = e.picker;
        Ext.EventManager.removeResizeListener(e.alignPicker, e);
        Ext.destroy(e.keyNav, t);
        if (t) {
            delete e.picker;
            delete t.pickerField
        }
        e.callParent()
    }
});Ext.define("Ext.selection.Model", {
    extend: Ext.util.Observable,
    alternateClassName: "Ext.AbstractSelectionModel",
    mixins: {
        bindable: Ext.util.Bindable
    },
    allowDeselect: undefined,
    toggleOnClick: true,
    selected: null,
    pruneRemoved: true,
    suspendChange: 0,
    constructor: function(e) {
        var t = this;
        e = e || {};
        Ext.apply(t, e);
        t.addEvents("selectionchange", "focuschange");
        t.modes = {
            SINGLE: true,
            SIMPLE: true,
            MULTI: true
        };
        t.setSelectionMode(e.mode || t.mode);
        t.selected = new Ext.util.MixedCollection(null, t.getSelectionId);
        t.callParent(arguments)
    },
    bindStore: function(e, t) {
        var n = this;
        n.mixins.bindable.bindStore.apply(n, arguments);
        if (n.store && !t) {
            n.refresh()
        }
    },
    getStoreListeners: function() {
        var e = this;
        return {
            add: e.onStoreAdd,
            clear: e.onStoreClear,
            bulkremove: e.onStoreRemove,
            update: e.onStoreUpdate,
            load: e.onStoreLoad,
            idchanged: e.onModelIdChanged,
            refresh: e.onStoreRefresh
        }
    },
    suspendChanges: function() {++this.suspendChange
    },
    resumeChanges: function() {
        if (this.suspendChange) {--this.suspendChange
        }
    },
    selectAll: function(e) {
        var t = this,
        n = t.store.getRange(),
        r = 0,
        i = n.length,
        s = t.getSelection().length;
        t.suspendChanges();
        for (; r < i; r++) {
            t.doSelect(n[r], true, e)
        }
        t.resumeChanges();
        if (!e) {
            t.maybeFireSelectionChange(t.getSelection().length !== s)
        }
    },
    deselectAll: function(e) {
        var t = this,
        n = t.getSelection(),
        r = {},
        i = t.store,
        s = n.length,
        o,
        u,
        a;
        for (o = 0, u = n.length; o < u; o++) {
            a = n[o];
            r[a.internalId] = i.indexOf(a)
        }
        n = Ext.Array.sort(n,
        function(e, t) {
            var n = r[e.internalId],
            i = r[t.internalId];
            return n < i ? -1 : 1
        });
        t.suspendChanges();
        t.doDeselect(n, e);
        t.resumeChanges();
        if (!e) {
            t.maybeFireSelectionChange(t.getSelection().length !== s)
        }
    },
    getSelectionStart: function() {
        if (!this.selectionStart) {
            this.setSelectionStart(this.lastFocused)
        }
        return this.selectionStart
    },
    setSelectionStart: function(e) {
        this.selectionStart = e
    },
    selectWithEvent: function(e, t) {
        var n = this,
        r = n.isSelected(e),
        i = t.shiftKey,
        s = t.ctrlKey,
        o = i && n.getSelectionStart(),
        u = n.getSelection(),
        a = u.length,
        f = n.allowDeselect,
        l,
        c,
        h;
        switch (n.selectionMode) {
        case "MULTI":
            if (i && o) {
                n.selectRange(o, e, s)
            } else {
                if (s && r) {
                    n.doDeselect(e, false)
                } else {
                    if (s) {
                        n.doSelect(e, true, false)
                    } else {
                        if (r && !i && !s && a > 1) {
                            l = [];
                            for (c = 0; c < a; ++c) {
                                h = u[c];
                                if (h !== e) {
                                    l.push(h)
                                }
                            }
                            n.doDeselect(l)
                        } else {
                            if (!r) {
                                n.doSelect(e, false)
                            }
                        }
                    }
                }
            }
            break;
        case "SIMPLE":
            if (r) {
                n.doDeselect(e)
            } else {
                n.doSelect(e, true)
            }
            break;
        case "SINGLE":
            if (f && !s) {
                f = n.toggleOnClick
            }
            if (f && r) {
                n.doDeselect(e)
            } else {
                n.doSelect(e, false)
            }
            break
        }
        if (!i) {
            if (n.isSelected(e)) {
                n.selectionStart = e
            } else {
                n.selectionStart = null
            }
        }
    },
    afterKeyNavigate: function(e, t) {
        var n = this,
        r, i, s = n.isSelected(t),
        o = n.selectionStart && n.isSelected(n.lastFocused) ? n.selectionStart: n.selectionStart = n.lastFocused,
        u = e.getCharCode(),
        a = u === e.SPACE,
        f = u === e.UP || u === e.PAGE_UP ? "up": u === e.DOWN || u === e.DOWN ? "down": null;
        switch (n.selectionMode) {
        case "MULTI":
            if (a) {
                if (e.shiftKey) {
                    n.selectRange(o, t, e.ctrlKey)
                } else {
                    if (s) {
                        n.doDeselect(t, e.ctrlKey);
                        n.setLastFocused(null);
                        n.setLastFocused(t)
                    } else {
                        n.doSelect(t, e.ctrlKey)
                    }
                }
            } else {
                if (e.shiftKey && o) {
                    i = n.store.indexOf(o);
                    r = n.store.indexOf(t);
                    if (f === "up" && i <= r) {
                        n.deselectRange(n.lastFocused, r + 1)
                    } else {
                        if (f === "down" && i >= r) {
                            n.deselectRange(n.lastFocused, r - 1)
                        } else {
                            if (o !== t) {
                                n.selectRange(o, t, e.ctrlKey)
                            }
                        }
                    }
                    n.lastSelected = t;
                    n.setLastFocused(t)
                } else {
                    if (e.ctrlKey && s) {
                        n.setLastFocused(t)
                    } else {
                        if (e.ctrlKey) {
                            n.setLastFocused(t)
                        } else {
                            n.doSelect(t, false)
                        }
                    }
                }
            }
            break;
        case "SIMPLE":
            if (s) {
                if (n.allowDeselect) {
                    n.doDeselect(t)
                }
            } else {
                n.doSelect(t, true)
            }
            break;
        case "SINGLE":
            if (a) {
                if (s) {
                    if (n.allowDeselect) {
                        n.doDeselect(t);
                        n.setLastFocused(t)
                    }
                } else {
                    n.doSelect(t)
                }
            } else {
                if (e.ctrlKey) {
                    n.setLastFocused(t)
                } else {
                    if (a && n.allowDeselect && s) {
                        n.doDeselect(t)
                    } else {
                        n.doSelect(t, false);
                        n.setLastFocused(t)
                    }
                }
            }
            break
        }
        if (!e.shiftKey) {
            if (n.isSelected(t)) {
                n.selectionStart = t
            }
        }
    },
    selectRange: function(e, t, n) {
        var r = this,
        i = r.store,
        s = r.selected.items,
        o, u, a, f, l, c, h;
        if (r.isLocked()) {
            return
        }
        o = r.normalizeRowRange(e, t);
        e = o[0];
        t = o[1];
        f = [];
        for (u = e; u <= t; u++) {
            if (!r.isSelected(i.getAt(u))) {
                f.push(i.getAt(u))
            }
        }
        if (!n) {
            l = [];
            r.suspendChanges();
            for (u = 0, a = s.length; u < a; ++u) {
                h = s[u];
                c = i.indexOf(h);
                if (c < e || c > t) {
                    l.push(h)
                }
            }
            for (u = 0, a = l.length; u < a; ++u) {
                r.doDeselect(l[u])
            }
            r.resumeChanges()
        }
        if (f.length) {
            r.doMultiSelect(f, true)
        } else {
            r.maybeFireSelectionChange(l.length > 0)
        }
    },
    deselectRange: function(e, t) {
        var n = this,
        r = n.store,
        i, s, o, u;
        if (n.isLocked()) {
            return
        }
        i = n.normalizeRowRange(e, t);
        e = i[0];
        t = i[1];
        o = [];
        for (s = e; s <= t; s++) {
            u = r.getAt(s);
            if (n.isSelected(u)) {
                o.push(u)
            }
        }
        if (o.length) {
            n.doDeselect(o)
        }
    },
    normalizeRowRange: function(e, t) {
        var n = this.store,
        r;
        if (!Ext.isNumber(e)) {
            e = n.indexOf(e)
        }
        e = Math.max(0, e);
        if (!Ext.isNumber(t)) {
            t = n.indexOf(t)
        }
        t = Math.min(t, n.getCount() - 1);
        if (e > t) {
            r = t;
            t = e;
            e = r
        }
        return [e, t]
    },
    onModelIdChanged: function(e, t, n, r, i) {
        this.selected.updateKey(i, r)
    },
    select: function(e, t, n) {
        if (Ext.isDefined(e) && !(Ext.isArray(e) && !e.length)) {
            this.doSelect(e, t, n)
        }
    },
    deselect: function(e, t) {
        this.doDeselect(e, t)
    },
    doSelect: function(e, t, n) {
        var r = this,
        i;
        if (r.locked || !r.store) {
            return
        }
        if (typeof e === "number") {
            i = r.store.getAt(e);
            if (!i) {
                return
            }
            e = [i]
        }
        if (r.selectionMode == "SINGLE" && e) {
            i = e.length ? e[0] : e;
            r.doSingleSelect(i, n)
        } else {
            r.doMultiSelect(e, t, n)
        }
    },
    doMultiSelect: function(e, t, n) {
        var r = this,
        i = r.selected,
        s = false,
        o, u, a, f, l;
        if (r.locked) {
            return
        }
        e = !Ext.isArray(e) ? [e] : e;
        a = e.length;
        if (!t && i.getCount() > 0) {
            o = r.deselectDuringSelect(e, i.getRange(), n);
            if (o[0]) {
                r.maybeFireSelectionChange(o[1] > 0 && !n);
                return
            }
        }
        l = function() {
            i.add(f);
            s = true
        };
        for (u = 0; u < a; u++) {
            f = e[u];
            if (r.isSelected(f)) {
                continue
            }
            r.lastSelected = f;
            r.onSelectChange(f, true, n, l)
        }
        if (!r.preventFocus) {
            r.setLastFocused(f, n)
        }
        r.maybeFireSelectionChange(s && !n)
    },
    deselectDuringSelect: function(e, t, n) {
        var r = this,
        i = t.length,
        s = 0,
        o = false,
        u, a;
        r.suspendChanges();
        for (a = 0; a < i; ++a) {
            u = t[a];
            if (!Ext.Array.contains(e, u)) {
                if (r.doDeselect(u, n)) {++s
                } else {
                    o = true
                }
            }
        }
        r.resumeChanges();
        return [o, s]
    },
    doDeselect: function(e, t) {
        var n = this,
        r = n.selected,
        i = 0,
        s, o, u = 0,
        a = 0,
        f;
        if (n.locked || !n.store) {
            return false
        }
        if (typeof e === "number") {
            o = n.store.getAt(e);
            if (!o) {
                return false
            }
            e = [o]
        } else {
            if (!Ext.isArray(e)) {
                e = [e]
            }
        }
        f = function() {++a;
            r.remove(o)
        };
        s = e.length;
        n.suspendChanges();
        for (; i < s; i++) {
            o = e[i];
            if (n.isSelected(o)) {
                if (n.lastSelected === o) {
                    n.lastSelected = r.last();
                    if (n.lastFocused === o) {
                        n.setLastFocused(null)
                    }
                }++u;
                n.onSelectChange(o, false, t, f)
            }
        }
        n.resumeChanges();
        n.maybeFireSelectionChange(a > 0 && !t);
        return a === u
    },
    doSingleSelect: function(e, t) {
        var n = this,
        r = false,
        i = n.selected,
        s;
        if (n.locked) {
            return
        }
        if (n.isSelected(e)) {
            return
        }
        if (i.getCount()) {
            n.suspendChanges();
            if (!n.doDeselect(n.lastSelected, t)) {
                n.resumeChanges();
                return
            }
            n.resumeChanges()
        }
        s = function() {
            i.add(e);
            n.lastSelected = e;
            r = true
        };
        n.onSelectChange(e, true, t, s);
        if (r) {
            if (!t && !n.preventFocus) {
                n.setLastFocused(e)
            }
            n.maybeFireSelectionChange(!t)
        }
    },
    setLastFocused: function(e, t) {
        var n = this,
        r = n.lastFocused;
        if (e !== r) {
            n.lastFocused = e;
            n.onLastFocusChanged(r, e, t)
        }
    },
    isFocused: function(e) {
        return e === this.getLastFocused()
    },
    maybeFireSelectionChange: function(e) {
        var t = this;
        if (e && !t.suspendChange) {
            t.fireEvent("selectionchange", t, t.getSelection())
        }
    },
    getLastSelected: function() {
        return this.lastSelected
    },
    getLastFocused: function() {
        return this.lastFocused
    },
    getSelection: function() {
        return this.selected.getRange()
    },
    getSelectionMode: function() {
        return this.selectionMode
    },
    setSelectionMode: function(e) {
        e = e ? e.toUpperCase() : "SINGLE";
        this.selectionMode = this.modes[e] ? e: "SINGLE"
    },
    isLocked: function() {
        return this.locked
    },
    setLocked: function(e) {
        this.locked = !!e
    },
    isRangeSelected: function(e, t) {
        var n = this,
        r = n.store,
        i, s;
        s = n.normalizeRowRange(e, t);
        e = s[0];
        t = s[1];
        for (i = e; i <= t; i++) {
            if (!n.isSelected(r.getAt(i))) {
                return false
            }
        }
        return true
    },
    isSelected: function(e) {
        e = Ext.isNumber(e) ? this.store.getAt(e) : e;
        return this.selected.contains(e)
    },
    hasSelection: function() {
        return this.selected.getCount() > 0
    },
    getSelectionId: function(e) {
        return e.internalId
    },
    pruneIf: function() {
        var e = this,
        t = e.selected,
        n = [],
        r = t.length,
        i,
        s;
        if (e.pruneRemoved) {
            for (i = 0; i < r; i++) {
                s = t.getAt(i);
                if (!e.getStoreRecord(s)) {
                    n.push(s)
                }
            }
            if (n.length) {
                for (i = 0, r = n.length; i < r; i++) {
                    t.remove(n[i])
                }
                e.maybeFireSelectionChange(true)
            }
        }
    },
    getStoreRecord: function(e) {
        var t = this.store,
        n, r, i, s, o;
        if (e) {
            if (e.hasId()) {
                return t.getById(e.getId())
            } else {
                n = t.data.items;
                i = n.length;
                s = e.internalId;
                for (o = 0; o < i; ++o) {
                    r = n[o];
                    if (s === r.internalId) {
                        return r
                    }
                }
            }
        }
        return null
    },
    refresh: function() {
        var e = this,
        t = e.store,
        n, r = [],
        i = [],
        s = e.getSelection(),
        o = s.length,
        u,
        a,
        f = 0,
        l = e.getLastFocused();
        if (!t) {
            return
        }
        for (; f < o; f++) {
            u = s[f];
            if (t.indexOf(u) !== -1) {
                r.push(u)
            } else {
                if (!e.pruneRemoved) {
                    n = t.getById(u.getId());
                    if (n) {
                        r.push(n)
                    } else {
                        i.push(u)
                    }
                }
            }
            if (e.mode === "SINGLE" && i.length) {
                break
            }
        }
        if (e.selected.getCount() != r.length + i.length) {
            a = true
        }
        e.clearSelections();
        if (t.indexOf(l) !== -1) {
            e.setLastFocused(l, true)
        }
        if (r.length) {
            e.doSelect(r, false, true)
        }
        if (i.length) {
            e.selected.addAll(i);
            if (!e.lastSelected) {
                e.lastSelected = i[i.length - 1]
            }
        }
        e.maybeFireSelectionChange(a)
    },
    clearSelections: function() {
        this.selected.clear();
        this.lastSelected = null;
        this.setLastFocused(null)
    },
    onStoreAdd: Ext.emptyFn,
    onStoreClear: function() {
        if (this.selected.getCount() > 0) {
            this.clearSelections();
            this.maybeFireSelectionChange(true)
        }
    },
    onStoreRemove: function(e, t, n, r) {
        var i = this;
        if (i.selectionStart && Ext.Array.contains(t, i.selectionStart)) {
            i.selectionStart = null
        }
        if (r || i.locked || !i.pruneRemoved) {
            return
        }
        i.deselectDeletedRecords(t)
    },
    deselectDeletedRecords: function(e) {
        var t = this,
        n = t.selected,
        r, i = e.length,
        s = 0,
        o;
        for (r = 0; r < i; r++) {
            o = e[r];
            if (n.remove(o)) {
                if (t.lastSelected == o) {
                    t.lastSelected = null
                }
                if (t.getLastFocused() == o) {
                    t.setLastFocused(null)
                }++s
            }
        }
        if (s) {
            t.maybeFireSelectionChange(true)
        }
    },
    getCount: function() {
        return this.selected.getCount()
    },
    onUpdate: Ext.emptyFn,
    destroy: function() {
        this.clearListeners()
    },
    onStoreUpdate: Ext.emptyFn,
    onStoreRefresh: function() {
        var e = this,
        t = e.selected,
        n, r, i, s, o;
        if (e.store.buffered) {
            return
        }
        n = t.items;
        r = n.length;
        e.lastSelected = e.getStoreRecord(e.lastSelected);
        for (i = 0; i < r; ++i) {
            s = n[i];
            o = e.getStoreRecord(s);
            if (o) {
                if (s.hasId()) {
                    e.selected.replace(o)
                }
            } else {
                e.selected.remove(s)
            }
        }
    },
    onStoreLoad: Ext.emptyFn,
    onSelectChange: function(e, t, n, r) {
        var i = this,
        s = t ? "select": "deselect";
        if ((n || i.fireEvent("before" + s, i, e)) !== false && r() !== false) {
            if (!n) {
                i.fireEvent(s, i, e)
            }
        }
    },
    onLastFocusChanged: function(e, t) {
        this.fireEvent("focuschange", this, e, t)
    },
    onEditorKey: Ext.emptyFn,
    beforeViewRender: function(e) {
        this.views = this.views || [];
        this.views.push(e);
        this.bindStore(e.getStore(), true)
    },
    bindComponent: Ext.emptyFn
});Ext.define("Ext.selection.DataViewModel", {
    extend: Ext.selection.Model,
    deselectOnContainerClick: true,
    enableKeyNav: true,
    constructor: function(e) {
        this.addEvents("beforedeselect", "beforeselect", "deselect", "select");
        this.callParent(arguments)
    },
    bindComponent: function(e) {
        var t = this,
        n = {
            refresh: t.refresh,
            scope: t
        };
        t.view = e;
        t.bindStore(e.getStore());
        n[e.triggerEvent] = t.onItemClick;
        n[e.triggerCtEvent] = t.onContainerClick;
        e.on(n);
        if (t.enableKeyNav) {
            t.initKeyNav(e)
        }
    },
    onUpdate: function(e) {
        var t = this.view;
        if (t && this.isSelected(e)) {
            t.onItemSelect(e)
        }
    },
    onItemClick: function(e, t, n, r, i) {
        this.selectWithEvent(t, i)
    },
    onContainerClick: function() {
        if (this.deselectOnContainerClick) {
            this.deselectAll()
        }
    },
    initKeyNav: function(e) {
        var t = this;
        if (!e.rendered) {
            e.on({
                render: Ext.Function.bind(t.initKeyNav, t, [e]),
                single: true
            });
            return
        }
        e.el.set({
            tabIndex: -1
        });
        t.keyNav = new Ext.util.KeyNav({
            target: e.el,
            ignoreInputFields: true,
            down: Ext.pass(t.onNavKey, [1], t),
            right: Ext.pass(t.onNavKey, [1], t),
            left: Ext.pass(t.onNavKey, [ - 1], t),
            up: Ext.pass(t.onNavKey, [ - 1], t),
            scope: t
        })
    },
    onNavKey: function(e) {
        e = e || 1;
        var t = this,
        n = t.view,
        r = t.getSelection()[0],
        i = t.view.store.getCount(),
        s;
        if (r) {
            s = n.indexOf(n.getNode(r)) + e
        } else {
            s = 0
        }
        if (s < 0) {
            s = i - 1
        } else {
            if (s >= i) {
                s = 0
            }
        }
        t.select(s)
    },
    onSelectChange: function(e, t, n, r) {
        var i = this,
        s = i.view,
        o = t ? "select": "deselect";
        if ((n || i.fireEvent("before" + o, i, e)) !== false && r() !== false) {
            if (s) {
                if (t) {
                    s.onItemSelect(e)
                } else {
                    s.onItemDeselect(e)
                }
            }
            if (!n) {
                i.fireEvent(o, i, e)
            }
        }
    },
    onLastFocusChanged: function(e, t, n) {
        var r = this.view;
        if (r && !n && t) {
            r.focusNode(t);
            this.fireEvent("focuschange", this, e, t)
        }
    },
    destroy: function() {
        Ext.destroy(this.keyNav);
        this.callParent()
    }
});Ext.define("Ext.view.AbstractView", {
    extend: Ext.Component,
    mixins: {
        bindable: Ext.util.Bindable
    },
    inheritableStatics: {
        getRecord: function(e) {
            return this.getBoundView(e).getRecord(e)
        },
        getBoundView: function(e) {
            return Ext.getCmp(e.boundView)
        }
    },
    deferInitialRefresh: true,
    itemCls: Ext.baseCSSPrefix + "dataview-item",
    loadingText: "Loading...",
    loadMask: false,
    loadingUseMsg: true,
    selectedItemCls: Ext.baseCSSPrefix + "item-selected",
    emptyText: "",
    deferEmptyText: true,
    trackOver: false,
    blockRefresh: false,
    preserveScrollOnRefresh: false,
    ariaRole: "listbox",
    itemAriaRole: "option",
    last: false,
    triggerEvent: "itemclick",
    triggerCtEvent: "containerclick",
    refreshNeeded: true,
    addCmpEvents: Ext.emptyFn,
    initComponent: function() {
        var e = this,
        t = Ext.isDefined,
        n = e.itemTpl,
        r = {};
        if (n) {
            if (Ext.isArray(n)) {
                n = n.join("")
            } else {
                if (Ext.isObject(n)) {
                    r = Ext.apply(r, n.initialConfig);
                    n = n.html
                }
            }
            if (!e.itemSelector) {
                e.itemSelector = "." + e.itemCls
            }
            n = Ext.String.format('<tpl for="."><div class="{0}" role="{2}">{1}</div></tpl>', e.itemCls, n, e.itemAriaRole);
            e.tpl = new Ext.XTemplate(n, r)
        }
        e.callParent();
        e.tpl = e.getTpl("tpl");
        if (e.overItemCls) {
            e.trackOver = true
        }
        e.addEvents("beforerefresh", "refresh", "viewready", "itemupdate", "itemadd", "itemremove");
        e.addCmpEvents();
        e.store = Ext.data.StoreManager.lookup(e.store || "ext-empty-store");
        if (!e.dataSource) {
            e.dataSource = e.store
        }
        e.bindStore(e.dataSource, true, "dataSource");
        if (!e.all) {
            e.all = new Ext.CompositeElementLite
        }
        e.scrollState = {
            top: 0,
            left: 0
        };
        e.on({
            scroll: e.onViewScroll,
            element: "el",
            scope: e
        })
    },
    onRender: function() {
        var e = this,
        t = e.loadMask,
        n = e.getMaskStore(),
        r = {
            target: e,
            msg: e.loadingText,
            useMsg: e.loadingUseMsg,
            store: n
        };
        e.callParent(arguments);
        if (t && !n.proxy.isSynchronous) {
            if (e.loadingCls) {
                r.msgCls = e.loadingCls
            }
            if (Ext.isObject(t)) {
                r = Ext.apply(r, t)
            }
            e.loadMask = new Ext.LoadMask(r);
            e.loadMask.on({
                scope: e,
                beforeshow: e.onMaskBeforeShow,
                hide: e.onMaskHide
            })
        }
    },
    beforeLayout: function() {
        var e = this;
        e.callParent(arguments);
        if (e.refreshNeeded && !e.pendingRefresh) {
            if (e.refreshCounter) {
                e.refresh()
            } else {
                e.doFirstRefresh(e.dataSource)
            }
        }
    },
    getMaskStore: function() {
        return this.store
    },
    onMaskBeforeShow: function() {
        var e = this,
        t = e.loadingHeight;
        if (t && t > e.getHeight()) {
            e.hasLoadingHeight = true;
            e.oldMinHeight = e.minHeight;
            e.minHeight = t;
            e.updateLayout()
        }
    },
    onMaskHide: function() {
        var e = this;
        if (!e.destroying && e.hasLoadingHeight) {
            e.minHeight = e.oldMinHeight;
            e.updateLayout();
            delete e.hasLoadingHeight
        }
    },
    beforeRender: function() {
        this.callParent(arguments);
        this.getSelectionModel().beforeViewRender(this)
    },
    afterRender: function() {
        this.callParent(arguments);
        this.getSelectionModel().bindComponent(this)
    },
    getSelectionModel: function() {
        var e = this,
        t = "SINGLE";
        if (e.simpleSelect) {
            t = "SIMPLE"
        } else {
            if (e.multiSelect) {
                t = "MULTI"
            }
        }
        if (!e.selModel || !e.selModel.events) {
            e.selModel = new Ext.selection.DataViewModel(Ext.apply({
                allowDeselect: e.allowDeselect,
                mode: t
            },
            e.selModel))
        }
        if (!e.selModel.hasRelaySetup) {
            e.relayEvents(e.selModel, ["selectionchange", "beforeselect", "beforedeselect", "select", "deselect", "focuschange"]);
            e.selModel.hasRelaySetup = true
        }
        if (e.disableSelection) {
            e.selModel.locked = true
        }
        return e.selModel
    },
    refresh: function() {
        var e = this,
        t, n, r, i, s, o, u;
        if (!e.rendered || e.isDestroyed) {
            return
        }
        if (!e.hasListeners.beforerefresh || e.fireEvent("beforerefresh", e) !== false) {
            t = e.getTargetEl();
            o = e.getViewRange();
            s = t.dom;
            if (!e.preserveScrollOnRefresh) {
                n = s.parentNode;
                r = s.style.display;
                s.style.display = "none";
                i = s.nextSibling;
                n.removeChild(s)
            }
            if (e.refreshCounter) {
                u = true;
                e.clearViewEl()
            } else {
                e.fixedNodes = t.dom.childNodes.length;
                e.refreshCounter = 1
            }
            e.tpl.append(t, e.collectData(o, e.all.startIndex || 0));
            if (!e.preserveScrollOnRefresh) {
                n.insertBefore(s, i);
                s.style.display = r
            }
            if (o.length < 1) {
                if (!this.store.loading && (!e.deferEmptyText || u)) {
                    Ext.core.DomHelper.insertHtml("beforeEnd", t.dom, e.emptyText)
                }
                e.all.clear()
            } else {
                e.collectNodes(t.dom);
                e.updateIndexes(0)
            }
            if (u) {
                if (e.refreshSelmodelOnRefresh !== false) {
                    e.selModel.refresh()
                } else {
                    e.selModel.pruneIf()
                }
            }
            e.refreshNeeded = false;
            this.refreshSize();
            e.fireEvent("refresh", e);
            if (!e.viewReady) {
                e.viewReady = true;
                e.fireEvent("viewready", e)
            }
        }
    },
    collectNodes: function(e) {
        var t = this.all;
        t.fill(Ext.query(this.getItemSelector(), Ext.getDom(e)), t.startIndex || 0)
    },
    getViewRange: function() {
        return this.dataSource.getRange()
    },
    refreshSize: function() {
        var e = this.getSizeModel();
        if (e.height.shrinkWrap || e.width.shrinkWrap) {
            this.updateLayout()
        }
    },
    clearViewEl: function() {
        var e = this,
        t = e.getTargetEl();
        if (e.fixedNodes) {
            while (t.dom.childNodes[e.fixedNodes]) {
                t.dom.removeChild(t.dom.childNodes[e.fixedNodes])
            }
        } else {
            t.update("")
        }
        e.refreshCounter++
    },
    onViewScroll: Ext.emptyFn,
    onIdChanged: Ext.emptyFn,
    saveScrollState: function() {
        if (this.rendered) {
            var e = this.el.dom,
            t = this.scrollState;
            t.left = e.scrollLeft;
            t.top = e.scrollTop
        }
    },
    restoreScrollState: function() {
        if (this.rendered) {
            var e = this.el.dom,
            t = this.scrollState;
            e.scrollLeft = t.left;
            e.scrollTop = t.top
        }
    },
    prepareData: function(e, t, n) {
        var r, i, s;
        if (n) {
            r = n.getAssociatedData();
            for (i in r) {
                if (r.hasOwnProperty(i)) {
                    if (!s) {
                        e = Ext.Object.chain(e);
                        s = true
                    }
                    e[i] = r[i]
                }
            }
        }
        return e
    },
    collectData: function(e, t) {
        var n = [],
        r = 0,
        i = e.length,
        s;
        for (; r < i; r++) {
            s = e[r];
            n[r] = this.prepareData(s.data, t + r, s)
        }
        return n
    },
    bufferRender: function(e, t) {
        var n = this,
        r = n.renderBuffer || (n.renderBuffer = document.createElement("div"));
        n.tpl.overwrite(r, n.collectData(e, t));
        return Ext.DomQuery.select(n.getItemSelector(), r)
    },
    getNodeContainer: function() {
        return this.getTargetEl()
    },
    onUpdate: function(e, t) {
        var n = this,
        r, i;
        if (n.viewReady) {
            r = n.dataSource.indexOf(t);
            if (r > -1) {
                i = n.bufferRender([t], r)[0];
                if (n.getNode(t)) {
                    n.all.replaceElement(r, i, true);
                    n.updateIndexes(r, r);
                    n.selModel.onUpdate(t);
                    if (n.hasListeners.itemupdate) {
                        n.fireEvent("itemupdate", t, r, i)
                    }
                    return i
                }
            }
        }
    },
    onReplace: function(e, t, n, r) {
        var i = this,
        s, o = i.all,
        u, a, f, l;
        if (i.rendered) {
            u = i.bufferRender(r, t, true);
            a = o.item(t);
            if (a) {
                o.item(t).insertSibling(u, "before", true)
            } else {
                i.appendNodes(u)
            }
            o.insert(t, u);
            t += r.length;
            s = t + n.length - 1;
            o.removeRange(t, s, true);
            if (i.refreshSelmodelOnRefresh !== false) {
                i.selModel.refresh()
            }
            i.updateIndexes(t);
            i.refreshSize();
            if (i.hasListeners.itemremove) {
                for (f = n.length, l = s; f >= 0; --f, --l) {
                    i.fireEvent("itemremove", n[f], l)
                }
            }
            if (i.hasListeners.itemadd) {
                i.fireEvent("itemadd", r, t, u)
            }
        }
    },
    onAdd: function(e, t, n) {
        var r = this,
        i;
        if (r.rendered) {
            if (r.all.getCount() === 0) {
                r.refresh();
                i = r.all.slice()
            } else {
                i = r.doAdd(t, n);
                if (r.refreshSelmodelOnRefresh !== false) {
                    r.selModel.refresh()
                }
                r.updateIndexes(n);
                r.refreshSize()
            }
            if (r.hasListeners.itemadd) {
                r.fireEvent("itemadd", t, n, i)
            }
        }
    },
    appendNodes: function(e) {
        var t = document.createDocumentFragment(),
        n = e.length,
        r;
        for (r = 0; r < n; ++r) {
            t.appendChild(e[r])
        }
        this.getNodeContainer().appendChild(t)
    },
    doAdd: function(e, t) {
        var n = this,
        r = n.bufferRender(e, t, true),
        i = n.all,
        s = i.getCount(),
        o = i.startIndex || 0,
        u = i.endIndex || s - 1;
        if (s === 0 || t > u) {
            n.appendNodes(r)
        } else {
            if (t <= o) {
                i.item(o).insertSibling(r, "before", true)
            } else {
                i.item(t).insertSibling(r, "before", true)
            }
        }
        i.insert(t, r);
        return r
    },
    onRemove: function(e, t, n) {
        var r = this,
        i = r.hasListeners.itemremove,
        s, o, u;
        if (r.all.getCount()) {
            if (r.dataSource.getCount() === 0) {
                if (i) {
                    for (s = n.length - 1; s >= 0; --s) {
                        r.fireEvent("itemremove", t[s], n[s])
                    }
                }
                r.refresh()
            } else {
                for (s = n.length - 1; s >= 0; --s) {
                    o = t[s];
                    u = n[s];
                    if (r.all.item(u)) {
                        r.doRemove(o, u);
                        if (i) {
                            r.fireEvent("itemremove", o, u)
                        }
                    }
                }
                r.updateIndexes(n[0])
            }
            this.refreshSize()
        }
    },
    doRemove: function(e, t) {
        this.all.removeElement(t, true)
    },
    refreshNode: function(e) {
        this.onUpdate(this.dataSource, this.store.getAt(e))
    },
    updateIndexes: function(e, t) {
        var n = this.all.elements,
        r = this.getViewRange(),
        i;
        e = e || 0;
        t = t || (t === 0 ? 0 : n.length - 1);
        for (i = e; i <= t; i++) {
            n[i].viewIndex = i;
            n[i].viewRecordId = r[i].internalId;
            if (!n[i].boundView) {
                n[i].boundView = this.id
            }
        }
    },
    getStore: function() {
        return this.store
    },
    bindStore: function(e, t, n) {
        var r = this;
        r.mixins.bindable.bindStore.apply(r, arguments);
        if (!t) {
            r.getSelectionModel().bindStore(e)
        }
        if (r.componentLayoutCounter) {
            r.doFirstRefresh(e)
        }
    },
    doFirstRefresh: function(e) {
        var t = this;
        if (e && !e.loading) {
            if (t.deferInitialRefresh) {
                t.applyFirstRefresh()
            } else {
                t.refresh()
            }
        }
    },
    applyFirstRefresh: function() {
        var e = this;
        if (e.isDestroyed) {
            return
        }
        e.pendingRefresh = 0;
        if (e.up("[isCollapsingOrExpanding]")) {
            e.pendingRefresh = Ext.Function.defer(e.applyFirstRefresh, 100, e)
        } else {
            e.pendingRefresh = Ext.Function.defer(function() {
                e.pendingRefresh = 0;
                if (!e.isDestroyed) {
                    e.refresh()
                }
            },
            1)
        }
    },
    onUnbindStore: function(e) {
        this.setMaskBind(null)
    },
    onBindStore: function(e, t, n) {
        this.setMaskBind(e);
        if (!t && n === "store") {
            this.bindStore(e, false, "dataSource")
        }
    },
    setMaskBind: function(e) {
        var t = this.loadMask;
        if (t && t.bindStore) {
            t.bindStore(e)
        }
    },
    getStoreListeners: function() {
        var e = this;
        return {
            idchanged: e.onIdChanged,
            refresh: e.onDataRefresh,
            replace: e.onReplace,
            add: e.onAdd,
            bulkremove: e.onRemove,
            update: e.onUpdate,
            clear: e.refresh
        }
    },
    onDataRefresh: function() {
        this.refreshView()
    },
    refreshView: function() {
        var e = this,
        t = e.blockRefresh || !e.rendered || e.up("[collapsed],[isCollapsingOrExpanding],[hidden]");
        if (t) {
            e.refreshNeeded = true;
            e.deferInitialRefresh = false
        } else {
            e.refresh()
        }
    },
    findItemByChild: function(e) {
        return Ext.fly(e).findParent(this.getItemSelector(), this.getTargetEl())
    },
    findTargetByEvent: function(e) {
        return e.getTarget(this.getItemSelector(), this.getTargetEl())
    },
    getSelectedNodes: function() {
        var e = [],
        t = this.selModel.getSelection(),
        n = t.length,
        r = 0;
        for (; r < n; r++) {
            e.push(this.getNode(t[r]))
        }
        return e
    },
    getRecords: function(e) {
        var t = [],
        n = 0,
        r = e.length,
        i = this.dataSource.data;
        for (; n < r; n++) {
            t[t.length] = i.getByKey(e[n].viewRecordId)
        }
        return t
    },
    getRecord: function(e) {
        return this.dataSource.data.getByKey(Ext.getDom(e).viewRecordId)
    },
    isSelected: function(e) {
        var t = this.getRecord(e);
        return this.selModel.isSelected(t)
    },
    select: function(e, t, n) {
        this.selModel.select(e, t, n)
    },
    deselect: function(e, t) {
        this.selModel.deselect(e, t)
    },
    getNode: function(e) {
        if (!e && e !== 0 || !this.rendered) {
            return null
        }
        if (Ext.isString(e)) {
            return document.getElementById(e)
        }
        if (Ext.isNumber(e)) {
            return this.all.elements[e]
        }
        if (e.isModel) {
            return this.getNodeByRecord(e)
        }
        return e
    },
    getNodeByRecord: function(e) {
        var t = this.all.elements,
        n = t.length,
        r = 0;
        for (; r < n; r++) {
            if (t[r].viewRecordId === e.internalId) {
                return t[r]
            }
        }
        return null
    },
    getNodes: function(e, t) {
        var n = this.all;
        if (t === undefined) {
            t = n.getCount()
        } else {
            t++
        }
        return n.slice(e || 0, t)
    },
    indexOf: function(e) {
        e = this.getNode(e);
        if (!e && e !== 0) {
            return - 1
        }
        if (Ext.isNumber(e.viewIndex)) {
            return e.viewIndex
        }
        return this.all.indexOf(e)
    },
    onDestroy: function() {
        var e = this;
        e.all.clear();
        e.callParent();
        e.bindStore(null);
        e.selModel.destroy()
    },
    onItemSelect: function(e) {
        var t = this.getNode(e);
        if (t) {
            Ext.fly(t).addCls(this.selectedItemCls)
        }
    },
    onItemDeselect: function(e) {
        var t = this.getNode(e);
        if (t) {
            Ext.fly(t).removeCls(this.selectedItemCls)
        }
    },
    getItemSelector: function() {
        return this.itemSelector
    }
},
function() {
    Ext.deprecate("extjs", "4.0",
    function() {
        Ext.view.AbstractView.override({
            getSelectionCount: function() {
                if (Ext.global.console) {
                    Ext.global.console.warn("DataView: getSelectionCount will be removed, please interact with the Ext.selection.DataViewModel")
                }
                return this.selModel.getSelection().length
            },
            getSelectedRecords: function() {
                if (Ext.global.console) {
                    Ext.global.console.warn("DataView: getSelectedRecords will be removed, please interact with the Ext.selection.DataViewModel")
                }
                return this.selModel.getSelection()
            },
            select: function(e, t, n) {
                if (Ext.global.console) {
                    Ext.global.console.warn("DataView: select will be removed, please access select through a DataView's SelectionModel, ie: view.getSelectionModel().select()")
                }
                var r = this.getSelectionModel();
                return r.select.apply(r, arguments)
            },
            clearSelections: function() {
                if (Ext.global.console) {
                    Ext.global.console.warn("DataView: clearSelections will be removed, please access deselectAll through DataView's SelectionModel, ie: view.getSelectionModel().deselectAll()")
                }
                var e = this.getSelectionModel();
                return e.deselectAll()
            }
        })
    })
});Ext.define("Ext.view.View", {
    extend: Ext.view.AbstractView,
    alternateClassName: "Ext.DataView",
    alias: "widget.dataview",
    deferHighlight: Ext.isIE7m ? 100 : 0,
    mouseOverOutBuffer: 20,
    inputTagRe: /^textarea$|^input$/i,
    inheritableStatics: {
        EventMap: {
            mousedown: "MouseDown",
            mouseup: "MouseUp",
            click: "Click",
            dblclick: "DblClick",
            contextmenu: "ContextMenu",
            mouseover: "MouseOver",
            mouseout: "MouseOut",
            mouseenter: "MouseEnter",
            mouseleave: "MouseLeave",
            keydown: "KeyDown",
            focus: "Focus"
        }
    },
    initComponent: function() {
        var e = this;
        e.callParent();
        if (e.mouseOverOutBuffer) {
            e.handleMouseOver = Ext.Function.createBuffered(e.handleMouseOver, e.mouseOverOutBuffer, e);
            e.handleMouseOut = Ext.Function.createBuffered(e.handleMouseOut, e.mouseOverOutBuffer, e);
            e.lastMouseOverEvent = new Ext.EventObjectImpl;
            e.lastMouseOutEvent = new Ext.EventObjectImpl
        } else {
            if (e.deferHighlight) {
                e.setHighlightedItem = Ext.Function.createBuffered(e.setHighlightedItem, e.deferHighlight, e)
            }
        }
    },
    addCmpEvents: function() {
        this.addEvents("beforeitemmousedown", "beforeitemmouseup", "beforeitemmouseenter", "beforeitemmouseleave", "beforeitemclick", "beforeitemdblclick", "beforeitemcontextmenu", "beforeitemkeydown", "itemmousedown", "itemmouseup", "itemmouseenter", "itemmouseleave", "itemclick", "itemdblclick", "itemcontextmenu", "itemkeydown", "beforecontainermousedown", "beforecontainermouseup", "beforecontainermouseover", "beforecontainermouseout", "beforecontainerclick", "beforecontainerdblclick", "beforecontainercontextmenu", "beforecontainerkeydown", "containermousedown", "containermouseup", "containermouseover", "containermouseout", "containerclick", "containerdblclick", "containercontextmenu", "containerkeydown", "selectionchange", "beforeselect", "beforedeselect", "select", "deselect", "focuschange", "highlightitem", "unhighlightitem")
    },
    getFocusEl: function() {
        return this.getTargetEl()
    },
    afterRender: function() {
        var e = this;
        e.callParent();
        e.mon(e.getTargetEl(), {
            scope: e,
            freezeEvent: true,
            click: e.handleEvent,
            mousedown: e.handleEvent,
            mouseup: e.handleEvent,
            dblclick: e.handleEvent,
            contextmenu: e.handleEvent,
            keydown: e.handleEvent,
            mouseover: e.onMouseOver,
            mouseout: e.onMouseOut
        })
    },
    onMouseOver: function(e) {
        var t = this;
        if (t.mouseOverOutBuffer) {
            e = t.lastMouseOverEvent.setEvent(e.browserEvent, true)
        }
        t.handleMouseOver(e)
    },
    onMouseOut: function(e) {
        var t = this,
        n = t.getTargetSelector(),
        r = e.getTarget(n),
        i = e.getRelatedTarget(n);
        if (r === i && !(r === null && i === null)) {
            return
        }
        if (t.mouseOverOutBuffer) {
            e = t.lastMouseOutEvent.setEvent(e.browserEvent, true)
        }
        t.handleMouseOut(e, r)
    },
    getTargetSelector: function() {
        return this.dataRowSelector || this.itemSelector
    },
    handleMouseOver: function(e) {
        var t = this,
        n = t.getTargetSelector(),
        r = e.getTarget(n);
        if (!t.isDestroyed) {
            if (r) {
                if (t.mouseOverItem !== r && t.el.contains(r)) {
                    t.mouseOverItem = e.item = r;
                    e.newType = "mouseenter";
                    t.handleEvent(e)
                }
            } else {
                t.handleEvent(e)
            }
        }
    },
    handleMouseOut: function(e, t) {
        var n = this,
        r;
        if (!n.isDestroyed) {
            if (t && (r = n.self.getBoundView(t))) {
                e.item = t;
                e.newType = "mouseleave";
                r.handleEvent(e);
                r.mouseOverItem = null
            } else {
                n.handleEvent(e)
            }
        }
    },
    handleEvent: function(e) {
        var t = this,
        n = e.type === "keydown" && e.getKey();
        if (t.processUIEvent(e) !== false) {
            t.processSpecialEvent(e)
        }
        if (n === e.SPACE) {
            if (!t.inputTagRe.test(e.getTarget().tagName)) {
                e.stopEvent()
            }
        }
    },
    processItemEvent: Ext.emptyFn,
    processContainerEvent: Ext.emptyFn,
    processSpecialEvent: Ext.emptyFn,
    processUIEvent: function(e) {
        if (!Ext.getBody().isAncestor(e.target)) {
            return
        }
        var t = this,
        n = e.getTarget(t.getTargetSelector(), t.getTargetEl()),
        r = t.statics().EventMap,
        i,
        s,
        o = e.type,
        u = o,
        a;
        if (e.newType) {
            u = e.newType;
            n = e.item;
            e.newType = e.item = null
        }
        if (!n && o == "keydown") {
            a = t.getSelectionModel();
            s = a.lastFocused || a.getLastSelected();
            if (s) {
                n = t.getNode(s, true)
            }
        }
        if (n) {
            if (!s) {
                s = t.getRecord(n)
            }
            i = t.indexInStore ? t.indexInStore(s) : t.indexOf(n);
            if (!s || t.processItemEvent(s, n, i, e) === false) {
                return false
            }
            if (t["onBeforeItem" + r[u]](s, n, i, e) === false || t.fireEvent("beforeitem" + u, t, s, n, i, e) === false || t["onItem" + r[u]](s, n, i, e) === false) {
                return false
            }
            t.fireEvent("item" + u, t, s, n, i, e)
        } else {
            if (t.processContainerEvent(e) === false || t["onBeforeContainer" + r[o]](e) === false || t.fireEvent("beforecontainer" + o, t, e) === false || t["onContainer" + r[o]](e) === false) {
                return false
            }
            t.fireEvent("container" + o, t, e)
        }
        return true
    },
    onItemMouseEnter: function(e, t, n, r) {
        if (this.trackOver) {
            this.highlightItem(t)
        }
    },
    onItemMouseLeave: function(e, t, n, r) {
        if (this.trackOver) {
            this.clearHighlight()
        }
    },
    onItemMouseDown: Ext.emptyFn,
    onItemMouseUp: Ext.emptyFn,
    onItemFocus: Ext.emptyFn,
    onItemClick: Ext.emptyFn,
    onItemDblClick: Ext.emptyFn,
    onItemContextMenu: Ext.emptyFn,
    onItemKeyDown: Ext.emptyFn,
    onBeforeItemMouseDown: Ext.emptyFn,
    onBeforeItemMouseUp: Ext.emptyFn,
    onBeforeItemFocus: Ext.emptyFn,
    onBeforeItemMouseEnter: Ext.emptyFn,
    onBeforeItemMouseLeave: Ext.emptyFn,
    onBeforeItemClick: Ext.emptyFn,
    onBeforeItemDblClick: Ext.emptyFn,
    onBeforeItemContextMenu: Ext.emptyFn,
    onBeforeItemKeyDown: Ext.emptyFn,
    onContainerMouseDown: Ext.emptyFn,
    onContainerMouseUp: Ext.emptyFn,
    onContainerMouseOver: Ext.emptyFn,
    onContainerMouseOut: Ext.emptyFn,
    onContainerClick: Ext.emptyFn,
    onContainerDblClick: Ext.emptyFn,
    onContainerContextMenu: Ext.emptyFn,
    onContainerKeyDown: Ext.emptyFn,
    onBeforeContainerMouseDown: Ext.emptyFn,
    onBeforeContainerMouseUp: Ext.emptyFn,
    onBeforeContainerMouseOver: Ext.emptyFn,
    onBeforeContainerMouseOut: Ext.emptyFn,
    onBeforeContainerClick: Ext.emptyFn,
    onBeforeContainerDblClick: Ext.emptyFn,
    onBeforeContainerContextMenu: Ext.emptyFn,
    onBeforeContainerKeyDown: Ext.emptyFn,
    setHighlightedItem: function(e) {
        var t = this,
        n = t.highlightedItem,
        r = t.overItemCls,
        i = t.beforeOverItemCls,
        s;
        if (n != e) {
            if (n) {
                Ext.fly(n).removeCls(r);
                s = n.previousSibling;
                if (i && s) {
                    Ext.fly(s).removeCls(i)
                }
                t.fireEvent("unhighlightitem", t, n)
            }
            t.highlightedItem = e;
            if (e) {
                Ext.fly(e).addCls(t.overItemCls);
                s = e.previousSibling;
                if (i && s) {
                    Ext.fly(s).addCls(i)
                }
                t.fireEvent("highlightitem", t, e)
            }
        }
    },
    highlightItem: function(e) {
        this.setHighlightedItem(e)
    },
    clearHighlight: function() {
        this.setHighlightedItem(undefined)
    },
    onUpdate: function(e, t) {
        var n = this,
        r, i, s;
        if (n.viewReady) {
            r = n.getNode(t);
            i = n.callParent(arguments);
            s = n.highlightedItem;
            if (s && s === r) {
                delete n.highlightedItem;
                if (i) {
                    n.highlightItem(i)
                }
            }
        }
    },
    refresh: function() {
        this.clearHighlight();
        this.callParent(arguments)
    },
    focusNode: function(e) {
        var t = this,
        n = t.getNode(e, true),
        r = t.el,
        i = 0,
        s = 0,
        o = r.getRegion(),
        u;
        o.bottom = o.top + r.dom.clientHeight;
        o.right = o.left + r.dom.clientWidth;
        if (n) {
            u = Ext.fly(n).getRegion();
            if (u.top < o.top) {
                i = u.top - o.top
            } else {
                if (u.bottom > o.bottom) {
                    i = u.bottom - o.bottom
                }
            }
            if (u.left < o.left) {
                s = u.left - o.left
            } else {
                if (u.right > o.right) {
                    s = u.right - o.right
                }
            }
            if (s || i) {
                t.scrollBy(s, i, false)
            }
            Ext.fly(n).set({
                tabIndex: -1
            });
            n.focus()
        }
    },
    bindStore: function(e, t, n) {
        var r = this[n];
        if (r && r.isFeatureStore) {
            if (e.isFeatureStore) {
                this.bindStoreListeners(e);
                r.bindStore(r.store)
            } else {
                r.bindStore(e)
            }
        } else {
            this.callParent(arguments)
        }
    }
});Ext.define("Ext.layout.component.BoundList", {
    extend: Ext.layout.component.Auto,
    alias: "layout.boundlist",
    type: "component",
    beginLayout: function(e) {
        var t = this,
        n = t.owner,
        r = n.pagingToolbar;
        t.callParent(arguments);
        if (n.floating) {
            e.savedXY = n.getXY();
            n.setXY([0, -9999])
        }
        if (r) {
            e.toolbarContext = e.context.getCmp(r)
        }
        e.listContext = e.getEl("listEl")
    },
    beginLayoutCycle: function(e) {
        var t = this.owner;
        this.callParent(arguments);
        if (e.heightModel.auto) {
            t.el.setHeight("auto");
            t.listEl.setHeight("auto")
        }
    },
    getLayoutItems: function() {
        var e = this.owner.pagingToolbar;
        return e ? [e] : []
    },
    isValidParent: function() {
        return true
    },
    finishedLayout: function(e) {
        var t = e.savedXY;
        this.callParent(arguments);
        if (t) {
            this.owner.setXY(t)
        }
    },
    measureContentWidth: function(e) {
        return this.owner.listEl.getWidth()
    },
    measureContentHeight: function(e) {
        return this.owner.listEl.getHeight()
    },
    publishInnerHeight: function(e, t) {
        var n = e.toolbarContext,
        r = 0;
        if (n) {
            r = n.getProp("height")
        }
        if (r === undefined) {
            this.done = false
        } else {
            e.listContext.setHeight(t - e.getFrameInfo().height - r)
        }
    },
    calculateOwnerHeightFromContentHeight: function(e) {
        var t = this.callParent(arguments),
        n = e.toolbarContext;
        if (n) {
            t += n.getProp("height")
        }
        return t
    }
});Ext.define("Ext.toolbar.TextItem", {
    extend: Ext.toolbar.Item,
    alias: "widget.tbtext",
    alternateClassName: "Ext.Toolbar.TextItem",
    text: "",
    renderTpl: "{text}",
    baseCls: Ext.baseCSSPrefix + "toolbar-text",
    ariaRole: null,
    beforeRender: function() {
        var e = this;
        e.callParent();
        Ext.apply(e.renderData, {
            text: e.text
        })
    },
    setText: function(e) {
        var t = this;
        t.text = e;
        if (t.rendered) {
            t.el.update(e);
            t.updateLayout()
        }
    }
});Ext.define("Ext.form.field.Spinner", {
    extend: Ext.form.field.Trigger,
    alias: "widget.spinnerfield",
    alternateClassName: "Ext.form.Spinner",
    trigger1Cls: Ext.baseCSSPrefix + "form-spinner-up",
    trigger2Cls: Ext.baseCSSPrefix + "form-spinner-down",
    spinUpEnabled: true,
    spinDownEnabled: true,
    keyNavEnabled: true,
    mouseWheelEnabled: true,
    repeatTriggerClick: true,
    onSpinUp: Ext.emptyFn,
    onSpinDown: Ext.emptyFn,
    ariaRole: "spinbutton",
    triggerTpl: '<td style="{triggerStyle}" class="{triggerCls}" role="presentation"><div class="' + Ext.baseCSSPrefix + "trigger-index-0 " + Ext.baseCSSPrefix + "form-trigger " + Ext.baseCSSPrefix + 'form-spinner-up {spinnerUpCls} {childElCls}" role="presentation"></div><div class="' + Ext.baseCSSPrefix + "trigger-index-1 " + Ext.baseCSSPrefix + "form-trigger " + Ext.baseCSSPrefix + 'form-spinner-down {spinnerDownCls} {childElCls}" role="presentation"></div></td></tr>',
    initComponent: function() {
        this.callParent();
        this.addEvents("spin", "spinup", "spindown")
    },
    onRender: function() {
        var e = this,
        t;
        e.callParent(arguments);
        t = e.triggerEl;
        e.spinUpEl = t.item(0);
        e.spinDownEl = t.item(1);
        e.triggerCell = e.spinUpEl.parent();
        if (e.keyNavEnabled) {
            e.spinnerKeyNav = new Ext.util.KeyNav(e.inputEl, {
                scope: e,
                up: e.spinUp,
                down: e.spinDown
            })
        }
        if (e.mouseWheelEnabled) {
            e.mon(e.bodyEl, "mousewheel", e.onMouseWheel, e)
        }
    },
    getSubTplMarkup: function(e) {
        var t = this,
        n = e.childElCls,
        r = Ext.form.field.Base.prototype.getSubTplMarkup.apply(t, arguments);
        return '<table id="' + t.id + '-triggerWrap" class="' + Ext.baseCSSPrefix + "form-trigger-wrap" + n + '" cellpadding="0" cellspacing="0" role="presentation"><tbody role="presentation"><tr role="presentation"><td id="' + t.id + '-inputCell" class="' + Ext.baseCSSPrefix + "form-trigger-input-cell" + n + '" role="presentation">' + r + "</td>" + t.getTriggerMarkup() + "</tbody></table>"
    },
    getTriggerMarkup: function() {
        return this.getTpl("triggerTpl").apply(this.getTriggerData())
    },
    getTriggerData: function() {
        var e = this,
        t = e.readOnly || e.hideTrigger;
        return {
            triggerCls: Ext.baseCSSPrefix + "trigger-cell",
            triggerStyle: t ? "display:none": "",
            spinnerUpCls: !e.spinUpEnabled ? e.trigger1Cls + "-disabled": "",
            spinnerDownCls: !e.spinDownEnabled ? e.trigger2Cls + "-disabled": ""
        }
    },
    getTriggerWidth: function() {
        var e = this,
        t = 0;
        if (e.triggerWrap && !e.hideTrigger && !e.readOnly) {
            t = e.triggerWidth
        }
        return t
    },
    onTrigger1Click: function() {
        this.spinUp()
    },
    onTrigger2Click: function() {
        this.spinDown()
    },
    onTriggerWrapMouseup: function() {
        this.inputEl.focus()
    },
    spinUp: function() {
        var e = this;
        if (e.spinUpEnabled && !e.disabled) {
            e.fireEvent("spin", e, "up");
            e.fireEvent("spinup", e);
            e.onSpinUp()
        }
    },
    spinDown: function() {
        var e = this;
        if (e.spinDownEnabled && !e.disabled) {
            e.fireEvent("spin", e, "down");
            e.fireEvent("spindown", e);
            e.onSpinDown()
        }
    },
    setSpinUpEnabled: function(e) {
        var t = this,
        n = t.spinUpEnabled;
        t.spinUpEnabled = e;
        if (n !== e && t.rendered) {
            t.spinUpEl[e ? "removeCls": "addCls"](t.trigger1Cls + "-disabled")
        }
    },
    setSpinDownEnabled: function(e) {
        var t = this,
        n = t.spinDownEnabled;
        t.spinDownEnabled = e;
        if (n !== e && t.rendered) {
            t.spinDownEl[e ? "removeCls": "addCls"](t.trigger2Cls + "-disabled")
        }
    },
    onMouseWheel: function(e) {
        var t = this,
        n;
        if (t.hasFocus) {
            n = e.getWheelDelta();
            if (n > 0) {
                t.spinUp()
            } else {
                if (n < 0) {
                    t.spinDown()
                }
            }
            e.stopEvent()
        }
    },
    onDestroy: function() {
        Ext.destroyMembers(this, "spinnerKeyNav", "spinUpEl", "spinDownEl");
        this.callParent()
    }
});Ext.define("Ext.form.field.Number", {
    extend: Ext.form.field.Spinner,
    alias: "widget.numberfield",
    alternateClassName: ["Ext.form.NumberField", "Ext.form.Number"],
    allowExponential: true,
    allowDecimals: true,
    decimalSeparator: null,
    submitLocaleSeparator: true,
    decimalPrecision: 2,
    minValue: Number.NEGATIVE_INFINITY,
    maxValue: Number.MAX_VALUE,
    step: 1,
    minText: "The minimum value for this field is {0}",
    maxText: "The maximum value for this field is {0}",
    nanText: "{0} is not a valid number",
    negativeText: "The value cannot be negative",
    baseChars: "0123456789",
    autoStripChars: false,
    initComponent: function() {
        var e = this;
        if (e.decimalSeparator === null) {
            e.decimalSeparator = Ext.util.Format.decimalSeparator
        }
        e.callParent();
        e.setMinValue(e.minValue);
        e.setMaxValue(e.maxValue)
    },
    getErrors: function(e) {
        var t = this,
        n = t.callParent(arguments),
        r = Ext.String.format,
        i;
        e = Ext.isDefined(e) ? e: this.processRawValue(this.getRawValue());
        if (e.length < 1) {
            return n
        }
        e = String(e).replace(t.decimalSeparator, ".");
        if (isNaN(e)) {
            n.push(r(t.nanText, e))
        }
        i = t.parseValue(e);
        if (t.minValue === 0 && i < 0) {
            n.push(this.negativeText)
        } else {
            if (i < t.minValue) {
                n.push(r(t.minText, t.minValue))
            }
        }
        if (i > t.maxValue) {
            n.push(r(t.maxText, t.maxValue))
        }
        return n
    },
    rawToValue: function(e) {
        var t = this.fixPrecision(this.parseValue(e));
        if (t === null) {
            t = e || null
        }
        return t
    },
    valueToRaw: function(e) {
        var t = this,
        n = t.decimalSeparator;
        e = t.parseValue(e);
        e = t.fixPrecision(e);
        e = Ext.isNumber(e) ? e: parseFloat(String(e).replace(n, "."));
        e = isNaN(e) ? "": String(e).replace(".", n);
        return e
    },
    getSubmitValue: function() {
        var e = this,
        t = e.callParent();
        if (!e.submitLocaleSeparator) {
            t = t.replace(e.decimalSeparator, ".")
        }
        return t
    },
    onChange: function() {
        this.toggleSpinners();
        this.callParent(arguments)
    },
    toggleSpinners: function() {
        var e = this,
        t = e.getValue(),
        n = t === null,
        r;
        if (e.spinUpEnabled || e.spinUpDisabledByToggle) {
            r = n || t < e.maxValue;
            e.setSpinUpEnabled(r, true)
        }
        if (e.spinDownEnabled || e.spinDownDisabledByToggle) {
            r = n || t > e.minValue;
            e.setSpinDownEnabled(r, true)
        }
    },
    setMinValue: function(e) {
        var t = this,
        n;
        t.minValue = Ext.Number.from(e, Number.NEGATIVE_INFINITY);
        t.toggleSpinners();
        if (t.disableKeyFilter !== true) {
            n = t.baseChars + "";
            if (t.allowExponential) {
                n += t.decimalSeparator + "e+-"
            } else {
                if (t.allowDecimals) {
                    n += t.decimalSeparator
                }
                if (t.minValue < 0) {
                    n += "-"
                }
            }
            n = Ext.String.escapeRegex(n);
            t.maskRe = new RegExp("[" + n + "]");
            if (t.autoStripChars) {
                t.stripCharsRe = new RegExp("[^" + n + "]", "gi")
            }
        }
    },
    setMaxValue: function(e) {
        this.maxValue = Ext.Number.from(e, Number.MAX_VALUE);
        this.toggleSpinners()
    },
    parseValue: function(e) {
        e = parseFloat(String(e).replace(this.decimalSeparator, "."));
        return isNaN(e) ? null: e
    },
    fixPrecision: function(e) {
        var t = this,
        n = isNaN(e),
        r = t.decimalPrecision;
        if (n || !e) {
            return n ? "": e
        } else {
            if (!t.allowDecimals || r <= 0) {
                r = 0
            }
        }
        return parseFloat(Ext.Number.toFixed(parseFloat(e), r))
    },
    beforeBlur: function() {
        var e = this,
        t = e.rawToValue(e.getRawValue());
        if (!Ext.isEmpty(t)) {
            e.setValue(t)
        }
    },
    setSpinUpEnabled: function(e, t) {
        this.callParent(arguments);
        if (!t) {
            delete this.spinUpDisabledByToggle
        } else {
            this.spinUpDisabledByToggle = !e
        }
    },
    onSpinUp: function() {
        var e = this;
        if (!e.readOnly) {
            e.setSpinValue(Ext.Number.constrain(e.getValue() + e.step, e.minValue, e.maxValue))
        }
    },
    setSpinDownEnabled: function(e, t) {
        this.callParent(arguments);
        if (!t) {
            delete this.spinDownDisabledByToggle
        } else {
            this.spinDownDisabledByToggle = !e
        }
    },
    onSpinDown: function() {
        var e = this;
        if (!e.readOnly) {
            e.setSpinValue(Ext.Number.constrain(e.getValue() - e.step, e.minValue, e.maxValue))
        }
    },
    setSpinValue: function(e) {
        var t = this,
        n;
        if (t.enforceMaxLength) {
            if (t.fixPrecision(e).toString().length > t.maxLength) {
                return
            }
        }
        t.setValue(e)
    }
});Ext.define("Ext.toolbar.Paging", {
    extend: Ext.toolbar.Toolbar,
    alias: "widget.pagingtoolbar",
    alternateClassName: "Ext.PagingToolbar",
    mixins: {
        bindable: Ext.util.Bindable
    },
    displayInfo: false,
    prependButtons: false,
    displayMsg: "Displaying {0} - {1} of {2}",
    emptyMsg: "No data to display",
    beforePageText: "Page",
    afterPageText: "of {0}",
    firstText: "First Page",
    prevText: "Previous Page",
    nextText: "Next Page",
    lastText: "Last Page",
    refreshText: "Refresh",
    inputItemWidth: 35,
    getPagingItems: function() {
        var e = this,
        t = {
            scope: e,
            blur: e.onPagingBlur
        };
        t[Ext.EventManager.getKeyEvent()] = e.onPagingKeyDown;
        return [{
            itemId: "first",
            tooltip: e.firstText,
            overflowText: e.firstText,
            iconCls: Ext.baseCSSPrefix + "tbar-page-first",
            disabled: true,
            handler: e.moveFirst,
            scope: e
        },
        {
            itemId: "prev",
            tooltip: e.prevText,
            overflowText: e.prevText,
            iconCls: Ext.baseCSSPrefix + "tbar-page-prev",
            disabled: true,
            handler: e.movePrevious,
            scope: e
        },
        "-", e.beforePageText, {
            xtype: "numberfield",
            itemId: "inputItem",
            name: "inputItem",
            cls: Ext.baseCSSPrefix + "tbar-page-number",
            allowDecimals: false,
            minValue: 1,
            hideTrigger: true,
            enableKeyEvents: true,
            keyNavEnabled: false,
            selectOnFocus: true,
            submitValue: false,
            isFormField: false,
            width: e.inputItemWidth,
            margins: "-1 2 3 2",
            listeners: t
        },
        {
            xtype: "tbtext",
            itemId: "afterTextItem",
            text: Ext.String.format(e.afterPageText, 1)
        },
        "-", {
            itemId: "next",
            tooltip: e.nextText,
            overflowText: e.nextText,
            iconCls: Ext.baseCSSPrefix + "tbar-page-next",
            disabled: true,
            handler: e.moveNext,
            scope: e
        },
        {
            itemId: "last",
            tooltip: e.lastText,
            overflowText: e.lastText,
            iconCls: Ext.baseCSSPrefix + "tbar-page-last",
            disabled: true,
            handler: e.moveLast,
            scope: e
        },
        "-", {
            itemId: "refresh",
            tooltip: e.refreshText,
            overflowText: e.refreshText,
            iconCls: Ext.baseCSSPrefix + "tbar-loading",
            disabled: e.store.isLoading(),
            handler: e.doRefresh,
            scope: e
        },
        {
            iconCls: "excel_icon",
            tooltip: Str.expCurToExcel,
            xtype: "splitbutton",
            handler: function() {
                var t = e.findParentByType("grid");
                Wb.getExcel(t, false)
            },
            menu: {
                scope: e,
                items: [{
                    iconCls: "excel_icon",
                    text: Str.expAllToExcel,
                    handler: function() {
                        Wb.getExcel(e, true)
                    }
                }]
            }
        },
        {
            itemId: "paging",
            tooltip: Str.recordsPerPage,
            overflowText: Str.recordsPerPage,
            iconCls: "page_icon",
            disabled: e.store.isLoading(),
            menu: {
                scope: e,
                listeners: {
                    show: function(t) {
                        var n = e.store;
                        if (n) {
                            var r, i = [10, 25, 50, 100, 200, 500, 1e3];
                            r = Wb.indexOf(i, n.pageSize);
                            if (r == -1) {
                                t.items.each(function(e) {
                                    if (e.checked) {
                                        e.setChecked(false)
                                    }
                                })
                            } else {
                                t.items.items[r].setChecked(true)
                            }
                        }
                    },
                    click: function(t, n) {
                        var r = e.store;
                        if (r) {
                            r.pageSize = parseInt(n.text, 10);
                            Wb.reload(r, {
                                params: {
                                    limit: r.pageSize
                                }
                            })
                        }
                    }
                },
                items: [{
                    text: "10",
                    group: "page",
                    checked: false
                },
                {
                    text: "25",
                    group: "page",
                    checked: false
                },
                {
                    text: "50",
                    group: "page",
                    checked: false
                },
                {
                    text: "100",
                    group: "page",
                    checked: false
                },
                {
                    text: "200",
                    group: "page",
                    checked: false
                },
                {
                    text: "500",
                    group: "page",
                    checked: false
                },
                {
                    text: "1000",
                    group: "page",
                    checked: false
                }]
            }
        }]
    },
    initComponent: function() {
        var e = this,
        t = e.items || e.buttons || [],
        n;
        e.bindStore(e.store || "ext-empty-store", true);
        n = e.getPagingItems();
        if (e.prependButtons) {
            e.items = t.concat(n)
        } else {
            e.items = n.concat(t)
        }
        delete e.buttons;
        if (e.displayInfo) {
            e.items.push("->");
            e.items.push({
                xtype: "tbtext",
                itemId: "displayItem"
            })
        }
        e.callParent();
        e.addEvents("change", "beforechange")
    },
    beforeRender: function() {
        var e = this;
        e.callParent(arguments);
        if (!e.store.isLoading()) {
            e.calledFromRender = true;
            e.onLoad();
            delete e.calledFromRender
        }
    },
    updateInfo: function() {
        var e = this,
        t = e.child("#displayItem"),
        n = e.store,
        r = e.getPageData(),
        i,
        s;
        if (t) {
            i = n.getCount();
            if (i === 0) {
                s = e.emptyMsg
            } else {
                s = Ext.String.format(e.displayMsg, r.fromRecord, r.toRecord, r.total)
            }
            t.setText(s)
        }
    },
    onAddRemove: function() {
        var e = this,
        t = e.store.getCount();
        e.store.totalCount = e.store.totalCount + t - e.lastLoadCount;
        e.lastLoadCount = t;
        this.updateInfo()
    },
    onLoad: function() {
        var e = this,
        t, n, r, i, s, o, u;
        s = e.store.getCount();
        e.lastLoadCount = s;
        o = s === 0 && e.store.getTotalCount() === 0;
        if (!o) {
            t = e.getPageData();
            n = t.currentPage;
            r = t.pageCount;
            if (n > r) {
                e.store.loadPage(r);
                return
            }
            i = Ext.String.format(e.afterPageText, isNaN(r) ? 1 : r)
        } else {
            n = 0;
            r = 0;
            i = Ext.String.format(e.afterPageText, 0)
        }
        Ext.suspendLayouts();
        u = e.child("#afterTextItem");
        if (u) {
            u.setText(i)
        }
        u = e.getInputItem();
        if (u) {
            u.setDisabled(o).setValue(n)
        }
        e.setChildDisabled("#first", n === 1 || o);
        e.setChildDisabled("#prev", n === 1 || o);
        e.setChildDisabled("#next", n === r || o);
        e.setChildDisabled("#last", n === r || o);
        e.setChildDisabled("#refresh", false);
        e.updateInfo();
        Ext.resumeLayouts(true);
        if (!e.calledFromRender) {
            e.fireEvent("change", e, t)
        }
    },
    setChildDisabled: function(e, t) {
        var n = this.child(e);
        if (n) {
            n.setDisabled(t)
        }
    },
    getPageData: function() {
        var e = this.store,
        t = e.getTotalCount(),
        n = (e.currentPage - 1) * e.pageSize + 1;
        return {
            total: t,
            currentPage: e.currentPage,
            pageCount: Math.ceil(t / e.pageSize),
            fromRecord: n,
            toRecord: n + e.getCount() - 1
        }
    },
    onLoadError: function() {
        this.setChildDisabled("#refresh", false)
    },
    getInputItem: function() {
        return this.child("#inputItem")
    },
    readPageFromInput: function(e) {
        var t = this.getInputItem(),
        n = false,
        r;
        if (t) {
            r = t.getValue();
            n = parseInt(r, 10);
            if (!r || isNaN(n)) {
                t.setValue(e.currentPage);
                return false
            }
        }
        return n
    },
    onPagingBlur: function(e) {
        var t = this.getInputItem(),
        n;
        if (t) {
            n = this.getPageData().currentPage;
            t.setValue(n)
        }
    },
    onPagingKeyDown: function(e, t) {
        this.processKeyEvent(e, t)
    },
    processKeyEvent: function(e, t) {
        var n = this,
        r = t.getKey(),
        i = n.getPageData(),
        s = t.shiftKey ? 10 : 1,
        o;
        if (r == t.RETURN) {
            t.stopEvent();
            o = n.readPageFromInput(i);
            if (o !== false) {
                o = Math.min(Math.max(1, o), i.pageCount);
                if (o !== i.currentPage && n.fireEvent("beforechange", n, o) !== false) {
                    n.store.loadPage(o)
                }
            }
        } else {
            if (r == t.HOME || r == t.END) {
                t.stopEvent();
                o = r == t.HOME ? 1 : i.pageCount;
                e.setValue(o)
            } else {
                if (r == t.UP || r == t.PAGE_UP || r == t.DOWN || r == t.PAGE_DOWN) {
                    t.stopEvent();
                    o = n.readPageFromInput(i);
                    if (o) {
                        if (r == t.DOWN || r == t.PAGE_DOWN) {
                            s *= -1
                        }
                        o += s;
                        if (o >= 1 && o <= i.pageCount) {
                            e.setValue(o)
                        }
                    }
                }
            }
        }
    },
    beforeLoad: function() {
        this.setChildDisabled("#refresh", true)
    },
    moveFirst: function() {
        if (this.fireEvent("beforechange", this, 1) !== false) {
            this.store.loadPage(1);
            return true
        }
        return false
    },
    movePrevious: function() {
        var e = this,
        t = e.store,
        n = t.currentPage - 1;
        if (n > 0) {
            if (e.fireEvent("beforechange", e, n) !== false) {
                t.previousPage();
                return true
            }
        }
        return false
    },
    moveNext: function() {
        var e = this,
        t = e.store,
        n = e.getPageData().pageCount,
        r = t.currentPage + 1;
        if (e.fireEvent("beforechange", e, r) !== false) {
            t.nextPage();
            return true
        }
        return false
    },
    moveLast: function() {
        var e = this,
        t = e.getPageData().pageCount;
        if (e.fireEvent("beforechange", e, t) !== false) {
            e.store.loadPage(t);
            return true
        }
        return false
    },
    doRefresh: function() {
        var e = this,
        t = e.store,
        n = t.currentPage;
        if (e.fireEvent("beforechange", e, n) !== false) {
            t.loadPage(n);
            return true
        }
        return false
    },
    getStoreListeners: function() {
        return {
            beforeload: this.beforeLoad,
            load: this.onLoad,
            add: this.onAddRemove,
            bulkremove: this.onAddRemove,
            exception: this.onLoadError
        }
    },
    unbind: function(e) {
        this.bindStore(null)
    },
    bind: function(e) {
        this.bindStore(e)
    },
    onDestroy: function() {
        this.unbind();
        this.callParent()
    }
});Ext.define("Ext.view.BoundList", {
    extend: Ext.view.View,
    alias: "widget.boundlist",
    alternateClassName: "Ext.BoundList",
    mixins: {
        queryable: Ext.Queryable
    },
    pageSize: 0,
    baseCls: Ext.baseCSSPrefix + "boundlist",
    itemCls: Ext.baseCSSPrefix + "boundlist-item",
    listItemCls: "",
    shadow: false,
    trackOver: true,
    refreshed: 0,
    preserveScrollOnRefresh: true,
    deferInitialRefresh: false,
    componentLayout: "boundlist",
    childEls: ["listEl"],
    renderTpl: ['<div id="{id}-listEl" role="presentation" class="{baseCls}-list-ct ', Ext.dom.Element.unselectableCls, '" style="overflow:auto"></div>', "{%", "var me=values.$comp, pagingToolbar=me.pagingToolbar;", "if (pagingToolbar) {", "pagingToolbar.ownerLayout = me.componentLayout;", "Ext.DomHelper.generateMarkup(pagingToolbar.getRenderTree(), out);", "}", "%}", {
        disableFormats: true
    }],
    initComponent: function() {
        var e = this,
        t = e.baseCls,
        n = e.itemCls;
        e.selectedItemCls = t + "-selected";
        if (e.trackOver) {
            e.overItemCls = t + "-item-over"
        }
        e.itemSelector = "." + n;
        if (e.floating) {
            e.addCls(t + "-floating")
        }
        if (!e.tpl) {
            e.tpl = new Ext.XTemplate('<ul class="' + Ext.plainListCls + '"><tpl for=".">', '<li role="option" unselectable="on" class="' + n + '">' + e.getInnerTpl(e.displayField) + "</li>", "</tpl></ul>")
        } else {
            if (!e.tpl.isTemplate) {
                e.tpl = new Ext.XTemplate(e.tpl)
            }
        }
        if (e.pageSize) {
            e.pagingToolbar = e.createPagingToolbar()
        }
        e.callParent()
    },
    getRefOwner: function() {
        return this.pickerField || this.callParent()
    },
    getRefItems: function() {
        var e = this,
        t = [];
        if (e.pagingToolbar) {
            t.push(e.pagingToolbar)
        }
        if (e.loadMask) {
            t.push(e.loadMask)
        }
        return t
    },
    createPagingToolbar: function() {
        return Ext.widget("pagingtoolbar", {
            id: this.id + "-paging-toolbar",
            pageSize: this.pageSize,
            store: this.dataSource,
            border: false,
            ownerCt: this,
            ownerLayout: this.getComponentLayout()
        })
    },
    finishRenderChildren: function() {
        var e = this.pagingToolbar;
        this.callParent(arguments);
        if (e) {
            e.finishRender()
        }
    },
    refresh: function() {
        var e = this,
        t = e.tpl,
        n = e.pagingToolbar,
        r = e.rendered;
        t.field = e.pickerField;
        t.store = e.store;
        e.callParent();
        t.field = t.store = null;
        if (r && n && n.rendered && !e.preserveScrollOnRefresh) {
            e.el.appendChild(n.el)
        }
        if (r && Ext.isIE6 && Ext.isStrict) {
            e.listEl.repaint()
        }
    },
    bindStore: function(e, t) {
        var n = this.pagingToolbar;
        this.callParent(arguments);
        if (n) {
            n.bindStore(e, t)
        }
    },
    getTargetEl: function() {
        return this.listEl || this.el
    },
    getNodeContainer: function() {
        return Ext.get(this.listEl.dom.firstChild)
    },
    getInnerTpl: function(e) {
        return "{" + e + "}"
    },
    onDestroy: function() {
        Ext.destroyMembers(this, "pagingToolbar", "listEl");
        this.callParent()
    }
});Ext.define("Ext.view.BoundListKeyNav", {
    extend: Ext.util.KeyNav,
    constructor: function(e, t) {
        var n = this;
        n.boundList = t.boundList;
        n.callParent([e, Ext.apply({},
        t, n.defaultHandlers)])
    },
    defaultHandlers: {
        up: function() {
            var e = this,
            t = e.boundList,
            n = t.all,
            r = t.highlightedItem,
            i = r ? t.indexOf(r) : -1,
            s = i > 0 ? i - 1 : n.getCount() - 1;
            e.highlightAt(s)
        },
        down: function() {
            var e = this,
            t = e.boundList,
            n = t.all,
            r = t.highlightedItem,
            i = r ? t.indexOf(r) : -1,
            s = i < n.getCount() - 1 ? i + 1 : 0;
            e.highlightAt(s)
        },
        pageup: function() {},
        pagedown: function() {},
        home: function() {
            this.highlightAt(0)
        },
        end: function() {
            var e = this;
            e.highlightAt(e.boundList.all.getCount() - 1)
        },
        enter: function(e) {
            this.selectHighlighted(e)
        }
    },
    highlightAt: function(e) {
        var t = this.boundList,
        n = t.all.item(e);
        if (n) {
            n = n.dom;
            t.highlightItem(n);
            t.getTargetEl().scrollChildIntoView(n, false)
        }
    },
    selectHighlighted: function(e) {
        var t = this.boundList,
        n = t.getSelectionModel(),
        r,
        i;
        r = t.highlightedItem;
        if (r) {
            i = t.getRecord(r);
            if (e.getKey() === e.ENTER || !n.isSelected(i)) {
                n.selectWithEvent(i, e)
            }
        }
    }
});Ext.define("Ext.layout.component.field.ComboBox", {
    extend: Ext.layout.component.field.Trigger,
    alias: "layout.combobox",
    type: "combobox",
    startingWidth: null,
    getTextWidth: function() {
        var e = this,
        t = e.owner,
        n = t.store,
        r = t.displayField,
        i = n.data.length,
        s = "",
        o = 0,
        u = 0,
        a, f, l;
        for (; o < i; o++) {
            f = n.getAt(o).data[r];
            a = f.length;
            if (a > u) {
                u = a;
                s = f
            }
        }
        l = Math.max(e.callParent(arguments), t.inputEl.getTextWidth(s + t.growAppend));
        if (!e.startingWidth || t.removingRecords) {
            e.startingWidth = l;
            if (l < t.growMin) {
                t.defaultListConfig.minWidth = t.growMin
            }
            t.removingRecords = false
        }
        return l < e.startingWidth ? e.startingWidth: l
    }
});Ext.define("Ext.form.field.ComboBox", {
    extend: Ext.form.field.Picker,
    alternateClassName: "Ext.form.ComboBox",
    alias: ["widget.combobox", "widget.combo"],
    mixins: {
        bindable: Ext.util.Bindable
    },
    componentLayout: "combobox",
    triggerCls: Ext.baseCSSPrefix + "form-arrow-trigger",
    hiddenName: "",
    hiddenDataCls: Ext.baseCSSPrefix + "hide-display " + Ext.baseCSSPrefix + "form-data-hidden",
    ariaRole: "combobox",
    fieldSubTpl: ['<div class="{hiddenDataCls}" role="presentation"></div>', '<input id="{id}" type="{type}" role="{role}" {inputAttrTpl} class="{fieldCls} {typeCls} {editableCls}" autocomplete="off"', '<tpl if="value"> value="{[Ext.util.Format.htmlEncode(values.value)]}"</tpl>', '<tpl if="name"> name="{name}"</tpl>', '<tpl if="placeholder"> placeholder="{placeholder}"</tpl>', '<tpl if="size"> size="{size}"</tpl>', '<tpl if="maxLength !== undefined"> maxlength="{maxLength}"</tpl>', '<tpl if="readOnly"> readonly="readonly"</tpl>', '<tpl if="disabled"> disabled="disabled"</tpl>', '<tpl if="tabIdx"> tabIndex="{tabIdx}"</tpl>', '<tpl if="fieldStyle"> style="{fieldStyle}"</tpl>', "/>", {
        compiled: true,
        disableFormats: true
    }],
    getSubTplData: function() {
        var e = this;
        Ext.applyIf(e.subTplData, {
            hiddenDataCls: e.hiddenDataCls
        });
        return e.callParent(arguments)
    },
    afterRender: function() {
        var e = this;
        e.callParent(arguments);
        e.setHiddenValue(e.value)
    },
    multiSelect: false,
    delimiter: ", ",
    displayField: "text",
    triggerAction: "all",
    allQuery: "",
    queryParam: "query",
    queryMode: "remote",
    queryCaching: false,
    pageSize: 0,
    anyMatch: false,
    caseSensitive: false,
    autoSelect: true,
    typeAhead: false,
    typeAheadDelay: 250,
    selectOnTab: true,
    forceSelection: false,
    growToLongestValue: true,
    clearFilterOnBlur: true,
    defaultListConfig: {
        loadingHeight: 70,
        minWidth: 70,
        maxHeight: 300,
        shadow: "sides"
    },
    transformInPlace: true,
    ignoreSelection: 0,
    removingRecords: null,
    resizeComboToGrow: function() {
        var e = this;
        return e.grow && e.growToLongestValue
    },
    initComponent: function() {
        var e = this,
        t = Ext.isDefined,
        n = e.store,
        r = e.transform,
        i = e.displayTpl,
        s, o;
        if (e.pageSize) {
            n.pageSize = e.pageSize
        }
        Ext.applyIf(e.renderSelectors, {
            hiddenDataEl: "." + e.hiddenDataCls.split(" ").join(".")
        });
        e.addEvents("beforequery", "select", "beforeselect", "beforedeselect");
        if (r) {
            s = Ext.getDom(r);
            if (s) {
                if (!e.store) {
                    n = Ext.Array.map(Ext.Array.from(s.options),
                    function(e) {
                        return [e.value, e.text]
                    })
                }
                if (!e.name) {
                    e.name = s.name
                }
                if (! ("value" in e)) {
                    e.value = s.value
                }
            }
        }
        e.bindStore(n || "ext-empty-store", true, true);
        n = e.store;
        if (n.autoCreated) {
            e.queryMode = "local";
            e.valueField = e.displayField = "field1";
            if (!n.expanded) {
                e.displayField = "field2"
            }
        }
        if (!t(e.valueField)) {
            e.valueField = e.displayField
        }
        o = e.queryMode === "local";
        if (!t(e.queryDelay)) {
            e.queryDelay = o ? 10 : 160
        }
        if (!t(e.minChars)) {
            e.minChars = 1
        }
        if (!i) {
            e.displayTpl = new Ext.XTemplate('<tpl for=".">{[typeof values === "string" ? values : values["' + e.displayField + '"]]}<tpl if="xindex < xcount">' + e.delimiter + "</tpl></tpl>")
        } else {
            if (!i.isTemplate) {
                e.displayTpl = new Ext.XTemplate(i)
            }
        }
        e.callParent();
        e.doQueryTask = new Ext.util.DelayedTask(e.doRawQuery, e);
        if (e.store.getCount() > 0) {
            e.setValue(e.value)
        }
        if (s) {
            if (e.transformInPlace) {
                e.render(s.parentNode, s);
                delete e.renderTo
            }
            Ext.removeNode(s)
        }
        if (e.enterKeyTriggerClick) {
            e.mon(e, "specialKey",
            function(e, t) {
                if (t.getKey() == t.ENTER) {
                    if (! (e.isExpanded && e.picker && e.picker.highlightedItem)) {
                        e.onTriggerClick();
                        t.stopEvent()
                    }
                }
            })
        }
    },
    getStore: function() {
        return this.store
    },
    beforeBlur: function() {
        var e = this,
        t = e.queryFilter;
        e.doQueryTask.cancel();
        e.assertValue();
        if (t && !t.disabled && e.queryMode === "local" && e.clearFilterOnBlur) {
            t.disabled = true;
            e.store.filter()
        }
    },
    onFocus: function() {
        var e = this,
        t = e.queryFilter;
        e.callParent(arguments);
        if (!e.duringTriggerClick && e.triggerAction !== "all" && t && t.disabled && e.queryMode === "local" && e.clearFilterOnBlur) {
            delete e.lastQuery;
            e.doRawQuery()
        }
    },
    assertValue: function() {
        var e = this,
        t = e.getRawValue(),
        n,
        r;
        if (e.forceSelection) {
            if (e.allowBlank && Ext.isEmpty(t)) {
                e.setValue(t);
                e.collapse();
                return
            }
            if (e.multiSelect) {
                if (t !== e.getDisplayValue()) {
                    e.setValue(e.lastSelection)
                }
            } else {
                n = e.findRecordByDisplay(t);
                if (n) {
                    r = e.value;
                    if (!e.findRecordByValue(r)) {
                        e.select(n, true)
                    }
                } else {
                    e.setValue(e.lastSelection)
                }
            }
        }
        e.collapse()
    },
    onTypeAhead: function() {
        var e = this,
        t = e.displayField,
        n = e.store.findRecord(t, e.getRawValue()),
        r = e.getPicker(),
        i,
        s,
        o;
        if (n) {
            i = n.get(t);
            s = i.length;
            o = e.getRawValue().length;
            r.highlightItem(r.getNode(n));
            if (o !== 0 && o !== s) {
                e.setRawValue(i);
                e.selectText(o, i.length)
            }
        }
    },
    resetToDefault: Ext.emptyFn,
    beforeReset: function() {
        var e = this.queryFilter;
        this.callParent();
        if (e && !e.disabled) {
            e.disabled = true;
            this.store.filter()
        }
    },
    onUnbindStore: function(e) {
        var t = this,
        n = t.picker,
        r = t.queryFilter;
        if (r) {
            t.store.removeFilter(r)
        }
        if (n) {
            n.bindStore(null)
        }
    },
    onBindStore: function(e, t) {
        var n = this.picker;
        if (!t) {
            this.resetToDefault()
        }
        if (n) {
            n.bindStore(e)
        }
    },
    bindStore: function(e, t, n) {
        var r = this,
        i = r.queryFilter;
        r.mixins.bindable.bindStore.call(r, e, n);
        e = r.getStore();
        if (e && e.showMask === undefined && !e.mask && !Wb.isValue(e.message)) {
            e.showMask = false
        }
        if (e && i) {
            i.disabled = !!t;
            e.addFilter(i)
        }
    },
    getStoreListeners: function() {
        var e = this;
        return {
            beforeload: e.onBeforeLoad,
            clear: e.onClear,
            datachanged: e.onDataChanged,
            load: e.onLoad,
            exception: e.onException,
            remove: e.onRemove
        }
    },
    onBeforeLoad: function() {++this.ignoreSelection
    },
    onDataChanged: function() {
        var e = this;
        if (e.resizeComboToGrow()) {
            e.updateLayout()
        }
    },
    onClear: function() {
        var e = this;
        if (e.resizeComboToGrow()) {
            e.removingRecords = true;
            e.onDataChanged()
        }
    },
    onRemove: function() {
        var e = this;
        if (e.resizeComboToGrow()) {
            e.removingRecords = true
        }
    },
    onException: function() {
        if (this.ignoreSelection > 0) {--this.ignoreSelection
        }
        this.collapse()
    },
    onLoad: function(e, t, n) {
        var r = this;
        if (r.ignoreSelection > 0) {--r.ignoreSelection
        }
        if (n && !e.lastOptions.rawQuery) {
            if (r.value == null) {
                if (r.store.getCount()) {
                    r.doAutoSelect()
                } else {
                    r.setValue(r.value)
                }
            } else {
                r.setValue(r.value)
            }
        }
    },
    doRawQuery: function() {
        this.doQuery(this.getRawValue(), false, true)
    },
    doQuery: function(e, t, n) {
        var r = this,
        i = r.beforeQuery({
            query: e || "",
            rawQuery: n,
            forceAll: t,
            combo: r,
            cancel: false
        });
        if (i === false || i.cancel) {
            return false
        }
        if (r.queryCaching && i.query === r.lastQuery) {
            if (r.store.getCount() || r.getPicker().emptyText) {
                r.expand();
                if (r.queryMode === "local") {
                    r.doAutoSelect()
                }
            } else {
                r.collapse()
            }
        } else {
            r.lastQuery = i.query;
            if (r.queryMode === "local") {
                r.doLocalQuery(i)
            } else {
                r.doRemoteQuery(i)
            }
        }
        return true
    },
    beforeQuery: function(e) {
        var t = this;
        if (t.fireEvent("beforequery", e) === false) {
            e.cancel = true
        } else {
            if (!e.cancel) {
                if (e.query.length < t.minChars && !e.forceAll) {
                    e.cancel = true;
                    t.collapse()
                }
            }
        }
        return e
    },
    doLocalQuery: function(e) {
        var t = this,
        n = e.query;
        if (!t.queryFilter) {
            t.queryFilter = new Ext.util.Filter({
                id: t.id + "-query-filter",
                anyMatch: t.anyMatch,
                caseSensitive: t.caseSensitive,
                root: "data",
                property: t.displayField
            });
            t.store.addFilter(t.queryFilter, false)
        }
        if (n || !e.forceAll) {
            t.queryFilter.disabled = false;
            t.queryFilter.setValue(t.enableRegEx ? new RegExp(n) : n)
        } else {
            t.queryFilter.disabled = true
        }
        t.store.filter();
        if (t.store.getCount() || t.getPicker().emptyText) {
            t.expand()
        } else {
            t.collapse()
        }
        t.afterQuery(e)
    },
    doRemoteQuery: function(e) {
        var t = this,
        n = function() {
            t.afterQuery(e)
        };
        if (t.pageSize) {
            t.loadPage(1, {
                rawQuery: e.rawQuery,
                callback: n
            })
        } else {
            t.store.load({
                params: t.getParams(e.query),
                rawQuery: e.rawQuery,
                callback: n
            })
        }
    },
    afterQuery: function(e) {
        var t = this;
        if (t.store.getCount()) {
            if (!t.isExpanded) {
                t.expand()
            }
            if (t.typeAhead) {
                t.doTypeAhead()
            }
            if (t.getRawValue() !== t.getDisplayValue()) {
                t.ignoreSelection++;
                t.picker.getSelectionModel().deselectAll();
                t.ignoreSelection--
            }
            if (e.rawQuery) {
                t.syncSelection();
                if (t.picker && !t.picker.getSelectionModel().hasSelection()) {
                    t.doAutoSelect()
                }
            } else {
                t.doAutoSelect()
            }
        } else {
            t.collapse()
        }
    },
    loadPage: function(e, t) {
        this.store.loadPage(e, Ext.apply({
            params: this.getParams(this.lastQuery)
        },
        t))
    },
    onPageChange: function(e, t) {
        this.loadPage(t);
        return false
    },
    getParams: function(e) {
        var t = {},
        n = this.queryParam;
        if (n) {
            t[n] = e
        }
        return t
    },
    doAutoSelect: function() {
        var e = this,
        t = e.picker,
        n, r;
        if (t && e.autoSelect && e.store.getCount() > 0) {
            n = t.getSelectionModel().lastSelected;
            r = t.getNode(n || 0);
            if (r) {
                t.highlightItem(r);
                t.listEl.scrollChildIntoView(r, false)
            }
        }
    },
    doTypeAhead: function() {
        var e = this;
        if (!e.typeAheadTask) {
            e.typeAheadTask = new Ext.util.DelayedTask(e.onTypeAhead, e)
        }
        if (e.lastKey != Ext.EventObject.BACKSPACE && e.lastKey != Ext.EventObject.DELETE) {
            e.typeAheadTask.delay(e.typeAheadDelay)
        }
    },
    onTriggerClick: function() {
        var e = this;
        e.duringTriggerClick = true;
        if (!e.readOnly && !e.disabled) {
            if (e.isExpanded) {
                e.collapse()
            } else {
                e.onFocus({});
                if (e.triggerAction === "all") {
                    e.doQuery(e.allQuery, true)
                } else {
                    if (e.triggerAction === "last") {
                        e.doQuery(e.lastQuery, true)
                    } else {
                        e.doQuery(e.getRawValue(), false, true)
                    }
                }
            }
            e.inputEl.focus()
        }
        delete e.duringTriggerClick
    },
    onPaste: function() {
        var e = this;
        if (!e.readOnly && !e.disabled && e.editable) {
            e.doQueryTask.delay(e.queryDelay)
        }
    },
    onKeyUp: function(e, t) {
        var n = this,
        r = e.getKey();
        if (!n.readOnly && !n.disabled && n.editable) {
            n.lastKey = r;
            if (!e.isSpecialKey() || r == e.BACKSPACE || r == e.DELETE) {
                n.doQueryTask.delay(n.queryDelay)
            }
        }
        if (n.enableKeyEvents) {
            n.callParent(arguments)
        }
    },
    initEvents: function() {
        var e = this;
        e.callParent();
        if (!e.enableKeyEvents) {
            e.mon(e.inputEl, "keyup", e.onKeyUp, e)
        }
        e.mon(e.inputEl, "paste", e.onPaste, e)
    },
    onDestroy: function() {
        var e = this;
        if (e.typeAheadTask) {
            e.typeAheadTask.cancel();
            e.typeAheadTask = null
        }
        Ext.destroy(e.listKeyNav);
        e.bindStore(null);
        e.callParent()
    },
    onAdded: function() {
        var e = this;
        e.callParent(arguments);
        if (e.picker) {
            e.picker.ownerCt = e.up("[floating]");
            e.picker.registerWithOwnerCt()
        }
    },
    createPicker: function() {
        var e = this,
        t, n = Ext.apply({
            xtype: "boundlist",
            pickerField: e,
            selModel: {
                mode: e.multiSelect ? "SIMPLE": "SINGLE"
            },
            floating: true,
            hidden: true,
            store: e.store,
            displayField: e.displayField,
            focusOnToFront: false,
            pageSize: e.pageSize,
            tpl: e.tpl
        },
        e.listConfig, e.defaultListConfig);
        t = e.picker = Ext.widget(n);
        if (e.pageSize) {
            t.pagingToolbar.on("beforechange", e.onPageChange, e)
        }
        e.mon(t, {
            itemclick: e.onItemClick,
            refresh: e.onListRefresh,
            scope: e
        });
        e.mon(t.getSelectionModel(), {
            beforeselect: e.onBeforeSelect,
            beforedeselect: e.onBeforeDeselect,
            selectionchange: e.onListSelectionChange,
            scope: e
        });
        return t
    },
    alignPicker: function() {
        var e = this,
        t = e.getPicker(),
        n = e.getPosition()[1] - Ext.getBody().getScroll().top,
        r = Ext.Element.getViewHeight() - n - e.getHeight(),
        i = Math.max(n, r);
        if (t.height) {
            delete t.height;
            t.updateLayout()
        }
        if (t.getHeight() > i - 5) {
            t.setHeight(i - 5)
        }
        e.callParent()
    },
    onListRefresh: function() {
        if (!this.expanding) {
            this.alignPicker()
        }
        this.syncSelection()
    },
    onItemClick: function(e, t) {
        var n = this,
        r = n.picker.getSelectionModel().getSelection(),
        i = n.valueField;
        if (!n.multiSelect && r.length) {
            if (t.get(i) === r[0].get(i)) {
                n.displayTplData = [t.data];
                n.setRawValue(n.getDisplayValue());
                n.collapse()
            }
        }
    },
    onBeforeSelect: function(e, t) {
        return this.fireEvent("beforeselect", this, t, t.index)
    },
    onBeforeDeselect: function(e, t) {
        return this.fireEvent("beforedeselect", this, t, t.index)
    },
    onListSelectionChange: function(e, t) {
        var n = this,
        r = n.multiSelect,
        i = t.length > 0;
        if (!n.ignoreSelection && n.isExpanded) {
            if (!r) {
                Ext.defer(n.collapse, 1, n)
            }
            if (r || i) {
                n.setValue(t, false)
            }
            if (i) {
                n.fireEvent("select", n, t)
            }
            n.inputEl.focus()
        }
    },
    onExpand: function() {
        var e = this,
        t = e.listKeyNav,
        n = e.selectOnTab,
        r = e.getPicker();
        if (t) {
            t.enable()
        } else {
            t = e.listKeyNav = new Ext.view.BoundListKeyNav(e.inputEl, {
                boundList: r,
                forceKeyDown: true,
                tab: function(t) {
                    if (n) {
                        this.selectHighlighted(t);
                        e.triggerBlur()
                    }
                    return true
                },
                enter: function(t) {
                    var n = r.getSelectionModel(),
                    i = n.getCount();
                    this.selectHighlighted(t);
                    if (!e.multiSelect && i === n.getCount()) {
                        e.collapse()
                    }
                }
            })
        }
        if (n) {
            e.ignoreMonitorTab = true
        }
        Ext.defer(t.enable, 1, t);
        e.inputEl.focus()
    },
    onCollapse: function() {
        var e = this,
        t = e.listKeyNav;
        if (t) {
            t.disable();
            e.ignoreMonitorTab = false
        }
    },
    select: function(e, t) {
        var n = this,
        r = n.picker,
        i;
        if (e && e.isModel && t === true && r) {
            i = !r.getSelectionModel().isSelected(e)
        }
        n.setValue(e, true);
        if (i) {
            n.fireEvent("select", n, e)
        }
    },
    findRecord: function(e, t) {
        var n = this.store,
        r = n.findExact(e, t);
        return r !== -1 ? n.getAt(r) : false
    },
    findRecordByValue: function(e) {
        return this.findRecord(this.valueField, e)
    },
    findRecordByDisplay: function(e) {
        return this.findRecord(this.displayField, e)
    },
    setValue: function(e, t) {
        var n = this,
        r = n.valueNotFoundText,
        i = n.inputEl,
        s, o, u, a, f = [],
        l = [],
        c = [];
        if (n.store.loading) {
            n.value = e;
            n.setHiddenValue(n.value);
            return n
        }
        e = Ext.Array.from(e);
        for (s = 0, o = e.length; s < o; s++) {
            u = e[s];
            if (!u || !u.isModel) {
                u = n.findRecordByValue(u)
            }
            if (u) {
                f.push(u);
                l.push(u.data);
                c.push(u.get(n.valueField))
            } else {
                if (!n.forceSelection) {
                    c.push(e[s]);
                    a = {};
                    a[n.displayField] = e[s];
                    l.push(a)
                } else {
                    if (Ext.isDefined(r)) {
                        l.push(r)
                    }
                }
            }
        }
        n.setHiddenValue(c);
        n.value = n.multiSelect ? c: c[0];
        if (!Ext.isDefined(n.value)) {
            n.value = null
        }
        n.displayTplData = l;
        n.lastSelection = n.valueModels = f;
        if (i && n.emptyText && !Ext.isEmpty(e)) {
            i.removeCls(n.emptyCls)
        }
        n.setRawValue(n.getDisplayValue());
        n.checkChange();
        if (t !== false) {
            n.syncSelection()
        }
        n.applyEmptyText();
        return n
    },
    setHiddenValue: function(e) {
        var t = this,
        n = t.hiddenName,
        r, i, s, o, u, a;
        if (!t.hiddenDataEl || !n) {
            return
        }
        e = Ext.Array.from(e);
        i = t.hiddenDataEl.dom;
        s = i.childNodes;
        o = s[0];
        u = e.length;
        a = s.length;
        if (!o && u > 0) {
            t.hiddenDataEl.update(Ext.DomHelper.markup({
                tag: "input",
                type: "hidden",
                name: n
            }));
            a = 1;
            o = i.firstChild
        }
        while (a > u) {
            i.removeChild(s[0]); --a
        }
        while (a < u) {
            i.appendChild(o.cloneNode(true)); ++a
        }
        for (r = 0; r < u; r++) {
            s[r].value = e[r]
        }
    },
    getDisplayValue: function() {
        return this.displayTpl.apply(this.displayTplData)
    },
    getValue: function() {
        var e = this,
        t = e.picker,
        n = e.getRawValue(),
        r = e.value;
        if (e.getDisplayValue() !== n) {
            r = n;
            e.value = e.displayTplData = e.valueModels = null;
            if (t) {
                e.ignoreSelection++;
                t.getSelectionModel().deselectAll();
                e.ignoreSelection--
            }
        }
        return r
    },
    getSubmitValue: function() {
        var e = this.getValue();
        if (Ext.isEmpty(e)) {
            e = ""
        }
        return e
    },
    isEqual: function(e, t) {
        var n = Ext.Array.from,
        r, i;
        e = n(e);
        t = n(t);
        i = e.length;
        if (i !== t.length) {
            return false
        }
        for (r = 0; r < i; r++) {
            if (t[r] !== e[r]) {
                return false
            }
        }
        return true
    },
    clearValue: function() {
        this.setValue([])
    },
    syncSelection: function() {
        var e = this,
        t = e.picker,
        n, r, i = e.valueModels || [],
        s = i.length,
        o,
        u;
        if (t) {
            n = [];
            for (o = 0; o < s; o++) {
                u = i[o];
                if (u && u.isModel && e.store.indexOf(u) >= 0) {
                    n.push(u)
                }
            }
            e.ignoreSelection++;
            r = t.getSelectionModel();
            r.deselectAll();
            if (n.length) {
                r.select(n, undefined, true)
            }
            e.ignoreSelection--
        }
    },
    onEditorTab: function(e) {
        var t = this.listKeyNav;
        if (this.selectOnTab && t) {
            t.selectHighlighted(e)
        }
    }
});Ext.define("Ext.picker.Month", {
    extend: Ext.Component,
    alias: "widget.monthpicker",
    alternateClassName: "Ext.MonthPicker",
    childEls: ["bodyEl", "prevEl", "nextEl", "monthEl", "yearEl"],
    renderTpl: ['<div id="{id}-bodyEl" class="{baseCls}-body">', '<div id="{id}-monthEl" class="{baseCls}-months">', '<tpl for="months">', '<div class="{parent.baseCls}-item {parent.baseCls}-month">', '<a style="{parent.monthStyle}" role="button" hidefocus="on" class="{parent.baseCls}-item-inner" href="#">{.}</a>', "</div>", "</tpl>", "</div>", '<div id="{id}-yearEl" class="{baseCls}-years">', '<div class="{baseCls}-yearnav">', '<div class="{baseCls}-yearnav-button-ct">', '<a id="{id}-prevEl" class="{baseCls}-yearnav-button {baseCls}-yearnav-prev" href="#" hidefocus="on" role="button"></a>', "</div>", '<div class="{baseCls}-yearnav-button-ct">', '<a id="{id}-nextEl" class="{baseCls}-yearnav-button {baseCls}-yearnav-next" href="#" hidefocus="on" role="button"></a>', "</div>", "</div>", '<tpl for="years">', '<div class="{parent.baseCls}-item {parent.baseCls}-year">', '<a hidefocus="on" class="{parent.baseCls}-item-inner" role="button" href="#">{.}</a>', "</div>", "</tpl>", "</div>", '<div class="' + Ext.baseCSSPrefix + 'clear"></div>', '<tpl if="showButtons">', '<div class="{baseCls}-buttons">{%', "var me=values.$comp, okBtn=me.okBtn, cancelBtn=me.cancelBtn;", "okBtn.ownerLayout = cancelBtn.ownerLayout = me.componentLayout;", "okBtn.ownerCt = cancelBtn.ownerCt = me;", "Ext.DomHelper.generateMarkup(okBtn.getRenderTree(), out);", "Ext.DomHelper.generateMarkup(cancelBtn.getRenderTree(), out);", "%}</div>", "</tpl>", "</div>"],
    okText: "OK",
    cancelText: "Cancel",
    baseCls: Ext.baseCSSPrefix + "monthpicker",
    showButtons: true,
    measureWidth: 35,
    measureMaxHeight: 20,
    smallCls: Ext.baseCSSPrefix + "monthpicker-small",
    totalYears: 10,
    yearOffset: 5,
    monthOffset: 6,
    initComponent: function() {
        var e = this;
        e.selectedCls = e.baseCls + "-selected";
        e.addEvents("cancelclick", "monthclick", "monthdblclick", "okclick", "select", "yearclick", "yeardblclick");
        if (e.small) {
            e.addCls(e.smallCls)
        }
        e.setValue(e.value);
        e.activeYear = e.getYear((new Date).getFullYear() - 4, -4);
        if (e.showButtons) {
            e.okBtn = new Ext.button.Button({
                text: e.okText,
                handler: e.onOkClick,
                scope: e
            });
            e.cancelBtn = new Ext.button.Button({
                text: e.cancelText,
                handler: e.onCancelClick,
                scope: e
            })
        }
        this.callParent()
    },
    beforeRender: function() {
        var e = this,
        t = 0,
        n = [],
        r = Ext.Date.getShortMonthName,
        i = e.monthOffset,
        s = e.monthMargin,
        o = "";
        if (e.padding && !e.width) {
            e.cacheWidth()
        }
        e.callParent();
        for (; t < i; ++t) {
            n.push(r(t), r(t + i))
        }
        if (Ext.isDefined(s)) {
            o = "margin: 0 " + s + "px;"
        }
        Ext.apply(e.renderData, {
            months: n,
            years: e.getYears(),
            showButtons: e.showButtons,
            monthStyle: o
        })
    },
    cacheWidth: function() {
        var e = this,
        t = e.parseBox(e.padding),
        n = Ext.getBody().createChild({
            cls: e.baseCls + " " + e.borderBoxCls,
            style: "position:absolute;top:-1000px;left:-1000px;",
            html: "&nbsp;"
        });
        e.self.prototype.width = n.getWidth() + t.left + t.right;
        n.remove()
    },
    afterRender: function() {
        var e = this,
        t = e.bodyEl;
        e.callParent();
        e.mon(t, "click", e.onBodyClick, e);
        e.mon(t, "dblclick", e.onBodyClick, e);
        e.years = t.select("." + e.baseCls + "-year a");
        e.months = t.select("." + e.baseCls + "-month a");
        e.backRepeater = new Ext.util.ClickRepeater(e.prevEl, {
            handler: Ext.Function.bind(e.adjustYear, e, [ - e.totalYears])
        });
        e.prevEl.addClsOnOver(e.baseCls + "-yearnav-prev-over");
        e.nextRepeater = new Ext.util.ClickRepeater(e.nextEl, {
            handler: Ext.Function.bind(e.adjustYear, e, [e.totalYears])
        });
        e.nextEl.addClsOnOver(e.baseCls + "-yearnav-next-over");
        e.updateBody();
        if (!Ext.isDefined(e.monthMargin)) {
            Ext.picker.Month.prototype.monthMargin = e.calculateMonthMargin()
        }
    },
    calculateMonthMargin: function() {
        var e = this,
        t = e.monthEl,
        n = e.months,
        r = n.first(),
        i = r.getMargin("l");
        while (i && e.getLargest() > e.measureMaxHeight) {--i;
            n.setStyle("margin", "0 " + i + "px")
        }
        return i
    },
    getLargest: function(e) {
        var t = 0;
        this.months.each(function(e) {
            var n = e.getHeight();
            if (n > t) {
                t = n
            }
        });
        return t
    },
    setValue: function(e) {
        var t = this,
        n = t.activeYear,
        r = t.monthOffset,
        i, s;
        if (!e) {
            t.value = [null, null]
        } else {
            if (Ext.isDate(e)) {
                t.value = [e.getMonth(), e.getFullYear()]
            } else {
                t.value = [e[0], e[1]]
            }
        }
        if (t.rendered) {
            i = t.value[1];
            if (i !== null) {
                if (i < n || i > n + t.yearOffset) {
                    t.activeYear = i - t.yearOffset + 1
                }
            }
            t.updateBody()
        }
        return t
    },
    getValue: function() {
        return this.value
    },
    hasSelection: function() {
        var e = this.value;
        return e[0] !== null && e[1] !== null
    },
    getYears: function() {
        var e = this,
        t = e.yearOffset,
        n = e.activeYear,
        r = n + t,
        i = n,
        s = [];
        for (; i < r; ++i) {
            s.push(i, i + t)
        }
        return s
    },
    updateBody: function() {
        var e = this,
        t = e.years,
        n = e.months,
        r = e.getYears(),
        i = e.selectedCls,
        s = e.getYear(null),
        o = e.value[0],
        u = e.monthOffset,
        a,
        f,
        l,
        c,
        h;
        if (e.rendered) {
            t.removeCls(i);
            n.removeCls(i);
            f = t.elements;
            c = f.length;
            for (l = 0; l < c; l++) {
                h = Ext.fly(f[l]);
                a = r[l];
                h.dom.innerHTML = a;
                if (a == s) {
                    h.addCls(i)
                }
            }
            if (o !== null) {
                if (o < u) {
                    o = o * 2
                } else {
                    o = (o - u) * 2 + 1
                }
                n.item(o).addCls(i)
            }
        }
    },
    getYear: function(e, t) {
        var n = this.value[1];
        t = t || 0;
        return n === null ? e: n + t
    },
    onBodyClick: function(e, t) {
        var n = this,
        r = e.type == "dblclick";
        if (e.getTarget("." + n.baseCls + "-month")) {
            e.stopEvent();
            n.onMonthClick(t, r)
        } else {
            if (e.getTarget("." + n.baseCls + "-year")) {
                e.stopEvent();
                n.onYearClick(t, r)
            }
        }
    },
    adjustYear: function(e) {
        if (typeof e != "number") {
            e = this.totalYears
        }
        this.activeYear += e;
        this.updateBody()
    },
    onOkClick: function() {
        this.fireEvent("okclick", this, this.value)
    },
    onCancelClick: function() {
        this.fireEvent("cancelclick", this)
    },
    onMonthClick: function(e, t) {
        var n = this;
        n.value[0] = n.resolveOffset(n.months.indexOf(e), n.monthOffset);
        n.updateBody();
        n.fireEvent("month" + (t ? "dbl": "") + "click", n, n.value);
        n.fireEvent("select", n, n.value)
    },
    onYearClick: function(e, t) {
        var n = this;
        n.value[1] = n.activeYear + n.resolveOffset(n.years.indexOf(e), n.yearOffset);
        n.updateBody();
        n.fireEvent("year" + (t ? "dbl": "") + "click", n, n.value);
        n.fireEvent("select", n, n.value)
    },
    resolveOffset: function(e, t) {
        if (e % 2 === 0) {
            return e / 2
        } else {
            return t + Math.floor(e / 2)
        }
    },
    beforeDestroy: function() {
        var e = this;
        e.years = e.months = null;
        Ext.destroyMembers(e, "backRepeater", "nextRepeater", "okBtn", "cancelBtn");
        e.callParent()
    },
    finishRenderChildren: function() {
        var e = this;
        this.callParent(arguments);
        if (this.showButtons) {
            e.okBtn.finishRender();
            e.cancelBtn.finishRender()
        }
    },
    onDestroy: function() {
        Ext.destroyMembers(this, "okBtn", "cancelBtn");
        this.callParent()
    }
});Ext.define("Ext.picker.Date", {
    extend: Ext.Component,
    alias: "widget.datepicker",
    alternateClassName: "Ext.DatePicker",
    childEls: ["innerEl", "eventEl", "prevEl", "nextEl", "middleBtnEl", "footerEl"],
    border: true,
    renderTpl: ['<div id="{id}-innerEl" role="grid">', '<div role="presentation" class="{baseCls}-header">', '<a id="{id}-prevEl" class="{baseCls}-prev {baseCls}-arrow" href="#" role="button" title="{prevText}" hidefocus="on" ></a>', '<div class="{baseCls}-month" id="{id}-middleBtnEl">{%this.renderMonthBtn(values, out)%}</div>', '<a id="{id}-nextEl" class="{baseCls}-next {baseCls}-arrow" href="#" role="button" title="{nextText}" hidefocus="on" ></a>', "</div>", '<table id="{id}-eventEl" class="{baseCls}-inner" cellspacing="0" role="grid">', '<thead role="presentation"><tr role="row">', '<tpl for="dayNames">', '<th role="columnheader" class="{parent.baseCls}-column-header" title="{.}">', '<div class="{parent.baseCls}-column-header-inner">{.:this.firstInitial}</div>', "</th>", "</tpl>", "</tr></thead>", '<tbody role="presentation"><tr role="row">', '<tpl for="days">', "{#:this.isEndOfWeek}", '<td role="gridcell" id="{[Ext.id()]}">', '<a role="button" hidefocus="on" class="{parent.baseCls}-date" href="#"></a>', "</td>", "</tpl>", "</tr></tbody>", "</table>", '<tpl if="showToday">', '<div id="{id}-footerEl" role="presentation" class="{baseCls}-footer">{%this.renderTodayBtn(values, out)%}</div>', "</tpl>", "</div>", {
        firstInitial: function(e) {
            return Ext.picker.Date.prototype.getDayInitial(e)
        },
        isEndOfWeek: function(e) {
            e--;
            var t = e % 7 === 0 && e !== 0;
            return t ? '</tr><tr role="row">': ""
        },
        renderTodayBtn: function(e, t) {
            Ext.DomHelper.generateMarkup(e.$comp.todayBtn.getRenderTree(), t)
        },
        renderMonthBtn: function(e, t) {
            Ext.DomHelper.generateMarkup(e.$comp.monthBtn.getRenderTree(), t)
        }
    }],
    todayText: "Today",
    ariaTitle: "Date Picker: {0}",
    ariaTitleDateFormat: "F d, Y",
    todayTip: "{0} (Spacebar)",
    minText: "This date is before the minimum date",
    maxText: "This date is after the maximum date",
    disabledDaysText: "Disabled",
    disabledDatesText: "Disabled",
    nextText: "Next Month (Control+Right)",
    prevText: "Previous Month (Control+Left)",
    monthYearText: "Choose a month (Control+Up/Down to move years)",
    monthYearFormat: "F Y",
    startDay: 0,
    showToday: true,
    disableAnim: false,
    baseCls: Ext.baseCSSPrefix + "datepicker",
    longDayFormat: "F d, Y",
    focusOnShow: false,
    focusOnSelect: true,
    initHour: 12,
    numDays: 42,
    initComponent: function() {
        var e = this,
        t = Ext.Date.clearTime;
        e.selectedCls = e.baseCls + "-selected";
        e.disabledCellCls = e.baseCls + "-disabled";
        e.prevCls = e.baseCls + "-prevday";
        e.activeCls = e.baseCls + "-active";
        e.cellCls = e.baseCls + "-cell";
        e.nextCls = e.baseCls + "-prevday";
        e.todayCls = e.baseCls + "-today";
        if (!e.format) {
            e.format = Ext.Date.defaultFormat
        }
        if (!e.dayNames) {
            e.dayNames = Ext.Date.dayNames
        }
        e.dayNames = e.dayNames.slice(e.startDay).concat(e.dayNames.slice(0, e.startDay));
        e.callParent();
        e.value = e.value ? t(e.value, true) : t(new Date);
        e.addEvents("select");
        e.initDisabledDays()
    },
    getRefOwner: function() {
        return this.pickerField || this.callParent()
    },
    getRefItems: function() {
        var e = [],
        t = this.monthBtn,
        n = this.todayBtn;
        if (t) {
            e.push(t)
        }
        if (n) {
            e.push(n)
        }
        return e
    },
    beforeRender: function() {
        var e = this,
        t = new Array(e.numDays),
        n = Ext.Date.format(new Date, e.format);
        if (e.padding && !e.width) {
            e.cacheWidth()
        }
        e.monthBtn = new Ext.button.Split({
            ownerCt: e,
            ownerLayout: e.getComponentLayout(),
            text: "",
            tooltip: e.monthYearText,
            listeners: {
                click: e.doShowMonthPicker,
                arrowclick: e.doShowMonthPicker,
                scope: e
            }
        });
        if (e.showToday) {
            e.todayBtn = new Ext.button.Button({
                ownerCt: e,
                ownerLayout: e.getComponentLayout(),
                text: Ext.String.format(e.todayText, n),
                tooltip: Ext.String.format(e.todayTip, n),
                tooltipType: "title",
                handler: e.selectToday,
                scope: e
            })
        }
        e.callParent();
        Ext.applyIf(e, {
            renderData: {}
        });
        Ext.apply(e.renderData, {
            dayNames: e.dayNames,
            showToday: e.showToday,
            prevText: e.prevText,
            nextText: e.nextText,
            days: t
        });
        e.protoEl.unselectable()
    },
    cacheWidth: function() {
        var e = this,
        t = e.parseBox(e.padding),
        n = Ext.getBody().createChild({
            cls: e.baseCls + " " + e.borderBoxCls,
            style: "position:absolute;top:-1000px;left:-1000px;"
        });
        e.self.prototype.width = n.getWidth() + t.left + t.right;
        n.remove()
    },
    finishRenderChildren: function() {
        var e = this;
        e.callParent();
        e.monthBtn.finishRender();
        if (e.showToday) {
            e.todayBtn.finishRender()
        }
    },
    onRender: function(e, t) {
        var n = this;
        n.callParent(arguments);
        n.cells = n.eventEl.select("tbody td");
        n.textNodes = n.eventEl.query("tbody td a");
        n.mon(n.eventEl, {
            scope: n,
            mousewheel: n.handleMouseWheel,
            click: {
                fn: n.handleDateClick,
                delegate: "a." + n.baseCls + "-date"
            }
        })
    },
    initEvents: function() {
        var e = this,
        t = Ext.Date,
        n = t.DAY;
        e.callParent();
        e.prevRepeater = new Ext.util.ClickRepeater(e.prevEl, {
            handler: e.showPrevMonth,
            scope: e,
            preventDefault: true,
            stopDefault: true
        });
        e.nextRepeater = new Ext.util.ClickRepeater(e.nextEl, {
            handler: e.showNextMonth,
            scope: e,
            preventDefault: true,
            stopDefault: true
        });
        e.keyNav = new Ext.util.KeyNav(e.eventEl, Ext.apply({
            scope: e,
            left: function(r) {
                if (r.ctrlKey) {
                    e.showPrevMonth()
                } else {
                    e.update(t.add(e.activeDate, n, -1))
                }
            },
            right: function(r) {
                if (r.ctrlKey) {
                    e.showNextMonth()
                } else {
                    e.update(t.add(e.activeDate, n, 1))
                }
            },
            up: function(r) {
                if (r.ctrlKey) {
                    e.showNextYear()
                } else {
                    e.update(t.add(e.activeDate, n, -7))
                }
            },
            down: function(r) {
                if (r.ctrlKey) {
                    e.showPrevYear()
                } else {
                    e.update(t.add(e.activeDate, n, 7))
                }
            },
            pageUp: function(t) {
                if (t.altKey) {
                    e.showPrevYear()
                } else {
                    e.showPrevMonth()
                }
            },
            pageDown: function(t) {
                if (t.altKey) {
                    e.showNextYear()
                } else {
                    e.showNextMonth()
                }
            },
            tab: function(t) {
                e.doCancelFieldFocus = true;
                e.handleTabClick(t);
                delete e.doCancelFieldFocus;
                return true
            },
            enter: function(e) {
                e.stopPropagation();
                return true
            },
            home: function(n) {
                e.update(t.getFirstDateOfMonth(e.activeDate))
            },
            end: function(n) {
                e.update(t.getLastDateOfMonth(e.activeDate))
            }
        },
        e.keyNavConfig));
        if (e.showToday) {
            e.todayKeyListener = e.eventEl.addKeyListener(Ext.EventObject.SPACE, e.selectToday, e)
        }
        e.update(e.value)
    },
    handleTabClick: function(e) {
        var t = this,
        n = t.getSelectedDate(t.activeDate),
        r = t.handler;
        if (!t.disabled && n.dateValue && !Ext.fly(n.parentNode).hasCls(t.disabledCellCls)) {
            if (t.pickerField) {
                e.stopEvent()
            }
            t.doCancelFocus = true;
            t.setValue(new Date(n.dateValue));
            delete t.doCancelFocus;
            t.fireEvent("select", t, t.value);
            if (r) {
                r.call(t.scope || t, t, t.value)
            }
            t.onSelect()
        }
    },
    getSelectedDate: function(e) {
        var t = this,
        n = e.getTime(),
        r = t.cells,
        i = t.selectedCls,
        s = r.elements,
        o,
        u = s.length,
        a;
        r.removeCls(i);
        for (o = 0; o < u; o++) {
            a = Ext.fly(s[o]);
            if (a.dom.firstChild.dateValue == n) {
                return a.dom.firstChild
            }
        }
        return null
    },
    initDisabledDays: function() {
        var e = this,
        t = e.disabledDates,
        n = "(?:",
        r, i, s, o;
        if (!e.disabledDatesRE && t) {
            r = t.length - 1;
            s = t.length;
            for (i = 0; i < s; i++) {
                o = t[i];
                n += Ext.isDate(o) ? "^" + Ext.String.escapeRegex(Ext.Date.dateFormat(o, e.format)) + "$": o;
                if (i != r) {
                    n += "|"
                }
            }
            e.disabledDatesRE = new RegExp(n + ")")
        }
    },
    setDisabledDates: function(e) {
        var t = this;
        if (Ext.isArray(e)) {
            t.disabledDates = e;
            t.disabledDatesRE = null
        } else {
            t.disabledDatesRE = e
        }
        t.initDisabledDays();
        t.update(t.value, true);
        return t
    },
    setDisabledDays: function(e) {
        this.disabledDays = e;
        return this.update(this.value, true)
    },
    setMinDate: function(e) {
        this.minDate = e;
        return this.update(this.value, true)
    },
    setMaxDate: function(e) {
        this.maxDate = e;
        return this.update(this.value, true)
    },
    setValue: function(e) {
        this.value = Ext.Date.clearTime(e, true);
        return this.update(this.value)
    },
    getValue: function() {
        return this.value
    },
    getDayInitial: function(e) {
        return e.substr(0, 1)
    },
    focus: function() {
        this.update(this.activeDate)
    },
    onEnable: function() {
        this.callParent();
        this.setDisabledStatus(false);
        this.update(this.activeDate)
    },
    onDisable: function() {
        this.callParent();
        this.setDisabledStatus(true)
    },
    setDisabledStatus: function(e) {
        var t = this;
        t.keyNav.setDisabled(e);
        t.prevRepeater.setDisabled(e);
        t.nextRepeater.setDisabled(e);
        if (t.showToday) {
            t.todayKeyListener.setDisabled(e);
            t.todayBtn.setDisabled(e)
        }
    },
    getActive: function() {
        return this.activeDate || this.value
    },
    runAnimation: function(e) {
        var t = this.monthPicker,
        n = {
            duration: 200,
            callback: function() {
                t.setVisible(!e)
            }
        },
        r = t.isVisible();
        if (e) {
            t.el.slideOut("t", n)
        } else {
            t.el.slideIn("t", n)
        }
    },
    hideMonthPicker: function(e) {
        var t = this,
        n = t.monthPicker;
        if (n && n.isVisible()) {
            if (t.shouldAnimate(e)) {
                t.runAnimation(true)
            } else {
                n.hide()
            }
        }
        return t
    },
    doShowMonthPicker: function() {
        this.showMonthPicker()
    },
    doHideMonthPicker: function() {
        this.hideMonthPicker()
    },
    showMonthPicker: function(e) {
        var t = this,
        n = t.el,
        r;
        if (t.rendered && !t.disabled) {
            r = t.createMonthPicker();
            if (!r.isVisible()) {
                r.setValue(t.getActive());
                r.setSize(n.getSize());
                r.setPosition( - n.getBorderWidth("l"), -n.getBorderWidth("t"));
                if (t.shouldAnimate(e)) {
                    t.runAnimation(false)
                } else {
                    r.show()
                }
            }
        }
        return t
    },
    shouldAnimate: function(e) {
        return Ext.isDefined(e) ? e: !this.disableAnim
    },
    createMonthPicker: function() {
        var e = this,
        t = e.monthPicker;
        if (!t) {
            e.monthPicker = t = new Ext.picker.Month({
                renderTo: e.el,
                floating: true,
                padding: e.padding,
                shadow: false,
                small: e.showToday === false,
                listeners: {
                    scope: e,
                    cancelclick: e.onCancelClick,
                    okclick: e.onOkClick,
                    yeardblclick: e.onOkClick,
                    monthdblclick: e.onOkClick
                }
            });
            if (!e.disableAnim) {
                t.el.setStyle("display", "none")
            }
            t.hide();
            e.on("beforehide", e.doHideMonthPicker, e)
        }
        return t
    },
    onOkClick: function(e, t) {
        var n = this,
        r = t[0],
        i = t[1],
        s = new Date(i, r, n.getActive().getDate());
        if (s.getMonth() !== r) {
            s = Ext.Date.getLastDateOfMonth(new Date(i, r, 1))
        }
        n.setValue(s);
        n.hideMonthPicker()
    },
    onCancelClick: function() {
        this.selectedUpdate(this.activeDate);
        this.hideMonthPicker()
    },
    showPrevMonth: function(e) {
        return this.setValue(Ext.Date.add(this.activeDate, Ext.Date.MONTH, -1))
    },
    showNextMonth: function(e) {
        return this.setValue(Ext.Date.add(this.activeDate, Ext.Date.MONTH, 1))
    },
    showPrevYear: function() {
        return this.setValue(Ext.Date.add(this.activeDate, Ext.Date.YEAR, -1))
    },
    showNextYear: function() {
        return this.setValue(Ext.Date.add(this.activeDate, Ext.Date.YEAR, 1))
    },
    handleMouseWheel: function(e) {
        e.stopEvent();
        if (!this.disabled) {
            var t = e.getWheelDelta();
            if (t > 0) {
                this.showPrevMonth()
            } else {
                if (t < 0) {
                    this.showNextMonth()
                }
            }
        }
    },
    handleDateClick: function(e, t) {
        var n = this,
        r = n.handler;
        e.stopEvent();
        if (!n.disabled && t.dateValue && !Ext.fly(t.parentNode).hasCls(n.disabledCellCls)) {
            n.doCancelFocus = n.focusOnSelect === false;
            n.setValue(new Date(t.dateValue));
            delete n.doCancelFocus;
            n.fireEvent("select", n, n.value);
            if (r) {
                r.call(n.scope || n, n, n.value)
            }
            n.onSelect()
        }
    },
    onSelect: function() {
        if (this.hideOnSelect) {
            this.hide()
        }
    },
    selectToday: function() {
        var e = this,
        t = e.todayBtn,
        n = e.handler;
        if (t && !t.disabled) {
            e.setValue(Ext.Date.clearTime(new Date));
            e.fireEvent("select", e, e.value);
            if (n) {
                n.call(e.scope || e, e, e.value)
            }
            e.onSelect()
        }
        return e
    },
    selectedUpdate: function(e) {
        var t = this,
        n = e.getTime(),
        r = t.cells,
        i = t.selectedCls,
        s = r.elements,
        o,
        u = s.length,
        a;
        r.removeCls(i);
        for (o = 0; o < u; o++) {
            a = Ext.fly(s[o]);
            if (a.dom.firstChild.dateValue == n) {
                t.fireEvent("highlightitem", t, a);
                a.addCls(i);
                if (t.isVisible() && !t.doCancelFocus) {
                    Ext.fly(a.dom.firstChild).focus(50)
                }
                break
            }
        }
    },
    fullUpdate: function(e) {
        var t = this,
        n = t.cells.elements,
        r = t.textNodes,
        i = t.disabledCellCls,
        s = Ext.Date,
        o = 0,
        u = 0,
        a = t.isVisible(),
        f = +s.clearTime(e, true),
        l = +s.clearTime(new Date),
        c = t.minDate ? s.clearTime(t.minDate, true) : Number.NEGATIVE_INFINITY,
        h = t.maxDate ? s.clearTime(t.maxDate, true) : Number.POSITIVE_INFINITY,
        p = t.disabledDatesRE,
        d = t.disabledDatesText,
        v = t.disabledDays ? t.disabledDays.join("") : false,
        m = t.disabledDaysText,
        g = t.format,
        y = s.getDaysInMonth(e),
        b = s.getFirstDateOfMonth(e),
        w = b.getDay() - t.startDay,
        E = s.add(e, s.MONTH, -1),
        S = t.longDayFormat,
        x,
        T,
        N,
        C,
        k,
        L,
        A,
        O,
        M;
        if (w < 0) {
            w += 7
        }
        y += w;
        x = s.getDaysInMonth(E) - w;
        T = new Date(E.getFullYear(), E.getMonth(), x, t.initHour);
        if (t.showToday) {
            C = s.clearTime(new Date);
            N = C < c || C > h || p && g && p.test(s.dateFormat(C, g)) || v && v.indexOf(C.getDay()) != -1;
            if (!t.disabled) {
                t.todayBtn.setDisabled(N);
                t.todayKeyListener.setDisabled(N)
            }
        }
        k = function(e, n) {
            M = +s.clearTime(T, true);
            e.title = s.format(T, S);
            e.firstChild.dateValue = M;
            if (M == l) {
                n += " " + t.todayCls;
                e.title = t.todayText;
                t.todayElSpan = Ext.DomHelper.append(e.firstChild, {
                    tag: "span",
                    cls: Ext.baseCSSPrefix + "hide-clip",
                    html: t.todayText
                },
                true)
            }
            if (M == f) {
                n += " " + t.selectedCls;
                t.fireEvent("highlightitem", t, e);
                if (a && t.floating) {
                    Ext.fly(e.firstChild).focus(50)
                }
            }
            if (M < c) {
                n += " " + i;
                e.title = t.minText
            } else {
                if (M > h) {
                    n += " " + i;
                    e.title = t.maxText
                } else {
                    if (v && v.indexOf(T.getDay()) !== -1) {
                        e.title = m;
                        n += " " + i
                    } else {
                        if (p && g) {
                            O = s.dateFormat(T, g);
                            if (p.test(O)) {
                                e.title = d.replace("%0", O);
                                n += " " + i
                            }
                        }
                    }
                }
            }
            e.className = n + " " + t.cellCls
        };
        for (; o < t.numDays; ++o) {
            if (o < w) {
                L = ++x;
                A = t.prevCls
            } else {
                if (o >= y) {
                    L = ++u;
                    A = t.nextCls
                } else {
                    L = o - w + 1;
                    A = t.activeCls
                }
            }
            r[o].innerHTML = L;
            T.setDate(T.getDate() + 1);
            k(n[o], A)
        }
        t.monthBtn.setText(Ext.Date.format(e, t.monthYearFormat))
    },
    update: function(e, t) {
        var n = this,
        r = n.activeDate;
        if (n.rendered) {
            n.activeDate = e;
            if (!t && r && n.el && r.getMonth() == e.getMonth() && r.getFullYear() == e.getFullYear()) {
                n.selectedUpdate(e, r)
            } else {
                n.fullUpdate(e, r)
            }
        }
        return n
    },
    beforeDestroy: function() {
        var e = this;
        if (e.rendered) {
            Ext.destroy(e.todayKeyListener, e.keyNav, e.monthPicker, e.monthBtn, e.nextRepeater, e.prevRepeater, e.todayBtn);
            delete e.textNodes;
            delete e.cells.elements
        }
        e.callParent()
    },
    onShow: function() {
        this.callParent(arguments);
        if (this.focusOnShow) {
            this.focus()
        }
    }
});Ext.define("Ext.form.field.Date", {
    extend: Ext.form.field.Picker,
    alias: "widget.datefield",
    alternateClassName: ["Ext.form.DateField", "Ext.form.Date"],
    format: "m/d/Y",
    altFormats: "m/d/Y|n/j/Y|n/j/y|m/j/y|n/d/y|m/j/Y|n/d/Y|m-d-y|m-d-Y|m/d|m-d|md|mdy|mdY|Ymd|d|j|Y-m-d|n-j|n/j",
    disabledDaysText: "Disabled",
    disabledDatesText: "Disabled",
    minText: "The date in this field must be equal to or after {0}",
    maxText: "The date in this field must be equal to or before {0}",
    invalidText: "{0} is not a valid date - it must be in the format {1}",
    triggerCls: Ext.baseCSSPrefix + "form-date-trigger",
    showToday: true,
    useStrict: undefined,
    initTime: "12",
    initTimeFormat: "H",
    matchFieldWidth: false,
    startDay: 0,
    initComponent: function() {
        var e = this,
        t = Ext.isString,
        n, r;
        n = e.minValue;
        r = e.maxValue;
        if (t(n)) {
            e.minValue = e.parseDate(n)
        }
        if (t(r)) {
            e.maxValue = e.parseDate(r)
        }
        e.disabledDatesRE = null;
        e.initDisabledDays();
        e.callParent()
    },
    initValue: function() {
        var e = this,
        t = e.value;
        if (Ext.isString(t)) {
            e.value = e.rawToValue(t)
        }
        e.callParent()
    },
    initDisabledDays: function() {
        if (this.disabledDates) {
            var e = this.disabledDates,
            t = e.length - 1,
            n = "(?:",
            r, i = e.length,
            s;
            for (r = 0; r < i; r++) {
                s = e[r];
                n += Ext.isDate(s) ? "^" + Ext.String.escapeRegex(s.dateFormat(this.format)) + "$": s;
                if (r !== t) {
                    n += "|"
                }
            }
            this.disabledDatesRE = new RegExp(n + ")")
        }
    },
    setDisabledDates: function(e) {
        var t = this,
        n = t.picker;
        t.disabledDates = e;
        t.initDisabledDays();
        if (n) {
            n.setDisabledDates(t.disabledDatesRE)
        }
    },
    setDisabledDays: function(e) {
        var t = this.picker;
        this.disabledDays = e;
        if (t) {
            t.setDisabledDays(e)
        }
    },
    setMinValue: function(e) {
        var t = this,
        n = t.picker,
        r = Ext.isString(e) ? t.parseDate(e) : e;
        t.minValue = r;
        if (n) {
            n.minText = Ext.String.format(t.minText, t.formatDate(t.minValue));
            n.setMinDate(r)
        }
    },
    setMaxValue: function(e) {
        var t = this,
        n = t.picker,
        r = Ext.isString(e) ? t.parseDate(e) : e;
        t.maxValue = r;
        if (n) {
            n.maxText = Ext.String.format(t.maxText, t.formatDate(t.maxValue));
            n.setMaxDate(r)
        }
    },
    getErrors: function(e) {
        var t = this,
        n = Ext.String.format,
        r = Ext.Date.clearTime,
        i = t.callParent(arguments),
        s = t.disabledDays,
        o = t.disabledDatesRE,
        u = t.minValue,
        a = t.maxValue,
        f = s ? s.length: 0,
        l = 0,
        c,
        h,
        p,
        d;
        e = t.formatDate(e || t.processRawValue(t.getRawValue()));
        if (e === null || e.length < 1) {
            return i
        }
        c = e;
        e = t.parseDate(e);
        if (!e) {
            i.push(n(t.invalidText, c, Ext.Date.unescapeFormat(t.format)));
            return i
        }
        d = e.getTime();
        if (u && d < r(u).getTime()) {
            i.push(n(t.minText, t.formatDate(u)))
        }
        if (a && d > r(a).getTime()) {
            i.push(n(t.maxText, t.formatDate(a)))
        }
        if (s) {
            p = e.getDay();
            for (; l < f; l++) {
                if (p === s[l]) {
                    i.push(t.disabledDaysText);
                    break
                }
            }
        }
        h = t.formatDate(e);
        if (o && o.test(h)) {
            i.push(n(t.disabledDatesText, h))
        }
        return i
    },
    rawToValue: function(e) {
        return this.parseDate(e) || e || null
    },
    valueToRaw: function(e) {
        return this.formatDate(this.parseDate(e))
    },
    safeParse: function(e, t) {
        var n = this,
        r = Ext.Date,
        i = null,
        s = n.useStrict,
        o;
        if (r.formatContainsHourInfo(t)) {
            i = r.parse(e, t, s)
        } else {
            o = r.parse(e + " " + n.initTime, t + " " + n.initTimeFormat, s);
            if (o) {
                i = r.clearTime(o)
            }
        }
        return i
    },
    getSubmitValue: function() {
        var e = this.submitFormat || this.format,
        t = this.getValue();
        return t ? Ext.Date.format(t, e) : ""
    },
    parseDate: function(e) {
        if (!e || Ext.isDate(e)) {
            return e
        }
        var t = this,
        n = t.safeParse(e, t.format),
        r = t.altFormats,
        i = t.altFormatsArray,
        s = 0,
        o;
        if (!n && r) {
            i = i || r.split("|");
            o = i.length;
            for (; s < o && !n; ++s) {
                n = t.safeParse(e, i[s])
            }
        }
        return n
    },
    formatDate: function(e) {
        return Ext.isDate(e) ? Ext.Date.dateFormat(e, this.format) : e
    },
    createPicker: function() {
        var e = this,
        t = Ext.String.format;
        return new Ext.picker.Date({
            pickerField: e,
            renderTo: document.body,
            floating: true,
            hidden: true,
            focusOnShow: true,
            minDate: e.minValue,
            maxDate: e.maxValue,
            disabledDatesRE: e.disabledDatesRE,
            disabledDatesText: e.disabledDatesText,
            disabledDays: e.disabledDays,
            disabledDaysText: e.disabledDaysText,
            format: e.format,
            showToday: e.showToday,
            startDay: e.startDay,
            minText: t(e.minText, e.formatDate(e.minValue)),
            maxText: t(e.maxText, e.formatDate(e.maxValue)),
            listeners: {
                scope: e,
                select: e.onSelect
            },
            keyNavConfig: {
                esc: function() {
                    e.collapse();
                    e.focus()
                }
            }
        })
    },
    onDownArrow: function(e) {
        this.callParent(arguments);
        if (this.isExpanded) {
            this.getPicker().focus()
        }
    },
    onSelect: function(e, t) {
        var n = this;
        n.setValue(t);
        n.fireEvent("select", n, t);
        n.collapse();
        n.focus(false, 50)
    },
    onExpand: function() {
        var e = this.getValue();
        this.picker.setValue(Ext.isDate(e) ? e: new Date)
    },
    beforeBlur: function() {
        var e = this,
        t = e.rawToValue(e.getRawValue());
        if (Ext.isDate(t)) {
            e.setValue(t)
        }
    }
});Ext.define("Ext.form.field.FileButton", {
    extend: Ext.button.Button,
    alias: "widget.filebutton",
    childEls: ["btnEl", "btnWrap", "btnInnerEl", "btnIconEl", "fileInputEl"],
    inputCls: Ext.baseCSSPrefix + "form-file-input",
    cls: Ext.baseCSSPrefix + "form-file-btn",
    preventDefault: false,
    autoEl: {
        tag: "div",
        unselectable: "on"
    },
    renderTpl: ['<span id="{id}-btnWrap" role="presentation" class="{baseCls}-wrap', '<tpl if="splitCls"> {splitCls}</tpl>', '{childElCls}" unselectable="on">', '<span id="{id}-btnEl" class="{baseCls}-button" role="button">', '<span id="{id}-btnInnerEl" class="{baseCls}-inner {innerCls}', '{childElCls}" unselectable="on">', "{text}", "</span>", '<span role="presentation" id="{id}-btnIconEl" class="{baseCls}-icon-el {iconCls}', '{childElCls} {glyphCls}" unselectable="on" style="', '<tpl if="iconUrl">background-image:url({iconUrl});</tpl>', '<tpl if="glyph && glyphFontFamily">font-family:{glyphFontFamily};</tpl>">', '<tpl if="glyph">&#{glyph};</tpl><tpl if="iconCls || iconUrl">&#160;</tpl>', "</span>", "</span>", "</span>", '<input id="{id}-fileInputEl" class="{childElCls} {inputCls}" type="file" size="1" name="{inputName}" role="{role}" tabIndex="{tabIndex}">'],
    getTemplateArgs: function() {
        var e = this.callParent();
        e.inputCls = this.inputCls;
        e.inputName = this.inputName;
        e.tabIndex = this.ownerCt.tabIndex;
        return e
    },
    afterRender: function() {
        var e = this;
        e.callParent(arguments);
        e.fileInputEl.on("change", e.fireChange, e)
    },
    fireChange: function(e) {
        this.fireEvent("change", this, e, this.fileInputEl.dom.value)
    },
    createFileInput: function(e) {
        var t = this;
        t.fileInputEl = t.el.createChild({
            name: t.inputName,
            id: !e ? t.id + "-fileInputEl": undefined,
            cls: t.inputCls,
            tag: "input",
            type: "file",
            size: 1,
            role: "button"
        });
        t.fileInputEl.on("change", t.fireChange, t)
    },
    reset: function(e) {
        if (e) {
            this.fileInputEl.remove()
        }
        this.createFileInput(!e)
    },
    restoreInput: function(e) {
        this.fileInputEl.remove();
        e = Ext.get(e);
        this.el.appendChild(e);
        this.fileInputEl = e
    },
    onDisable: function() {
        this.callParent();
        this.fileInputEl.dom.disabled = true
    },
    onEnable: function() {
        this.callParent();
        this.fileInputEl.dom.disabled = false
    }
});Ext.define("Ext.form.field.File", {
    extend: Ext.form.field.Trigger,
    alias: ["widget.filefield", "widget.fileuploadfield"],
    alternateClassName: ["Ext.form.FileUploadField", "Ext.ux.form.FileUploadField", "Ext.form.File"],
    buttonText: "Browse...",
    buttonOnly: false,
    buttonMargin: 3,
    clearOnSubmit: false,
    extraFieldBodyCls: Ext.baseCSSPrefix + "form-file-wrap",
    readOnly: true,
    submitValue: false,
    triggerNoEditCls: "",
    componentLayout: "triggerfield",
    childEls: ["browseButtonWrap"],
    onRender: function() {
        var e = this,
        t = e.id,
        n;
        e.callParent(arguments);
        if (e.itemId) {
            e.name = e.itemId
        }
        n = e.inputEl;
        n.dom.name = "";
        e.button = new Ext.form.field.FileButton(Ext.apply({
            renderTo: t + "-browseButtonWrap",
            ownerCt: e,
            ownerLayout: e.componentLayout,
            id: t + "-button",
            ui: e.ui,
            disabled: e.disabled,
            text: e.buttonText,
            style: e.buttonOnly ? "": e.getButtonMarginProp() + e.buttonMargin + "px",
            inputName: e.getName(),
            listeners: {
                scope: e,
                change: e.onFileChange
            }
        },
        e.buttonConfig));
        e.fileInputEl = e.button.fileInputEl;
        if (e.buttonOnly) {
            e.inputCell.setDisplayed(false);
            e.shrinkWrap = 3
        }
        e.browseButtonWrap.dom.style.width = e.browseButtonWrap.dom.lastChild.offsetWidth + e.button.getEl().getMargin("lr") + "px";
        if (Ext.isIE) {
            e.button.getEl().repaint()
        }
    },
    getTriggerMarkup: function() {
        return '<td id="' + this.id + '-browseButtonWrap" role="presentation"></td>'
    },
    onFileChange: function(e, t, n) {
        this.duringFileSelect = true;
        Ext.form.field.File.superclass.setValue.call(this, Wb.getFilename(n));
        delete this.duringFileSelect
    },
    didValueChange: function() {
        return !! this.duringFileSelect
    },
    setValue: Ext.emptyFn,
    reset: function(e) {
        var t = this,
        n;
        if (e === true) {
            n = t.clearOnSubmit
        } else {
            n = true
        }
        if (t.rendered) {
            t.button.reset(n);
            t.fileInputEl = t.button.fileInputEl;
            if (n) {
                t.inputEl.dom.value = "";
                Ext.form.field.File.superclass.setValue.call(this, null)
            }
        }
        t.callParent()
    },
    onShow: function() {
        this.callParent();
        this.button.updateLayout()
    },
    onDisable: function() {
        this.callParent();
        this.button.disable()
    },
    onEnable: function() {
        this.callParent();
        this.button.enable()
    },
    isFileUpload: function() {
        return true
    },
    extractFileInput: function() {
        var e = this,
        t;
        if (e.rendered) {
            t = e.button.fileInputEl.dom;
            e.reset(true)
        } else {
            t = document.createElement("input");
            t.type = "file";
            t.className = Ext.baseCSSPrefix + "hide-display";
            t.name = e.getName()
        }
        return t
    },
    restoreInput: function(e) {
        if (this.rendered) {
            var t = this.button;
            t.restoreInput(e);
            this.fileInputEl = t.fileInputEl
        }
    },
    onDestroy: function() {
        Ext.destroyMembers(this, "button");
        delete this.fileInputEl;
        this.callParent()
    },
    getButtonMarginProp: function() {
        return "margin-left:"
    }
});Ext.define("Ext.form.field.Hidden", {
    extend: Ext.form.field.Base,
    alias: ["widget.hiddenfield", "widget.hidden"],
    alternateClassName: "Ext.form.Hidden",
    inputType: "hidden",
    hideLabel: true,
    hidden: true,
    ariaRole: "presentation",
    initComponent: function() {
        this.formItemCls += "-hidden";
        this.callParent()
    },
    isEqual: function(e, t) {
        return this.isEqualAsString(e, t)
    },
    initEvents: Ext.emptyFn,
    setSize: Ext.emptyFn,
    setWidth: Ext.emptyFn,
    setHeight: Ext.emptyFn,
    setPosition: Ext.emptyFn,
    setPagePosition: Ext.emptyFn,
    markInvalid: Ext.emptyFn,
    clearInvalid: Ext.emptyFn,
    getValue: function() {
        return this.value
    },
    setValue: function(e) {
        this.value = e
    }
});Ext.define("Ext.picker.Color", {
    extend: Ext.Component,
    alias: "widget.colorpicker",
    alternateClassName: "Ext.ColorPalette",
    componentCls: Ext.baseCSSPrefix + "color-picker",
    selectedCls: Ext.baseCSSPrefix + "color-picker-selected",
    itemCls: Ext.baseCSSPrefix + "color-picker-item",
    value: null,
    clickEvent: "click",
    allowReselect: false,
    colors: ["000000", "993300", "333300", "003300", "003366", "000080", "333399", "333333", "800000", "FF6600", "808000", "008000", "008080", "0000FF", "666699", "808080", "FF0000", "FF9900", "99CC00", "339966", "33CCCC", "3366FF", "800080", "969696", "FF00FF", "FFCC00", "FFFF00", "00FF00", "00FFFF", "00CCFF", "993366", "C0C0C0", "FF99CC", "FFCC99", "FFFF99", "CCFFCC", "CCFFFF", "99CCFF", "CC99FF", "FFFFFF"],
    colorRe: /(?:^|\s)color-(.{6})(?:\s|$)/,
    renderTpl: ['<tpl for="colors">', '<a href="#" role="button" class="color-{.} {parent.itemCls}" hidefocus="on">', '<span class="{parent.itemCls}-inner" style="background:#{.}">&#160;</span>', "</a>", "</tpl>"],
    initComponent: function() {
        var e = this;
        e.callParent(arguments);
        e.addEvents("select");
        if (e.handler) {
            e.on("select", e.handler, e.scope, true)
        }
    },
    initRenderData: function() {
        var e = this;
        return Ext.apply(e.callParent(), {
            itemCls: e.itemCls,
            colors: e.colors
        })
    },
    onRender: function() {
        var e = this,
        t = e.clickEvent;
        e.callParent(arguments);
        e.mon(e.el, t, e.handleClick, e, {
            delegate: "a"
        });
        if (t != "click") {
            e.mon(e.el, "click", Ext.emptyFn, e, {
                delegate: "a",
                stopEvent: true
            })
        }
    },
    afterRender: function() {
        var e = this,
        t;
        e.callParent(arguments);
        if (e.value) {
            t = e.value;
            e.value = null;
            e.select(t, true)
        }
    },
    handleClick: function(e, t) {
        var n = this,
        r;
        e.stopEvent();
        if (!n.disabled) {
            r = t.className.match(n.colorRe)[1];
            n.select(r.toUpperCase())
        }
    },
    select: function(e, t) {
        var n = this,
        r = n.selectedCls,
        i = n.value,
        s;
        e = e.replace("#", "");
        if (!n.rendered) {
            n.value = e;
            return
        }
        if (e != i || n.allowReselect) {
            s = n.el;
            if (n.value) {
                s.down("a.color-" + i).removeCls(r)
            }
            s.down("a.color-" + e).addCls(r);
            n.value = e;
            if (t !== true) {
                n.fireEvent("select", n, e)
            }
        }
    },
    clear: function() {
        var e = this,
        t = e.value,
        n;
        if (t && e.rendered) {
            n = e.el.down("a.color-" + t);
            n.removeCls(e.selectedCls)
        }
        e.value = null
    },
    getValue: function() {
        return this.value || null
    }
});Ext.define("Ext.layout.component.field.HtmlEditor", {
    extend: Ext.layout.component.field.FieldContainer,
    alias: ["layout.htmleditor"],
    type: "htmleditor",
    naturalHeight: 150,
    naturalWidth: 300,
    beginLayout: function(e) {
        var t = this.owner,
        n;
        if (Ext.isGecko) {
            n = t.textareaEl.dom;
            this.lastValue = n.value;
            n.value = ""
        }
        this.callParent(arguments);
        e.toolbarContext = e.context.getCmp(t.toolbar);
        e.inputCmpContext = e.context.getCmp(t.inputCmp);
        e.textAreaContext = e.getEl("textareaEl");
        e.iframeContext = e.getEl("iframeEl")
    },
    beginLayoutCycle: function(e) {
        var t = this,
        n = e.widthModel,
        r = e.heightModel,
        i = t.owner,
        s = i.iframeEl,
        o = i.textareaEl;
        t.callParent(arguments);
        if (n.shrinkWrap) {
            s.setStyle("width", "");
            o.setStyle("width", "")
        } else {
            if (n.natural) {
                e.bodyCellContext.setWidth(t.naturalWidth)
            }
        }
        if (r.natural || r.shrinkWrap) {
            s.setHeight(t.naturalHeight);
            o.setHeight(t.naturalHeight)
        }
    },
    finishedLayout: function() {
        var e = this.owner;
        this.callParent(arguments);
        if (Ext.isIE9m && Ext.isIEQuirks) {
            e.el.repaint()
        }
        if (Ext.isGecko) {
            e.textareaEl.dom.value = this.lastValue
        }
    },
    publishOwnerWidth: function(e, t) {
        this.callParent(arguments);
        t -= e.inputCmpContext.getBorderInfo().width;
        e.textAreaContext.setWidth(t);
        e.iframeContext.setWidth(t)
    },
    publishInnerWidth: function(e, t) {
        var n = e.inputCmpContext.getBorderInfo().width,
        r = Ext.isStrict && Ext.isIE8m,
        i = e.widthModel.natural;
        this.callParent(arguments);
        t = e.bodyCellContext.props.width - n;
        if (i) {
            if (r) {
                t -= 2
            }
            e.textAreaContext.setWidth(t);
            e.iframeContext.setWidth(t)
        } else {
            if (r) {
                e.textAreaContext.setWidth(t)
            }
        }
    },
    publishInnerHeight: function(e, t) {
        var n = e.toolbarContext.getProp("height"),
        r = this.owner.sourceEditMode;
        this.callParent(arguments);
        t = e.bodyCellContext.props.height;
        if (n !== undefined) {
            t -= n + e.inputCmpContext.getFrameInfo().height;
            if (Ext.isIE8 && Ext.isStrict) {
                t -= 2
            } else {
                if (Ext.isIEQuirks && (Ext.isIE8 || Ext.isIE9)) {
                    t -= 4
                }
            }
            e.iframeContext.setHeight(t);
            e.textAreaContext.setHeight(t)
        } else {
            this.done = false
        }
    }
});Ext.define("Ext.form.field.HtmlEditor", {
    extend: Ext.form.FieldContainer,
    mixins: {
        field: Ext.form.field.Field
    },
    alias: "widget.htmleditor",
    alternateClassName: "Ext.form.HtmlEditor",
    componentLayout: "htmleditor",
    componentTpl: ["{beforeTextAreaTpl}", '<textarea id="{id}-textareaEl" name="{name}" tabIndex="-1" {inputAttrTpl}', ' class="{textareaCls}" autocomplete="off">', "{[Ext.util.Format.htmlEncode(values.value)]}", "</textarea>", "{afterTextAreaTpl}", "{beforeIFrameTpl}", '<iframe id="{id}-iframeEl" name="{iframeName}" frameBorder="0" {iframeAttrTpl}', ' src="{iframeSrc}" class="{iframeCls}"></iframe>', "{afterIFrameTpl}", {
        disableFormats: true
    }],
    stretchInputElFixed: true,
    subTplInsertions: ["beforeTextAreaTpl", "afterTextAreaTpl", "beforeIFrameTpl", "afterIFrameTpl", "iframeAttrTpl", "inputAttrTpl"],
    enableFormat: true,
    enableFontSize: true,
    enableColors: true,
    enableAlignments: true,
    enableLists: true,
    enableSourceEdit: true,
    enableLinks: true,
    enableFont: true,
    createLinkText: "Please enter the URL for the link:",
    defaultLinkValue: "http://",
    fontFamilies: ["Arial", "Courier New", "Tahoma", "Times New Roman", "Verdana"],
    defaultValue: Ext.isOpera || Ext.isIE6 ? "&#160;": "&#8203;",
    extraFieldBodyCls: Ext.baseCSSPrefix + "html-editor-wrap",
    initialized: false,
    activated: false,
    sourceEditMode: false,
    iframePad: 3,
    hideMode: "offsets",
    maskOnDisable: true,
    containerElCls: Ext.baseCSSPrefix + "html-editor-container",
    reStripQuotes: /^['"]*|['"]*$/g,
    initComponent: function() {
        var e = this;
        e.addEvents("initialize", "activate", "beforesync", "beforepush", "sync", "push", "editmodechange");
        e.items = [e.createToolbar(), e.createInputCmp()];
        e.layout = {
            type: "vbox",
            align: "stretch"
        };
        e.callParent(arguments);
        e.initField()
    },
    createInputCmp: function() {
        this.inputCmp = Ext.widget(this.getInputCmpCfg());
        return this.inputCmp
    },
    getInputCmpCfg: function() {
        var e = this,
        t = e.id + "-inputCmp",
        n = {
            id: t,
            name: e.name,
            textareaCls: Ext.baseCSSPrefix + "hidden",
            value: e.value,
            iframeName: Ext.id(),
            iframeSrc: Ext.SSL_SECURE_URL,
            iframeCls: Ext.baseCSSPrefix + "htmleditor-iframe"
        };
        e.getInsertionRenderData(n, e.subTplInsertions);
        return {
            flex: 1,
            xtype: "component",
            tpl: e.getTpl("componentTpl"),
            childEls: ["iframeEl", "textareaEl"],
            id: t,
            cls: Ext.baseCSSPrefix + "html-editor-input",
            data: n
        }
    },
    createToolbar: function() {
        this.toolbar = Ext.widget(this.getToolbarCfg());
        return this.toolbar
    },
    getToolbarCfg: function() {
        function u(t, n, s) {
            return {
                itemId: t,
                cls: i + "btn-icon",
                iconCls: i + "edit-" + t,
                enableToggle: n !== false,
                scope: e,
                handler: s || e.relayBtnCmd,
                clickEvent: "mousedown",
                tooltip: r ? e.buttonTips[t] || o: o,
                overflowText: e.buttonTips[t].title || o,
                tabIndex: -1
            }
        }
        var e = this,
        t = [],
        n,
        r = Ext.quickTipsActive && Ext.tip.QuickTipManager.isEnabled(),
        i = Ext.baseCSSPrefix,
        s,
        o;
        if (e.enableFont && !Ext.isSafari2) {
            s = Ext.widget("component", {
                itemId: "fontSelect",
                renderTpl: ['<select id="{id}-selectEl" class="' + i + 'font-select">', "</select>"],
                childEls: ["selectEl"],
                afterRender: function() {
                    e.fontSelect = this.selectEl;
                    Ext.Component.prototype.afterRender.apply(this, arguments)
                },
                onDisable: function() {
                    var e = this.selectEl;
                    if (e) {
                        e.dom.disabled = true
                    }
                    Ext.Component.prototype.onDisable.apply(this, arguments)
                },
                onEnable: function() {
                    var e = this.selectEl;
                    if (e) {
                        e.dom.disabled = false
                    }
                    Ext.Component.prototype.onEnable.apply(this, arguments)
                },
                listeners: {
                    change: function() {
                        e.win.focus();
                        e.relayCmd("fontName", e.fontSelect.dom.value);
                        e.deferFocus()
                    },
                    element: "selectEl"
                }
            });
            t.push(s, "-")
        }
        if (e.enableFormat) {
            t.push(u("bold"), u("italic"), u("underline"))
        }
        if (e.enableFontSize) {
            t.push("-", u("increasefontsize", false, e.adjustFont), u("decreasefontsize", false, e.adjustFont))
        }
        if (e.enableColors) {
            t.push("-", {
                itemId: "forecolor",
                cls: i + "btn-icon",
                iconCls: i + "edit-forecolor",
                overflowText: e.buttonTips.forecolor.title,
                tooltip: r ? e.buttonTips.forecolor || o: o,
                tabIndex: -1,
                menu: Ext.widget("menu", {
                    plain: true,
                    items: [{
                        xtype: "colorpicker",
                        allowReselect: true,
                        focus: Ext.emptyFn,
                        value: "000000",
                        plain: true,
                        clickEvent: "mousedown",
                        handler: function(t, n) {
                            e.relayCmd("forecolor", Ext.isWebKit || Ext.isIE ? "#" + n: n);
                            this.up("menu").hide()
                        }
                    }]
                })
            },
            {
                itemId: "backcolor",
                cls: i + "btn-icon",
                iconCls: i + "edit-backcolor",
                overflowText: e.buttonTips.backcolor.title,
                tooltip: r ? e.buttonTips.backcolor || o: o,
                tabIndex: -1,
                menu: Ext.widget("menu", {
                    plain: true,
                    items: [{
                        xtype: "colorpicker",
                        focus: Ext.emptyFn,
                        value: "FFFFFF",
                        plain: true,
                        allowReselect: true,
                        clickEvent: "mousedown",
                        handler: function(t, n) {
                            if (Ext.isGecko) {
                                e.execCmd("useCSS", false);
                                e.execCmd("hilitecolor", "#" + n);
                                e.execCmd("useCSS", true);
                                e.deferFocus()
                            } else {
                                e.relayCmd(Ext.isOpera ? "hilitecolor": "backcolor", Ext.isWebKit || Ext.isIE || Ext.isOpera ? "#" + n: n)
                            }
                            this.up("menu").hide()
                        }
                    }]
                })
            })
        }
        if (e.enableAlignments) {
            t.push("-", u("justifyleft"), u("justifycenter"), u("justifyright"))
        }
        if (!Ext.isSafari2) {
            if (e.enableLinks) {
                t.push("-", u("createlink", false, e.createLink))
            }
            if (e.enableLists) {
                t.push("-", u("insertorderedlist"), u("insertunorderedlist"))
            }
            if (e.enableSourceEdit) {
                t.push("-", u("sourceedit", true,
                function(t) {
                    e.toggleSourceEdit(!e.sourceEditMode)
                }))
            }
        }
        for (n = 0; n < t.length; n++) {
            if (t[n].itemId !== "sourceedit") {
                t[n].disabled = true
            }
        }
        return {
            xtype: "toolbar",
            defaultButtonUI: e.defaultButtonUI,
            cls: Ext.baseCSSPrefix + "html-editor-tb",
            enableOverflow: true,
            items: t,
            listeners: {
                click: function(e) {
                    e.preventDefault()
                },
                element: "el"
            }
        }
    },
    getMaskTarget: function() {
        return Ext.isGecko ? this.inputCmp.el: this.bodyEl
    },
    setReadOnly: function(e) {
        var t = this,
        n = t.textareaEl,
        r = t.iframeEl,
        i;
        t.readOnly = e;
        if (n) {
            n.dom.readOnly = e
        }
        if (t.initialized) {
            i = t.getEditorBody();
            if (Ext.isIE) {
                r.setDisplayed(false);
                i.contentEditable = !e;
                r.setDisplayed(true)
            } else {
                t.setDesignMode(!e)
            }
            if (i) {
                i.style.cursor = e ? "default": "text"
            }
            t.disableItems(e)
        }
    },
    getDocMarkup: function() {
        var e = this,
        t = e.iframeEl.getHeight() - e.iframePad * 2,
        n = Ext.isIE8m;
        return Ext.String.format((n ? "": "<!DOCTYPE html>") + '<html><head><style type="text/css">' + (Ext.isOpera ? "p{margin:0;}": "") + "body{border:0;margin:0;padding:{0}px;direction:" + (e.rtl ? "rtl;": "ltr;") + (n ? Ext.emptyString: "min-") + "height:{1}px;box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;cursor:text;background-color:white;" + (Ext.isIE ? "": "font-size:12px;font-family:{2}") + "}</style></head><body></body></html>", e.iframePad, t, e.defaultFont)
    },
    getEditorBody: function() {
        var e = this.getDoc();
        return e.body || e.documentElement
    },
    getDoc: function() {
        return this.iframeEl.dom.contentDocument || this.getWin().document
    },
    getWin: function() {
        return this.iframeEl.dom.contentWindow || window.frames[this.iframeEl.dom.name]
    },
    initDefaultFont: function() {
        var e = this,
        t = 0,
        n, r, i, s, o, u, a;
        if (!e.defaultFont) {
            r = e.textareaEl.getStyle("font-family");
            r = Ext.String.capitalize(r.split(",")[0]);
            n = Ext.Array.clone(e.fontFamilies);
            Ext.Array.include(n, r);
            n.sort();
            e.defaultFont = r;
            i = e.down("#fontSelect").selectEl.dom;
            for (o = 0, u = n.length; o < u; ++o) {
                r = n[o];
                a = r.toLowerCase();
                s = new Option(r, a);
                if (r == e.defaultFont) {
                    t = o
                }
                s.style.fontFamily = a;
                if (Ext.isIE) {
                    i.add(s)
                } else {
                    i.options.add(s)
                }
            }
            i.options[t].selected = true
        }
    },
    isEqual: function(e, t) {
        return this.isEqualAsString(e, t)
    },
    afterRender: function() {
        var e = this,
        t = e.inputCmp;
        e.callParent(arguments);
        e.iframeEl = t.iframeEl;
        e.textareaEl = t.textareaEl;
        e.inputEl = e.iframeEl;
        if (e.enableFont) {
            e.initDefaultFont()
        }
        e.monitorTask = Ext.TaskManager.start({
            run: e.checkDesignMode,
            scope: e,
            interval: 100
        })
    },
    initFrameDoc: function() {
        var e = this,
        t, n;
        Ext.TaskManager.stop(e.monitorTask);
        t = e.getDoc();
        e.win = e.getWin();
        t.open();
        t.write(e.getDocMarkup());
        t.close();
        n = {
            run: function() {
                var t = e.getDoc();
                if (t.body || t.readyState === "complete") {
                    Ext.TaskManager.stop(n);
                    e.setDesignMode(true);
                    Ext.defer(e.initEditor, 10, e)
                }
            },
            interval: 10,
            duration: 1e4,
            scope: e
        };
        Ext.TaskManager.start(n)
    },
    checkDesignMode: function() {
        var e = this,
        t = e.getDoc();
        if (t && (!t.editorInitialized || e.getDesignMode() !== "on")) {
            e.initFrameDoc()
        }
    },
    setDesignMode: function(e) {
        var t = this,
        n = t.getDoc();
        if (n) {
            if (t.readOnly) {
                e = false
            }
            n.designMode = /on|true/i.test(String(e).toLowerCase()) ? "on": "off"
        }
    },
    getDesignMode: function() {
        var e = this.getDoc();
        return ! e ? "": String(e.designMode).toLowerCase()
    },
    disableItems: function(e) {
        var t = this.getToolbar().items.items,
        n,
        r = t.length,
        i;
        for (n = 0; n < r; n++) {
            i = t[n];
            if (i.getItemId() !== "sourceedit") {
                i.setDisabled(e)
            }
        }
    },
    toggleSourceEdit: function(e) {
        var t = this,
        n = t.iframeEl,
        r = t.textareaEl,
        i = Ext.baseCSSPrefix + "hidden",
        s = t.getToolbar().getComponent("sourceedit");
        if (!Ext.isBoolean(e)) {
            e = !t.sourceEditMode
        }
        t.sourceEditMode = e;
        if (s.pressed !== e) {
            s.toggle(e)
        }
        if (e) {
            t.disableItems(true);
            t.syncValue();
            n.addCls(i);
            r.removeCls(i);
            r.dom.removeAttribute("tabIndex");
            r.focus();
            t.inputEl = r
        } else {
            if (t.initialized) {
                t.disableItems(t.readOnly)
            }
            t.pushValue();
            n.removeCls(i);
            r.addCls(i);
            r.dom.setAttribute("tabIndex", -1);
            t.deferFocus();
            t.inputEl = n
        }
        t.fireEvent("editmodechange", t, e);
        t.updateLayout()
    },
    createLink: function() {
        var e = prompt(this.createLinkText, this.defaultLinkValue);
        if (e && e !== "http://") {
            this.relayCmd("createlink", e)
        }
    },
    clearInvalid: Ext.emptyFn,
    setValue: function(e) {
        var t = this,
        n = t.textareaEl,
        r = t.inputCmp;
        if (e === null || e === undefined) {
            e = ""
        }
        if (n) {
            n.dom.value = e
        }
        t.pushValue();
        if (!t.rendered && t.inputCmp) {
            t.inputCmp.data.value = e
        }
        t.mixins.field.setValue.call(t, e);
        return t
    },
    cleanHtml: function(e) {
        e = String(e);
        if (Ext.isWebKit) {
            e = e.replace(/\sclass="(?:Apple-style-span|Apple-tab-span|khtml-block-placeholder)"/gi, "")
        }
        if (e.charCodeAt(0) === parseInt(this.defaultValue.replace(/\D/g, ""), 10)) {
            e = e.substring(1)
        }
        return e
    },
    syncValue: function() {
        var e = this,
        t, n, r, i, s, o;
        if (e.initialized) {
            t = e.getEditorBody();
            r = t.innerHTML;
            o = e.textareaEl.dom;
            if (Ext.isWebKit) {
                i = t.getAttribute("style");
                s = i.match(/text-align:(.*?);/i);
                if (s && s[1]) {
                    r = '<div style="' + s[0] + '">' + r + "</div>"
                }
            }
            r = e.cleanHtml(r);
            if (e.fireEvent("beforesync", e, r) !== false) {
                if (Ext.isGecko && o.value === "" && r === "<br>") {
                    r = ""
                }
                if (o.value !== r) {
                    o.value = r;
                    n = true
                }
                e.fireEvent("sync", e, r);
                if (n) {
                    e.checkChange()
                }
            }
        }
    },
    getValue: function() {
        var e = this,
        t;
        if (!e.sourceEditMode) {
            e.syncValue()
        }
        t = e.rendered ? e.textareaEl.dom.value: e.value;
        e.value = t;
        return t
    },
    pushValue: function() {
        var e = this,
        t;
        if (e.initialized) {
            t = e.textareaEl.dom.value || "";
            if (!e.activated && t.length < 1) {
                t = e.defaultValue
            }
            if (e.fireEvent("beforepush", e, t) !== false) {
                e.getEditorBody().innerHTML = t;
                if (Ext.isGecko) {
                    e.setDesignMode(false);
                    e.setDesignMode(true)
                }
                e.fireEvent("push", e, t)
            }
        }
    },
    deferFocus: function() {
        this.focus(false, true)
    },
    getFocusEl: function() {
        var e = this,
        t = e.win;
        return t && !e.sourceEditMode ? t: e.textareaEl
    },
    focus: function(e, t) {
        var n = this,
        r, i;
        if (t) {
            if (!n.focusTask) {
                n.focusTask = new Ext.util.DelayedTask(n.focus)
            }
            n.focusTask.delay(Ext.isNumber(t) ? t: 10, null, n, [e, false])
        } else {
            if (e) {
                if (n.textareaEl && n.textareaEl.dom) {
                    r = n.textareaEl.dom.value
                }
                if (r && r.length) {
                    n.execCmd("selectall", true)
                }
            }
            i = n.getFocusEl();
            if (i && i.focus) {
                i.focus()
            }
        }
        return n
    },
    initEditor: function() {
        try {
            var e = this,
            t = e.getEditorBody(),
            n = e.textareaEl.getStyles("font-size", "font-family", "background-image", "background-repeat", "background-color", "color"),
            r,
            i;
            n["background-attachment"] = "fixed";
            t.bgProperties = "fixed";
            Ext.DomHelper.applyStyles(t, n);
            r = e.getDoc();
            if (r) {
                try {
                    Ext.EventManager.removeAll(r)
                } catch(s) {}
            }
            i = Ext.Function.bind(e.onEditorEvent, e);
            Ext.EventManager.on(r, {
                mousedown: i,
                dblclick: i,
                click: i,
                keyup: i,
                buffer: 100
            });
            i = e.onRelayedEvent;
            Ext.EventManager.on(r, {
                mousedown: i,
                mousemove: i,
                mouseup: i,
                click: i,
                dblclick: i,
                scope: e
            });
            if (Ext.isGecko) {
                Ext.EventManager.on(r, "keypress", e.applyCommand, e)
            }
            if (e.fixKeys) {
                Ext.EventManager.on(r, "keydown", e.fixKeys, e)
            }
            if (e.fixKeysAfter) {
                Ext.EventManager.on(r, "keyup", e.fixKeysAfter, e)
            }
            if (Ext.isIE9 && Ext.isStrict) {
                Ext.EventManager.on(r.documentElement, "focus", e.focus, e)
            }
            if (Ext.isIE8m || Ext.isIE9 && !Ext.isStrict) {
                Ext.EventManager.on(r, "focusout",
                function() {
                    e.savedSelection = r.selection.type !== "None" ? r.selection.createRange() : null
                },
                e);
                Ext.EventManager.on(r, "focusin",
                function() {
                    if (e.savedSelection) {
                        e.savedSelection.select()
                    }
                },
                e)
            }
            Ext.EventManager.onWindowUnload(e.beforeDestroy, e);
            r.editorInitialized = true;
            e.initialized = true;
            e.pushValue();
            e.setReadOnly(e.readOnly);
            e.fireEvent("initialize", e)
        } catch(o) {}
    },
    beforeDestroy: function() {
        var e = this,
        t = e.monitorTask,
        n, r;
        if (t) {
            Ext.TaskManager.stop(t)
        }
        if (e.rendered) {
            Ext.EventManager.removeUnloadListener(e.beforeDestroy, e);
            try {
                n = e.getDoc();
                if (n) {
                    Ext.EventManager.removeAll(Ext.fly(n));
                    for (r in n) {
                        if (n.hasOwnProperty && n.hasOwnProperty(r)) {
                            delete n[r]
                        }
                    }
                }
            } catch(i) {}
            e.iframeEl.remove();
            delete e.iframeEl;
            delete e.textareaEl;
            delete e.toolbar;
            delete e.inputCmp
        }
        e.callParent()
    },
    onRelayedEvent: function(e) {
        var t = this.iframeEl,
        n = Ext.Element.getTrueXY(t),
        r = e.getXY(),
        i = Ext.EventManager.getPageXY(e.browserEvent);
        e.xy = [n[0] + i[0], n[1] + i[1]];
        e.injectEvent(t);
        e.xy = r
    },
    onFirstFocus: function() {
        var e = this,
        t, n;
        e.activated = true;
        e.disableItems(e.readOnly);
        if (Ext.isGecko) {
            e.win.focus();
            t = e.win.getSelection();
            if (t.focusNode && !e.getValue().length) {
                n = t.getRangeAt(0);
                n.selectNodeContents(e.getEditorBody());
                n.collapse(true);
                e.deferFocus()
            }
            try {
                e.execCmd("useCSS", true);
                e.execCmd("styleWithCSS", false)
            } catch(r) {}
        }
        e.fireEvent("activate", e)
    },
    adjustFont: function(e) {
        var t = e.getItemId() === "increasefontsize" ? 1 : -1,
        n = this.getDoc().queryCommandValue("FontSize") || "2",
        r = Ext.isString(n) && n.indexOf("px") !== -1,
        i;
        n = parseInt(n, 10);
        if (r) {
            if (n <= 10) {
                n = 1 + t
            } else {
                if (n <= 13) {
                    n = 2 + t
                } else {
                    if (n <= 16) {
                        n = 3 + t
                    } else {
                        if (n <= 18) {
                            n = 4 + t
                        } else {
                            if (n <= 24) {
                                n = 5 + t
                            } else {
                                n = 6 + t
                            }
                        }
                    }
                }
            }
            n = Ext.Number.constrain(n, 1, 6)
        } else {
            i = Ext.isSafari;
            if (i) {
                t *= 2
            }
            n = Math.max(1, n + t) + (i ? "px": 0)
        }
        this.relayCmd("FontSize", n)
    },
    onEditorEvent: function(e) {
        this.updateToolbar()
    },
    updateToolbar: function() {
        function f() {
            var e;
            for (t = 0, n = arguments.length, s; t < n; t++) {
                s = arguments[t];
                try {
                    e = i.queryCommandState(s)
                } catch(o) {
                    e = false
                }
                r[s].toggle(e)
            }
        }
        var e = this,
        t, n, r, i, s, o, u, a;
        if (e.readOnly) {
            return
        }
        if (!e.activated) {
            e.onFirstFocus();
            return
        }
        r = e.getToolbar().items.map;
        i = e.getDoc();
        if (e.enableFont && !Ext.isSafari2) {
            o = i.queryCommandValue("fontName");
            s = (o ? o.split(",")[0].replace(e.reStripQuotes, "") : e.defaultFont).toLowerCase();
            u = e.fontSelect.dom;
            if (s !== u.value || s != o) {
                u.value = s
            }
        }
        if (e.enableFormat) {
            f("bold", "italic", "underline")
        }
        if (e.enableAlignments) {
            f("justifyleft", "justifycenter", "justifyright")
        }
        if (!Ext.isSafari2 && e.enableLists) {
            f("insertorderedlist", "insertunorderedlist")
        }
        a = e.toolbar.query("menu");
        for (t = 0; t < a.length; t++) {
            a[t].hide()
        }
        e.syncValue()
    },
    relayBtnCmd: function(e) {
        this.relayCmd(e.getItemId())
    },
    relayCmd: function(e, t) {
        Ext.defer(function() {
            var n = this;
            if (!this.isDestroyed) {
                n.win.focus();
                n.execCmd(e, t);
                n.updateToolbar()
            }
        },
        10, this)
    },
    execCmd: function(e, t) {
        var n = this,
        r = n.getDoc();
        r.execCommand(e, false, t == undefined ? null: t);
        n.syncValue()
    },
    applyCommand: function(e) {
        if (e.ctrlKey) {
            var t = this,
            n = e.getCharCode(),
            r;
            if (n > 0) {
                n = String.fromCharCode(n);
                switch (n) {
                case "b":
                    r = "bold";
                    break;
                case "i":
                    r = "italic";
                    break;
                case "u":
                    r = "underline";
                    break
                }
                if (r) {
                    t.win.focus();
                    t.execCmd(r);
                    t.deferFocus();
                    e.preventDefault()
                }
            }
        }
    },
    insertAtCursor: function(e) {
        var t = this,
        n;
        if (t.activated) {
            t.win.focus();
            if (Ext.isIE) {
                n = t.getDoc().selection.createRange();
                if (n) {
                    n.pasteHTML(e);
                    t.syncValue();
                    t.deferFocus()
                }
            } else {
                t.execCmd("InsertHTML", e);
                t.deferFocus()
            }
        }
    },
    fixKeys: function() {
        var e;
        if (Ext.isIE) {
            return function(t) {
                var n = this,
                r = t.getKey(),
                i = n.getDoc(),
                s = n.readOnly,
                o,
                u;
                if (r === t.TAB) {
                    t.stopEvent();
                    if (!s) {
                        o = i.selection.createRange();
                        if (o) {
                            if (o.collapse) {
                                o.collapse(true);
                                o.pasteHTML("&#160;&#160;&#160;&#160;")
                            }
                            n.deferFocus()
                        }
                    }
                } else {
                    if (r === t.ENTER) {
                        if (!s) {
                            if (Ext.isIE10m) {
                                o = i.selection.createRange();
                                if (o) {
                                    u = o.parentElement();
                                    if (!u || u.tagName.toLowerCase() !== "li") {
                                        t.stopEvent();
                                        o.pasteHTML("<br />");
                                        o.collapse(false);
                                        o.select()
                                    }
                                }
                            } else {
                                o = i.getSelection().getRangeAt(0);
                                if (o && o.commonAncestorContainer.parentNode.tagName.toLowerCase() !== "li") {
                                    t.stopEvent();
                                    e = i.createElement("div");
                                    o.insertNode(e)
                                }
                            }
                        }
                    }
                }
            }
        }
        if (Ext.isOpera) {
            return function(e) {
                var t = this,
                n = e.getKey(),
                r = t.readOnly;
                if (n === e.TAB) {
                    e.stopEvent();
                    if (!r) {
                        t.win.focus();
                        t.execCmd("InsertHTML", "&#160;&#160;&#160;&#160;");
                        t.deferFocus()
                    }
                }
            }
        }
        return null
    } (),
    fixKeysAfter: function() {
        if (Ext.isIE) {
            return function(e) {
                var t = this,
                n = e.getKey(),
                r = t.getDoc(),
                i = t.readOnly,
                s;
                if (!i && (n === e.BACKSPACE || n === e.DELETE)) {
                    s = r.body.innerHTML;
                    if (s === "<p>&nbsp;</p>" || s === "<P>&nbsp;</P>") {
                        r.body.innerHTML = ""
                    }
                }
            }
        }
        return null
    } (),
    getToolbar: function() {
        return this.toolbar
    },
    buttonTips: {
        bold: {
            title: "Bold (Ctrl+B)",
            text: "Make the selected text bold.",
            cls: Ext.baseCSSPrefix + "html-editor-tip"
        },
        italic: {
            title: "Italic (Ctrl+I)",
            text: "Make the selected text italic.",
            cls: Ext.baseCSSPrefix + "html-editor-tip"
        },
        underline: {
            title: "Underline (Ctrl+U)",
            text: "Underline the selected text.",
            cls: Ext.baseCSSPrefix + "html-editor-tip"
        },
        increasefontsize: {
            title: "Grow Text",
            text: "Increase the font size.",
            cls: Ext.baseCSSPrefix + "html-editor-tip"
        },
        decreasefontsize: {
            title: "Shrink Text",
            text: "Decrease the font size.",
            cls: Ext.baseCSSPrefix + "html-editor-tip"
        },
        backcolor: {
            title: "Text Highlight Color",
            text: "Change the background color of the selected text.",
            cls: Ext.baseCSSPrefix + "html-editor-tip"
        },
        forecolor: {
            title: "Font Color",
            text: "Change the color of the selected text.",
            cls: Ext.baseCSSPrefix + "html-editor-tip"
        },
        justifyleft: {
            title: "Align Text Left",
            text: "Align text to the left.",
            cls: Ext.baseCSSPrefix + "html-editor-tip"
        },
        justifycenter: {
            title: "Center Text",
            text: "Center text in the editor.",
            cls: Ext.baseCSSPrefix + "html-editor-tip"
        },
        justifyright: {
            title: "Align Text Right",
            text: "Align text to the right.",
            cls: Ext.baseCSSPrefix + "html-editor-tip"
        },
        insertunorderedlist: {
            title: "Bullet List",
            text: "Start a bulleted list.",
            cls: Ext.baseCSSPrefix + "html-editor-tip"
        },
        insertorderedlist: {
            title: "Numbered List",
            text: "Start a numbered list.",
            cls: Ext.baseCSSPrefix + "html-editor-tip"
        },
        createlink: {
            title: "Hyperlink",
            text: "Make the selected text a hyperlink.",
            cls: Ext.baseCSSPrefix + "html-editor-tip"
        },
        sourceedit: {
            title: "Source Edit",
            text: "Switch to source editing mode.",
            cls: Ext.baseCSSPrefix + "html-editor-tip"
        }
    }
});Ext.define("Ext.picker.Time", {
    extend: Ext.view.BoundList,
    alias: "widget.timepicker",
    increment: 15,
    format: "g:i A",
    displayField: "disp",
    initDate: [2008, 0, 1],
    componentCls: Ext.baseCSSPrefix + "timepicker",
    loadMask: false,
    initComponent: function() {
        var e = this,
        t = Ext.Date,
        n = t.clearTime,
        r = e.initDate;
        e.absMin = n(new Date(r[0], r[1], r[2]));
        e.absMax = t.add(n(new Date(r[0], r[1], r[2])), "mi", 24 * 60 - 1);
        e.store = e.createStore();
        e.store.addFilter(e.rangeFilter = new Ext.util.Filter({
            id: "time-picker-filter"
        }), false);
        e.updateList();
        e.callParent()
    },
    setMinValue: function(e) {
        this.minValue = e;
        this.updateList()
    },
    setMaxValue: function(e) {
        this.maxValue = e;
        this.updateList()
    },
    normalizeDate: function(e) {
        var t = this.initDate;
        e.setFullYear(t[0], t[1], t[2]);
        return e
    },
    updateList: function() {
        var e = this,
        t = e.normalizeDate(e.minValue || e.absMin),
        n = e.normalizeDate(e.maxValue || e.absMax);
        e.rangeFilter.setFilterFn(function(e) {
            var r = e.get("date");
            return r >= t && r <= n
        });
        e.store.filter()
    },
    createStore: function() {
        var e = this,
        t = Ext.Date,
        n = [],
        r = e.absMin,
        i = e.absMax;
        while (r <= i) {
            n.push({
                disp: t.dateFormat(r, e.format),
                date: r
            });
            r = t.add(r, "mi", e.increment)
        }
        return new Ext.data.Store({
            model: e.modelType,
            autoDestroy: true,
            data: n
        })
    },
    focusNode: function(e) {
        return false
    }
},
function() {
    this.prototype.modelType = Ext.define(null, {
        extend: "Ext.data.Model",
        fields: ["disp", "date"]
    })
});Ext.define("Ext.form.field.Time", {
    extend: Ext.form.field.ComboBox,
    alias: "widget.timefield",
    alternateClassName: ["Ext.form.TimeField", "Ext.form.Time"],
    triggerCls: Ext.baseCSSPrefix + "form-time-trigger",
    minText: "The time in this field must be equal to or after {0}",
    maxText: "The time in this field must be equal to or before {0}",
    invalidText: "{0} is not a valid time",
    format: "g:i A",
    altFormats: "g:ia|g:iA|g:i a|g:i A|h:i|g:i|H:i|ga|ha|gA|h a|g a|g A|gi|hi|gia|hia|g|H|gi a|hi a|giA|hiA|gi A|hi A",
    increment: 15,
    pickerMaxHeight: 300,
    selectOnTab: true,
    snapToIncrement: false,
    initDate: "1/1/2008",
    initDateParts: [2008, 0, 1],
    initDateFormat: "j/n/Y",
    ignoreSelection: 0,
    queryMode: "local",
    displayField: "disp",
    valueField: "date",
    initComponent: function() {
        var e = this,
        t = e.minValue,
        n = e.maxValue;
        if (t) {
            e.setMinValue(t)
        }
        if (n) {
            e.setMaxValue(n)
        }
        e.store = e.getPicker().store;
        e.displayTpl = new Ext.XTemplate('<tpl for=".">{[typeof values === "string" ? values : this.formatDate(values["' + e.displayField + '"])]}<tpl if="xindex < xcount">' + e.delimiter + "</tpl></tpl>", {
            formatDate: Ext.Function.bind(e.formatDate, e)
        });
        e.callParent()
    },
    transformOriginalValue: function(e) {
        if (Ext.isDefined(e)) {
            return this.rawToValue(e) || e || null
        }
        return e
    },
    isEqual: function(e, t) {
        var n = Ext.Array.from,
        r = this.isEqualAsString,
        i, s;
        e = n(e);
        t = n(t);
        s = e.length;
        if (s !== t.length) {
            return false
        }
        for (i = 0; i < s; i++) {
            if (!r(t[i], e[i])) {
                return false
            }
        }
        return true
    },
    setMinValue: function(e) {
        var t = this,
        n = t.picker;
        t.setLimit(e, true);
        if (n) {
            n.setMinValue(t.minValue)
        }
    },
    setMaxValue: function(e) {
        var t = this,
        n = t.picker;
        t.setLimit(e, false);
        if (n) {
            n.setMaxValue(t.maxValue)
        }
    },
    setLimit: function(e, t) {
        var n = this,
        r, i;
        if (Ext.isString(e)) {
            r = n.parseDate(e)
        } else {
            if (Ext.isDate(e)) {
                r = e
            }
        }
        if (r) {
            i = n.getInitDate();
            i.setHours(r.getHours(), r.getMinutes(), r.getSeconds(), r.getMilliseconds())
        } else {
            i = null
        }
        n[t ? "minValue": "maxValue"] = i
    },
    getInitDate: function(e, t, n, r) {
        var i = this.initDateParts;
        return new Date(i[0], i[1], i[2], e || 0, t || 0, n || 0, r || 0)
    },
    valueToRaw: function(e) {
        return this.formatDate(this.parseDate(e))
    },
    getErrors: function(e) {
        var t = this,
        n = Ext.String.format,
        r = t.callParent(arguments),
        i = t.minValue,
        s = t.maxValue,
        o = t.displayTplData,
        u = t.getRawValue(),
        a,
        f,
        l,
        c;
        if (o && o.length > 0) {
            for (a = 0, f = o.length; a < f; a++) {
                c = o[a];
                c = c.date || c.disp;
                l = t.parseDate(c);
                if (!l) {
                    r.push(n(t.invalidText, c, Ext.Date.unescapeFormat(t.format)));
                    continue
                }
                if (i && l < i) {
                    r.push(n(t.minText, t.formatDate(i)))
                }
                if (s && l > s) {
                    r.push(n(t.maxText, t.formatDate(s)))
                }
            }
        } else {
            if (u.length && !t.parseDate(u)) {
                r.push(n(t.invalidText, u, Ext.Date.unescapeFormat(t.format)))
            }
        }
        return r
    },
    formatDate: function(e) {
        var t = [],
        n,
        r;
        e = Ext.Array.from(e);
        for (n = 0, r = e.length; n < r; n++) {
            t.push(Ext.form.field.Date.prototype.formatDate.call(this, e[n]))
        }
        return t.join(this.delimiter)
    },
    parseDate: function(e) {
        var t = this,
        n = e,
        r = t.altFormats,
        i = t.altFormatsArray,
        s = 0,
        o;
        if (e && !Ext.isDate(e)) {
            n = t.safeParse(e, t.format);
            if (!n && r) {
                i = i || r.split("|");
                o = i.length;
                for (; s < o && !n; ++s) {
                    n = t.safeParse(e, i[s])
                }
            }
        }
        if (n && t.snapToIncrement) {
            n = new Date(Ext.Number.snap(n.getTime(), t.increment * 60 * 1e3))
        }
        return n
    },
    safeParse: function(e, t) {
        var n = this,
        r = Ext.Date,
        i, s = null;
        if (r.formatContainsDateInfo(t)) {
            s = r.parse(e, t)
        } else {
            i = r.parse(n.initDate + " " + e, n.initDateFormat + " " + t);
            if (i) {
                s = i
            }
        }
        return s
    },
    getSubmitValue: function() {
        var e = this,
        t = e.submitFormat || e.format,
        n = e.getValue();
        return n ? Ext.Date.format(n, t) : null
    },
    createPicker: function() {
        var e = this,
        t;
        e.listConfig = Ext.apply({
            xtype: "timepicker",
            selModel: {
                mode: e.multiSelect ? "SIMPLE": "SINGLE"
            },
            cls: undefined,
            minValue: e.minValue,
            maxValue: e.maxValue,
            increment: e.increment,
            format: e.format,
            maxHeight: e.pickerMaxHeight
        },
        e.listConfig);
        t = e.callParent();
        return t
    },
    onItemClick: function(e, t) {
        var n = this,
        r = e.getSelectionModel().getSelection();
        if (!n.multiSelect && r.length) {
            if (r.length > 0) {
                r = r[0];
                if (r && Ext.Date.isEqual(t.get("date"), r.get("date"))) {
                    n.collapse()
                }
            }
        }
    },
    syncSelection: function() {
        var e = this,
        t = e.picker,
        n = Ext.Date.isEqual,
        r = [],
        i,
        s,
        o,
        u,
        a,
        f,
        l,
        c,
        h,
        p;
        if (t) {
            t.clearHighlight();
            s = e.getValue();
            i = t.getSelectionModel();
            e.ignoreSelection++;
            if (s === null) {
                i.deselectAll()
            } else {
                o = Ext.Array.from(s);
                l = t.store.data.items;
                h = l.length;
                for (u = 0, a = o.length; u < a; u++) {
                    f = o[u];
                    if (Ext.isDate(f)) {
                        for (c = 0; c < h; c++) {
                            p = l[c];
                            if (n(p.get("date"), f)) {
                                r.push(p);
                                if (!e.multiSelect) {
                                    break
                                }
                            }
                        }
                        if (r.length) {
                            i.select(r)
                        }
                    }
                }
            }
            e.ignoreSelection--
        }
    },
    postBlur: function() {
        var e = this,
        t = e.getValue();
        e.callParent(arguments);
        if (e.validateValue(t)) {
            e.setValue(t)
        }
    },
    findRecordByValue: function(e) {
        if (typeof e === "string") {
            e = this.parseDate(e)
        }
        return this.callParent([e])
    },
    rawToValue: function(e) {
        var t = this,
        n, r, i, s;
        if (t.multiSelect) {
            r = [];
            n = Ext.Array.from(e);
            for (i = 0, s = n.length; i < s; i++) {
                r.push(t.parseDate(n[i]))
            }
            return r
        }
        return t.parseDate(e) || e || null
    },
    setValue: function(e) {
        this.getPicker();
        if (Ext.isDate(e)) {
            e = this.getInitDate(e.getHours(), e.getMinutes(), e.getSeconds(), e.getMilliseconds())
        }
        return this.callParent([e])
    },
    getValue: function() {
        return this.rawToValue(this.callParent(arguments))
    }
});Ext.define("Ext.grid.CellContext", {
    isCellContext: true,
    constructor: function(e) {
        this.view = e
    },
    isEqual: function(e) {
        if (e) {
            return this.record === e.record && this.columnHeader === e.columnHeader
        }
        return false
    },
    setPosition: function(e, t) {
        var n = this;
        if (arguments.length === 1) {
            if (e.view) {
                n.view = e.view
            }
            t = e.column;
            e = e.row
        }
        n.setRow(e);
        n.setColumn(t);
        return n
    },
    setRow: function(e) {
        var t = this;
        if (e !== undefined) {
            if (typeof e === "number") {
                t.row = Math.max(Math.min(e, t.view.dataSource.getCount() - 1), 0);
                t.record = t.view.dataSource.getAt(e)
            } else {
                if (e.isModel) {
                    t.record = e;
                    t.row = t.view.indexOf(e)
                } else {
                    if (e.tagName) {
                        t.record = t.view.getRecord(e);
                        t.row = t.view.indexOf(t.record)
                    }
                }
            }
        }
    },
    setColumn: function(e) {
        var t = this,
        n = t.view.ownerCt.getColumnManager();
        if (e !== undefined) {
            if (typeof e === "number") {
                t.column = e;
                t.columnHeader = n.getHeaderAtIndex(e)
            } else {
                if (e.isHeader) {
                    t.columnHeader = e;
                    t.column = n.getHeaderIndex(e)
                }
            }
        }
    }
});Ext.define("Ext.grid.CellEditor", {
    extend: Ext.Editor,
    y: 0,
    constructor: function(e) {
        e = Ext.apply({},
        e);
        if (e.field) {
            e.field.monitorTab = false
        }
        this.callParent([e])
    },
    setGrid: function(e) {
        var t = this,
        n = t.grid,
        r, i;
        if (e != n) {
            i = {
                beforerefresh: t.beforeViewRefresh,
                refresh: t.onViewRefresh,
                scope: t
            };
            if (n) {
                n.getView().un(i)
            }
            r = e.getView(),
            t.renderTo = r.getTargetEl().dom;
            t.grid = t.ownerCt = e;
            r.on(i)
        }
    },
    adjustPosition: function() {
        return {
            x: 0,
            y: 0
        }
    },
    beforeViewRefresh: function() {
        var e = this,
        t = e.el && e.el.dom;
        if (t && t.parentNode) {
            if (e.editing && !e.field.column.sorting) {
                e.wasAllowBlur = e.allowBlur;
                e.allowBlur = false
            }
            t.parentNode.removeChild(t)
        }
    },
    onViewRefresh: function() {
        var e = this,
        t = e.el && e.el.dom,
        n;
        if (t) {
            if (e.field.column) {
                n = e.field.column.sorting
            } else {
                n = false
            }
            if (e.editing && !n) {
                e.allowBlur = e.wasAllowBlur;
                e.renderTo.appendChild(t);
                e.field.focus()
            } else {
                if (!n) {
                    Ext.getDetachedBody().dom.appendChild(t)
                }
            }
            if (e.editing && n) {
                e.completeEdit()
            }
        }
    },
    onShow: function() {
        var e = this,
        t = e.boundEl.first();
        if (e.el.dom.parentNode !== e.renderTo) {
            e.renderTo.appendChild(e.el.dom)
        }
        if (t) {
            if (e.isForTree) {
                t = t.child(e.treeNodeSelector)
            }
            t.hide()
        }
        e.callParent(arguments)
    },
    onHide: function() {
        var e = this,
        t = e.boundEl.first();
        if (t) {
            if (e.isForTree) {
                t = t.child(e.treeNodeSelector)
            }
            t.show()
        }
        e.callParent(arguments)
    },
    afterRender: function() {
        var e = this,
        t = e.field;
        e.callParent(arguments);
        if (t.isCheckbox) {
            t.mon(t.inputEl, {
                mousedown: e.onCheckBoxMouseDown,
                click: e.onCheckBoxClick,
                scope: e
            })
        }
    },
    onCheckBoxMouseDown: function() {
        this.completeEdit = Ext.emptyFn
    },
    onCheckBoxClick: function() {
        delete this.completeEdit;
        this.field.focus(false, 10)
    },
    realign: function(e) {
        var t = this,
        n = t.boundEl,
        r = n.first(),
        i = r.dom.firstChild,
        s = n.getWidth(),
        o = Ext.Array.clone(t.offsets),
        u = t.grid,
        a,
        f = "",
        l = !i || i.nodeType === 3 && !Ext.String.trim(f = i.data).length;
        if (t.isForTree) {
            a = t.getTreeNodeOffset(r);
            s -= Math.abs(a);
            o[0] += a
        }
        if (u.columnLines) {
            s -= n.getBorderWidth("rl")
        }
        if (e === true) {
            t.field.setWidth(s)
        }
        if (l) {
            r.dom.innerHTML = "X"
        }
        t.alignTo(r, t.alignment, o);
        if (l) {
            r.dom.firstChild.data = f
        }
    },
    getTreeNodeOffset: function(e) {
        return e.child(this.treeNodeSelector).getOffsetsTo(e)[0]
    },
    onEditorTab: function(e) {
        var t = this.field;
        if (t.onEditorTab) {
            t.onEditorTab(e)
        }
    },
    onFieldBlur: function() {
        this.callParent(arguments);
        this.selectSameEditor = false
    },
    alignment: "tl-tl?",
    hideEl: false,
    cls: Ext.baseCSSPrefix + "small-editor " + Ext.baseCSSPrefix + "grid-editor " + Ext.baseCSSPrefix + "grid-cell-editor",
    treeNodeSelector: "." + Ext.baseCSSPrefix + "tree-node-text",
    shim: false,
    shadow: false
});Ext.define("Ext.grid.ColumnComponentLayout", {
    extend: Ext.layout.component.Auto,
    alias: "layout.columncomponent",
    type: "columncomponent",
    setWidthInDom: true,
    beginLayout: function(e) {
        this.callParent(arguments);
        e.titleContext = e.getEl("titleEl");
        e.triggerContext = e.getEl("triggerEl")
    },
    beginLayoutCycle: function(e) {
        var t = this.owner;
        this.callParent(arguments);
        if (e.widthModel.shrinkWrap) {
            t.el.setWidth("")
        }
        t.titleEl.setStyle({
            paddingTop: "",
            paddingBottom: ""
        })
    },
    publishInnerHeight: function(e, t) {
        var n = this,
        r = n.owner,
        i, s, o, u, a, f;
        if (r.getOwnerHeaderCt().hiddenHeaders) {
            e.setProp("innerHeight", 0);
            return
        }
        i = t - e.getBorderInfo().height;
        s = i;
        if (!r.noWrap && !e.hasDomProp("width")) {
            n.done = false;
            return
        }
        if (e.hasRawContent) {
            u = s;
            o = r.textEl.getHeight();
            if (o) {
                s -= o;
                if (s > 0) {
                    a = Math.floor(s / 2);
                    f = s - a;
                    e.titleContext.setProp("padding-top", a);
                    e.titleContext.setProp("padding-bottom", f)
                }
            }
        } else {
            u = r.titleEl.getHeight();
            e.setProp("innerHeight", i - u, false)
        }
        if ((Ext.isIE6 || Ext.isIEQuirks) && e.triggerContext) {
            e.triggerContext.setHeight(u)
        }
    },
    measureContentHeight: function(e) {
        return e.el.dom.offsetHeight
    },
    publishOwnerHeight: function(e, t) {
        this.callParent(arguments);
        if ((Ext.isIE6 || Ext.isIEQuirks) && e.triggerContext) {
            e.triggerContext.setHeight(t)
        }
    },
    publishInnerWidth: function(e, t) {
        if (!e.hasRawContent) {
            e.setProp("innerWidth", t - e.getBorderInfo().width, false)
        }
    },
    calculateOwnerHeightFromContentHeight: function(e, t) {
        var n = this.callParent(arguments);
        if (!e.hasRawContent) {
            if (this.owner.noWrap || e.hasDomProp("width")) {
                return t + this.owner.titleEl.getHeight() + e.getBorderInfo().height
            }
            return null
        }
        return n
    },
    calculateOwnerWidthFromContentWidth: function(e, t) {
        var n = this.owner,
        r = e.getPaddingInfo().width,
        i = this.getTriggerOffset(n, e),
        s;
        if (n.isGroupHeader) {
            s = t
        } else {
            s = Math.max(t, n.textEl.getWidth() + e.titleContext.getPaddingInfo().width)
        }
        return s + r + i
    },
    getTriggerOffset: function(e, t) {
        var n = 0;
        if (t.widthModel.shrinkWrap && !e.menuDisabled) {
            if (e.query(">:not([hidden])").length === 0) {
                n = e.self.triggerElWidth
            }
        }
        return n
    }
});Ext.define("Ext.grid.ColumnLayout", {
    extend: Ext.layout.container.HBox,
    alias: "layout.gridcolumn",
    type: "gridcolumn",
    reserveOffset: false,
    firstHeaderCls: Ext.baseCSSPrefix + "column-header-first",
    lastHeaderCls: Ext.baseCSSPrefix + "column-header-last",
    initLayout: function() {
        var e = this;
        if (e.scrollbarWidth === undefined) {
            e.self.prototype.scrollbarWidth = Ext.getScrollbarSize().width
        }
        e.grid = e.owner.up("tablepanel");
        e.controllingGrid = e.owner.up("[scrollerOwner]");
        e.callParent()
    },
    beginLayout: function(e) {
        var t = this,
        n = t.owner,
        r = t.controllingGrid,
        i = t.grid.view,
        s = t.getVisibleItems(),
        o = s.length,
        u = t.firstHeaderCls,
        a = t.lastHeaderCls,
        f = [u, a],
        l,
        c;
        if (!i.scrollFlags.y) {
            t.scrollbarWidth = 0
        } else {
            delete t.scrollbarWidth
        }
        for (l = 0; l < o; l++) {
            c = s[l];
            c.margin = null;
            c.removeCls(f);
            if (l === 0) {
                c.addCls(u)
            }
            if (l === o - 1) {
                c.addCls(a)
            }
        }
        t.scrollbarAdjustment = t.scrollbarWidth;
        t.callParent(arguments);
        if (!n.isColumn && !r.collapsed && i && i.rendered && (e.viewTable = i.body.dom) && t.scrollbarWidth) {
            e.viewContext = e.context.getCmp(i)
        }
    },
    injectViewContext: function(e, t) {
        if (!this.controllingGrid.collapsed && t.rendered && (e.viewTable = t.body.dom) && this.scrollbarWidth) {
            e.viewContext = e.context.getCmp(t)
        }
    },
    roundFlex: function(e) {
        return Math.floor(e)
    },
    calculate: function(e) {
        this.callParent(arguments);
        if (e.state.parallelDone && !(this.owner.forceFit && !e.state.flexesCalculated)) {
            e.setProp("columnWidthsDone", true)
        }
        if (e.viewContext) {
            e.state.tableHeight = e.viewTable.offsetHeight
        }
    },
    completeLayout: function(e) {
        var t = this,
        n = t.owner,
        r = e.state;
        t.callParent(arguments);
        if (e.viewTable && !r.flexesCalculated && !e.flexedItems.length && n.forceFit && t.convertWidthsToFlexes(e)) {
            t.cacheFlexes(e);
            e.invalidate({
                state: {
                    flexesCalculated: true,
                    tableHeight: e.viewTable.offsetHeight
                }
            })
        } else {
            e.setProp("columnWidthsDone", true)
        }
    },
    finishedLayout: function(e) {
        var t = this.grid.getView();
        this.callParent(arguments);
        if (!this.owner.isColumn && t.scrollFlags.x && this.owner.tooNarrow && this.owner.componentLayoutCounter) {
            this.owner.el.dom.scrollLeft = t.el.dom.scrollLeft
        }
    },
    convertWidthsToFlexes: function(e) {
        var t = this,
        n = 0,
        r = t.sizeModels.calculated,
        i, s, o, u, a;
        i = e.childItems;
        s = i.length;
        for (o = 0; o < s; o++) {
            u = i[o];
            a = u.target;
            n += u.props.width;
            if (! (a.fixed || a.resizable === false)) {
                a.flex = e.childItems[o].flex = u.props.width;
                a.width = null;
                u.widthModel = r
            }
        }
        return n !== e.props.width
    },
    getContainerSize: function(e) {
        var t = this,
        n, r = e.viewContext,
        i, s, o = r && r.heightModel.shrinkWrap;
        if (t.owner.isColumn) {
            n = t.getColumnContainerSize(e)
        } else {
            n = t.callParent(arguments);
            if (t.scrollbarWidth && !t.controllingGrid.reserveScrollbar && r) {
                s = r.target.componentLayout.ownerContext;
                if (!o && r.target.scrollFlags.y && (e.flexedItems && e.flexedItems.length || t.owner.forceFit) && s) {
                    i = r.getProp("height");
                    if (isNaN(i)) {
                        t.done = false
                    } else {
                        if (e.state.tableHeight <= i && r.target.scrollFlags.y) {
                            e.state.parallelDone = false;
                            s.invalidate();
                            return n
                        }
                    }
                }
            }
        }
        if (!o) {
            n.width -= t.scrollbarWidth
        }
        return n
    },
    getColumnContainerSize: function(e) {
        var t = e.paddingContext.getPaddingInfo(),
        n = 0,
        r = 0,
        i,
        s,
        o,
        u;
        if (!e.widthModel.shrinkWrap) {++r;
            o = e.getProp("innerWidth");
            i = typeof o == "number";
            if (i) {++n;
                o -= t.width;
                if (o < 0) {
                    o = 0
                }
            }
        }
        if (!e.heightModel.shrinkWrap) {++r;
            u = e.getProp("innerHeight");
            s = typeof u == "number";
            if (s) {++n;
                u -= t.height;
                if (u < 0) {
                    u = 0
                }
            }
        }
        return {
            width: o,
            height: u,
            needed: r,
            got: n,
            gotAll: n == r,
            gotWidth: i,
            gotHeight: s
        }
    },
    publishInnerCtSize: function(e) {
        var t = this,
        n = t.owner,
        r = e.state.boxPlan.targetSize,
        i = e.peek("contentWidth");
        t.owner.tooNarrow = e.state.boxPlan.tooNarrow;
        if (i != null && !n.isColumn) {
            r.width = i;
            if (n.ownerCt.view.scrollFlags.y) {
                r.width += t.scrollbarAdjustment
            }
        }
        return t.callParent(arguments)
    }
});Ext.define("Ext.grid.ColumnManager", {
    alternateClassName: ["Ext.grid.ColumnModel"],
    columns: null,
    constructor: function(e, t, n) {
        this.headerCt = t;
        if (n) {
            this.secondHeaderCt = n
        }
        this.visibleOnly = !!e
    },
    getColumns: function() {
        if (!this.columns) {
            this.cacheColumns()
        }
        return this.columns
    },
    getHeaderIndex: function(e) {
        if (e.isGroupHeader) {
            e = this.getHeaderColumns(e)[0]
        }
        return Ext.Array.indexOf(this.getColumns(), e)
    },
    getHeaderAtIndex: function(e) {
        var t = this.getColumns(),
        n = t[e];
        return n || null
    },
    getPreviousSibling: function(e) {
        var t = this.getHeaderIndex(e),
        n = null;
        if (t > 0) {
            n = this.getColumns()[t - 1]
        }
        return n
    },
    getNextSibling: function(e) {
        var t = this.getHeaderIndex(e),
        n;
        if (t !== -1) {
            n = this.getColumns()[t + 1]
        }
        return n || null
    },
    getFirst: function() {
        var e = this.getColumns();
        return e.length > 0 ? e[0] : null
    },
    getLast: function() {
        var e = this.getColumns(),
        t = e.length;
        return t > 0 ? e[t - 1] : null
    },
    getHeaderById: function(e) {
        var t = this.getColumns(),
        n = t.length,
        r,
        i;
        for (r = 0; r < n; ++r) {
            i = t[r];
            if (i.getItemId() === e) {
                return i
            }
        }
        return null
    },
    getVisibleHeaderClosestToIndex: function(e) {
        var t = this.getHeaderAtIndex(e);
        if (t && t.hidden) {
            t = t.next(":not([hidden])") || t.prev(":not([hidden])")
        }
        return t
    },
    cacheColumns: function() {
        var e = this.getHeaderColumns(this.headerCt),
        t = this.secondHeaderCt;
        if (t) {
            e = e.concat(this.getHeaderColumns(t))
        }
        this.columns = e
    },
    getHeaderColumns: function(e) {
        var t = this.visibleOnly ? e.getVisibleGridColumns() : e.getGridColumns();
        return Ext.Array.clone(t)
    },
    invalidate: function() {
        var e = this.rootColumns;
        this.columns = null;
        if (e) {
            e.invalidate()
        }
    },
    destroy: function() {
        this.columns = this.rootColumns = null
    }
},
function() {
    this.createAlias("indexOf", "getHeaderIndex")
});Ext.define("Ext.layout.container.Fit", {
    extend: Ext.layout.container.Container,
    alternateClassName: "Ext.layout.FitLayout",
    alias: "layout.fit",
    itemCls: Ext.baseCSSPrefix + "fit-item",
    targetCls: Ext.baseCSSPrefix + "layout-fit",
    type: "fit",
    defaultMargins: {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
    },
    manageMargins: true,
    sizePolicies: {
        0 : {
            readsWidth: 1,
            readsHeight: 1,
            setsWidth: 0,
            setsHeight: 0
        },
        1 : {
            readsWidth: 0,
            readsHeight: 1,
            setsWidth: 1,
            setsHeight: 0
        },
        2 : {
            readsWidth: 1,
            readsHeight: 0,
            setsWidth: 0,
            setsHeight: 1
        },
        3 : {
            readsWidth: 0,
            readsHeight: 0,
            setsWidth: 1,
            setsHeight: 1
        }
    },
    getItemSizePolicy: function(e, t) {
        var n = t || this.owner.getSizeModel(),
        r = (n.width.shrinkWrap ? 0 : 1) | (n.height.shrinkWrap ? 0 : 2);
        return this.sizePolicies[r]
    },
    beginLayoutCycle: function(e, t) {
        var n = this,
        r = n.lastHeightModel && n.lastHeightModel.calculated,
        i = n.lastWidthModel && n.lastWidthModel.calculated,
        s = i || r,
        o = 0,
        u = 0,
        a, f, l, c, h, p, d, v, m, g;
        n.callParent(arguments);
        if (s && e.targetContext.el.dom.tagName.toUpperCase() != "TD") {
            s = i = r = false
        }
        f = e.childItems;
        h = f.length;
        for (l = 0; l < h; ++l) {
            c = f[l];
            if (t) {
                a = c.target;
                d = a.minHeight;
                v = a.minWidth;
                if (v || d) {
                    p = c.marginInfo || c.getMarginInfo();
                    d += p.height;
                    v += p.height;
                    if (o < d) {
                        o = d
                    }
                    if (u < v) {
                        u = v
                    }
                }
            }
            if (s) {
                m = c.el.dom.style;
                if (r) {
                    m.height = ""
                }
                if (i) {
                    m.width = ""
                }
            }
        }
        if (t) {
            e.maxChildMinHeight = o;
            e.maxChildMinWidth = u
        }
        a = e.target;
        e.overflowX = !e.widthModel.shrinkWrap && e.maxChildMinWidth && a.scrollFlags.x || g;
        e.overflowY = !e.heightModel.shrinkWrap && e.maxChildMinHeight && a.scrollFlags.y || g
    },
    calculate: function(e) {
        var t = this,
        n = e.childItems,
        r = n.length,
        i = t.getContainerSize(e),
        s = {
            length: r,
            ownerContext: e,
            targetSize: i
        },
        o = e.widthModel.shrinkWrap,
        u = e.heightModel.shrinkWrap,
        a = e.overflowX,
        f = e.overflowY,
        l,
        c,
        h,
        p,
        d,
        v;
        if (a || f) {
            l = t.getScrollbarsNeeded(a && i.width, f && i.height, e.maxChildMinWidth, e.maxChildMinHeight);
            if (l) {
                c = Ext.getScrollbarSize();
                if (l & 1) {
                    i.height -= c.height
                }
                if (l & 2) {
                    i.width -= c.width
                }
            }
        }
        if (r > 0) {
            for (p = 0; p < r; ++p) {
                s.index = p;
                t.fitItem(n[p], s)
            }
        } else {
            s.contentWidth = s.contentHeight = 0
        }
        if (u || o) {
            h = e.targetContext.getPaddingInfo();
            if (o) {
                if (f && !i.gotHeight) {
                    t.done = false
                } else {
                    d = s.contentWidth + h.width;
                    if (l & 2) {
                        d += c.width
                    }
                    if (!e.setContentWidth(d)) {
                        t.done = false
                    }
                }
            }
            if (u) {
                if (a && !i.gotWidth) {
                    t.done = false
                } else {
                    v = s.contentHeight + h.height;
                    if (l & 1) {
                        v += c.height
                    }
                    if (!e.setContentHeight(v)) {
                        t.done = false
                    }
                }
            }
        }
    },
    fitItem: function(e, t) {
        var n = this;
        if (e.invalid) {
            n.done = false;
            return
        }
        t.margins = e.getMarginInfo();
        t.needed = t.got = 0;
        n.fitItemWidth(e, t);
        n.fitItemHeight(e, t);
        if (t.got != t.needed) {
            n.done = false
        }
    },
    fitItemWidth: function(e, t) {
        var n, r;
        if (t.ownerContext.widthModel.shrinkWrap) {
            r = e.getProp("width") + t.margins.width;
            n = t.contentWidth;
            if (n === undefined) {
                t.contentWidth = r
            } else {
                t.contentWidth = Math.max(n, r)
            }
        } else {
            if (e.widthModel.calculated) {++t.needed;
                if (t.targetSize.gotWidth) {++t.got;
                    this.setItemWidth(e, t)
                }
            }
        }
        this.positionItemX(e, t)
    },
    fitItemHeight: function(e, t) {
        var n, r;
        if (t.ownerContext.heightModel.shrinkWrap) {
            r = e.getProp("height") + t.margins.height;
            n = t.contentHeight;
            if (n === undefined) {
                t.contentHeight = r
            } else {
                t.contentHeight = Math.max(n, r)
            }
        } else {
            if (e.heightModel.calculated) {++t.needed;
                if (t.targetSize.gotHeight) {++t.got;
                    this.setItemHeight(e, t)
                }
            }
        }
        this.positionItemY(e, t)
    },
    positionItemX: function(e, t) {
        var n = t.margins;
        if (t.index || n.left) {
            e.setProp("x", n.left)
        }
        if (n.width) {
            e.setProp("margin-right", n.width)
        }
    },
    positionItemY: function(e, t) {
        var n = t.margins;
        if (t.index || n.top) {
            e.setProp("y", n.top)
        }
        if (n.height) {
            e.setProp("margin-bottom", n.height)
        }
    },
    setItemHeight: function(e, t) {
        e.setHeight(t.targetSize.height - t.margins.height)
    },
    setItemWidth: function(e, t) {
        e.setWidth(t.targetSize.width - t.margins.width)
    }
});Ext.define("Ext.layout.container.Center", {
    extend: "Ext.layout.container.Fit",
    alias: "layout.center",
    percentRe: /^\d+(?:\.\d+)?\%$/,
    itemCls: "ux-layout-center-item",
    initLayout: function() {
        this.callParent(arguments);
        this.owner.addCls("ux-layout-center")
    },
    getItemSizePolicy: function(e) {
        var t = this.callParent(arguments);
        if (typeof e.width == "number") {
            t = this.sizePolicies[t.setsHeight ? 2 : 0]
        }
        return t
    },
    getPos: function(e, t, n) {
        var r = e.props[n] + t.margins[n],
        i = Math.round((t.targetSize[n] - r) / 2);
        return Math.max(i, 0)
    },
    getSize: function(e, t, n) {
        var r = e[n];
        if (typeof r == "string" && this.percentRe.test(r)) {
            r = parseFloat(r) / 100
        } else {
            r = e[n + "Ratio"]
        }
        return t.targetSize[n] * (r || 1) - t.margins[n]
    },
    positionItemX: function(e, t) {
        var n = this.getPos(e, t, "width");
        e.setProp("x", n)
    },
    positionItemY: function(e, t) {
        var n = this.getPos(e, t, "height");
        e.setProp("y", n)
    },
    setItemHeight: function(e, t) {
        var n = this.getSize(e.target, t, "height");
        e.setHeight(n)
    },
    setItemWidth: function(e, t) {
        var n = this.getSize(e.target, t, "width");
        e.setWidth(n)
    }
});Ext.define("Ext.panel.Table", {
    extend: Ext.panel.Panel,
    alias: "widget.tablepanel",
    extraBaseCls: Ext.baseCSSPrefix + "grid",
    extraBodyCls: Ext.baseCSSPrefix + "grid-body",
    layout: "fit",
    hasView: false,
    viewType: null,
    selType: "rowmodel",
    scroll: true,
    deferRowRender: true,
    sortableColumns: true,
    multiColumnSort: false,
    enableLocking: false,
    scrollerOwner: true,
    enableColumnMove: true,
    sealedColumns: false,
    enableColumnResize: true,
    rowLines: true,
    colLinesCls: Ext.baseCSSPrefix + "grid-with-col-lines",
    rowLinesCls: Ext.baseCSSPrefix + "grid-with-row-lines",
    noRowLinesCls: Ext.baseCSSPrefix + "grid-no-row-lines",
    hiddenHeaderCtCls: Ext.baseCSSPrefix + "grid-header-ct-hidden",
    hiddenHeaderCls: Ext.baseCSSPrefix + "grid-header-hidden",
    resizeMarkerCls: Ext.baseCSSPrefix + "grid-resize-marker",
    emptyCls: Ext.baseCSSPrefix + "grid-empty",
    initComponent: function() {
        var e = this,
        t = e.columns || e.colModel || [],
        n,
        r,
        i,
        s = e.store = Ext.data.StoreManager.lookup(e.store || "ext-empty-store"),
        o;
        s.bindTable = e;
        if (s.maskBindObject) {
            s.mask = function() {
                return e
            }
        }
        if (e.plugins) {
            e.plugins = e.constructPlugins()
        }
        if (e.columnLines) {
            e.addBodyCls(e.colLinesCls)
        }
        e.addBodyCls(e.rowLines ? e.rowLinesCls: e.noRowLinesCls);
        e.addBodyCls(e.extraBodyCls);
        if (t.isRootHeader) {
            e.headerCt = t;
            e.headerCt.forceFit = !!e.forceFit;
            e.columnManager = t.columnManager;
            e.visibleColumnManager = t.visibleColumnManager;
            if (e.columnLines) {
                e.headerCt.cascade(function(e) {
                    if (!e.isColumn) {
                        e.columnLines = true
                    }
                })
            }
        } else {
            if (e.enableLocking || e.hasLockedColumns(t)) {
                e.self.mixin("lockable", Ext.grid.locking.Lockable);
                e.injectLockable()
            } else {
                if (Ext.isArray(t)) {
                    t = {
                        items: t
                    }
                }
                Ext.apply(t, {
                    grid: e,
                    forceFit: e.forceFit,
                    sortable: e.sortableColumns,
                    enableColumnMove: e.enableColumnMove,
                    enableColumnResize: e.enableColumnResize,
                    columnLines: e.columnLines,
                    sealed: e.sealedColumns
                });
                if (Ext.isDefined(e.enableColumnHide)) {
                    t.enableColumnHide = e.enableColumnHide
                }
                if (!e.headerCt) {
                    e.headerCt = new Ext.grid.header.Container(t)
                }
            }
        }
        e.columns = o = e.headerCt.getGridColumns();
        e.scrollTask = new Ext.util.DelayedTask(e.syncHorizontalScroll, e);
        e.addEvents("reconfigure", "viewready");
        e.cls = (e.cls || "") + (" " + e.extraBaseCls);
        delete e.autoScroll;
        if (!e.hasView) {
            if (s.buffered && !s.remoteSort) {
                for (r = 0, i = o.length; r < i; r++) {
                    o[r].sortable = false
                }
            }
            if (e.hideHeaders) {
                e.headerCt.height = 0;
                e.headerCt.hiddenHeaders = true;
                e.headerCt.addCls(e.hiddenHeaderCtCls);
                e.addCls(e.hiddenHeaderCls);
                if (Ext.isIEQuirks) {
                    e.headerCt.style = {
                        display: "none"
                    }
                }
            }
            e.relayHeaderCtEvents(e.headerCt);
            e.features = e.features || [];
            if (!Ext.isArray(e.features)) {
                e.features = [e.features]
            }
            e.dockedItems = [].concat(e.dockedItems || []);
            e.dockedItems.unshift(e.headerCt);
            e.viewConfig = e.viewConfig || {};
            n = e.getView();
            e.items = [n];
            e.hasView = true;
            if (!e.hideHeaders) {
                n.on({
                    scroll: {
                        fn: e.onHorizontalScroll,
                        element: "el",
                        scope: e
                    }
                })
            }
            e.bindStore(s, true);
            e.mon(n, {
                viewready: e.onViewReady,
                refresh: e.onRestoreHorzScroll,
                scope: e
            })
        }
        e.relayEvents(e.view, ["beforeitemmousedown", "beforeitemmouseup", "beforeitemmouseenter", "beforeitemmouseleave", "beforeitemclick", "beforeitemdblclick", "beforeitemcontextmenu", "itemmousedown", "itemmouseup", "itemmouseenter", "itemmouseleave", "itemclick", "itemdblclick", "itemcontextmenu", "beforecellclick", "cellclick", "beforecelldblclick", "celldblclick", "beforecellcontextmenu", "cellcontextmenu", "beforecellmousedown", "cellmousedown", "beforecellmouseup", "cellmouseup", "beforecellkeydown", "cellkeydown", "beforeitemkeydown", "itemkeydown", "beforecontainermousedown", "beforecontainermouseup", "beforecontainermouseover", "beforecontainermouseout", "beforecontainerclick", "beforecontainerdblclick", "beforecontainercontextmenu", "beforecontainerkeydown", "containermouseup", "containermousedown", "containermouseover", "containermouseout", "containerclick", "containerdblclick", "containercontextmenu", "containerkeydown", "selectionchange", "beforeselect", "select", "beforedeselect", "deselect"]);
        e.callParent(arguments);
        e.addStateEvents(["columnresize", "columnmove", "columnhide", "columnshow", "sortchange", "filterchange", "groupchange"])
    },
    hasLockedColumns: function(e) {
        var t, n, r;
        if (Ext.isObject(e)) {
            e = e.items
        }
        for (t = 0, n = e.length; t < n; t++) {
            r = e[t];
            if (!r.processed && r.locked) {
                return true
            }
        }
    },
    relayHeaderCtEvents: function(e) {
        this.relayEvents(e, ["columnresize", "columnmove", "columnhide", "columnshow", "columnschanged", "sortchange", "headerclick", "headercontextmenu", "headertriggerclick"])
    },
    getState: function() {
        var e = this,
        t = e.callParent(),
        n = e.store.getState();
        t = e.addPropertyToState(t, "columns", e.headerCt.getColumnsState());
        if (n) {
            t.storeState = n
        }
        return t
    },
    applyState: function(e) {
        var t = this,
        n = e.sort,
        r = e.storeState,
        i = t.store,
        s = e.columns;
        delete e.columns;
        t.callParent(arguments);
        if (s) {
            t.headerCt.applyColumnsState(s)
        }
        if (n) {
            if (i.remoteSort) {
                i.sort({
                    property: n.property,
                    direction: n.direction,
                    root: n.root
                },
                null, false)
            } else {
                i.sort(n.property, n.direction)
            }
        } else {
            if (r) {
                i.applyState(r)
            }
        }
    },
    getStore: function() {
        return this.store
    },
    getView: function() {
        var e = this,
        t;
        if (!e.view) {
            t = e.getSelectionModel();
            Ext.widget(Ext.apply({
                grid: e,
                deferInitialRefresh: e.deferRowRender !== false,
                trackOver: e.trackMouseOver !== false,
                scroll: e.scroll,
                xtype: e.viewType,
                store: e.store,
                headerCt: e.headerCt,
                columnLines: e.columnLines,
                rowLines: e.rowLines,
                selModel: t,
                features: e.features,
                panel: e,
                emptyText: e.emptyText || ""
            },
            e.viewConfig));
            if (e.view.emptyText) {
                e.view.emptyText = '<div class="' + e.emptyCls + '">' + e.view.emptyText + "</div>"
            }
            e.view.getComponentLayout().headerCt = e.headerCt;
            e.mon(e.view, {
                uievent: e.processEvent,
                scope: e
            });
            t.view = e.view;
            e.headerCt.view = e.view;
            if (e.hasListeners.viewcreated) {
                e.fireEvent("viewcreated", e, e.view)
            }
        }
        return e.view
    },
    getColumnManager: function() {
        return this.columnManager
    },
    getVisibleColumnManager: function() {
        return this.visibleColumnManager
    },
    getTopLevelColumnManager: function() {
        var e = this.ownerLockable;
        return e ? e.getColumnManager() : this.getColumnManager()
    },
    getTopLevelVisibleColumnManager: function() {
        var e = this.ownerLockable;
        return e ? e.getVisibleColumnManager() : this.getVisibleColumnManager()
    },
    setAutoScroll: Ext.emptyFn,
    processEvent: function(e, t, n, r, i, s, o, u) {
        var a = this,
        f;
        if (i !== -1) {
            f = a.getColumnManager().getHeaderAtIndex(i);
            return f.processEvent.apply(f, arguments)
        }
    },
    getSelection: function() {
        var e = this;
        return e.selModel.getSelection()
    },
    setSelection: function(e, t, n) {
        var r = this;
        return r.selModel.select(e, t, n)
    },
    determineScrollbars: function() {},
    invalidateScroller: function() {},
    scrollByDeltaY: function(e, t) {
        this.getView().scrollBy(0, e, t)
    },
    scrollByDeltaX: function(e, t) {
        this.getView().scrollBy(e, 0, t)
    },
    afterCollapse: function() {
        this.saveScrollPos();
        this.callParent(arguments)
    },
    afterExpand: function() {
        this.callParent(arguments);
        this.restoreScrollPos()
    },
    saveScrollPos: Ext.emptyFn,
    restoreScrollPos: Ext.emptyFn,
    onHeaderResize: Ext.emptyFn,
    onHeaderMove: function(e, t, n, r, i) {
        var s = this;
        if (s.optimizedColumnMove === false) {
            s.view.refreshView()
        } else {
            s.view.moveColumn(r, i, n)
        }
        s.delayScroll()
    },
    onHeaderHide: function(e, t) {
        if (this.view.refreshCounter) {
            this.view.refreshView()
        }
    },
    onHeaderShow: function(e, t) {
        if (this.view.refreshCounter) {
            this.view.refreshView()
        }
    },
    onHeadersChanged: function(e, t) {
        var n = this;
        if (n.rendered && !n.reconfiguring) {
            n.view.refreshView();
            n.delayScroll()
        }
    },
    delayScroll: function() {
        var e = this.getScrollTarget().el;
        if (e) {
            this.scrollTask.delay(10, null, null, [e.dom])
        }
    },
    onViewReady: function() {
        this.fireEvent("viewready", this)
    },
    onRestoreHorzScroll: function() {
        var e = this.scrollLeft;
        if (e) {
            this.syncHorizontalScroll(this, true)
        }
    },
    getScrollerOwner: function() {
        var e = this;
        if (!this.scrollerOwner) {
            e = this.up("[scrollerOwner]")
        }
        return e
    },
    getLhsMarker: function() {
        var e = this;
        return e.lhsMarker || (e.lhsMarker = Ext.DomHelper.append(e.el, {
            role: "presentation",
            cls: e.resizeMarkerCls
        },
        true))
    },
    getRhsMarker: function() {
        var e = this;
        return e.rhsMarker || (e.rhsMarker = Ext.DomHelper.append(e.el, {
            role: "presentation",
            cls: e.resizeMarkerCls
        },
        true))
    },
    getSelectionModel: function() {
        var e = this,
        t = e.selModel,
        n, r, i;
        if (!t) {
            t = {};
            n = true
        }
        if (!t.events) {
            i = t.selType || e.selType;
            n = !t.mode;
            t = e.selModel = Ext.create("selection." + i, t)
        }
        if (e.simpleSelect) {
            r = "SIMPLE"
        } else {
            if (e.multiSelect) {
                r = "MULTI"
            }
        }
        Ext.applyIf(t, {
            allowDeselect: e.allowDeselect
        });
        if (r && n) {
            t.setSelectionMode(r)
        }
        if (!t.hasRelaySetup) {
            e.relayEvents(t, ["selectionchange", "beforeselect", "beforedeselect", "select", "deselect"]);
            t.hasRelaySetup = true
        }
        if (e.disableSelection) {
            t.locked = true
        }
        return t
    },
    getScrollTarget: function() {
        var e = this.getScrollerOwner(),
        t = e.query("tableview");
        return t[1] || t[0]
    },
    onHorizontalScroll: function(e, t) {
        this.syncHorizontalScroll(t)
    },
    syncHorizontalScroll: function(e, t) {
        var n = this,
        r = e.scrollLeft,
        i;
        t = t === true;
        if (n.rendered && (t || r !== n.scrollLeft)) {
            if (t) {
                i = n.getScrollTarget();
                i.el.dom.scrollLeft = r
            }
            n.headerCt.el.dom.scrollLeft = r;
            n.scrollLeft = r
        }
    },
    onStoreLoad: Ext.emptyFn,
    getEditorParent: function() {
        return this.body
    },
    bindStore: function(e, t) {
        var n = this,
        r = n.getView(),
        i = e && e.buffered,
        s;
        if (e) {
            n.store = e;
            s = n.findPlugin("bufferedrenderer");
            if (s) {
                n.verticalScroller = s;
                if (s.store) {
                    s.bindStore(e)
                }
            } else {
                if (i) {
                    n.verticalScroller = s = n.addPlugin(Ext.apply({
                        ptype: "bufferedrenderer"
                    },
                    n.initialConfig.verticalScroller))
                }
            }
            if (r.store !== e) {
                r.bindStore(e, false)
            }
            n.mon(e, {
                load: n.onStoreLoad,
                scope: n
            });
            n.storeRelayers = n.relayEvents(e, ["filterchange", "groupchange"]);
            if (s) {
                n.invalidateScrollerOnRefresh = false
            }
            if (n.invalidateScrollerOnRefresh !== undefined) {
                r.preserveScrollOnRefresh = !n.invalidateScrollerOnRefresh
            }
        } else {
            n.unbindStore()
        }
    },
    unbindStore: function() {
        var e = this,
        t = e.store,
        n;
        if (t) {
            e.store = null;
            e.mun(t, {
                load: e.onStoreLoad,
                scope: e
            });
            Ext.destroy(e.storeRelayers);
            n = e.view;
            if (n.store) {
                n.bindStore(null)
            }
        }
    },
    reconfigure: function(e, t) {
        var n = this,
        r = n.getView(),
        i,
        s = n.store,
        o = n.headerCt,
        u = o ? o.items.getRange() : n.columns;
        if (n.rowNumber === false && t && t.length && t[0].xtype == "rownumberer") {
            t.splice(0, 1)
        }
        if (arguments.length === 1 && Ext.isArray(e)) {
            t = e;
            e = null
        }
        if (t) {
            t = Ext.Array.slice(t)
        }
        n.reconfiguring = true;
        n.fireEvent("beforereconfigure", n, e, t, s, u);
        if (n.lockable) {
            n.reconfigureLockable(e, t)
        } else {
            Ext.suspendLayouts();
            if (t) {
                delete n.scrollLeft;
                o.removeAll();
                o.add(t)
            }
            if (e && (e = Ext.StoreManager.lookup(e)) !== s) {
                if (n.store) {
                    n.unbindStore()
                }
                i = r.deferInitialRefresh;
                r.deferInitialRefresh = false;
                n.bindStore(e);
                r.deferInitialRefresh = i
            } else {
                n.getView().refreshView()
            }
            o.setSortState();
            Ext.resumeLayouts(true)
        }
        n.fireEvent("reconfigure", n, e, t, s, u);
        n.columns = n.headerCt.getGridColumns();
        delete n.reconfiguring
    },
    beforeDestroy: function() {
        var e = this.scrollTask;
        if (e) {
            e.cancel();
            this.scrollTask = null
        }
        this.callParent()
    },
    onDestroy: function() {
        var e = this;
        if (e.lockable) {
            e.destroyLockable()
        }
        e.callParent();
        e.columns = e.storeRelayers = e.columnManager = e.visibleColumnManager = null
    },
    destroy: function() {
        var e = this;
        e.callParent();
        if (e.isDestroyed) {
            e.view = e.selModel = e.headerCt = null
        }
    }
});Ext.define("Ext.util.CSS",
function() {
    var e, t = null,
    n = document,
    r = /(-[a-z])/gi,
    i = function(e, t) {
        return t.charAt(1).toUpperCase()
    };
    return {
        singleton: true,
        rules: t,
        initialized: false,
        constructor: function() {
            e = this
        },
        createStyleSheet: function(t, r) {
            var i, s = n.getElementsByTagName("head")[0],
            o = n.createElement("style");
            o.setAttribute("type", "text/css");
            if (r) {
                o.setAttribute("id", r)
            }
            i = o.styleSheet;
            if (i) {
                s.appendChild(o);
                i.cssText = t
            } else {
                o.appendChild(n.createTextNode(t));
                s.appendChild(o);
                i = o.sheet
            }
            e.cacheStyleSheet(i);
            return i
        },
        removeStyleSheet: function(e) {
            var t = n.getElementById(e);
            if (t) {
                t.parentNode.removeChild(t)
            }
        },
        swapStyleSheet: function(t, r) {
            var i;
            e.removeStyleSheet(t);
            i = n.createElement("link");
            i.setAttribute("rel", "stylesheet");
            i.setAttribute("type", "text/css");
            i.setAttribute("id", t);
            i.setAttribute("href", r);
            n.getElementsByTagName("head")[0].appendChild(i)
        },
        cacheStyleSheet: function(n) {
            if (!t) {
                t = e.rules = {}
            }
            try {
                var r = n.cssRules || n.rules,
                i = r.length - 1,
                s = n.imports,
                o = s ? s.length: 0,
                u,
                a;
                for (a = 0; a < o; ++a) {
                    e.cacheStyleSheet(s[a])
                }
                for (; i >= 0; --i) {
                    u = r[i];
                    if (u.styleSheet) {
                        e.cacheStyleSheet(u.styleSheet)
                    }
                    e.cacheRule(u, n)
                }
            } catch(f) {}
        },
        cacheRule: function(n, r) {
            if (n.styleSheet) {
                return e.cacheStyleSheet(n.styleSheet)
            }
            var i = n.selectorText,
            s, o;
            if (i) {
                i = i.split(",");
                s = i.length;
                for (o = 0; o < s; o++) {
                    t[Ext.String.trim(i[o]).toLowerCase()] = {
                        parentStyleSheet: r,
                        cssRule: n
                    }
                }
            }
        },
        getRules: function(n) {
            var r = {},
            i;
            if (t === null || n) {
                e.refreshCache()
            }
            for (i in t) {
                r[i] = t[i].cssRule
            }
            return r
        },
        refreshCache: function() {
            var r = n.styleSheets,
            i = 0,
            s = r.length;
            t = e.rules = {};
            for (; i < s; i++) {
                try {
                    if (!r[i].disabled) {
                        e.cacheStyleSheet(r[i])
                    }
                } catch(o) {}
            }
        },
        getRule: function(n, r, i) {
            var s, o;
            if (!t || r) {
                e.refreshCache()
            }
            if (!Ext.isArray(n)) {
                o = t[n.toLowerCase()];
                if (o && !i) {
                    o = o.cssRule
                }
                return o || null
            }
            for (s = 0; s < n.length; s++) {
                if (t[n[s]]) {
                    return i ? t[n[s].toLowerCase()] : t[n[s].toLowerCase()].cssRule
                }
            }
            return null
        },
        createRule: function(t, n, r) {
            var i, s = t.cssRules || t.rules,
            o = s.length;
            if (t.insertRule) {
                t.insertRule(n + "{" + r + "}", o)
            } else {
                t.addRule(n, r || " ")
            }
            e.cacheRule(i = s[o], t);
            return i
        },
        updateRule: function(t, n, s) {
            var o, u, f;
            if (!Ext.isArray(t)) {
                o = e.getRule(t);
                if (o) {
                    if (arguments.length === 2) {
                        f = Ext.Element.parseStyles(n);
                        for (n in f) {
                            o.style[n.replace(r, i)] = f[n]
                        }
                    } else {
                        o.style[n.replace(r, i)] = s
                    }
                    return true
                }
            } else {
                for (u = 0; u < t.length; u++) {
                    if (e.updateRule(t[u], n, s)) {
                        return true
                    }
                }
            }
            return false
        },
        deleteRule: function(n) {
            var r = e.getRule(n, false, true),
            i,
            s;
            if (r) {
                i = r.parentStyleSheet;
                s = Ext.Array.indexOf(i.cssRules || i.rules, r.cssRule);
                if (i.deleteRule) {
                    i.deleteRule(s)
                } else {
                    i.removeRule(s)
                }
                delete t[n]
            }
        }
    }
});Ext.define("Ext.view.TableLayout", {
    extend: Ext.layout.component.Auto,
    alias: ["layout.tableview"],
    type: "tableview",
    beginLayout: function(e) {
        var t = this,
        n = t.owner.lockingPartner,
        r = t.owner;
        t.callParent(arguments);
        if (n) {
            t.lockedGrid = t.owner.up("[lockable]");
            t.lockedGrid.needsRowHeightSync = true;
            if (!e.lockingPartner) {
                e.lockingPartner = e.context.getItem(n, n.el);
                if (e.lockingPartner && !e.lockingPartner.lockingPartner) {
                    e.lockingPartner.lockingPartner = e
                }
            }
        }
        e.headerContext = e.context.getCmp(t.headerCt);
        if (t.owner.body.dom) {
            e.bodyContext = e.getEl(t.owner.body)
        }
        if (Ext.isWebKit) {
            r.el.select(r.getBodySelector()).setStyle("table-layout", "auto")
        }
    },
    calculate: function(e) {
        var t = this,
        n = t.lockingPartner,
        r = t.owner,
        i = 0,
        s;
        if (e.headerContext.hasProp("columnWidthsDone")) {
            if (!t.setColumnWidths(e)) {
                t.done = false;
                return
            }
            e.state.columnWidthsSynced = true;
            if (e.bodyContext) {
                s = t.owner.el.down("." + r.ownerCt.emptyCls, true);
                if (!s) {
                    i = e.bodyContext.el.dom.offsetHeight;
                    e.bodyContext.setHeight(i, false)
                } else {
                    i = s.offsetHeight
                }
                if (e.headerContext.state.boxPlan.tooNarrow && e.ownerCtContext.sizeModel.height.shrinkWrap) {
                    i += Ext.getScrollbarSize().height
                }
                e.setProp("contentHeight", i)
            }
            if (n && !n.state.columnWidthsSynced) {
                t.done = false
            } else {
                t.callParent(arguments)
            }
        } else {
            t.done = false
        }
    },
    measureContentHeight: function(e) {
        var t = e.lockingPartner;
        if (!e.bodyContext || e.state.columnWidthsSynced && (!t || t.state.columnWidthsSynced)) {
            return this.callParent(arguments)
        }
    },
    setColumnWidths: function(e) {
        if (!this.owner.body.dom) {
            return true
        }
        var t = this,
        n = t.owner,
        r = e.context,
        i = t.headerCt.getVisibleGridColumns(),
        s,
        o,
        u = i.length,
        a = 0,
        f = 0,
        l,
        c,
        h = !Ext.isBorderBox,
        p = n.body.dom.firstChild,
        d = p.tagName.toUpperCase() === "COLGROUP",
        v = [];
        if (r) {
            r.currentLayout = t
        }
        for (o = 0; o < u; o++) {
            s = i[o];
            l = r.getCmp(s);
            if (!s.lastBox || s.lastBox.invalid || l.props.width !== s.lastBox.width || l.cellWidth && l.cellWidth != l.props.width) {
                c = l.props.width;
                if (isNaN(c)) {
                    l.getProp("width");
                    return false
                }
                a += c;
                l.columnIndex = o;
                v.push(l)
            } else {
                a += s.lastBox.width
            }
            l.cellWidth = l.props.width
        }
        u = v.length;
        if (!u) {
            return true
        }
        n.body.setWidth(a);
        for (o = 0; o < u; o++) {
            l = v[o];
            c = l.props.width;
            if (h && n.columnLines) {
                if (!f) {
                    f = e.headerContext.childItems[0].borderInfo.width
                }
                c -= f
            }
            if (d) {
                p.childNodes[l.columnIndex].style.width = c + "px"
            }
            if (n.features.length) {
                n.body.select(n.getColumnSizerSelector(l.target)).setWidth(c)
            }
        }
        return true
    },
    finishedLayout: function() {
        var e = this,
        t = e.owner;
        e.callParent(arguments);
        if (Ext.isWebKit) {
            t.el.select(t.getBodySelector()).setStyle("table-layout", "")
        }
        if (t.refreshCounter && e.lockedGrid && e.lockedGrid.syncRowHeight && e.lockedGrid.needsRowHeightSync) {
            e.lockedGrid.syncRowHeights();
            e.lockedGrid.needsRowHeightSync = false
        }
    }
});Ext.define("Ext.view.NodeCache", {
    constructor: function(e) {
        this.view = e;
        this.clear();
        this.el = new Ext.dom.AbstractElement.Fly
    },
    clear: function(e) {
        var t = this,
        n = this.elements,
        r, i;
        if (e) {
            for (r in n) {
                i = n[r];
                i.parentNode.removeChild(i)
            }
        }
        t.elements = {};
        t.count = t.startIndex = 0;
        t.endIndex = -1
    },
    fill: function(e, t) {
        var n = this,
        r = n.elements = {},
        i, s = e.length;
        if (!t) {
            t = 0
        }
        for (i = 0; i < s; i++) {
            r[t + i] = e[i]
        }
        n.startIndex = t;
        n.endIndex = t + s - 1;
        n.count = s;
        return this
    },
    insert: function(e, t) {
        var n = this,
        r = n.elements,
        i, s = t.length;
        if (n.count) {
            if (e < n.count) {
                for (i = n.endIndex + s; i >= e + s; i--) {
                    r[i] = r[i - s];
                    r[i].setAttribute("data-recordIndex", i)
                }
            }
            n.endIndex = n.endIndex + s
        } else {
            n.startIndex = e;
            n.endIndex = e + s - 1
        }
        for (i = 0; i < s; i++, e++) {
            r[e] = t[i];
            r[e].setAttribute("data-recordIndex", e)
        }
        n.count += s
    },
    item: function(e, t) {
        var n = this.elements[e],
        r = null;
        if (n) {
            r = t ? this.elements[e] : this.el.attach(this.elements[e])
        }
        return r
    },
    first: function(e) {
        return this.item(this.startIndex, e)
    },
    last: function(e) {
        return this.item(this.endIndex, e)
    },
    getCount: function() {
        return this.count
    },
    slice: function(e, t) {
        var n = this.elements,
        r = [],
        i;
        if (arguments.length < 2) {
            t = this.endIndex
        } else {
            t = Math.min(this.endIndex, t - 1)
        }
        for (i = e || this.startIndex; i <= t; i++) {
            r.push(n[i])
        }
        return r
    },
    replaceElement: function(e, t, n) {
        var r = this.elements,
        i = typeof e === "number" ? e: this.indexOf(e);
        if (i > -1) {
            t = Ext.getDom(t);
            if (n) {
                e = r[i];
                e.parentNode.insertBefore(t, e);
                Ext.removeNode(e);
                t.setAttribute("data-recordIndex", i)
            }
            this.elements[i] = t
        }
        return this
    },
    indexOf: function(e) {
        var t = this.elements,
        n;
        e = Ext.getDom(e);
        for (n = this.startIndex; n <= this.endIndex; n++) {
            if (t[n] === e) {
                return n
            }
        }
        return - 1
    },
    removeRange: function(e, t, n) {
        var r = this,
        i = r.elements,
        s, o, u, a;
        if (t == null) {
            t = r.endIndex + 1
        } else {
            t = Math.min(r.endIndex + 1, t + 1)
        }
        if (e == null) {
            e = r.startIndex
        }
        u = t - e;
        for (o = e, a = t; o <= r.endIndex; o++, a++) {
            if (n && o < t) {
                Ext.removeNode(i[o])
            }
            if (a <= r.endIndex) {
                s = i[o] = i[a];
                s.setAttribute("data-recordIndex", o)
            } else {
                delete i[o]
            }
        }
        r.count -= u;
        r.endIndex -= u
    },
    removeElement: function(e, t) {
        var n = this,
        r, i, s = n.elements,
        o, u, a = 0,
        f, l;
        if (Ext.isArray(e)) {
            r = e;
            e = [];
            u = r.length;
            for (a = 0; a < u; a++) {
                i = r[a];
                if (typeof i !== "number") {
                    i = n.indexOf(i)
                }
                if (i >= n.startIndex && i <= n.endIndex) {
                    e[e.length] = i
                }
            }
            Ext.Array.sort(e);
            u = e.length
        } else {
            if (e < n.startIndex || e > n.endIndex) {
                return
            }
            u = 1;
            e = [e]
        }
        for (f = l = e[0], a = 0; f <= n.endIndex; f++, l++) {
            if (a < u && f === e[a]) {
                l++;
                a++;
                if (t) {
                    Ext.removeNode(s[f])
                }
            }
            if (l <= n.endIndex && l >= n.startIndex) {
                o = s[f] = s[l];
                o.setAttribute("data-recordIndex", f)
            } else {
                delete s[f]
            }
        }
        n.endIndex -= u;
        n.count -= u
    },
    scroll: function(e, t, n) {
        var r = this,
        i = r.elements,
        s = e.length,
        o, u, a, f, l = r.view.getNodeContainer(),
        c = document.createDocumentFragment();
        if (t == -1) {
            for (o = r.endIndex - n + 1; o <= r.endIndex; o++) {
                u = i[o];
                delete i[o];
                u.parentNode.removeChild(u)
            }
            r.endIndex -= n;
            f = r.view.bufferRender(e, r.startIndex -= s);
            for (o = 0; o < s; o++) {
                i[r.startIndex + o] = f[o];
                c.appendChild(f[o])
            }
            l.insertBefore(c, l.firstChild)
        } else {
            a = r.startIndex + n;
            for (o = r.startIndex; o < a; o++) {
                u = i[o];
                delete i[o];
                u.parentNode.removeChild(u)
            }
            r.startIndex = o;
            f = r.view.bufferRender(e, r.endIndex + 1);
            for (o = 0; o < s; o++) {
                i[r.endIndex += 1] = f[o];
                c.appendChild(f[o])
            }
            l.appendChild(c)
        }
        r.count = r.endIndex - r.startIndex + 1
    }
});Ext.define("Ext.view.Table", {
    extend: Ext.view.View,
    alias: "widget.tableview",
    componentLayout: "tableview",
    baseCls: Ext.baseCSSPrefix + "grid-view",
    unselectableCls: Ext.baseCSSPrefix + "unselectable",
    firstCls: Ext.baseCSSPrefix + "grid-cell-first",
    lastCls: Ext.baseCSSPrefix + "grid-cell-last",
    headerRowSelector: "tr." + Ext.baseCSSPrefix + "grid-header-row",
    selectedItemCls: Ext.baseCSSPrefix + "grid-row-selected",
    beforeSelectedItemCls: Ext.baseCSSPrefix + "grid-row-before-selected",
    selectedCellCls: Ext.baseCSSPrefix + "grid-cell-selected",
    focusedItemCls: Ext.baseCSSPrefix + "grid-row-focused",
    beforeFocusedItemCls: Ext.baseCSSPrefix + "grid-row-before-focused",
    tableFocusedFirstCls: Ext.baseCSSPrefix + "grid-table-focused-first",
    tableSelectedFirstCls: Ext.baseCSSPrefix + "grid-table-selected-first",
    tableOverFirstCls: Ext.baseCSSPrefix + "grid-table-over-first",
    overItemCls: Ext.baseCSSPrefix + "grid-row-over",
    beforeOverItemCls: Ext.baseCSSPrefix + "grid-row-before-over",
    altRowCls: Ext.baseCSSPrefix + "grid-row-alt",
    dirtyCls: Ext.baseCSSPrefix + "grid-dirty-cell",
    rowClsRe: new RegExp("(?:^|\\s*)" + Ext.baseCSSPrefix + "grid-row-(first|last|alt)(?:\\s+|$)", "g"),
    cellRe: new RegExp(Ext.baseCSSPrefix + "grid-cell-headerId-([^\\s]+)(?:\\s|$)", ""),
    positionBody: true,
    trackOver: true,
    getRowClass: null,
    stripeRows: true,
    markDirty: true,
    ariaRole: "grid",
    tpl: "{%values.view.tableTpl.applyOut(values, out)%}",
    tableTpl: ["{%", 'var view=values.view,tableCls="' + Ext.baseCSSPrefix + '" + view.id + "-table ' + Ext.baseCSSPrefix + 'grid-table";', "values.fullWidth", "%}", '<table id="{view.id}-table" class="{[tableCls]}" border="0" cellspacing="0" cellpadding="0" style="{tableStyle}" {ariaTableAttr}>', "{[view.renderColumnSizer(out)]}", "{[view.renderTHead(values, out)]}", "{[view.renderTFoot(values, out)]}", '<tbody id="{view.id}-body" {ariaTbodyAttr}>', "{%", "view.renderRows(values.rows, values.viewStartIndex, out);", "%}", "</tbody>", "</table>", {
        priority: 0
    }],
    rowTpl: ["{%", 'var dataRowCls = values.recordIndex === -1 ? "" : " ' + Ext.baseCSSPrefix + 'grid-data-row";', "%}", '<tr {[values.rowId ? ("id=\\"" + values.rowId + "\\"") : ""]} ', 'data-boundView="{view.id}" ', 'data-recordId="{record.internalId}" ', 'data-recordIndex="{recordIndex}" ', 'class="{[values.itemClasses.join(" ")]} {[values.rowClasses.join(" ")]}{[dataRowCls]}" ', '{rowAttr:attributes} tabIndex="-1" {ariaRowAttr}>', '<tpl for="columns">{%', "parent.view.renderCell(values, parent.record, parent.recordIndex, parent.rowIndex, xindex - 1, out, parent)", "%}", "</tpl>", "</tr>", {
        priority: 0
    }],
    cellTpl: ['<td class="{tdCls}" {tdAttr} {[Ext.aria ? "id=\\"" + Ext.id() + "\\"" : ""]} {ariaCellAttr}>', '<div {unselectableAttr} class="' + Ext.baseCSSPrefix + 'grid-cell-inner {innerCls}"', 'style="text-align:{align};<tpl if="style">{style}</tpl>" {ariaCellInnerAttr}>{value}</div>', "</td>", {
        priority: 0
    }],
    refreshSelmodelOnRefresh: false,
    tableValues: {},
    rowValues: {
        itemClasses: [],
        rowClasses: []
    },
    cellValues: {
        classes: [Ext.baseCSSPrefix + "grid-cell " + Ext.baseCSSPrefix + "grid-td"]
    },
    renderBuffer: document.createElement("div"),
    constructor: function(e) {
        if (e.grid.isTree) {
            e.baseCls = Ext.baseCSSPrefix + "tree-view"
        }
        this.callParent([e])
    },
    initComponent: function() {
        var e = this,
        t = e.scroll;
        this.addEvents("beforecellclick", "cellclick", "beforecelldblclick", "celldblclick", "beforecellcontextmenu", "cellcontextmenu", "beforecellmousedown", "cellmousedown", "beforecellmouseup", "cellmouseup", "beforecellkeydown", "cellkeydown");
        e.body = new Ext.dom.Element.Fly;
        e.body.id = e.id + "gridBody";
        e.autoScroll = undefined;
        if (!e.trackOver) {
            e.overItemCls = null;
            e.beforeOverItemCls = null
        }
        if (t === true || t === "both") {
            e.autoScroll = true
        } else {
            if (t === "horizontal") {
                e.overflowX = "auto"
            } else {
                if (t === "vertical") {
                    e.overflowY = "auto"
                }
            }
        }
        e.selModel.view = e.headerCt.view = e;
        e.grid.view = e;
        e.initFeatures(e.grid);
        delete e.grid;
        e.itemSelector = e.getItemSelector();
        e.all = new Ext.view.NodeCache(e);
        e.callParent()
    },
    getVisibleColumnManager: function() {
        var e = this.ownerCt,
        t = e.ownerLockable;
        return t ? t.getVisibleColumnManager() : e.getVisibleColumnManager()
    },
    beforeLayout: function() {
        var e = this,
        t = !e.firstRefreshDone && e.headerCt.layout.running;
        e.callParent(arguments);
        if (t && e.body.dom) {
            e.headerCt.layout.injectViewContext(e.headerCt.layout.ownerContext, e)
        }
    },
    moveColumn: function(e, t, n) {
        var r = this,
        i = n > 1 ? document.createDocumentFragment() : undefined,
        s = t,
        o = r.getGridColumns().length,
        u = o - 1,
        a = (r.firstCls || r.lastCls) && (t === 0 || t == o || e === 0 || e == u),
        f,
        l,
        c,
        h,
        p,
        d,
        v;
        if (r.rendered && t !== e) {
            c = r.el.query(r.getDataRowSelector());
            if (t > e && i) {
                s -= 1
            }
            for (f = 0, h = c.length; f < h; f++) {
                p = c[f];
                d = p.childNodes;
                if (a) {
                    if (d.length === 1) {
                        Ext.fly(d[0]).addCls(r.firstCls);
                        Ext.fly(d[0]).addCls(r.lastCls);
                        continue
                    }
                    if (e === 0) {
                        Ext.fly(d[0]).removeCls(r.firstCls);
                        Ext.fly(d[1]).addCls(r.firstCls)
                    } else {
                        if (e === u) {
                            Ext.fly(d[u]).removeCls(r.lastCls);
                            Ext.fly(d[u - 1]).addCls(r.lastCls)
                        }
                    }
                    if (t === 0) {
                        Ext.fly(d[0]).removeCls(r.firstCls);
                        Ext.fly(d[e]).addCls(r.firstCls)
                    } else {
                        if (t === o) {
                            Ext.fly(d[u]).removeCls(r.lastCls);
                            Ext.fly(d[e]).addCls(r.lastCls)
                        }
                    }
                }
                if (i) {
                    for (l = 0; l < n; l++) {
                        i.appendChild(d[e])
                    }
                    p.insertBefore(i, d[s] || null)
                } else {
                    p.insertBefore(d[e], d[s] || null)
                }
            }
            v = r.el.query(r.getBodySelector());
            for (f = 0, h = v.length; f < h; f++) {
                p = v[f].firstChild;
                if (p.tagName.toUpperCase() === "COLGROUP") {
                    if (i) {
                        for (l = 0; l < n; l++) {
                            i.appendChild(p.childNodes[e])
                        }
                        p.insertBefore(i, p.childNodes[s] || null)
                    } else {
                        p.insertBefore(p.childNodes[e], p.childNodes[s] || null)
                    }
                }
            }
        }
    },
    scrollToTop: Ext.emptyFn,
    addElListener: function(e, t, n) {
        this.mon(this, e, t, n, {
            element: "el"
        })
    },
    getGridColumns: function() {
        return this.ownerCt.getVisibleColumnManager().getColumns()
    },
    getHeaderAtIndex: function(e) {
        return this.ownerCt.getVisibleColumnManager().getHeaderAtIndex(e)
    },
    getCell: function(e, t) {
        var n = this.getNode(e, true);
        return Ext.fly(n).down(t.getCellSelector())
    },
    getFeature: function(e) {
        var t = this.featuresMC;
        if (t) {
            return t.get(e)
        }
    },
    findFeature: function(e) {
        if (this.features) {
            return Ext.Array.findBy(this.features,
            function(t) {
                if (t.ftype === e) {
                    return true
                }
            })
        }
    },
    initFeatures: function(e) {
        var t = this,
        n, r, i, s;
        t.tableTpl = Ext.XTemplate.getTpl(this, "tableTpl");
        t.rowTpl = Ext.XTemplate.getTpl(this, "rowTpl");
        t.cellTpl = Ext.XTemplate.getTpl(this, "cellTpl");
        t.featuresMC = new Ext.util.MixedCollection;
        r = t.features = t.constructFeatures();
        s = r ? r.length: 0;
        for (n = 0; n < s; n++) {
            i = r[n];
            i.view = t;
            i.grid = e;
            t.featuresMC.add(i);
            i.init(e)
        }
    },
    renderTHead: function(e, t) {
        var n = e.view.headerFns,
        r, i;
        if (n) {
            for (i = 0, r = n.length; i < r; ++i) {
                n[i].call(this, e, t)
            }
        }
    },
    addHeaderFn: function() {
        var e = this.headerFns;
        if (!e) {
            e = this.headerFns = []
        }
        e.push(fn)
    },
    renderTFoot: function(e, t) {
        var n = e.view.footerFns,
        r, i;
        if (n) {
            for (i = 0, r = n.length; i < r; ++i) {
                n[i].call(this, e, t)
            }
        }
    },
    addFooterFn: function(e) {
        var t = this.footerFns;
        if (!t) {
            t = this.footerFns = []
        }
        t.push(e)
    },
    addTableTpl: function(e) {
        return this.addTpl("tableTpl", e)
    },
    addRowTpl: function(e) {
        return this.addTpl("rowTpl", e)
    },
    addCellTpl: function(e) {
        return this.addTpl("cellTpl", e)
    },
    addTpl: function(e, t) {
        var n = this,
        r, i;
        t = Ext.Object.chain(t);
        if (!t.isTemplate) {
            t.applyOut = n.tplApplyOut
        }
        for (r = n[e]; t.priority < r.priority; r = r.nextTpl) {
            i = r
        }
        if (i) {
            i.nextTpl = t
        } else {
            n[e] = t
        }
        t.nextTpl = r;
        return t
    },
    tplApplyOut: function(e, t) {
        if (this.before) {
            if (this.before(e, t) === false) {
                return
            }
        }
        this.nextTpl.applyOut(e, t);
        if (this.after) {
            this.after(e, t)
        }
    },
    constructFeatures: function() {
        var e = this,
        t = e.features,
        n, r, i = 0,
        s;
        if (t) {
            r = [];
            s = t.length;
            for (; i < s; i++) {
                n = t[i];
                if (!n.isFeature) {
                    n = Ext.create("feature." + n.ftype, n)
                }
                r[i] = n
            }
        }
        return r
    },
    beforeRender: function() {
        var e = this;
        e.callParent();
        if (!e.enableTextSelection) {
            e.protoEl.unselectable()
        }
    },
    onViewScroll: function(e, t) {
        if (!this.ignoreScroll) {
            this.callParent(arguments);
            this.fireEvent("bodyscroll", e, t)
        }
    },
    createRowElement: function(e, t) {
        var n = this,
        r = n.renderBuffer;
        n.tpl.overwrite(r, n.collectData([e], t));
        return Ext.fly(r).down(n.getNodeContainerSelector(), true).firstChild
    },
    bufferRender: function(e, t) {
        var n = this,
        r = n.renderBuffer;
        n.tpl.overwrite(r, n.collectData(e, t));
        return Ext.Array.toArray(Ext.fly(r).down(n.getNodeContainerSelector(), true).childNodes)
    },
    collectData: function(e, t) {
        this.rowValues.view = this;
        return {
            view: this,
            rows: e,
            viewStartIndex: t,
            tableStyle: "width:" + this.headerCt.getTableWidth() + "px" + (this.bufferedRenderer ? ";position:absolute;top:" + this.bufferedRenderer.bodyTop + "px": "")
        }
    },
    collectNodes: function(e) {
        this.all.fill(this.getNodeContainer().childNodes, this.all.startIndex)
    },
    refreshSize: function() {
        var e = this,
        t, n = e.getBodySelector();
        if (n) {
            e.body.attach(e.el.child(n, true))
        }
        if (!e.hasLoadingHeight) {
            t = e.up("tablepanel");
            Ext.suspendLayouts();
            e.callParent();
            if (e.dataSource.getCount()) {
                t.updateLayout()
            }
            Ext.resumeLayouts(true)
        }
    },
    getMaskTarget: function() {
        var e = this.ownerCt;
        if (e.ownerLockable) {
            e = e.ownerLockable
        }
        return e.getMaskTarget()
    },
    statics: {
        getBoundView: function(e) {
            return Ext.getCmp(e.getAttribute("data-boundView"))
        }
    },
    getRecord: function(e) {
        var t = this,
        n;
        if (t.store.isDestroyed) {
            return
        }
        e = t.getNode(e);
        if (e) {
            if (!t.hasActiveFeature()) {
                n = e.getAttribute("data-recordIndex");
                if (n) {
                    n = parseInt(n, 10);
                    if (n > -1) {
                        return t.store.data.getAt(n)
                    }
                }
            }
            return t.dataSource.getByInternalId(e.getAttribute("data-recordId"))
        }
    },
    indexOf: function(e) {
        e = this.getNode(e, false);
        if (!e && e !== 0) {
            return - 1
        }
        return this.all.indexOf(e)
    },
    indexInStore: function(e) {
        return this.dataSource.indexOf(this.getRecord(e))
    },
    renderRows: function(e, t, n) {
        var r = this.rowValues,
        i = e.length,
        s;
        r.view = this;
        r.columns = this.ownerCt.getVisibleColumnManager().getColumns();
        for (s = 0; s < i; s++, t++) {
            r.itemClasses.length = r.rowClasses.length = 0;
            this.renderRow(e[s], t, n)
        }
        r.view = r.columns = r.record = null
    },
    renderColumnSizer: function(e) {
        var t = this.getGridColumns(),
        n = t.length,
        r,
        i;
        e.push('<colgroup role="presentation">');
        for (r = 0; r < n; r++) {
            i = t[r];
            e.push('<col role="presentation" class="', t[r].getCellId(), '" style="width:' + i.getCellWidth() + 'px">')
        }
        e.push("</colgroup>")
    },
    renderRow: function(e, t, n) {
        var r = this,
        i = t === -1,
        s = r.selModel,
        o = r.rowValues,
        u = o.itemClasses,
        a = o.rowClasses,
        f, l = r.rowTpl;
        o.rowAttr = {};
        o.record = e;
        o.recordId = e.internalId;
        o.recordIndex = r.store.indexOf(e);
        o.rowIndex = t;
        o.rowId = r.getRowId(e);
        o.itemCls = o.rowCls = "";
        if (!o.columns) {
            o.columns = r.ownerCt.getVisibleColumnManager().getColumns()
        }
        u.length = a.length = 0;
        if (!i) {
            u[0] = Ext.baseCSSPrefix + "grid-row";
            if (!r.ownerCt.disableSelection && s.isRowSelected) {
                if (s.isRowSelected(e)) {
                    u.push(r.selectedItemCls)
                }
                if (r.rowValues.recordIndex < r.store.getTotalCount() - 1 && s.isRowSelected(r.rowValues.recordIndex + 1) && !r.isRowStyleFirst(t + 1)) {
                    a.push(r.beforeSelectedItemCls)
                }
            }
            if (r.stripeRows && t % 2 !== 0) {
                u.push(r.altRowCls)
            }
            if (r.getRowClass) {
                f = r.getRowClass(e, t, null, r.dataSource);
                if (f) {
                    a.push(f)
                }
            }
        }
        if (n) {
            l.applyOut(o, n)
        } else {
            return l.apply(o)
        }
    },
    renderCell: function(e, t, n, r, i, s) {
        var o = this,
        u = o.selModel,
        a = o.cellValues,
        f = a.classes,
        l = t.data[e.dataIndex],
        c = o.cellTpl,
        h,
        p,
        d;
        a.record = t;
        a.column = e;
        a.recordIndex = n;
        a.rowIndex = r;
        a.columnIndex = i;
        a.cellIndex = i;
        a.align = e.align;
        a.tdCls = e.tdCls;
        a.innerCls = e.innerCls;
        a.style = a.tdAttr = "";
        a.unselectableAttr = o.enableTextSelection ? "": 'unselectable="on"';
        if (e.renderer && e.renderer.call) {
            h = o.ownerCt.columnManager.getHeaderIndex(e);
            p = e.renderer.call(e.usingDefaultRenderer ? e: e.scope || o.ownerCt, l, a, t, n, h, o.dataSource, o);
            if (a.css) {
                t.cssWarning = true;
                a.tdCls += " " + a.css;
                delete a.css
            }
        } else {
            p = l
        }
        a.value = p == null || p === "" ? e.emptyCellText: p;
        f[1] = e.getCellId();
        d = 2;
        if (e.tdCls) {
            f[d++] = e.tdCls
        }
        if (o.markDirty && t.isModified(e.dataIndex)) {
            f[d++] = o.dirtyCls
        }
        if (e.isFirstVisible) {
            f[d++] = o.firstCls
        }
        if (e.isLastVisible) {
            f[d++] = o.lastCls
        }
        if (!o.enableTextSelection) {
            f[d++] = o.unselectableCls
        }
        if (a.tdCls) {
            f[d++] = a.tdCls
        }
        if (u && u.isCellModel && u.isCellSelected(o, n, e)) {
            f[d++] = o.selectedCellCls
        }
        f.length = d;
        a.tdCls = f.join(" ");
        c.applyOut(a, s);
        a.column = null
    },
    getNode: function(e, t) {
        var n, r = this.callParent(arguments);
        if (r && r.tagName) {
            if (t) {
                if (! (n = Ext.fly(r)).is(this.dataRowSelector)) {
                    return n.down(this.dataRowSelector, true)
                }
            } else {
                if (t === false) {
                    if (! (n = Ext.fly(r)).is(this.itemSelector)) {
                        return n.up(this.itemSelector, null, true)
                    }
                }
            }
        }
        return r
    },
    getRowId: function(e) {
        return this.id + "-record-" + e.internalId
    },
    constructRowId: function(e) {
        return this.id + "-record-" + e
    },
    getNodeById: function(e, t) {
        e = this.constructRowId(e);
        return this.retrieveNode(e, t)
    },
    getNodeByRecord: function(e, t) {
        var n = this.getRowId(e);
        return this.retrieveNode(n, t)
    },
    retrieveNode: function(e, t) {
        var n = this.el.getById(e, true),
        r = this.itemSelector,
        i;
        if (t === false && n) {
            if (! (i = Ext.fly(n)).is(r)) {
                return i.up(r, null, true)
            }
        }
        return n
    },
    updateIndexes: Ext.emptyFn,
    bodySelector: "table",
    nodeContainerSelector: "tbody",
    itemSelector: "tr." + Ext.baseCSSPrefix + "grid-row",
    dataRowSelector: "tr." + Ext.baseCSSPrefix + "grid-data-row",
    cellSelector: "td." + Ext.baseCSSPrefix + "grid-cell",
    sizerSelector: "col." + Ext.baseCSSPrefix + "grid-cell-headerId",
    innerSelector: "div." + Ext.baseCSSPrefix + "grid-cell-inner",
    getNodeContainer: function() {
        return this.el.down(this.nodeContainerSelector, true)
    },
    getBodySelector: function() {
        return this.bodySelector + "." + Ext.baseCSSPrefix + this.id + "-table"
    },
    getNodeContainerSelector: function() {
        return this.nodeContainerSelector
    },
    getColumnSizerSelector: function(e) {
        return this.sizerSelector + "-" + e.getItemId()
    },
    getItemSelector: function() {
        return this.itemSelector
    },
    getDataRowSelector: function() {
        return this.dataRowSelector
    },
    getCellSelector: function(e) {
        return e ? e.getCellSelector() : this.cellSelector
    },
    getCellInnerSelector: function(e) {
        return this.getCellSelector(e) + " " + this.innerSelector
    },
    addRowCls: function(e, t) {
        var n = this.getNode(e, false);
        if (n) {
            Ext.fly(n).addCls(t)
        }
    },
    removeRowCls: function(e, t) {
        var n = this.getNode(e, false);
        if (n) {
            Ext.fly(n).removeCls(t)
        }
    },
    setHighlightedItem: function(e) {
        var t = this,
        n = t.highlightedItem;
        if (n && t.el.isAncestor(n) && t.isRowStyleFirst(n)) {
            t.toggleRowTableCls(n, t.tableOverFirstCls, false)
        }
        e = t.getNode(e, false);
        if (e && t.isRowStyleFirst(e)) {
            t.toggleRowTableCls(e, t.tableOverFirstCls, true)
        }
        t.callParent(arguments)
    },
    onRowSelect: function(e) {
        var t = this,
        n = t.beforeSelectedItemCls;
        t.addRowCls(e, t.selectedItemCls);
        if (t.isRowStyleFirst(e)) {
            t.toggleRowTableCls(e, t.tableSelectedFirstCls, true);
            if (e > 0) {
                t.removeRowCls(e - 1, n)
            }
        } else {
            t.addRowCls(e - 1, n)
        }
    },
    onRowDeselect: function(e) {
        var t = this;
        t.removeRowCls(e, [t.selectedItemCls, t.focusedItemCls]);
        if (t.isRowStyleFirst(e)) {
            t.toggleRowTableCls(e, [t.tableFocusedFirstCls, t.tableSelectedFirstCls], false)
        } else {
            t.removeRowCls(e - 1, [t.beforeFocusedItemCls, t.beforeSelectedItemCls])
        }
    },
    onCellSelect: function(e) {
        var t = this.getCellByPosition(e);
        if (t) {
            t.addCls(this.selectedCellCls)
        }
    },
    onCellDeselect: function(e) {
        var t = this.getCellByPosition(e, true);
        if (t) {
            Ext.fly(t).removeCls(this.selectedCellCls)
        }
    },
    getCellByPosition: function(e, t) {
        if (e) {
            var n = this.getNode(e.row, true),
            r = this.ownerCt.getColumnManager().getHeaderAtIndex(e.column);
            if (r && n) {
                return Ext.fly(n).down(this.getCellSelector(r), t)
            }
        }
        return false
    },
    getFocusEl: function() {
        return this.focusEl
    },
    onRowFocus: function(e, t, n) {
        var r = this;
        if (t) {
            r.addRowCls(e, r.focusedItemCls);
            if (r.isRowStyleFirst(e)) {
                r.toggleRowTableCls(e, r.tableFocusedFirstCls, true)
            } else {
                r.addRowCls(e - 1, r.beforeFocusedItemCls)
            }
            if (!n) {
                r.focusRow(e)
            }
        } else {
            r.removeRowCls(e, r.focusedItemCls);
            if (r.isRowStyleFirst(e)) {
                r.toggleRowTableCls(e, r.tableFocusedFirstCls, false)
            } else {
                r.removeRowCls(e - 1, r.beforeFocusedItemCls)
            }
        }
        if ((Ext.isIE6 || Ext.isIE7) && !r.ownerCt.rowLines) {
            r.repaintRow(e)
        }
    },
    focusRow: function(e, t) {
        var n = this,
        r, i = n.getFocusTask();
        if (t) {
            i.delay(Ext.isNumber(t) ? t: 10, n.focusRow, n, [e, false]);
            return
        }
        i.cancel();
        if (n.isVisible(true) && (e = n.getNode(e, true))) {
            n.scrollRowIntoView(e);
            r = n.getRecord(e);
            n.selModel.setLastFocused(r);
            n.doFocus(e);
            n.fireEvent("rowfocus", r, e, n.indexInStore(e))
        }
    },
    scrollRowIntoView: function(e) {
        e = this.getNode(e, true);
        if (e) {
            Ext.fly(e).scrollIntoView(this.el, false)
        }
    },
    focusCell: function(e, t) {
        var n = this,
        r, i = n.getFocusTask();
        if (t) {
            i.delay(Ext.isNumber(t) ? t: 10, n.focusCell, n, [e, false]);
            return
        }
        i.cancel();
        if (n.isVisible(true) && (r = n.getCellByPosition(e))) {
            n.scrollCellIntoView(r);
            n.doFocus(n.getNode(e.row, true));
            n.fireEvent("cellfocus", e.record, r, e)
        }
    },
    doFocus: function(e) {
        var t = this,
        n = Ext.isIE,
        r;
        if (n) {
            r = t.el.getScrollLeft();
            t.ignoreScroll = true
        } (t.focusEl = Ext.get(e)).focus();
        if (n) {
            t.el.setScrollLeft(r);
            t.ignoreScroll = false
        }
    },
    scrollCellIntoView: function(e) {
        if (e.row != null && e.column != null) {
            e = this.getCellByPosition(e)
        }
        if (e) {
            Ext.fly(e).scrollIntoView(this.el)
        }
    },
    scrollByDelta: function(e, t) {
        t = t || "scrollTop";
        var n = this.el.dom;
        n[t] = n[t] += e
    },
    isDataRow: function(e) {
        return Ext.fly(e).hasCls(Ext.baseCSSPrefix + "grid-data-row")
    },
    syncRowHeights: function(e, t) {
        e = Ext.get(e);
        t = Ext.get(t);
        e.dom.style.height = t.dom.style.height = "";
        var n = this,
        r = n.rowTpl,
        i = e.dom.offsetHeight,
        s = t.dom.offsetHeight;
        if (i !== s) {
            while (r) {
                if (r.syncRowHeights) {
                    if (r.syncRowHeights(e, t) === false) {
                        break
                    }
                }
                r = r.nextTpl
            }
            i = e.dom.offsetHeight;
            s = t.dom.offsetHeight;
            if (i !== s) {
                e = e.down("[data-recordId]") || e;
                t = t.down("[data-recordId]") || t;
                if (e && t) {
                    e.dom.style.height = t.dom.style.height = "";
                    i = e.dom.offsetHeight;
                    s = t.dom.offsetHeight;
                    if (i > s) {
                        e.setHeight(i);
                        t.setHeight(i)
                    } else {
                        if (s > i) {
                            e.setHeight(s);
                            t.setHeight(s)
                        }
                    }
                }
            }
        }
    },
    onIdChanged: function(e, t, n, r, i) {
        var s = this,
        o;
        if (s.viewReady) {
            o = s.getNodeById(i);
            if (o) {
                o.setAttribute("data-recordId", t.internalId);
                o.id = s.getRowId(t)
            }
        }
    },
    onUpdate: function(e, t, n, r) {
        var i = this,
        s = i.rowTpl,
        o, u, a, f, l, c, h, p, d, v, m, g, y, b, w;
        if (i.viewReady) {
            u = i.getNodeByRecord(t, false);
            if (u) {
                d = i.overItemCls;
                v = i.beforeOverItemCls;
                m = i.focusedItemCls;
                g = i.beforeFocusedItemCls;
                y = i.selectedItemCls;
                b = i.beforeSelectedItemCls;
                o = Ext.fly(u, "_internal");
                f = i.createRowElement(t, i.dataSource.data.indexOf(t));
                if (o.hasCls(d)) {
                    Ext.fly(f).addCls(d)
                }
                if (o.hasCls(v)) {
                    Ext.fly(f).addCls(v)
                }
                if (o.hasCls(m)) {
                    Ext.fly(f).addCls(m)
                }
                if (o.hasCls(g)) {
                    Ext.fly(f).addCls(g)
                }
                if (o.hasCls(y)) {
                    Ext.fly(f).addCls(y)
                }
                if (o.hasCls(b)) {
                    Ext.fly(f).addCls(b)
                }
                w = i.ownerCt.getVisibleColumnManager().getColumns();
                if (Ext.isIE9m && u.mergeAttributes) {
                    u.mergeAttributes(f, true)
                } else {
                    l = f.attributes;
                    c = l.length;
                    for (p = 0; p < c; p++) {
                        h = l[p].name;
                        if (h !== "id") {
                            u.setAttribute(h, l[p].value)
                        }
                    }
                }
                if (w.length && (a = i.getNode(u, true))) {
                    i.updateColumns(t, a, i.getNode(f, true), w, r)
                }
                while (s) {
                    if (s.syncContent) {
                        if (s.syncContent(u, f) === false) {
                            break
                        }
                    }
                    s = s.nextTpl
                }
                i.fireEvent("itemupdate", t, i.store.indexOf(t), u);
                i.refreshSize()
            }
        }
    },
    updateColumns: function(e, t, n, r, i) {
        var s = this,
        o, u, a, f, l = r.length,
        c, h, p, d, v, m = s.editingPlugin || s.lockingPartner && s.ownerCt.ownerLockable.view.editingPlugin,
        g = m && m.editing,
        y = s.getCellSelector();
        if (t.mergeAttributes) {
            t.mergeAttributes(n, true)
        } else {
            o = n.attributes;
            u = o.length;
            for (f = 0; f < u; f++) {
                a = o[f].name;
                if (a !== "id") {
                    t.setAttribute(a, o[f].value)
                }
            }
        }
        for (c = 0; c < l; c++) {
            h = r[c];
            if (s.shouldUpdateCell(e, h, i)) {
                y = s.getCellSelector(h);
                p = Ext.DomQuery.selectNode(y, t);
                d = Ext.DomQuery.selectNode(y, n);
                if (g) {
                    Ext.fly(p).syncContent(d)
                } else {
                    v = p.parentNode;
                    v.insertBefore(d, p);
                    v.removeChild(p)
                }
            }
        }
    },
    shouldUpdateCell: function(e, t, n) {
        if (t.hasCustomRenderer || !n) {
            return true
        }
        if (n) {
            var r = n.length,
            i, s;
            for (i = 0; i < r; ++i) {
                s = n[i];
                if (s === t.dataIndex || s === e.idProperty) {
                    return true
                }
            }
        }
        return false
    },
    refresh: function() {
        var e = this;
        e.callParent(arguments);
        e.headerCt.setSortState();
        if (e.el && e.headerCt && !e.ownerCt.hideHeaders && e.headerCt.tooNarrow && !e.all.getCount()) {
            e.el.createChild({
                role: "presentation",
                style: "position:absolute;height:1px;width:1px;left:" + (e.headerCt.getTableWidth() - 1) + "px"
            })
        }
        e.refreshSelection()
    },
    refreshSelection: function() {
        var e = this,
        t = e.selModel,
        n, r, i;
        if (t.isRowModel) {
            n = t.selected.items;
            r = n.length;
            for (i = 0; i < r; i++) {
                e.onRowSelect(e.indexOf(e.getNode(n[i])))
            }
        }
        e.selModel.onLastFocusChanged(null, e.selModel.lastFocused, true)
    },
    processItemEvent: function(e, t, n, r) {
        i = this;
        if (Ext.isIE && r.type === "mouseup" && !r.within(i.el)) {
            return false
        }
        if (this.indexInStore(t) !== -1) {
            var i, s = r.getTarget(i.getCellSelector(), t),
            o,
            u = i.statics().EventMap,
            a = i.getSelectionModel(),
            f = r.type,
            l = i.features,
            c = l.length,
            h,
            p,
            d,
            v;
            if (f == "keydown" && !s && a.getCurrentPosition) {
                s = i.getCellByPosition(a.getCurrentPosition(), true)
            }
            if (s) {
                if (!s.parentNode) {
                    return false
                }
                v = i.getHeaderByCell(s);
                o = i.ownerCt.getColumnManager().getHeaderIndex(v)
            } else {
                o = -1
            }
            p = i.fireEvent("uievent", f, i, s, n, o, r, e, t);
            if (p === false || i.callParent(arguments) === false) {
                if (a.onVetoUIEvent) {
                    a.onVetoUIEvent(f, i, s, n, o, r, e, t)
                }
                return false
            }
            for (h = 0; h < c; ++h) {
                d = l[h];
                if (d.wrapsItem) {
                    if (d.vetoEvent(e, t, n, r) === false) {
                        i.processSpecialEvent(r);
                        return false
                    }
                }
            }
            if (f == "mouseover" || f == "mouseout") {
                return true
            }
            if (!s) {
                return true
            }
            return ! (i["onBeforeCell" + u[f]](s, o, e, t, n, r) === false || i.fireEvent("beforecell" + f, i, s, o, e, t, n, r) === false || i["onCell" + u[f]](s, o, e, t, n, r) === false || i.fireEvent("cell" + f, i, s, o, e, t, n, r) === false)
        } else {
            this.processSpecialEvent(r);
            return false
        }
    },
    processSpecialEvent: function(e) {
        var t = this,
        n = t.features,
        r = n.length,
        i = e.type,
        s, o, u, a, f, l, c = t.ownerCt;
        t.callParent(arguments);
        if (i == "mouseover" || i == "mouseout") {
            return
        }
        for (s = 0; s < r; s++) {
            o = n[s];
            if (o.hasFeatureEvent) {
                a = e.getTarget(o.eventSelector, t.getTargetEl());
                if (a) {
                    u = o.eventPrefix;
                    f = o.getFireEventArgs("before" + u + i, t, a, e);
                    l = o.getFireEventArgs(u + i, t, a, e);
                    if (t.fireEvent.apply(t, f) === false || c.fireEvent.apply(c, f) === false || t.fireEvent.apply(t, l) === false || c.fireEvent.apply(c, l) === false) {
                        return false
                    }
                }
            }
        }
        return true
    },
    onCellMouseDown: Ext.emptyFn,
    onCellMouseUp: Ext.emptyFn,
    onCellClick: Ext.emptyFn,
    onCellDblClick: Ext.emptyFn,
    onCellContextMenu: Ext.emptyFn,
    onCellKeyDown: Ext.emptyFn,
    onBeforeCellMouseDown: Ext.emptyFn,
    onBeforeCellMouseUp: Ext.emptyFn,
    onBeforeCellClick: Ext.emptyFn,
    onBeforeCellDblClick: Ext.emptyFn,
    onBeforeCellContextMenu: Ext.emptyFn,
    onBeforeCellKeyDown: Ext.emptyFn,
    expandToFit: function(e) {
        this.autoSizeColumn(e)
    },
    autoSizeColumn: function(e) {
        if (Ext.isNumber(e)) {
            e = this.getGridColumns[e]
        }
        if (e) {
            if (e.isGroupHeader) {
                e.autoSize();
                return
            }
            delete e.flex;
            e.setWidth(this.getMaxContentWidth(e))
        }
    },
    getMaxContentWidth: function(e) {
        var t = this,
        n = t.el.query(e.getCellInnerSelector()),
        r = e.getWidth(),
        i = 0,
        s = n.length,
        o = t.body.select(t.getColumnSizerSelector(e)),
        u = Math.max,
        a = 0,
        f;
        if (s > 0) {
            if (Ext.supports.ScrollWidthInlinePaddingBug) {
                a += t.getCellPaddingAfter(n[0])
            }
            if (t.columnLines) {
                a += Ext.fly(n[0].parentNode).getBorderWidth("lr")
            }
        }
        o.setWidth(1);
        e.titleEl.setStyle("text-overflow", "clip");
        f = e.textEl.dom.offsetWidth + e.titleEl.getPadding("lr");
        e.titleEl.setStyle("text-overflow", "");
        for (; i < s; i++) {
            f = u(f, n[i].scrollWidth)
        }
        f += a;
        f = u(f, 40);
        o.setWidth(r);
        return f
    },
    getPositionByEvent: function(e) {
        var t = this,
        n = e.getTarget(t.cellSelector),
        r = e.getTarget(t.itemSelector),
        i = t.getRecord(r),
        s = t.getHeaderByCell(n);
        return t.getPosition(i, s)
    },
    getHeaderByCell: function(e) {
        if (e) {
            var t = e.className.match(this.cellRe);
            if (t && t[1]) {
                return this.ownerCt.getVisibleColumnManager().getHeaderById(t[1])
            }
        }
        return false
    },
    walkCells: function(e, t, n, r, i, s) {
        if (!e) {
            return false
        }
        var o = this,
        u = e.row,
        a = e.column,
        f = o.dataSource.getCount(),
        l = o.ownerCt.getColumnManager(),
        c = o.ownerCt.getVisibleColumnManager(),
        h = l.getHeaderIndex(c.getFirst()),
        p = l.getHeaderIndex(c.getLast()),
        d = u,
        v = a,
        m = l.getHeaderAtIndex(a);
        if (!m || m.hidden || !f) {
            return false
        }
        n = n || {};
        t = t.toLowerCase();
        switch (t) {
        case "right":
            if (a === p) {
                if (r || u === f - 1) {
                    return false
                }
                if (!n.ctrlKey) {
                    d = o.walkRows(u, 1);
                    if (d !== u) {
                        v = h
                    }
                }
            } else {
                if (!n.ctrlKey) {
                    v = l.getHeaderIndex(c.getNextSibling(m))
                } else {
                    v = p
                }
            }
            break;
        case "left":
            if (a === h) {
                if (r || u === 0) {
                    return false
                }
                if (!n.ctrlKey) {
                    d = o.walkRows(u, -1);
                    if (d !== u) {
                        v = p
                    }
                }
            } else {
                if (!n.ctrlKey) {
                    v = l.getHeaderIndex(c.getPreviousSibling(m))
                } else {
                    v = h
                }
            }
            break;
        case "up":
            if (u === 0) {
                return false
            } else {
                if (!n.ctrlKey) {
                    d = o.walkRows(u, -1)
                } else {
                    d = o.walkRows( - 1, 1)
                }
            }
            break;
        case "down":
            if (u === f - 1) {
                return false
            } else {
                if (!n.ctrlKey) {
                    d = o.walkRows(u, 1)
                } else {
                    d = o.walkRows(f, -1)
                }
            }
            break
        }
        if (i && i.call(s || o, {
            row: d,
            column: v
        }) !== true) {
            return false
        }
        v = l.getHeaderAtIndex(v);
        return (new Ext.grid.CellContext(o)).setPosition(d, v)
    },
    walkRows: function(e, t) {
        var n = this,
        r = n.dataSource,
        i = 0,
        s = e,
        o, u = t < 0 ? 0 : (r.buffered ? r.getTotalCount() : r.getCount()) - 1,
        a = u ? 1 : -1,
        f = e;
        do {
            if (u ? f >= u: f <= u) {
                return s || u
            }
            f += a;
            if ((o = Ext.fly(n.getNode(f, true))) && o.isVisible(true)) {
                i += a;
                s = f
            }
        } while ( i !== t );
        return f
    },
    walkRecs: function(e, t) {
        var n = this,
        r = n.dataSource,
        i = 0,
        s = e,
        o, u = t < 0 ? 0 : (r.buffered ? r.getTotalCount() : r.getCount()) - 1,
        a = u ? 1 : -1,
        f = r.indexOf(e),
        l;
        do {
            if (u ? f >= u: f <= u) {
                return s
            }
            f += a;
            l = r.getAt(f);
            if (!l.isCollapsedPlaceholder && (o = Ext.fly(n.getNodeByRecord(l, true))) && o.isVisible(true)) {
                i += a;
                s = l
            }
        } while ( i !== t );
        return s
    },
    getFirstVisibleRowIndex: function() {
        var e = this,
        t = e.dataSource.buffered ? e.dataSource.getTotalCount() : e.dataSource.getCount(),
        n = e.indexOf(e.all.first()) - 1;
        do {
            n += 1;
            if (n === t) {
                return
            }
        } while (! Ext . fly ( e . getNode ( n , true )).isVisible(true));
        return n
    },
    getLastVisibleRowIndex: function() {
        var e = this,
        t = e.indexOf(e.all.last());
        do {
            t -= 1;
            if (t === -1) {
                return
            }
        } while (! Ext . fly ( e . getNode ( t , true )).isVisible(true));
        return t
    },
    getHeaderCt: function() {
        return this.headerCt
    },
    getPosition: function(e, t) {
        return (new Ext.grid.CellContext(this)).setPosition(e, t)
    },
    beforeDestroy: function() {
        var e = this;
        if (e.rendered) {
            e.el.removeAllListeners()
        }
        e.callParent(arguments)
    },
    onDestroy: function() {
        var e = this,
        t = e.featuresMC,
        n, r;
        if (t) {
            for (r = 0, n = t.getCount(); r < n; ++r) {
                t.getAt(r).destroy()
            }
        }
        e.featuresMC = null;
        this.callParent(arguments)
    },
    onReplace: function(e, t, n, r) {
        var i = this,
        s = i.selModel,
        o, u, a;
        i.callParent(arguments);
        i.doStripeRows(t);
        if (i.rendered && s.isRowModel && !r[0].isCollapsedPlaceholder) {
            o = t + r.length;
            u = s.isRowSelected(o);
            a = i.indexOf(s.lastFocused) === o;
            if (u || a) {
                i.onRowDeselect(t)
            }
            if (u) {
                i.onRowSelect(o)
            }
            if (s.isRowSelected(t)) {
                i.onRowSelect(t)
            }
        }
        i.selModel.onLastFocusChanged(null, i.selModel.lastFocused, true)
    },
    onAdd: function(e, t, n) {
        var r = this,
        i = r.selModel,
        s, o, u;
        r.callParent(arguments);
        r.doStripeRows(n);
        if (r.rendered && i.isRowModel && !t[0].isCollapsedPlaceholder) {
            s = n + t.length;
            o = i.isRowSelected(s);
            u = r.indexOf(i.lastFocused) === s;
            if (o || u) {
                r.onRowDeselect(n)
            }
            if (o) {
                r.onRowSelect(s)
            }
            if (i.isRowSelected(n)) {
                r.onRowSelect(n)
            }
        }
        r.selModel.onLastFocusChanged(null, r.selModel.lastFocused, true)
    },
    onRemove: function(e, t, n) {
        var r = this,
        i, s = r.selModel,
        o = n.length,
        u = 0,
        a = 0,
        f;
        r.callParent(arguments);
        r.doStripeRows(n[0]);
        if (r.rendered && s.isRowModel && !t[0].isCollapsedPlaceholder) {
            for (; u < o; u++, a++) {
                i = n[u] - a;
                f = r.store.getAt(i);
                r.onRowDeselect(i);
                if (s.isRowSelected(f) && r.getNode(f)) {
                    r.onRowSelect(i)
                }
            }
        }
        s.onLastFocusChanged(null, s.lastFocused, true)
    },
    doStripeRows: function(e, t) {
        var n = this,
        r, i, s, o;
        if (n.rendered && n.stripeRows) {
            r = n.getNodes(e, t);
            for (s = 0, i = r.length; s < i; s++) {
                o = r[s];
                o.className = o.className.replace(n.rowClsRe, " ");
                e++;
                if (e % 2 === 0) {
                    o.className += " " + n.altRowCls
                }
            }
        }
    },
    repaintRow: function(e) {
        var t = this.getNode(e),
        n,
        r;
        if (t) {
            n = t.childNodes;
            r = n.length;
            while (r--) {
                n[r].className = n[r].className
            }
        }
    },
    getRowStyleTableEl: function(e) {
        var t = this;
        if (!e.tagName) {
            e = this.getNode(e)
        }
        return (t.hasActiveFeature() ? Ext.fly(e) : this.el).down("table." + Ext.baseCSSPrefix + "grid-table")
    },
    toggleRowTableCls: function(e, t, n) {
        var r = this,
        i, s;
        if (!e.tagName) {
            e = this.getNode(e)
        }
        s = r.isGrouping ? Ext.fly(e) : this.el;
        if (s) {
            i = s.down("table." + Ext.baseCSSPrefix + "grid-table")
        }
        if (i) {
            i[n ? "addCls": "removeCls"](t)
        }
    },
    isRowStyleFirst: function(e) {
        var t = this,
        n;
        if (e === -1) {
            return false
        }
        if (!e.tagName) {
            n = e;
            e = this.getNode(e)
        } else {
            n = t.indexOf(e)
        }
        return ! n || t.hasActiveFeature() && e && Ext.fly(e).hasCls(Ext.baseCSSPrefix + "grid-group-row")
    },
    hasActiveFeature: function() {
        return this.isGrouping && this.store.isGrouped() || this.isRowWrapped
    },
    getCellPaddingAfter: function(e) {
        return Ext.fly(e).getPadding("r")
    },
    hasVerticalScroll: function() {
        var e = this,
        t;
        if (e.ownerCt.isLocked || !e.scrollFlags.y) {
            return false
        }
        t = e.el.down("table");
        if (!t) {
            return false
        }
        return this.getHeight() < t.getHeight()
    }
});Ext.define("Ext.grid.View", {
    extend: Ext.view.Table,
    alias: "widget.gridview",
    stripeRows: true,
    autoScroll: true
});Ext.define("Ext.grid.Panel", {
    extend: Ext.panel.Table,
    alias: ["widget.gridpanel", "widget.grid"],
    alternateClassName: ["Ext.list.ListView", "Ext.ListView", "Ext.grid.GridPanel"],
    viewType: "gridview",
    pagingBar: true,
    lockable: false,
    rowLines: true,
    initComponent: function() {
        var e = this;
        if (e.editable) {
            e.plugins = {
                ptype: "cellediting",
                clicksToEdit: 1
            }
        }
        e.callParent(arguments);
        if (e.pagingBar && !e.bbar && !(e instanceof Ext.grid.PropertyGrid)) {
            e.addDocked({
                dock: "bottom",
                xtype: "pagingtoolbar",
                displayInfo: true,
                store: e.store
            })
        }
        if (e.store && e.autoRowNumWidth) {
            e.mon(e.store, "success",
            function(e) {
                var t = e.bindTable;
                if (t && t.columns && t.columns.length) {
                    t.columns[0].setWidth(Math.max(String(e.buffered ? e.getTotalCount() : e.currentPage * e.pageSize).length * 10, 25))
                }
            })
        }
    },
    getValue: function() {
        var e = this,
        t = e.store,
        n;
        if (!t) {
            return null
        }
        if (e.submitSelect) {
            n = e.getSelection()
        } else {
            n = e.store.getRange()
        }
        return Wb.getData(n, true)
    }
});Ext.define("Ext.grid.plugin.BufferedRendererTableView", {
    override: "Ext.view.Table",
    onReplace: function(e, t, n, r) {
        var i = this,
        s = i.bufferedRenderer;
        if (i.rendered && s) {
            s.onReplace(e, t, n, r)
        } else {
            i.callParent(arguments)
        }
    },
    onAdd: function(e, t, n) {
        var r = this,
        i = r.bufferedRenderer;
        if (r.rendered && i) {
            i.onReplace(e, n, [], t)
        } else {
            r.callParent([e, t, n])
        }
    },
    onRemove: function(e, t, n, r, i) {
        var s = this,
        o = s.bufferedRenderer;
        if (s.rendered && o) {
            if (i) {
                o.onReplace(e, n[0], t, [])
            } else {
                o.refreshView()
            }
        } else {
            s.callParent([e, t, n])
        }
    },
    onDataRefresh: function() {
        var e = this;
        if (e.bufferedRenderer) {
            e.all.clear();
            e.bufferedRenderer.onStoreClear()
        }
        e.callParent()
    }
});Ext.define("Ext.grid.RowEditorButtons", {
    extend: Ext.container.Container,
    alias: "widget.roweditorbuttons",
    frame: true,
    shrinkWrap: true,
    position: "bottom",
    constructor: function(e) {
        var t = this,
        n = e.rowEditor,
        r = Ext.baseCSSPrefix,
        i = n.editingPlugin;
        e = Ext.apply({
            baseCls: r + "grid-row-editor-buttons",
            defaults: {
                xtype: "button",
                ui: n.buttonUI,
                scope: i,
                flex: 1,
                minWidth: Ext.panel.Panel.prototype.minButtonWidth
            },
            items: [{
                cls: r + "row-editor-update-button",
                itemId: "update",
                handler: i.completeEdit,
                text: n.saveBtnText,
                disabled: n.updateButtonDisabled
            },
            {
                cls: r + "row-editor-cancel-button",
                itemId: "cancel",
                handler: i.cancelEdit,
                text: n.cancelBtnText
            }]
        },
        e);
        t.callParent([e]);
        t.addClsWithUI(t.position)
    },
    setButtonPosition: function(e) {
        var t = this,
        n = this.rowEditor,
        r = n.getHeight(),
        i = n.body,
        s = "",
        o = "";
        t.removeClsWithUI(t.position);
        t.position = e;
        t.addClsWithUI(e);
        if (e === "top") {
            s = r - i.getBorderWidth("t") + "px"
        } else {
            o = r - i.getBorderWidth("b") + "px"
        }
        t.el.setStyle({
            top: o,
            bottom: s
        })
    },
    getFramingInfoCls: function() {
        return this.baseCls + "-" + this.ui + "-" + this.position
    },
    getFrameInfo: function() {
        var e = this.callParent();
        e.top = true;
        return e
    }
});Ext.define("Ext.grid.RowEditor", {
    extend: Ext.form.Panel,
    alias: "widget.roweditor",
    saveBtnText: "Update",
    cancelBtnText: "Cancel",
    errorsText: "Errors",
    dirtyText: "You need to commit or cancel your changes",
    lastScrollLeft: 0,
    lastScrollTop: 0,
    border: false,
    errorCls: Ext.baseCSSPrefix + "grid-row-editor-errors-item",
    buttonUI: "default",
    hideMode: "offsets",
    initComponent: function() {
        var e = this,
        t = e.editingPlugin.grid,
        n = Ext.container.Container,
        r;
        e.cls = Ext.baseCSSPrefix + "grid-editor " + Ext.baseCSSPrefix + "grid-row-editor";
        e.layout = {
            type: "hbox",
            align: "middle"
        };
        e.lockable = t.lockable;
        if (e.lockable) {
            e.items = [e.lockedColumnContainer = new n({
                id: t.id + "-locked-editor-cells",
                layout: {
                    type: "hbox",
                    align: "middle"
                },
                margin: "0 1 0 0"
            }), e.normalColumnContainer = new n({
                flex: 1,
                id: t.id + "-normal-editor-cells",
                layout: {
                    type: "hbox",
                    align: "middle"
                }
            })]
        } else {
            e.lockedColumnContainer = e.normalColumnContainer = e
        }
        e.callParent(arguments);
        if (e.fields) {
            e.addFieldsForColumn(e.fields, true);
            e.insertColumnEditor(e.fields);
            delete e.fields
        }
        e.mon(e.hierarchyEventSource, {
            scope: e,
            show: e.repositionIfVisible
        });
        r = e.getForm();
        r.trackResetOnLoad = true;
        r.on("validitychange", e.onValidityChange, e)
    },
    onGridResize: function() {
        var e = this,
        t = e.getClientWidth(),
        n = e.editingPlugin.grid,
        r = n.body,
        i = e.getFloatingButtons();
        e.setLocalX(r.getOffsetsTo(n)[0] + r.getBorderWidth("l") - n.el.getBorderWidth("l"));
        e.setWidth(t);
        i.setLocalX((t - i.getWidth()) / 2)
    },
    syncAllFieldWidths: function() {
        var e = this;
        Ext.Array.each(e.query("[isEditorComponent]"),
        function(t) {
            if (t.column.isVisible()) {
                e.onColumnShow(t.column)
            }
        },
        e)
    },
    syncFieldWidth: function(e) {
        var t = e.getEditor(),
        n;
        t._marginWidth = t._marginWidth || t.el.getMargin("lr");
        n = e.getWidth() - t._marginWidth;
        t.setWidth(n);
        if (t.xtype === "displayfield") {
            t.inputWidth = n
        }
    },
    onValidityChange: function(e, t) {
        var n = this;
        if (n.errorSummary && n.isVisible()) {
            n[t ? "hideToolTip": "showToolTip"]()
        }
        n.updateButton(t);
        n.isValid = t
    },
    updateButton: function(e) {
        var t = this.floatingButtons;
        if (t) {
            t.child("#update").setDisabled(!e)
        } else {
            this.updateButtonDisabled = !e
        }
    },
    afterRender: function() {
        var e = this,
        t = e.editingPlugin,
        n = t.grid,
        r = n.lockable ? n.normalGrid.view: n.view;
        e.callParent(arguments);
        e.scrollingView = r;
        e.scrollingViewEl = r.el;
        r.mon(e.scrollingViewEl, "scroll", e.onViewScroll, e);
        e.mon(e.el, {
            click: Ext.emptyFn,
            stopPropagation: true
        });
        e.mon(n, {
            resize: e.onGridResize,
            scope: e
        });
        e.el.swallowEvent(["keypress", "keydown"]);
        e.fieldScroller = e.normalColumnContainer.layout.innerCt;
        e.fieldScroller.dom.style.overflow = "hidden";
        e.fieldScroller.on({
            scroll: e.onFieldContainerScroll,
            scope: e
        });
        e.initKeyNav();
        e.mon(t.view, {
            beforerefresh: e.onBeforeViewRefresh,
            refresh: e.onViewRefresh,
            itemremove: e.onViewItemRemove,
            scope: e
        });
        e.preventReposition = true;
        e.syncAllFieldWidths();
        delete e.preventReposition
    },
    initKeyNav: function() {
        var e = this,
        t = e.editingPlugin;
        e.keyNav = new Ext.util.KeyNav(e.el, {
            enter: t.onEnter,
            esc: t.onEscKey,
            scope: t
        })
    },
    onBeforeViewRefresh: function(e) {
        var t = this,
        n = e.el.dom;
        if (t.el.dom.parentNode === n) {
            n.removeChild(t.el.dom)
        }
    },
    onViewRefresh: function(e) {
        var t = this,
        n = t.context,
        r;
        if (n && (r = e.getNode(n.record, true))) {
            n.row = r;
            t.reposition();
            if (t.tooltip && t.tooltip.isVisible()) {
                t.tooltip.setTarget(n.row)
            }
        } else {
            t.editingPlugin.cancelEdit()
        }
    },
    onViewItemRemove: function(e, t) {
        var n = this.context;
        if (n && e === n.record) {
            this.editingPlugin.cancelEdit()
        }
    },
    onViewScroll: function() {
        var e = this,
        t = e.editingPlugin.view.el,
        n = e.scrollingViewEl,
        r = n.dom.scrollTop,
        i = n.getScrollLeft(),
        s = i !== e.lastScrollLeft,
        o = r !== e.lastScrollTop,
        u;
        e.lastScrollTop = r;
        e.lastScrollLeft = i;
        if (e.isVisible()) {
            u = Ext.getDom(e.context.row.id);
            if (u && t.contains(u)) {
                if (o) {
                    e.context.row = u;
                    e.reposition(null, true);
                    if (e.tooltip && e.tooltip.isVisible() || e.hiddenTip) {
                        e.repositionTip()
                    }
                    e.syncEditorClip()
                }
            } else {
                e.setLocalY( - 400)
            }
        }
        if (e.rendered && s) {
            e.syncFieldsHorizontalScroll()
        }
    },
    syncFieldsHorizontalScroll: function() {
        this.fieldScroller.setScrollLeft(this.lastScrollLeft)
    },
    onFieldContainerScroll: function() {
        this.scrollingViewEl.setScrollLeft(this.fieldScroller.getScrollLeft())
    },
    onColumnResize: function(e, t) {
        var n = this;
        if (n.rendered && !n.editingPlugin.reconfiguring) {
            n.onGridResize();
            n.onViewScroll();
            if (!e.isGroupHeader) {
                n.syncFieldWidth(e);
                n.repositionIfVisible()
            }
        }
    },
    onColumnHide: function(e) {
        if (!this.editingPlugin.reconfiguring && !e.isGroupHeader) {
            e.getEditor().hide();
            this.repositionIfVisible()
        }
    },
    onColumnShow: function(e) {
        var t = this;
        if (t.rendered && !t.editingPlugin.reconfiguring && !e.isGroupHeader && e.getEditor) {
            e.getEditor().show();
            t.syncFieldWidth(e);
            if (!t.preventReposition) {
                this.repositionIfVisible()
            }
        }
    },
    onColumnMove: function(e, t, n) {
        var r = this,
        i = e.isLocked(),
        s = r.editingPlugin.grid,
        o = i ? s.lockedGrid.getColumnManager() : s.getColumnManager(),
        u = i ? r.lockedColumnContainer: r.normalColumnContainer,
        a,
        f,
        l,
        c,
        h;
        if (e.isGroupHeader) {
            Ext.suspendLayouts();
            c = n > t;
            h = c ? 1 : 0;
            a = e.getGridColumns();
            for (f = 0, l = a.length; f < l; ++f) {
                e = a[f];
                n = o.getHeaderIndex(e);
                if (c) {++h
                }
                this.setColumnEditor(e, n + h, u)
            }
            Ext.resumeLayouts(true)
        } else {
            n = o.getHeaderIndex(e);
            this.setColumnEditor(e, n, u)
        }
    },
    setColumnEditor: function(e, t, n) {
        this.addFieldsForColumn(e);
        n.insert(t, e.getEditor())
    },
    onColumnAdd: function(e) {
        if (e.isGroupHeader) {
            e = e.getGridColumns()
        }
        this.addFieldsForColumn(e);
        this.insertColumnEditor(e);
        this.preventReposition = false
    },
    insertColumnEditor: function(e) {
        var t = this,
        n = t.editingPlugin,
        r = n.grid,
        i = r.lockable,
        s, o, u;
        if (Ext.isArray(e)) {
            for (u = 0, o = e.length; u < o; u++) {
                t.insertColumnEditor(e[u])
            }
            return
        }
        if (!e.getEditor) {
            return
        }
        s = e.isLocked() ? t.lockedColumnContainer: t.normalColumnContainer;
        s.insert(r.getColumnManager().getHeaderIndex(e), e.getEditor());
        t.needsSyncFieldWidths = true
    },
    destroyColumnEditor: function(e) {
        var t = this,
        n, r, i;
        if (Ext.isArray(e)) {
            for (i = 0, r = e.length; i < r; i++) {
                t.removeColumnEditor(e[i])
            }
            return
        }
        if (e.hasEditor() && (n = e.getEditor())) {
            n.destroy()
        }
    },
    getFloatingButtons: function() {
        var e = this,
        t = e.floatingButtons;
        if (!t) {
            e.floatingButtons = t = new Ext.grid.RowEditorButtons({
                rowEditor: e
            })
        }
        return t
    },
    repositionIfVisible: function(e) {
        var t = this,
        n = t.view;
        if (e && (e == t || !e.el.isAncestor(n.el))) {
            return
        }
        if (t.isVisible() && n.isVisible(true)) {
            t.reposition()
        }
    },
    getRefOwner: function() {
        return this.editingPlugin.grid
    },
    getRefItems: function(e) {
        var t = this,
        n;
        if (t.lockable) {
            n = [t.lockedColumnContainer];
            n.push.apply(n, t.lockedColumnContainer.getRefItems(e));
            n.push(t.normalColumnContainer);
            n.push.apply(n, t.normalColumnContainer.getRefItems(e))
        } else {
            n = t.callParent(arguments)
        }
        n.push.apply(n, t.getFloatingButtons().getRefItems(e));
        return n
    },
    reposition: function(e, t) {
        var n = this,
        r = n.context,
        i = r && Ext.get(r.row),
        s = 0,
        o,
        u,
        a,
        f;
        if (i && Ext.isElement(i.dom)) {
            a = n.syncButtonPosition(n.getScrollDelta());
            if (!n.editingPlugin.grid.rowLines) {
                s = -parseInt(i.first().getStyle("border-bottom-width"), 10)
            }
            o = n.calculateLocalRowTop(i);
            u = n.calculateEditorTop(o) + s;
            if (!t) {
                f = function() {
                    if (a) {
                        n.scrollingViewEl.scrollBy(0, a, true)
                    }
                    n.focusContextCell()
                }
            }
            n.syncEditorClip();
            if (e) {
                n.animate(Ext.applyIf({
                    to: {
                        top: u
                    },
                    duration: e.duration || 125,
                    callback: f
                },
                e))
            } else {
                n.setLocalY(u);
                if (f) {
                    f()
                }
            }
        }
    },
    getScrollDelta: function() {
        var e = this,
        t = e.scrollingViewEl.dom,
        n = e.context,
        r = e.body,
        i = 0;
        if (n) {
            i = Ext.fly(n.row).getOffsetsTo(t)[1] - r.getBorderPadding().beforeY;
            if (i > 0) {
                i = Math.max(i + e.getHeight() + e.floatingButtons.getHeight() - t.clientHeight - r.getBorderWidth("b"), 0)
            }
        }
        return i
    },
    calculateLocalRowTop: function(e) {
        var t = this.editingPlugin.grid;
        return Ext.fly(e).getOffsetsTo(t)[1] - t.el.getBorderWidth("t") + this.lastScrollTop
    },
    calculateEditorTop: function(e) {
        return e - this.body.getBorderPadding().beforeY - this.lastScrollTop
    },
    getClientWidth: function() {
        var e = this,
        t = e.editingPlugin.grid,
        n;
        if (e.lockable) {
            n = t.lockedGrid.getWidth() + t.normalGrid.view.el.dom.clientWidth - 1
        } else {
            n = t.view.el.dom.clientWidth
        }
        return n
    },
    getEditor: function(e) {
        var t = this;
        if (Ext.isNumber(e)) {
            return t.query("[isEditorComponent]")[e]
        } else {
            if (e.isHeader && !e.isGroupHeader) {
                return e.getEditor()
            }
        }
    },
    addFieldsForColumn: function(e, t) {
        var n = this,
        r, i, s;
        if (Ext.isArray(e)) {
            for (r = 0, i = e.length; r < i; r++) {
                n.addFieldsForColumn(e[r], t)
            }
            return
        }
        if (e.getEditor) {
            s = e.getEditor(null, n.getDefaultFieldCfg());
            if (e.align === "right") {
                s.fieldStyle = "text-align:right"
            }
            if (e.xtype === "actioncolumn") {
                s.fieldCls += " " + Ext.baseCSSPrefix + "form-action-col-field"
            }
            if (n.isVisible() && n.context) {
                if (s.is("displayfield")) {
                    n.renderColumnData(s, n.context.record, e)
                } else {
                    s.suspendEvents();
                    s.setValue(n.context.record.get(e.dataIndex));
                    s.resumeEvents()
                }
            }
            if (e.hidden) {
                n.onColumnHide(e)
            } else {
                if (e.rendered && !t) {
                    n.onColumnShow(e)
                }
            }
        }
    },
    getDefaultFieldCfg: function() {
        return {
            xtype: "displayfield",
            getModelData: function() {
                return null
            }
        }
    },
    loadRecord: function(e) {
        var t = this,
        n = t.getForm(),
        r = n.getFields(),
        i = r.items,
        s = i.length,
        o,
        u,
        a;
        for (o = 0; o < s; o++) {
            i[o].suspendEvents()
        }
        n.loadRecord(e);
        for (o = 0; o < s; o++) {
            i[o].resumeEvents()
        }
        if (n.hasInvalidField() === n.wasValid) {
            delete n.wasValid
        }
        a = n.isValid();
        if (t.errorSummary) {
            if (a) {
                t.hideToolTip()
            } else {
                t.showToolTip()
            }
        }
        t.updateButton(a);
        u = t.query(">displayfield");
        s = u.length;
        for (o = 0; o < s; o++) {
            t.renderColumnData(u[o], e)
        }
    },
    renderColumnData: function(e, t, n) {
        var r = this,
        i = r.editingPlugin.grid,
        s = i.headerCt,
        o = r.scrollingView,
        u = o.dataSource,
        a = n || e.column,
        f = t.get(a.dataIndex),
        l = a.editRenderer || a.renderer,
        c,
        h,
        p;
        if (l) {
            c = {
                tdCls: "",
                style: ""
            };
            h = u.indexOf(t);
            p = s.getHeaderIndex(a);
            f = l.call(a.scope || s.ownerCt, f, c, t, h, p, u, o)
        }
        e.setRawValue(f);
        e.resetOriginalValue()
    },
    beforeEdit: function() {
        var e = this,
        t;
        if (e.isVisible() && e.errorSummary && !e.autoCancel && e.isDirty()) {
            t = e.getScrollDelta();
            if (t) {
                e.scrollingViewEl.scrollBy(0, t, true)
            }
            e.showToolTip();
            return false
        }
    },
    startEdit: function(e, t) {
        var n = this,
        r = n.editingPlugin,
        i = r.grid,
        s = n.context = r.context;
        if (!n.rendered) {
            n.width = n.getClientWidth();
            n.render(i.el, i.el.dom.firstChild);
            n.getFloatingButtons().render(n.el);
            n.onViewScroll()
        } else {
            n.syncFieldsHorizontalScroll()
        }
        s.grid.getSelectionModel().select(e);
        if (n.isVisible()) {
            n.reposition(true)
        } else {
            n.show()
        }
        n.onGridResize();
        n.loadRecord(e)
    },
    syncButtonPosition: function(e) {
        var t = this,
        n = t.getFloatingButtons(),
        r = t.scrollingViewEl.dom,
        i = this.getScrollDelta() - (r.scrollHeight - r.scrollTop - r.clientHeight);
        if (i > 0) {
            if (!t._buttonsOnTop) {
                n.setButtonPosition("top");
                t._buttonsOnTop = true
            }
            e = 0
        } else {
            if (t._buttonsOnTop !== false) {
                n.setButtonPosition("bottom");
                t._buttonsOnTop = false
            }
        }
        return e
    },
    syncEditorClip: function() {
        var e = this,
        t = e.getScrollDelta(),
        n;
        if (t) {
            e.isOverflowing = true;
            n = e.floatingButtons.getHeight();
            if (t > 0) {
                e.clipBottom(Math.max(e.getHeight() - t + n, -n))
            } else {
                if (t < 0) {
                    t = Math.abs(t);
                    e.clipTop(Math.max(t, 0))
                }
            }
        } else {
            if (e.isOverflowing) {
                e.clearClip();
                e.isOverflowing = false
            }
        }
    },
    focusContextCell: function() {
        var e = this.context.column,
        t;
        if (!e.isDestroyed) {
            t = this.getEditor(e);
            if (t && t.focus) {
                t.focus()
            }
        }
    },
    cancelEdit: function() {
        var e = this,
        t = e.getForm(),
        n = t.getFields(),
        r = n.items,
        i = r.length,
        s;
        e.hide();
        t.clearInvalid();
        for (s = 0; s < i; s++) {
            r[s].suspendEvents()
        }
        t.reset();
        for (s = 0; s < i; s++) {
            r[s].resumeEvents()
        }
    },
    completeEdit: function() {
        var e = this,
        t = e.getForm();
        if (!t.isValid()) {
            return false
        }
        t.updateRecord(e.context.record);
        e.hide();
        return true
    },
    onShow: function() {
        var e = this;
        e.callParent(arguments);
        if (e.needsSyncFieldWidths) {
            e.suspendLayouts();
            e.syncAllFieldWidths();
            e.resumeLayouts(true)
        }
        delete e.needsSyncFieldWidths;
        e.reposition()
    },
    onHide: function() {
        var e = this;
        e.callParent(arguments);
        if (e.tooltip) {
            e.hideToolTip()
        }
        if (e.context) {
            e.context.view.focusRow(e.context.record);
            e.context = null
        }
    },
    isDirty: function() {
        var e = this,
        t = e.getForm();
        return t.isDirty()
    },
    getToolTip: function() {
        return this.tooltip || (this.tooltip = new Ext.tip.ToolTip({
            cls: Ext.baseCSSPrefix + "grid-row-editor-errors",
            title: this.errorsText,
            autoHide: false,
            closable: true,
            closeAction: "disable",
            anchor: "left",
            anchorToTarget: false
        }))
    },
    hideToolTip: function() {
        var e = this,
        t = e.getToolTip();
        if (t.rendered) {
            t.disable()
        }
        e.hiddenTip = false
    },
    showToolTip: function() {
        var e = this,
        t = e.getToolTip();
        t.showAt([0, 0]);
        t.update(e.getErrors());
        e.repositionTip();
        t.enable()
    },
    repositionTip: function() {
        var e = this,
        t = e.getToolTip(),
        n = e.context,
        r = Ext.get(n.row),
        i = e.scrollingViewEl,
        s = i.dom.clientHeight,
        o = e.lastScrollTop,
        u = o + s,
        a = r.getHeight(),
        f = r.getOffsetsTo(e.context.view.body)[1],
        l = f + a;
        if (l > o && f < u) {
            t.showAt(t.getAlignToXY(i, "tl-tr", [15, r.getOffsetsTo(i)[1]]));
            e.hiddenTip = false
        } else {
            t.hide();
            e.hiddenTip = true
        }
    },
    getErrors: function() {
        var e = this,
        t = [],
        n = e.query(">[isFormField]"),
        r = n.length,
        i;
        for (i = 0; i < r; i++) {
            t = t.concat(Ext.Array.map(n[i].getErrors(), e.createErrorListItem))
        }
        if (!t.length && !e.autoCancel && e.isDirty()) {
            t[0] = e.createErrorListItem(e.dirtyText)
        }
        return '<ul class="' + Ext.plainListCls + '">' + t.join("") + "</ul>"
    },
    createErrorListItem: function(e) {
        return '<li class="' + this.errorCls + '">' + e + "</li>"
    },
    beforeDestroy: function() {
        Ext.destroy(this.floatingButtons, this.tooltip);
        this.callParent()
    },
    clipBottom: function(e) {
        this.el.setStyle("clip", "rect(-1000px auto " + e + "px auto)")
    },
    clipTop: function(e) {
        this.el.setStyle("clip", "rect(" + e + "px auto 1000px auto)")
    },
    clearClip: function(e) {
        this.el.setStyle("clip", Ext.isIE8m || Ext.isIEQuirks ? "rect(-1000px auto 1000px auto)": "auto")
    }
});Ext.define("Ext.view.DropZone", {
    extend: Ext.dd.DropZone,
    indicatorCls: Ext.baseCSSPrefix + "grid-drop-indicator",
    indicatorHtml: ['<div class="', Ext.baseCSSPrefix, 'grid-drop-indicator-left" role="presentation"></div>', '<div class="' + Ext.baseCSSPrefix + 'grid-drop-indicator-right" role="presentation"></div>'].join(""),
    constructor: function(e) {
        var t = this;
        Ext.apply(t, e);
        if (!t.ddGroup) {
            t.ddGroup = "view-dd-zone-" + t.view.id
        }
        t.callParent([t.view.el])
    },
    fireViewEvent: function() {
        var e = this,
        t;
        e.lock();
        t = e.view.fireEvent.apply(e.view, arguments);
        e.unlock();
        return t
    },
    getTargetFromEvent: function(e) {
        var t = e.getTarget(this.view.getItemSelector()),
        n,
        r,
        i,
        s,
        o,
        u;
        if (!t) {
            n = e.getPageY();
            for (s = 0, r = this.view.getNodes(), o = r.length; s < o; s++) {
                i = r[s];
                u = Ext.fly(i).getBox();
                if (n <= u.bottom) {
                    return i
                }
            }
        }
        return t
    },
    getIndicator: function() {
        var e = this;
        if (!e.indicator) {
            e.indicator = new Ext.Component({
                ariaRole: "presentation",
                html: e.indicatorHtml,
                cls: e.indicatorCls,
                ownerCt: e.view,
                floating: true,
                shadow: false
            })
        }
        return e.indicator
    },
    getPosition: function(e, t) {
        var n = e.getXY()[1],
        r = Ext.fly(t).getRegion(),
        i;
        if (r.bottom - n >= (r.bottom - r.top) / 2) {
            i = "before"
        } else {
            i = "after"
        }
        return i
    },
    containsRecordAtOffset: function(e, t, n) {
        if (!t) {
            return false
        }
        var r = this.view,
        i = r.indexOf(t),
        s = r.getNode(i + n, true),
        o = s ? r.getRecord(s) : null;
        return o && Ext.Array.contains(e, o)
    },
    positionIndicator: function(e, t, n) {
        var r = this,
        i = r.view,
        s = r.getPosition(n, e),
        o = i.getRecord(e),
        u = t.records,
        a;
        if (!Ext.Array.contains(u, o) && (s == "before" && !r.containsRecordAtOffset(u, o, -1) || s == "after" && !r.containsRecordAtOffset(u, o, 1))) {
            r.valid = true;
            if (r.overRecord != o || r.currentPosition != s) {
                a = Ext.fly(e).getY() - i.el.getY() - 1;
                if (s == "after") {
                    a += Ext.fly(e).getHeight()
                }
                r.getIndicator().setWidth(Ext.fly(i.el).getWidth()).showAt(0, a);
                r.overRecord = o;
                r.currentPosition = s
            }
        } else {
            r.invalidateDrop()
        }
    },
    invalidateDrop: function() {
        if (this.valid) {
            this.valid = false;
            this.getIndicator().hide()
        }
    },
    onNodeOver: function(e, t, n, r) {
        var i = this;
        if (!Ext.Array.contains(r.records, i.view.getRecord(e))) {
            i.positionIndicator(e, r, n)
        }
        return i.valid ? i.dropAllowed: i.dropNotAllowed
    },
    notifyOut: function(e, t, n, r) {
        var i = this;
        i.callParent(arguments);
        i.overRecord = i.currentPosition = null;
        i.valid = false;
        if (i.indicator) {
            i.indicator.hide()
        }
    },
    onContainerOver: function(e, t, n) {
        var r = this,
        i = r.view,
        s = i.dataSource.getCount();
        if (s) {
            r.positionIndicator(i.all.last(), n, t)
        } else {
            r.overRecord = r.currentPosition = null;
            r.getIndicator().setWidth(Ext.fly(i.el).getWidth()).showAt(0, 0);
            r.valid = true
        }
        return r.dropAllowed
    },
    onContainerDrop: function(e, t, n) {
        return this.onNodeDrop(e, null, t, n)
    },
    onNodeDrop: function(e, t, n, r) {
        var i = this,
        s = false,
        o = {
            wait: false,
            processDrop: function() {
                i.invalidateDrop();
                i.handleNodeDrop(r, i.overRecord, i.currentPosition);
                s = true;
                i.fireViewEvent("drop", e, r, i.overRecord, i.currentPosition)
            },
            cancelDrop: function() {
                i.invalidateDrop();
                s = true
            }
        },
        u = false;
        if (i.valid) {
            u = i.fireViewEvent("beforedrop", e, r, i.overRecord, i.currentPosition, o);
            if (o.wait) {
                return
            }
            if (u !== false) {
                if (!s) {
                    o.processDrop()
                }
            }
        }
        return u
    },
    destroy: function() {
        Ext.destroy(this.indicator);
        delete this.indicator;
        this.callParent()
    }
});Ext.define("Ext.grid.ViewDropZone", {
    extend: Ext.view.DropZone,
    indicatorHtml: '<div class="' + Ext.baseCSSPrefix + 'grid-drop-indicator-left" role="presentation"></div><div class="' + Ext.baseCSSPrefix + 'grid-drop-indicator-right" role="presentation"></div>',
    indicatorCls: Ext.baseCSSPrefix + "grid-drop-indicator",
    handleNodeDrop: function(e, t, n) {
        var r = this.view,
        i = r.getStore(),
        s,
        o,
        u,
        a;
        if (e.copy) {
            o = e.records;
            e.records = [];
            for (u = 0, a = o.length; u < a; u++) {
                e.records.push(o[u].copy())
            }
        } else {
            e.view.store.remove(e.records, e.view === r)
        }
        if (t && n) {
            s = i.indexOf(t);
            if (n !== "before") {
                s++
            }
            i.insert(s, e.records)
        } else {
            i.add(e.records)
        }
        r.getSelectionModel().select(e.records)
    }
});Ext.define("Ext.grid.plugin.HeaderResizer", {
    extend: Ext.AbstractPlugin,
    alias: "plugin.gridheaderresizer",
    disabled: false,
    config: {
        dynamic: false
    },
    colHeaderCls: Ext.baseCSSPrefix + "column-header",
    minColWidth: 40,
    maxColWidth: 1e3,
    wResizeCursor: "col-resize",
    eResizeCursor: "col-resize",
    init: function(e) {
        this.headerCt = e;
        e.on("render", this.afterHeaderRender, this, {
            single: true
        })
    },
    destroy: function() {
        var e = this.tracker;
        if (e) {
            delete e.onBeforeStart;
            delete e.onStart;
            delete e.onDrag;
            delete e.onEnd;
            e.destroy();
            this.tracker = null
        }
    },
    afterHeaderRender: function() {
        var e = this,
        t = this.headerCt,
        n = t.el;
        t.mon(n, "mousemove", this.onHeaderCtMouseMove, this);
        e.markerOwner = e.ownerGrid = e.headerCt.up("tablepanel");
        if (e.markerOwner.ownerLockable) {
            e.markerOwner = e.markerOwner.ownerLockable
        }
        e.tracker = new Ext.dd.DragTracker({
            disabled: e.disabled,
            onBeforeStart: Ext.Function.bind(e.onBeforeStart, e),
            onStart: Ext.Function.bind(e.onStart, e),
            onDrag: Ext.Function.bind(e.onDrag, e),
            onEnd: Ext.Function.bind(e.onEnd, e),
            tolerance: 3,
            autoStart: 300,
            el: n
        })
    },
    onHeaderCtMouseMove: function(e) {
        var t = this,
        n, r, i, s;
        if (t.headerCt.dragging || t.disabled) {
            if (t.activeHd) {
                t.activeHd.el.dom.style.cursor = "";
                delete t.activeHd
            }
        } else {
            n = e.getTarget("." + t.colHeaderCls, 3, true);
            if (n) {
                r = Ext.getCmp(n.id);
                if (r.isOnRightEdge(e)) {
                    if (t.headerCt.visibleColumnManager.getColumns().length === 1 && t.headerCt.forceFit) {
                        return
                    }
                    i = r
                } else {
                    if (r.isOnLeftEdge(e)) {
                        s = t.headerCt.visibleColumnManager.getColumns();
                        i = s[Ext.Array.indexOf(s, r) - 1];
                        if (!i && t.ownerGrid.ownerLockable && !t.ownerGrid.isLocked) {
                            s = t.ownerGrid.ownerLockable.lockedGrid.headerCt.visibleColumnManager.getColumns();
                            i = s[s.length - 1]
                        }
                    }
                }
                if (i) {
                    if (i.isGroupHeader) {
                        s = i.getGridColumns();
                        i = s[s.length - 1]
                    }
                    if (i && !(i.fixed || i.resizable === false)) {
                        t.activeHd = i;
                        r.el.dom.style.cursor = t.eResizeCursor;
                        if (r.triggerEl) {
                            r.triggerEl.dom.style.cursor = t.eResizeCursor
                        }
                    }
                } else {
                    r.el.dom.style.cursor = "";
                    if (r.triggerEl) {
                        r.triggerEl.dom.style.cursor = ""
                    }
                    t.activeHd = null
                }
            }
        }
    },
    onBeforeStart: function(e) {
        var t = this;
        t.dragHd = t.activeHd;
        if ( !! t.dragHd && !t.headerCt.dragging) {
            t.xDelta = t.dragHd.getX() + t.dragHd.getWidth() - t.tracker.getXY()[0];
            this.tracker.constrainTo = this.getConstrainRegion();
            return true
        } else {
            t.headerCt.dragging = false;
            return false
        }
    },
    getConstrainRegion: function() {
        var e = this,
        t = e.dragHd.el,
        n = 0,
        r, i, s = e.headerCt.getWidth() - e.headerCt.visibleColumnManager.getColumns().length * e.minColWidth;
        if (e.headerCt.forceFit) {
            r = e.dragHd.nextNode("gridcolumn:not([hidden]):not([isGroupHeader])");
            if (r && e.headerInSameGrid(r)) {
                n = r.getWidth() - e.minColWidth
            }
        } else {
            if ((i = e.dragHd.up("tablepanel")).isLocked) {
                n = e.dragHd.up("[scrollerOwner]").getTargetEl().getWidth() - i.getWidth() - (i.ownerLockable.normalGrid.visibleColumnManager.getColumns().length * e.minColWidth + Ext.getScrollbarSize().width)
            } else {
                n = s - t.getWidth()
            }
        }
        return e.adjustConstrainRegion(t.getRegion(), 0, n - e.xDelta, 0, e.minColWidth - e.xDelta)
    },
    onStart: function(e) {
        var t = this,
        n = t.dragHd,
        r = n.el.getWidth(),
        i = n.getOwnerHeaderCt(),
        s,
        o,
        u,
        a,
        f,
        l;
        t.headerCt.dragging = true;
        t.origWidth = r;
        if (!t.dynamic) {
            u = t.markerOwner;
            if (u.frame && u.resizable) {
                t.gridOverflowSetting = u.el.dom.style.overflow;
                u.el.dom.style.overflow = "hidden"
            }
            s = t.getLeftMarkerX(u);
            a = u.getLhsMarker();
            f = u.getRhsMarker();
            l = t.ownerGrid.body.getHeight() + i.getHeight();
            o = i.getOffsetsTo(u)[1] - u.el.getBorderWidth("t");
            a.setLocalY(o);
            f.setLocalY(o);
            a.setHeight(l);
            f.setHeight(l);
            t.setMarkerX(a, s);
            t.setMarkerX(f, s + r)
        }
    },
    onDrag: function(e) {
        var t = this;
        if (t.dynamic) {
            t.doResize()
        } else {
            t.setMarkerX(t.getMovingMarker(t.markerOwner), t.calculateDragX(t.markerOwner))
        }
    },
    getMovingMarker: function(e) {
        return e.getRhsMarker()
    },
    onEnd: function(e) {
        this.headerCt.dragging = false;
        if (this.dragHd) {
            if (!this.dynamic) {
                var t = this.headerCt.up("tablepanel");
                if (t.ownerLockable) {
                    t = t.ownerLockable
                }
                if ("gridOverflowSetting" in this) {
                    t.el.dom.style.overflow = this.gridOverflowSetting
                }
                this.setMarkerX(t.getLhsMarker(), -9999);
                this.setMarkerX(t.getRhsMarker(), -9999)
            }
            this.doResize()
        }
        this.onHeaderCtMouseMove(e)
    },
    doResize: function() {
        var e = this,
        t = e.dragHd,
        n, r = e.tracker.getOffset("point");
        if (t && r[0]) {
            if (t.flex) {
                delete t.flex
            }
            Ext.suspendLayouts();
            e.adjustColumnWidth(r[0]);
            if (e.headerCt.forceFit) {
                n = t.nextNode("gridcolumn:not([hidden]):not([isGroupHeader])");
                if (n && !e.headerInSameGrid(n)) {
                    n = null
                }
                if (n) {
                    delete n.flex;
                    n.setWidth(n.getWidth() - r[0])
                }
            }
            Ext.resumeLayouts(true)
        }
    },
    headerInSameGrid: function(e) {
        var t = this.dragHd.up("tablepanel");
        return !! e.up(t)
    },
    disable: function() {
        this.disabled = true;
        if (this.tracker) {
            this.tracker.disable()
        }
    },
    enable: function() {
        this.disabled = false;
        if (this.tracker) {
            this.tracker.enable()
        }
    },
    calculateDragX: function(e) {
        return this.tracker.getXY("point")[0] + this.xDelta - e.getX() - e.el.getBorderWidth("l")
    },
    getLeftMarkerX: function(e) {
        return this.dragHd.getX() - e.getX() - e.el.getBorderWidth("l") - 1
    },
    setMarkerX: function(e, t) {
        e.setLocalX(t)
    },
    adjustConstrainRegion: function(e, t, n, r, i) {
        return e.adjust(t, n, r, i)
    },
    adjustColumnWidth: function(e) {
        this.dragHd.setWidth(this.origWidth + e)
    }
});Ext.define("Ext.grid.header.DragZone", {
    extend: Ext.dd.DragZone,
    colHeaderSelector: "." + Ext.baseCSSPrefix + "column-header",
    colInnerSelector: "." + Ext.baseCSSPrefix + "column-header-inner",
    maxProxyWidth: 120,
    constructor: function(e) {
        var t = this;
        t.headerCt = e;
        t.ddGroup = t.getDDGroup();
        t.autoGroup = true;
        t.callParent([e.el]);
        t.proxy.el.addCls(Ext.baseCSSPrefix + "grid-col-dd")
    },
    getDDGroup: function() {
        return "header-dd-zone-" + this.headerCt.up("[scrollerOwner]").id
    },
    getDragData: function(e) {
        if (e.getTarget(this.colInnerSelector)) {
            var t = e.getTarget(this.colHeaderSelector),
            n,
            r;
            if (t) {
                n = Ext.getCmp(t.id);
                if (!this.headerCt.dragging && n.draggable && !(n.isOnLeftEdge(e) || n.isOnRightEdge(e))) {
                    r = document.createElement("div");
                    r.role = "presentation";
                    r.innerHTML = Ext.getCmp(t.id).text;
                    return {
                        ddel: r,
                        header: n
                    }
                }
            }
        }
        return false
    },
    onBeforeDrag: function() {
        return ! (this.headerCt.dragging || this.disabled)
    },
    onInitDrag: function() {
        this.headerCt.dragging = true;
        this.callParent(arguments)
    },
    onDragDrop: function() {
        this.headerCt.dragging = false;
        this.callParent(arguments)
    },
    afterRepair: function() {
        this.callParent();
        this.headerCt.dragging = false
    },
    getRepairXY: function() {
        return this.dragData.header.el.getXY()
    },
    disable: function() {
        this.disabled = true
    },
    enable: function() {
        this.disabled = false
    }
});Ext.define("Ext.grid.header.DropZone", {
    extend: Ext.dd.DropZone,
    colHeaderCls: Ext.baseCSSPrefix + "column-header",
    proxyOffsets: [ - 4, -9],
    constructor: function(e) {
        var t = this;
        t.headerCt = e;
        t.ddGroup = t.getDDGroup();
        t.autoGroup = true;
        t.callParent([e.el])
    },
    destroy: function() {
        this.callParent();
        Ext.destroy(this.topIndicator, this.bottomIndicator)
    },
    getDDGroup: function() {
        return "header-dd-zone-" + this.headerCt.up("[scrollerOwner]").id
    },
    getTargetFromEvent: function(e) {
        return e.getTarget("." + this.colHeaderCls)
    },
    getTopIndicator: function() {
        if (!this.topIndicator) {
            this.topIndicator = Ext.DomHelper.append(Ext.getBody(), {
                role: "presentation",
                cls: "col-move-top",
                html: "&#160;"
            },
            true);
            this.indicatorXOffset = Math.floor((this.topIndicator.dom.offsetWidth + 1) / 2)
        }
        return this.topIndicator
    },
    getBottomIndicator: function() {
        if (!this.bottomIndicator) {
            this.bottomIndicator = Ext.DomHelper.append(Ext.getBody(), {
                role: "presentation",
                cls: "col-move-bottom",
                html: "&#160;"
            },
            true)
        }
        return this.bottomIndicator
    },
    getLocation: function(e, t) {
        var n = e.getXY()[0],
        r = Ext.fly(t).getRegion(),
        i;
        if (r.right - n <= (r.right - r.left) / 2) {
            i = "after"
        } else {
            i = "before"
        }
        return {
            pos: i,
            header: Ext.getCmp(t.id),
            node: t
        }
    },
    positionIndicator: function(e, t, n) {
        var r = this,
        i = e.header,
        s = r.getLocation(n, t),
        o = s.header,
        u = s.pos,
        a,
        f,
        l,
        c,
        h,
        p,
        d,
        v,
        m,
        g,
        y,
        b,
        w,
        E,
        S;
        if (o === r.lastTargetHeader && u === r.lastDropPos) {
            return
        }
        a = i.nextSibling("gridcolumn:not([hidden])");
        f = i.previousSibling("gridcolumn:not([hidden])");
        r.lastTargetHeader = o;
        r.lastDropPos = u;
        if (!o.draggable && u === "before" && o.getIndex() === 0) {
            return false
        }
        e.dropLocation = s;
        if (i !== o && (u === "before" && a !== o || u === "after" && f !== o) && !o.isDescendantOf(i)) {
            b = Ext.dd.DragDropManager.getRelated(r);
            w = b.length;
            E = 0;
            for (; E < w; E++) {
                S = b[E];
                if (S !== r && S.invalidateDrop) {
                    S.invalidateDrop()
                }
            }
            r.valid = true;
            l = r.getTopIndicator();
            c = r.getBottomIndicator();
            if (u === "before") {
                h = "bc-tl";
                p = "tc-bl"
            } else {
                h = "bc-tr";
                p = "tc-br"
            }
            d = l.getAlignToXY(o.el, h);
            v = c.getAlignToXY(o.el, p);
            m = r.headerCt.el;
            g = m.getX() - r.indicatorXOffset;
            y = m.getX() + m.getWidth();
            d[0] = Ext.Number.constrain(d[0], g, y);
            v[0] = Ext.Number.constrain(v[0], g, y);
            l.setXY(d);
            c.setXY(v);
            l.show();
            c.show()
        } else {
            r.invalidateDrop()
        }
    },
    invalidateDrop: function() {
        this.valid = false;
        this.hideIndicators()
    },
    onNodeOver: function(e, t, n, r) {
        var i = this,
        s = r.header,
        o, u, a, f;
        if (r.header.el.dom === e) {
            o = false
        } else {
            r.isLock = r.isUnlock = r.crossPanel = false;
            u = i.getLocation(n, e).header;
            o = s.ownerCt === u.ownerCt;
            if (!o && !s.ownerCt.sealed && !u.ownerCt.sealed) {
                o = true;
                a = s.up("tablepanel");
                f = u.up("tablepanel");
                if (a !== f) {
                    r.crossPanel = true;
                    r.isLock = f.isLocked && !a.isLocked;
                    r.isUnlock = !f.isLocked && a.isLocked;
                    if (r.isUnlock && s.lockable === false || r.isLock && !s.isLockable()) {
                        o = false
                    }
                }
            }
        }
        if (o) {
            i.positionIndicator(r, e, n)
        } else {
            i.valid = false
        }
        return i.valid ? i.dropAllowed: i.dropNotAllowed
    },
    hideIndicators: function() {
        var e = this;
        e.getTopIndicator().hide();
        e.getBottomIndicator().hide();
        e.lastTargetHeader = e.lastDropPos = null
    },
    onNodeOut: function() {
        this.hideIndicators()
    },
    onNodeDrop: function(e, t, n, r) {
        if (this.valid) {
            var i = r.header,
            s = r.dropLocation,
            o = s.header,
            u = i.ownerCt,
            a = o.ownerCt,
            f = u === a,
            l = u.items.indexOf(r.header),
            c = a.items.indexOf(o),
            h = this.headerCt,
            p = h.visibleColumnManager,
            d = p.getHeaderIndex(i),
            v = o.isGroupHeader ? a.items.indexOf(o) : p.getHeaderIndex(o),
            m = i.isGroupHeader ? i.query(":not([hidden]):not([isGroupHeader])").length: 1,
            g = o.isGroupHeader ? s.pos === "after": p.getHeaderIndex(o) > p.getHeaderIndex(i),
            y,
            b;
            if (s.pos === "after") {
                c++;
                v += o.isGroupHeader ? o.query(":not([hidden]):not([isGroupHeader])").length: 1
            }
            if (r.isLock) {
                y = u.up("[scrollerOwner]");
                y.lock(i, c, a)
            } else {
                if (r.isUnlock) {
                    y = u.up("[scrollerOwner]");
                    y.unlock(i, c, a)
                } else {
                    this.invalidateDrop();
                    b = i.getWidth();
                    if (f) {
                        if (c > l) {
                            c -= 1
                        }
                        if (c === l) {
                            h.onHeaderMoved(i, m, d, v);
                            return
                        }
                    }
                    Ext.suspendLayouts();
                    if (f) {
                        a.move(l, c)
                    } else {
                        if (g && v === c) {
                            c -= 1
                        }
                        u.isDDMoveInGrid = a.isDDMoveInGrid = !r.crossPanel;
                        u.remove(i, false);
                        a.insert(c, i);
                        u.isDDMoveInGrid = a.isDDMoveInGrid = false
                    }
                    if (a.isGroupHeader) {
                        if (!f) {
                            i.savedFlex = i.flex;
                            delete i.flex;
                            i.width = b
                        }
                    } else {
                        if (i.savedFlex) {
                            i.flex = i.savedFlex;
                            delete i.width
                        }
                    }
                    Ext.resumeLayouts(true);
                    if (!f) {
                        h.onHeaderMoved(i, m, d, v)
                    }
                }
            }
        }
    }
});Ext.define("Ext.grid.plugin.HeaderReorderer", {
    extend: Ext.AbstractPlugin,
    alias: "plugin.gridheaderreorderer",
    init: function(e) {
        this.headerCt = e;
        e.on({
            render: this.onHeaderCtRender,
            single: true,
            scope: this
        })
    },
    destroy: function() {
        Ext.destroy(this.dragZone, this.dropZone)
    },
    onHeaderCtRender: function() {
        var e = this;
        e.dragZone = new Ext.grid.header.DragZone(e.headerCt);
        e.dropZone = new Ext.grid.header.DropZone(e.headerCt);
        if (e.disabled) {
            e.dragZone.disable()
        }
    },
    enable: function() {
        this.disabled = false;
        if (this.dragZone) {
            this.dragZone.enable()
        }
    },
    disable: function() {
        this.disabled = true;
        if (this.dragZone) {
            this.dragZone.disable()
        }
    }
});Ext.define("Ext.grid.header.Container", {
    extend: Ext.container.Container,
    border: true,
    alias: "widget.headercontainer",
    baseCls: Ext.baseCSSPrefix + "grid-header-ct",
    dock: "top",
    weight: 100,
    defaultType: "gridcolumn",
    detachOnRemove: false,
    defaultWidth: 100,
    sortAscText: "Sort Ascending",
    sortDescText: "Sort Descending",
    sortClearText: "Clear Sort",
    columnsText: "Columns",
    headerOpenCls: Ext.baseCSSPrefix + "column-header-open",
    menuSortAscCls: Ext.baseCSSPrefix + "hmenu-sort-asc",
    menuSortDescCls: Ext.baseCSSPrefix + "hmenu-sort-desc",
    menuColsIcon: Ext.baseCSSPrefix + "cols-icon",
    ddLock: false,
    dragging: false,
    sortable: true,
    enableColumnHide: true,
    initComponent: function() {
        var e = this;
        e.headerCounter = 0;
        e.plugins = e.plugins || [];
        e.defaults = e.defaults || {};
        if (!e.isColumn) {
            if (e.enableColumnResize) {
                e.resizer = new Ext.grid.plugin.HeaderResizer;
                e.plugins.push(e.resizer)
            }
            if (e.enableColumnMove) {
                e.reorderer = new Ext.grid.plugin.HeaderReorderer;
                e.plugins.push(e.reorderer)
            }
        }
        if (e.isColumn && !e.isGroupHeader) {
            if (!e.items || e.items.length === 0) {
                e.isContainer = false;
                e.layout = {
                    type: "container",
                    calculate: Ext.emptyFn
                }
            }
        } else {
            e.layout = Ext.apply({
                type: "gridcolumn",
                align: "stretch"
            },
            e.initialConfig.layout);
            e.defaults.columnLines = e.columnLines;
            if (!e.isGroupHeader) {
                e.isRootHeader = true;
                e.columnManager = new Ext.grid.ColumnManager(false, e);
                e.visibleColumnManager = new Ext.grid.ColumnManager(true, e);
                if (e.grid) {
                    e.grid.columnManager = e.columnManager;
                    e.grid.visibleColumnManager = e.visibleColumnManager
                }
            } else {
                e.visibleColumnManager = new Ext.grid.ColumnManager(true, e);
                e.columnManager = new Ext.grid.ColumnManager(false, e)
            }
        }
        Ext.applyIf(e.defaults, {
            sortable: e.sortable
        });
        e.menuTask = new Ext.util.DelayedTask(e.updateMenuDisabledState, e);
        e.callParent();
        e.addEvents("columnresize", "headerclick", "headercontextmenu", "headertriggerclick", "columnmove", "columnhide", "columnshow", "columnschanged", "sortchange", "menucreate")
    },
    initEvents: function() {
        var e = this;
        e.callParent();
        if (!e.isColumn && !e.isGroupHeader) {
            e.mon(e.el, {
                click: e.onHeaderCtEvent,
                dblclick: e.onHeaderCtEvent,
                contextmenu: e.onHeaderCtEvent,
                mouseover: e.onHeaderCtMouseOver,
                mouseout: e.onHeaderCtMouseOut,
                scope: e
            })
        }
    },
    onHeaderCtEvent: function(e, t) {
        var n = this,
        r = e.getTarget("." + Ext.grid.column.Column.prototype.baseCls),
        i,
        s,
        o;
        if (r && !n.ddLock) {
            i = Ext.getCmp(r.id);
            if (i) {
                s = i[i.clickTargetName];
                if (e.within(s)) {
                    if (e.type === "click") {
                        o = i.onTitleElClick(e, s);
                        if (o) {
                            n.onHeaderTriggerClick(i, e, t)
                        } else {
                            n.onHeaderClick(i, e, t)
                        }
                    } else {
                        if (e.type === "contextmenu") {
                            n.onHeaderContextMenu(i, e, t)
                        } else {
                            if (e.type === "dblclick" && i.resizable) {
                                i.onTitleElDblClick(e, s.dom)
                            }
                        }
                    }
                }
            }
        }
    },
    onHeaderCtMouseOver: function(e, t) {
        var n, r, i;
        if (!e.within(this.el, true)) {
            n = e.getTarget("." + Ext.grid.column.Column.prototype.baseCls);
            r = n && Ext.getCmp(n.id);
            if (r) {
                i = r[r.clickTargetName];
                if (e.within(i)) {
                    r.onTitleMouseOver(e, i.dom)
                }
            }
        }
    },
    onHeaderCtMouseOut: function(e, t) {
        var n = "." + Ext.grid.column.Column.prototype.baseCls,
        r = e.getTarget(n),
        i = e.getRelatedTarget(n),
        s,
        o;
        if (r !== i) {
            if (r) {
                s = Ext.getCmp(r.id);
                if (s) {
                    o = s[s.clickTargetName];
                    s.onTitleMouseOut(e, o.dom)
                }
            }
            if (i) {
                s = Ext.getCmp(i.id);
                if (s) {
                    o = s[s.clickTargetName];
                    s.onTitleMouseOver(e, o.dom)
                }
            }
        }
    },
    isLayoutRoot: function() {
        if (this.hiddenHeaders) {
            return false
        }
        return this.callParent()
    },
    getOwnerHeaderCt: function() {
        var e = this;
        return e.isRootHeader ? e: e.up("[isRootHeader]")
    },
    onDestroy: function() {
        var e = this;
        if (e.menu) {
            e.menu.un("hide", e.onMenuHide, e)
        }
        e.menuTask.cancel();
        e.callParent();
        Ext.destroy(e.visibleColumnManager, e.columnManager, e.menu);
        e.columnManager = e.visibleColumnManager = null
    },
    applyColumnsState: function(e) {
        if (!e || !e.length) {
            return
        }
        var t = this,
        n = t.items.items,
        r = n.length,
        i = 0,
        s = e.length,
        o, u, a, f, l = false;
        for (o = 0; o < s; o++) {
            a = e[o];
            for (f = r; f--;) {
                u = n[f];
                if (u.getStateId && u.getStateId() == a.id) {
                    if (i !== f) {
                        this.items.insert(i, this.items.getAt(f));
                        l = true
                    }
                    if (u.applyColumnState) {
                        u.applyColumnState(a)
                    }++i;
                    break
                }
            }
        }
        if (l) {
            t.purgeCache()
        }
    },
    getColumnsState: function() {
        var e = this,
        t = [],
        n;
        e.items.each(function(e) {
            n = e.getColumnState && e.getColumnState();
            if (n) {
                t.push(n)
            }
        });
        return t
    },
    onAdd: function(e) {
        var t = this;
        if (!e.headerId) {
            e.headerId = e.initialConfig.id || Ext.id(null, "header-")
        }
        if (!e.getStateId()) {
            e.stateId = e.initialConfig.id || "h" + ++t.headerCounter
        }
        t.callParent(arguments);
        t.onHeadersChanged(e, t.isDDMoveInGrid)
    },
    move: function(e, t) {
        var n = this,
        r = n.items.items[e];
        r.visibleFromIdx = n.getOwnerHeaderCt().visibleColumnManager.indexOf(r);
        n.callParent(arguments)
    },
    onMove: function(e, t, n) {
        var r = this,
        i = r.getOwnerHeaderCt(),
        s = i.visibleColumnManager,
        o = 1,
        u;
        r.onHeadersChanged(e, true);
        u = s.indexOf(e);
        if (u >= e.visibleFromIdx) {
            u++
        }
        r.callParent(arguments);
        if (e.isGroupHeader) {
            o = e.visibleColumnManager.getColumns().length
        }
        i.onHeaderMoved(e, o, e.visibleFromIdx, u)
    },
    onRemove: function(e) {
        var t = this,
        n = t.ownerCt;
        t.callParent(arguments);
        if (!t.destroying) {
            if (!t.isDDMoveInGrid) {
                t.onHeadersChanged(e, false)
            }
            if (t.isGroupHeader && !t.items.getCount() && n) {
                t.detachComponent(e);
                Ext.suspendLayouts();
                n.remove(t);
                Ext.resumeLayouts(true)
            }
        }
    },
    onHeadersChanged: function(e, t) {
        var n, r = this.getOwnerHeaderCt();
        this.purgeHeaderCtCache(this);
        if (r) {
            r.onColumnsChanged();
            if (!e.isGroupHeader) {
                n = r.ownerCt;
                if (n && !t) {
                    n.onHeadersChanged(r, e)
                }
            }
        }
    },
    onHeaderMoved: function(e, t, n, r) {
        var i = this,
        s = i.ownerCt;
        if (i.rendered) {
            if (s && s.onHeaderMove) {
                s.onHeaderMove(i, e, t, n, r)
            }
            i.fireEvent("columnmove", i, e, n, r)
        }
    },
    onColumnsChanged: function() {
        var e = this,
        t = e.menu,
        n, r;
        if (e.rendered) {
            e.fireEvent("columnschanged", e);
            if (t && (n = t.child("#columnItemSeparator"))) {
                r = t.child("#columnItem"),
                n.destroy();
                r.destroy()
            }
        }
    },
    applyDefaults: function(e) {
        var t;
        if (e && !e.isComponent && e.xtype == "rownumberer") {
            t = e
        } else {
            t = this.callParent(arguments);
            if (!e.isGroupHeader && !("width" in t) && !t.flex) {
                t.width = this.defaultWidth
            }
        }
        return t
    },
    setSortState: function() {
        var e = this.up("[store]").store,
        t = this.visibleColumnManager.getColumns(),
        n = t.length,
        r,
        i,
        s;
        for (r = 0; r < n; r++) {
            i = t[r];
            s = e.sorters.get(i.getSortParam());
            i.setSortState(s)
        }
    },
    getHeaderMenu: function() {
        var e = this.getMenu(),
        t;
        if (e) {
            t = e.child("#columnItem");
            if (t) {
                return t.menu
            }
        }
        return null
    },
    onHeaderVisibilityChange: function(e, t) {
        var n = this,
        r = n.getHeaderMenu(),
        i;
        n.purgeHeaderCtCache(e.ownerCt);
        if (r) {
            i = n.getMenuItemForHeader(r, e);
            if (i) {
                i.setChecked(t, true)
            }
            if (r.isVisible()) {
                n.menuTask.delay(50)
            }
        }
    },
    updateMenuDisabledState: function(e) {
        var t = this,
        n = t.query(":not([hidden])"),
        r,
        i = n.length,
        s,
        o,
        u;
        if (!e) {
            e = t.getMenu()
        }
        for (r = 0; r < i; ++r) {
            s = n[r];
            o = t.getMenuItemForHeader(e, s);
            if (o) {
                u = s.isHideable() ? "enable": "disable";
                if (o.menu) {
                    u += "CheckChange"
                }
                o[u]()
            }
        }
    },
    getMenuItemForHeader: function(e, t) {
        return t ? e.down("menucheckitem[headerId=" + t.id + "]") : null
    },
    onHeaderShow: function(e) {
        var t = this,
        n = t.ownerCt;
        if (t.forceFit) {
            delete t.flex
        }
        t.onHeaderVisibilityChange(e, true);
        if (!e.isGroupHeader) {
            if (n) {
                n.onHeaderShow(t, e)
            }
        }
        t.fireEvent("columnshow", t, e);
        t.fireEvent("columnschanged", this)
    },
    onHeaderHide: function(e) {
        var t = this,
        n = t.ownerCt;
        t.onHeaderVisibilityChange(e, false);
        if (!e.isGroupHeader) {
            if (n) {
                n.onHeaderHide(t, e)
            }
        }
        t.fireEvent("columnhide", t, e);
        t.fireEvent("columnschanged", this)
    },
    tempLock: function() {
        this.ddLock = true;
        Ext.Function.defer(function() {
            this.ddLock = false
        },
        200, this)
    },
    onHeaderResize: function(e, t) {
        var n = this,
        r = n.ownerCt;
        if (r) {
            r.onHeaderResize(n, e, t)
        }
        n.fireEvent("columnresize", n, e, t)
    },
    onHeaderClick: function(e, t, n) {
        e.fireEvent("headerclick", this, e, t, n);
        this.fireEvent("headerclick", this, e, t, n)
    },
    onHeaderContextMenu: function(e, t, n) {
        e.fireEvent("headercontextmenu", this, e, t, n);
        this.fireEvent("headercontextmenu", this, e, t, n)
    },
    onHeaderTriggerClick: function(e, t, n) {
        var r = this;
        if (e.fireEvent("headertriggerclick", r, e, t, n) !== false && r.fireEvent("headertriggerclick", r, e, t, n) !== false) {
            r.showMenuBy(n, e)
        }
    },
    showMenuBy: function(e, t) {
        var n = this.getMenu(),
        r = n.down("#ascItem"),
        i = n.down("#descItem"),
        s;
        n.activeHeader = n.ownerCmp = n.ownerButton = t;
        t.setMenuActive(true);
        s = t.sortable ? "enable": "disable";
        if (r) {
            r[s]()
        }
        if (i) {
            i[s]()
        }
        n.showBy(e, "tl-bl?")
    },
    onMenuHide: function(e) {
        e.activeHeader.setMenuActive(false)
    },
    moveHeader: function(e, t) {
        this.tempLock();
        this.move(e, t)
    },
    purgeHeaderCtCache: function(e) {
        while (e) {
            e.purgeCache();
            if (e.isRootHeader) {
                return
            }
            e = e.ownerCt
        }
    },
    purgeCache: function() {
        var e = this,
        t = e.visibleColumnManager,
        n = e.columnManager;
        e.gridVisibleColumns = e.gridDataColumns = e.hideableColumns = null;
        if (t) {
            t.invalidate();
            n.invalidate()
        }
    },
    getMenu: function() {
        var e = this;
        if (!e.menu) {
            e.menu = new Ext.menu.Menu({
                hideOnParentHide: false,
                items: e.getMenuItems(),
                listeners: {
                    beforeshow: e.beforeMenuShow,
                    hide: e.onMenuHide,
                    scope: e
                }
            });
            e.fireEvent("menucreate", e, e.menu)
        }
        return e.menu
    },
    beforeMenuShow: function(e) {
        var t = this,
        n = e.child("#columnItem"),
        r,
        i,
        e;
        if (!n) {
            r = t.enableColumnHide ? t.getColumnMenu(t) : null;
            i = t.sortable ? 2 : 0;
            if (r && r.length) {
                e.insert(i, [{
                    itemId: "columnItemSeparator",
                    xtype: "menuseparator"
                },
                {
                    itemId: "columnItem",
                    text: t.columnsText,
                    iconCls: t.menuColsIcon,
                    menu: {
                        items: r
                    },
                    hideOnClick: false
                }])
            }
        }
        t.updateMenuDisabledState(t.menu);
        if (!e.rendered) {
            e.render(this.el.up("{overflow=auto}") || document.body)
        }
    },
    getMenuItems: function() {
        var e = this,
        t = [],
        n = e.enableColumnHide ? e.getColumnMenu(e) : null;
        if (e.sortable) {
            t = [{
                itemId: "ascItem",
                text: e.sortAscText,
                iconCls: e.menuSortAscCls,
                handler: e.onSortAscClick,
                scope: e
            },
            {
                itemId: "descItem",
                text: e.sortDescText,
                iconCls: e.menuSortDescCls,
                handler: e.onSortDescClick,
                scope: e
            }]
        }
        if (n && n.length) {
            if (e.sortable) {
                t.push({
                    itemId: "columnItemSeparator",
                    xtype: "menuseparator"
                })
            }
            t.push({
                itemId: "columnItem",
                text: e.columnsText,
                iconCls: e.menuColsIcon,
                menu: n,
                hideOnClick: false
            })
        }
        return t
    },
    onSortAscClick: function() {
        var e = this.getMenu(),
        t = e.activeHeader;
        t.sort("ASC")
    },
    onSortDescClick: function() {
        var e = this.getMenu(),
        t = e.activeHeader;
        t.sort("DESC")
    },
    getColumnMenu: function(e) {
        var t = [],
        n = 0,
        r,
        i = e.query(">gridcolumn[hideable]"),
        s = i.length,
        o;
        for (; n < s; n++) {
            r = i[n];
            if (r.showInMenu === false) {
                continue
            }
            o = new Ext.menu.CheckItem({
                text: r.menuText || r.text,
                checked: !r.hidden,
                hideOnClick: false,
                headerId: r.id,
                menu: r.isGroupHeader ? this.getColumnMenu(r) : undefined,
                checkHandler: this.onColumnCheckChange,
                scope: this
            });
            t.push(o)
        }
        return t
    },
    onColumnCheckChange: function(e, t) {
        var n = Ext.getCmp(e.headerId);
        if (n.rendered) {
            n[t ? "show": "hide"]()
        } else {
            n.hidden = !t
        }
    },
    getColumnCount: function() {
        return this.getGridColumns().length
    },
    getTableWidth: function() {
        var e = 0,
        t = this.getVisibleGridColumns(),
        n = t.length,
        r;
        for (r = 0; r < n; r++) {
            e += t[r].getCellWidth() || 0
        }
        return e
    },
    getVisibleGridColumns: function() {
        if (this.gridVisibleColumns) {
            return this.gridVisibleColumns
        }
        var e = this.getGridColumns(),
        t = [],
        n = e.length,
        r;
        for (r = 0; r < n; r++) {
            if (!e[r].hidden) {
                t[t.length] = e[r]
            }
        }
        this.gridVisibleColumns = t;
        return t
    },
    getGridColumns: function(e, t) {
        if (!e && this.gridDataColumns) {
            return this.gridDataColumns
        }
        var n = this,
        r = e || [],
        i,
        s,
        o,
        u,
        a;
        t = t || n.hidden;
        if (n.items) {
            i = n.items.items;
            for (s = 0, o = i.length; s < o; s++) {
                u = i[s];
                if (u.isGroupHeader) {
                    u.getGridColumns(r, t)
                } else {
                    u.hiddenAncestor = t;
                    r.push(u)
                }
            }
        }
        if (!e) {
            n.gridDataColumns = r
        }
        if (!e && o) {
            for (s = 0, o = r.length; s < o; s++) {
                u = r[s];
                u.isFirstVisible = u.isLastVisible = false;
                if (! (u.hidden || u.hiddenAncestor)) {
                    if (!a) {
                        u.isFirstVisible = true
                    }
                    a = u
                }
            }
            if (a) {
                a.isLastVisible = true
            }
        }
        return r
    },
    getHideableColumns: function() {
        var e = this,
        t = e.hideableColumns;
        if (!t) {
            t = e.hideableColumns = e.query("[hideable]")
        }
        return t
    },
    getHeaderIndex: function(e) {
        if (!this.columnManager) {
            this.columnManager = this.getOwnerHeaderCt().columnManager
        }
        return this.columnManager.getHeaderIndex(e)
    },
    getHeaderAtIndex: function(e) {
        if (!this.columnManager) {
            this.columnManager = this.getOwnerHeaderCt().columnManager
        }
        return this.columnManager.getHeaderAtIndex(e)
    },
    getVisibleHeaderClosestToIndex: function(e) {
        if (!this.visibleColumnManager) {
            this.visibleColumnManager = this.getOwnerHeaderCt().visibleColumnManager
        }
        return this.visibleColumnManager.getVisibleHeaderClosestToIndex(e)
    },
    applyForceFit: function(e) {
        function v() {
            for (c = 0, l = a.length; c < l; c++) {
                h = a[c];
                if (h === e) {
                    continue
                }
                h.flex = h.flex || h.width || h.getWidth();
                u += h.flex;
                h.width = null
            }
        }
        function m() {
            var t;
            for (c = 0, l = a.length; c < l; c++) {
                h = a[c];
                t = h === e;
                if (i && !t) {
                    h.flex = r;
                    h.width = null
                } else {
                    if (!t) {
                        d = h.flex || s;
                        h.flex = Math.max(Math.ceil(d / u * o), r);
                        h.width = null
                    }
                }
                h.setWidth(h.width || h.flex)
            }
        }
        var t = this,
        n = t.view,
        r = Ext.grid.plugin.HeaderResizer.prototype.minColWidth,
        i = false,
        s = Ext.grid.header.Container.prototype.defaultWidth,
        o = t.el.getViewSize().width - (n.el.dom.scrollHeight > n.el.dom.clientHeight ? Ext.getScrollbarSize().width: 0),
        u = 0,
        a = t.getVisibleGridColumns(),
        f = e.hidden,
        l,
        c,
        h,
        p,
        d;
        Ext.suspendLayouts();
        p = o - (a.length + 1) * r;
        e.flex = null;
        if (f) {
            d = e.width || e.savedWidth;
            e.savedWidth = null
        } else {
            d = n.getMaxContentWidth(e)
        }
        if (d > p) {
            e.width = p;
            i = true
        } else {
            e.width = d;
            o -= d + s;
            v()
        }
        m();
        Ext.resumeLayouts(true)
    },
    autoSizeColumn: function(e) {
        var t = this.view;
        if (t) {
            t.autoSizeColumn(e);
            if (this.forceFit) {
                this.applyForceFit(e)
            }
        }
    }
});Ext.define("Ext.grid.column.Column", {
    extend: Ext.grid.header.Container,
    alias: "widget.gridcolumn",
    alternateClassName: "Ext.grid.Column",
    baseCls: Ext.baseCSSPrefix + "column-header",
    hoverCls: Ext.baseCSSPrefix + "column-header-over",
    handleWidth: 4,
    ariaRole: "columnheader",
    sortState: null,
    possibleSortStates: ["ASC", "DESC"],
    childEls: ["titleEl", "triggerEl", "textEl"],
    noWrap: true,
    renderTpl: ['<div id="{id}-titleEl" role="presentation" {tipMarkup}class="', Ext.baseCSSPrefix, "column-header-inner", '<tpl if="empty"> ', Ext.baseCSSPrefix, 'column-header-inner-empty</tpl>">', '<span id="{id}-textEl" class="', Ext.baseCSSPrefix, "column-header-text", '{childElCls}">', "{text}", "</span>", '<tpl if="!menuDisabled">', '<div id="{id}-triggerEl" role="presentation" class="', Ext.baseCSSPrefix, "column-header-trigger", '{childElCls}"></div>', "</tpl>", "</div>", "{%this.renderContainer(out,values)%}"],
    dataIndex: null,
    text: "&#160;",
    menuText: null,
    emptyCellText: "&#160;",
    sortable: true,
    resizable: true,
    hideable: true,
    menuDisabled: false,
    renderer: false,
    defaultRenderer: function(e, t) {
        if (e === null || e === undefined) {
            return ""
        }
        var n = this;
        if (n.autoWrap) {
            t.style = "white-space:normal;"
        }
        if (Ext.isDate(e)) {
            if (n.format) {
                return Wb.format(e, n.format)
            } else {
                return Wb.dateToText(e)
            }
        } else {
            if (Ext.isNumber(e)) {
                if (n.format) {
                    return Wb.format(e, n.format)
                }
            }
        }
        return Ext.htmlEncode(e)
    },
    editRenderer: false,
    align: "left",
    draggable: true,
    tooltipType: "qtip",
    initDraggable: Ext.emptyFn,
    tdCls: "",
    isHeader: true,
    isColumn: true,
    ascSortCls: Ext.baseCSSPrefix + "column-header-sort-ASC",
    descSortCls: Ext.baseCSSPrefix + "column-header-sort-DESC",
    componentLayout: "columncomponent",
    groupSubHeaderCls: Ext.baseCSSPrefix + "group-sub-header",
    groupHeaderCls: Ext.baseCSSPrefix + "group-header",
    clickTargetName: "titleEl",
    detachOnRemove: true,
    initResizable: Ext.emptyFn,
    initComponent: function() {
        var e = this,
        t;
        if (e.header != null) {
            e.text = e.header;
            e.header = null
        }
        if (Wb.isNeptune && e.width) {
            e.width = Math.round(e.width * 1.14)
        }
        if (e.items && !e.columns) {
            e.columns = e.items
        }
        if (e.columns != null) {
            e.isGroupHeader = true;
            e.items = e.columns;
            e.columns = e.flex = e.width = null;
            e.cls = (e.cls || "") + " " + e.groupHeaderCls;
            e.sortable = e.resizable = false;
            e.align = "center"
        } else {
            if (e.flex) {
                e.minWidth = e.minWidth || Ext.grid.plugin.HeaderResizer.prototype.minColWidth
            }
        }
        e.addCls(Ext.baseCSSPrefix + "column-header-align-" + (e.titleAlign || e.align));
        t = e.renderer;
        if (t) {
            if (typeof t == "string") {
                e.renderer = Ext.util.Format[t]
            }
            e.hasCustomRenderer = true
        } else {
            if (e.defaultRenderer) {
                e.renderer = e.defaultRenderer;
                e.usingDefaultRenderer = true
            }
        }
        e.callParent(arguments)
    },
    initItems: function() {
        var e = this;
        e.callParent(arguments);
        if (e.isGroupHeader) {
            if (!e.hasVisibleChildColumns()) {
                e.hide()
            }
        }
    },
    hasVisibleChildColumns: function() {
        var e = this.items.items,
        t = e.length,
        n, r;
        for (n = 0; n < t; ++n) {
            r = e[n];
            if (r.isColumn && !r.hidden) {
                return true
            }
        }
        return false
    },
    onAdd: function(e) {
        var t = this,
        n = t.getOwnerHeaderCt();
        if (e.isColumn) {
            e.isSubHeader = true;
            e.addCls(this.groupSubHeaderCls)
        }
        if (t.hidden && e.isColumn) {
            if (!n) {
                e.hide()
            } else {
                if (!e.hidden) {
                    t.show()
                }
            }
        }
        t.callParent(arguments)
    },
    onRemove: function(e) {
        var t = this;
        if (e.isSubHeader) {
            e.isSubHeader = false;
            e.removeCls(t.groupSubHeaderCls)
        }
        t.callParent(arguments);
        if (t.isGroupHeader && !t.hasVisibleChildColumns()) {
            t.hide()
        }
    },
    initRenderData: function() {
        var e = this,
        t = "",
        n = e.tooltip,
        r = e.text,
        i = e.tooltipType == "qtip" ? "data-qtip": "title";
        if (!Ext.isEmpty(n)) {
            t = i + '="' + n + '" '
        }
        return Ext.applyIf(e.callParent(arguments), {
            text: r,
            empty: r === "&#160;" || r === " " || r === "",
            menuDisabled: e.menuDisabled,
            tipMarkup: t
        })
    },
    applyColumnState: function(e) {
        var t = this;
        t.applyColumnsState(e.columns);
        if (e.hidden != null) {
            t.hidden = e.hidden
        }
        if (e.locked != null) {
            t.locked = e.locked
        }
        if (e.sortable != null) {
            t.sortable = e.sortable
        }
        if (e.width != null) {
            t.flex = null;
            t.width = e.width
        } else {
            if (e.flex != null) {
                t.width = null;
                t.flex = e.flex
            }
        }
    },
    getColumnState: function() {
        var e = this,
        t = e.items.items,
        n = t ? t.length: 0,
        r,
        i = [],
        s = {
            id: e.getStateId()
        };
        e.savePropsToState(["hidden", "sortable", "locked", "flex", "width"], s);
        if (e.isGroupHeader) {
            for (r = 0; r < n; r++) {
                i.push(t[r].getColumnState())
            }
            if (i.length) {
                s.columns = i
            }
        } else {
            if (e.isSubHeader && e.ownerCt.hidden) {
                delete e.hidden
            }
        }
        if ("width" in s) {
            delete s.flex
        }
        return s
    },
    getStateId: function() {
        return this.stateId || this.headerId
    },
    setText: function(e) {
        this.text = e;
        if (this.rendered) {
            this.textEl.update(e)
        }
    },
    getIndex: function() {
        return this.isGroupColumn ? false: this.getOwnerHeaderCt().getHeaderIndex(this)
    },
    getVisibleIndex: function() {
        return this.isGroupColumn ? false: Ext.Array.indexOf(this.getOwnerHeaderCt().getVisibleGridColumns(), this)
    },
    beforeRender: function() {
        var e = this,
        t = e.up("tablepanel");
        e.callParent();
        if (t && (!e.sortable || t.sortableColumns === false) && !e.groupable && !e.lockable && (t.enableColumnHide === false || !e.getOwnerHeaderCt().getHideableColumns().length)) {
            e.menuDisabled = true
        }
        e.protoEl.unselectable()
    },
    afterRender: function() {
        var e = this,
        t = e.triggerEl;
        e.callParent(arguments);
        if (t && e.self.triggerElWidth === undefined) {
            t.setStyle("display", "block");
            e.self.triggerElWidth = t.getWidth();
            t.setStyle("display", "")
        }
    },
    afterComponentLayout: function(e, t, n, r) {
        var i = this,
        s = i.getOwnerHeaderCt();
        i.callParent(arguments);
        if (s && (n != null || i.flex) && e !== n) {
            s.onHeaderResize(i, e)
        }
    },
    onDestroy: function() {
        var e = this;
        Ext.destroy(e.textEl, e.keyNav, e.field);
        e.keyNav = null;
        e.callParent(arguments)
    },
    onTitleMouseOver: function() {
        this.titleEl.addCls(this.hoverCls)
    },
    onTitleMouseOut: function() {
        this.titleEl.removeCls(this.hoverCls)
    },
    onDownKey: function(e) {
        if (this.triggerEl) {
            this.onTitleElClick(e, this.triggerEl.dom || this.el.dom)
        }
    },
    onEnterKey: function(e) {
        this.onTitleElClick(e, this.el.dom)
    },
    onTitleElDblClick: function(e, t) {
        var n = this,
        r, i, s;
        if (n.isOnLeftEdge(e)) {
            r = n.previousNode("gridcolumn:not([hidden]):not([isGroupHeader])");
            if (r && r.getOwnerHeaderCt() === n.getOwnerHeaderCt()) {
                r.autoSize()
            }
        } else {
            if (n.isOnRightEdge(e)) {
                if (n.isGroupHeader && e.getPoint().isContainedBy(n.layout.innerCt)) {
                    i = n.query("gridcolumn:not([hidden]):not([isGroupHeader])");
                    n.getOwnerHeaderCt().autoSizeColumn(i[i.length - 1]);
                    return
                } else {
                    s = n.getOwnerHeaderCt();
                    if (s.visibleColumnManager.getColumns().length === 1 && s.forceFit) {
                        return
                    }
                }
                n.autoSize()
            }
        }
    },
    autoSize: function() {
        var e = this,
        t, n, r, i;
        if (e.isGroupHeader) {
            t = e.query("gridcolumn:not([hidden]):not([isGroupHeader])");
            n = t.length;
            i = this.getOwnerHeaderCt();
            Ext.suspendLayouts();
            for (r = 0; r < n; r++) {
                i.autoSizeColumn(t[r])
            }
            Ext.resumeLayouts(true);
            return
        }
        this.getOwnerHeaderCt().autoSizeColumn(this)
    },
    onTitleElClick: function(e, t) {
        var n = this,
        r;
        r = n.triggerEl && (e.target === n.triggerEl.dom || t === n.triggerEl.dom || e.within(n.triggerEl));
        if (!r && !n.isOnLeftEdge(e) && !n.isOnRightEdge(e) || e.getKey()) {
            n.toggleSortState()
        }
        return r
    },
    processEvent: function(e, t, n, r, i, s) {
        return this.fireEvent.apply(this, arguments)
    },
    toggleSortState: function() {
        var e = this,
        t, n;
        if (e.sortable) {
            t = Ext.Array.indexOf(e.possibleSortStates, e.sortState);
            n = (t + 1) % e.possibleSortStates.length;
            e.sort()
        }
    },
    sort: function(e) {
        var t = this,
        n = t.up("tablepanel"),
        r = n.store;
        if (n.ownerLockable && r.isNodeStore) {
            r = n.ownerLockable.lockedGrid.store
        }
        t.sorting = true;
        r.sort(t.getSortParam(), e, n.multiColumnSort ? "multi": "replace");
        delete t.sorting
    },
    getSortParam: function() {
        return this.dataIndex
    },
    setSortState: function(e) {
        var t = this,
        n = e && e.direction,
        r = t.ascSortCls,
        i = t.descSortCls,
        s = t.getOwnerHeaderCt();
        switch (n) {
        case "DESC":
            t.addCls(i);
            t.removeCls(r);
            break;
        case "ASC":
            t.addCls(r);
            t.removeCls(i);
            break;
        default:
            t.removeCls([r, i])
        }
        if (n) {
            s.fireEvent("sortchange", s, t, n)
        }
    },
    isHideable: function() {
        var e = {
            hideCandidate: this,
            result: this.hideable
        };
        if (e.result) {
            this.ownerCt.bubble(this.hasOtherMenuEnabledChildren, null, [e])
        }
        return e.result
    },
    hasOtherMenuEnabledChildren: function(e) {
        var t, n;
        if (!this.isXType("headercontainer")) {
            e.result = false;
            return false
        }
        t = this.query(">:not([hidden]):not([menuDisabled])");
        n = t.length;
        if (Ext.Array.contains(t, e.hideCandidate)) {
            n--
        }
        if (n) {
            return false
        }
        e.hideCandidate = this
    },
    isLockable: function() {
        var e = {
            result: this.lockable !== false
        };
        if (e.result) {
            this.ownerCt.bubble(this.hasMultipleVisibleChildren, null, [e])
        }
        return e.result
    },
    isLocked: function() {
        return this.locked || !!this.up("[isColumn][locked]", "[isRootHeader]")
    },
    hasMultipleVisibleChildren: function(e) {
        if (!this.isXType("headercontainer")) {
            e.result = false;
            return false
        }
        if (this.query(">:not([hidden])").length > 1) {
            return false
        }
    },
    hide: function(e) {
        var t = this,
        n = t.getOwnerHeaderCt(),
        r = t.ownerCt,
        i,
        s,
        o,
        u,
        a;
        if (!n) {
            t.callParent();
            return t
        }
        if (t.rendered && !t.isVisible()) {
            return t
        }
        if (n.forceFit) {
            t.visibleSiblingCount = n.getVisibleGridColumns().length - 1;
            if (t.flex) {
                t.savedWidth = t.getWidth();
                t.flex = null
            }
        }
        i = r.isGroupHeader;
        if (i && !e) {
            o = r.query(">:not([hidden])");
            if (o.length === 1 && o[0] === t) {
                t.ownerCt.hide();
                return
            }
        }
        Ext.suspendLayouts();
        if (t.isGroupHeader) {
            o = t.items.items;
            for (a = 0, u = o.length; a < u; a++) {
                s = o[a];
                if (!s.hidden) {
                    s.hide(true)
                }
            }
        }
        t.callParent();
        n.onHeaderHide(t);
        Ext.resumeLayouts(true);
        return t
    },
    show: function(e, t) {
        var n = this,
        r = n.getOwnerHeaderCt(),
        i = n.ownerCt,
        s,
        o,
        u,
        a;
        if (n.isVisible()) {
            return n
        }
        if (n.rendered) {
            if (r.forceFit) {
                r.applyForceFit(n)
            }
        }
        Ext.suspendLayouts();
        if (n.isSubHeader && i.hidden) {
            i.show(false, true)
        }
        n.callParent(arguments);
        if (n.isGroupHeader && t !== true && !n.query(":not([hidden])").length) {
            s = n.items.items;
            for (u = 0, o = s.length; u < o; u++) {
                a = s[u];
                if (a.hidden) {
                    a.show(true)
                }
            }
        }
        i = n.getOwnerHeaderCt();
        if (i) {
            i.onHeaderShow(n)
        }
        Ext.resumeLayouts(true);
        return n
    },
    getCellWidth: function() {
        var e = this,
        t, n = true;
        if (e.rendered && e.componentLayout && e.componentLayout.lastComponentSize) {
            t = e.componentLayout.lastComponentSize.width
        } else {
            if (e.width) {
                t = e.width
            } else {
                if (!e.isColumn) {
                    t = e.getTableWidth();
                    n = false
                }
            }
        }
        if (n && !Ext.isBorderBox && e.ownerCt.columnLines) {
            if (e.columnBorderWidth == null && e.rendered) {
                e.self.prototype.columnBorderWidth = e.el.getBorderWidth("lr")
            }
            t -= e.columnBorderWidth
        }
        return t
    },
    getCellId: function() {
        return Ext.baseCSSPrefix + "grid-cell-headerId-" + this.getItemId()
    },
    getCellSelector: function() {
        return "." + this.getCellId()
    },
    getCellInnerSelector: function() {
        return this.getCellSelector() + " ." + Ext.baseCSSPrefix + "grid-cell-inner"
    },
    isOnLeftEdge: function(e) {
        return e.getXY()[0] - this.getX() < this.handleWidth
    },
    isOnRightEdge: function(e) {
        return this.getX() + this.getWidth() - e.getXY()[0] <= this.handleWidth
    },
    setMenuActive: function(e) {
        this.titleEl[e ? "addCls": "removeCls"](this.headerOpenCls)
    }
});Ext.define("Ext.grid.column.Action", {
    extend: Ext.grid.column.Column,
    alias: ["widget.actioncolumn"],
    alternateClassName: "Ext.grid.ActionColumn",
    stopSelection: true,
    actionIdRe: new RegExp(Ext.baseCSSPrefix + "action-col-(\\d+)"),
    altText: "",
    menuText: "<i>Actions</i>",
    sortable: false,
    innerCls: Ext.baseCSSPrefix + "grid-cell-inner-action-col",
    actionIconCls: Ext.baseCSSPrefix + "action-col-icon",
    constructor: function(e) {
        var t = this,
        n = Ext.apply({},
        e),
        r = n.items || t.items || [t],
        i,
        s,
        o;
        t.origRenderer = n.renderer || t.renderer;
        t.origScope = n.scope || t.scope;
        t.renderer = t.scope = n.renderer = n.scope = null;
        n.items = null;
        t.callParent([n]);
        t.items = r;
        for (s = 0, o = r.length; s < o; ++s) {
            if (r[s].getClass) {
                i = true;
                break
            }
        }
        if (t.origRenderer || i) {
            t.hasCustomRenderer = true
        }
    },
    defaultRenderer: function(e, t, n, r, i, s, o) {
        var u = this,
        a = Ext.baseCSSPrefix,
        f = u.origScope || u,
        l = u.items,
        c = l.length,
        h = 0,
        p, d, v, m;
        d = Ext.isFunction(u.origRenderer) ? u.origRenderer.apply(f, arguments) || "": "";
        t.tdCls += " " + Ext.baseCSSPrefix + "action-col-cell";
        for (; h < c; h++) {
            p = l[h];
            v = p.disabled || (p.isDisabled ? p.isDisabled.call(p.scope || f, o, r, i, p, n) : false);
            m = v ? null: p.tooltip || (p.getTip ? p.getTip.apply(p.scope || f, arguments) : null);
            if (!p.hasActionConfiguration) {
                p.stopSelection = u.stopSelection;
                p.disable = Ext.Function.bind(u.disableAction, u, [h], 0);
                p.enable = Ext.Function.bind(u.enableAction, u, [h], 0);
                p.hasActionConfiguration = true
            }
            d += '<img role="button" alt="' + (p.altText || u.altText) + '" src="' + (p.icon || Ext.BLANK_IMAGE_URL) + '" class="' + u.actionIconCls + " " + a + "action-col-" + String(h) + " " + (v ? a + "item-disabled": " ") + (Ext.isFunction(p.getClass) ? p.getClass.apply(p.scope || f, arguments) : p.iconCls || u.iconCls || "") + '"' + (m ? ' data-qtip="' + m + '"': "") + " />"
        }
        return d
    },
    enableAction: function(e, t) {
        var n = this;
        if (!e) {
            e = 0
        } else {
            if (!Ext.isNumber(e)) {
                e = Ext.Array.indexOf(n.items, e)
            }
        }
        n.items[e].disabled = false;
        n.up("tablepanel").el.select("." + Ext.baseCSSPrefix + "action-col-" + e).removeCls(n.disabledCls);
        if (!t) {
            n.fireEvent("enable", n)
        }
    },
    disableAction: function(e, t) {
        var n = this;
        if (!e) {
            e = 0
        } else {
            if (!Ext.isNumber(e)) {
                e = Ext.Array.indexOf(n.items, e)
            }
        }
        n.items[e].disabled = true;
        n.up("tablepanel").el.select("." + Ext.baseCSSPrefix + "action-col-" + e).addCls(n.disabledCls);
        if (!t) {
            n.fireEvent("disable", n)
        }
    },
    destroy: function() {
        delete this.items;
        delete this.renderer;
        return this.callParent(arguments)
    },
    processEvent: function(e, t, n, r, i, s, o, u) {
        var a = this,
        f = s.getTarget(),
        l,
        c,
        h,
        p = e === "keydown" && s.getKey(),
        d;
        if (e === "mousedown") {
            return false
        }
        if (p && !Ext.fly(f).findParent(t.getCellSelector())) {
            f = Ext.fly(n).down("." + Ext.baseCSSPrefix + "action-col-icon", true)
        }
        if (f && (l = f.className.match(a.actionIdRe))) {
            c = a.items[parseInt(l[1], 10)];
            d = c.disabled || (c.isDisabled ? c.isDisabled.call(c.scope || a.origScope || a, t, r, i, c, o) : false);
            if (c && !d) {
                if (e == "click" || p == s.ENTER || p == s.SPACE) {
                    h = c.handler || a.handler;
                    if (h) {
                        h.call(c.scope || a.origScope || a, t, r, i, c, s, o, u)
                    }
                    if (c.stopSelection !== false) {
                        return false
                    }
                }
            }
        }
        return a.callParent(arguments)
    },
    cascade: function(e, t) {
        e.call(t || this, this)
    },
    getRefItems: function() {
        return []
    }
});Ext.define("Ext.grid.column.Boolean", {
    extend: Ext.grid.column.Column,
    alias: ["widget.booleancolumn"],
    alternateClassName: "Ext.grid.BooleanColumn",
    trueText: "true",
    falseText: "false",
    undefinedText: "&#160;",
    defaultRenderer: function(e) {
        if (e === undefined) {
            return this.undefinedText
        }
        if (!e || e === "false") {
            return this.falseText
        }
        return this.trueText
    }
});Ext.define("Ext.grid.column.Check", {
    extend: Ext.grid.column.Column,
    alternateClassName: ["Ext.ux.CheckColumn", "Ext.grid.column.CheckColumn"],
    alias: "widget.checkcolumn",
    align: "center",
    stopSelection: true,
    tdCls: Ext.baseCSSPrefix + "grid-cell-checkcolumn",
    innerCls: Ext.baseCSSPrefix + "grid-cell-inner-checkcolumn",
    clickTargetName: "el",
    constructor: function() {
        this.addEvents("beforecheckchange", "checkchange");
        this.scope = this;
        this.callParent(arguments)
    },
    processEvent: function(e, t, n, r, i, s, o, u) {
        var a = this,
        f = e === "keydown" && s.getKey(),
        l = e == "mousedown";
        if (!a.disabled && (l || f == s.ENTER || f == s.SPACE)) {
            var c = a.dataIndex,
            h = o.get(c),
            p = Ext.isBoolean(h),
            d;
            if (p) {
                d = !h
            } else {
                d = h ? 0 : 1
            }
            if (a.fireEvent("beforecheckchange", a, r, d) !== false) {
                o.set(c, d);
                a.fireEvent("checkchange", a, r, d);
                if (l) {
                    s.stopEvent()
                }
                if (!a.stopSelection) {
                    t.selModel.selectByPosition({
                        row: r,
                        column: i
                    })
                }
                return false
            } else {
                return ! a.stopSelection
            }
        } else {
            return a.callParent(arguments)
        }
    },
    onEnable: function() {
        this.callParent(arguments);
        this._setDisabled(false)
    },
    onDisable: function() {
        this._setDisabled(true)
    },
    _setDisabled: function(e) {
        var t = this,
        n = t.disabledCls,
        r;
        r = t.up("tablepanel").el.select(t.getCellSelector());
        if (e) {
            r.addCls(n)
        } else {
            r.removeCls(n)
        }
    },
    renderer: function(e, t) {
        var n = Ext.baseCSSPrefix,
        r = n + "grid-checkcolumn";
        if (this.disabled) {
            t.tdCls += " " + this.disabledCls
        }
        if (e) {
            r += " " + n + "grid-checkcolumn-checked"
        }
        return '<img class="' + r + '" src="' + Ext.BLANK_IMAGE_URL + '"/>'
    }
});Ext.define("Ext.grid.column.Date", {
    extend: Ext.grid.column.Column,
    alias: ["widget.datecolumn"],
    alternateClassName: "Ext.grid.DateColumn",
    initComponent: function() {
        if (!this.format) {
            this.format = Ext.Date.defaultFormat
        }
        this.callParent(arguments)
    },
    defaultRenderer: function(e) {
        return Ext.util.Format.date(e, this.format)
    }
});Ext.define("Ext.grid.column.Number", {
    extend: Ext.grid.column.Column,
    alias: ["widget.numbercolumn"],
    alternateClassName: "Ext.grid.NumberColumn",
    format: "0,000.00",
    align: "right",
    defaultRenderer: function(e) {
        return Ext.util.Format.number(e, this.format)
    }
});Ext.define("Ext.grid.column.RowNumberer", {
    extend: Ext.grid.column.Column,
    alternateClassName: "Ext.grid.RowNumberer",
    alias: "widget.rownumberer",
    text: "&#160;",
    width: 40,
    sortable: false,
    draggable: false,
    autoLock: true,
    lockable: false,
    align: "right",
    constructor: function(e) {
        var t = this;
        t.width = t.width;
        t.callParent(arguments);
        t.scope = t
    },
    beforeRender: function() {
        var e = this.up("tablepanel").view.findFeature("rowbody");
        this.callParent(arguments);
        if (e && this.ownerCt.items.indexOf(this) === 1) {
            e.colSpanDecrement = e.colSpanDecrement + 1;
            this.rowspan = 2
        }
    },
    resizable: true,
    hideable: false,
    menuDisabled: true,
    dataIndex: "",
    cls: Ext.baseCSSPrefix + "row-numberer",
    tdCls: Ext.baseCSSPrefix + "grid-cell-row-numberer " + Ext.baseCSSPrefix + "grid-cell-special",
    innerCls: Ext.baseCSSPrefix + "grid-cell-inner-row-numberer",
    rowspan: undefined,
    renderer: function(e, t, n, r, i, s, o) {
        var u = this.rowspan,
        a = s.currentPage,
        f = o.store.indexOf(n);
        if (u) {
            t.tdAttr = 'rowspan="' + u + '"'
        }
        if (a > 1) {
            f += (a - 1) * s.pageSize
        }
        return f + 1
    }
});Ext.define("Ext.grid.column.Template", {
    extend: Ext.grid.column.Column,
    alias: ["widget.templatecolumn"],
    alternateClassName: "Ext.grid.TemplateColumn",
    initComponent: function() {
        var e = this;
        e.tpl = !Ext.isPrimitive(e.tpl) && e.tpl.compile ? e.tpl: new Ext.XTemplate(e.tpl);
        e.hasCustomRenderer = true;
        e.callParent(arguments)
    },
    defaultRenderer: function(e, t, n) {
        var r = Ext.apply({},
        n.data, n.getAssociatedData());
        return this.tpl.apply(r)
    }
});Ext.define("Ext.grid.feature.Feature", {
    extend: Ext.util.Observable,
    alias: "feature.feature",
    wrapsItem: false,
    isFeature: true,
    disabled: false,
    hasFeatureEvent: true,
    eventPrefix: null,
    eventSelector: null,
    view: null,
    grid: null,
    constructor: function(e) {
        this.initialConfig = e;
        this.callParent(arguments)
    },
    clone: function() {
        return new this.self(this.initialConfig)
    },
    init: Ext.emptyFn,
    destroy: function() {
        this.clearListeners()
    },
    getFireEventArgs: function(e, t, n, r) {
        return [e, t, n, r]
    },
    vetoEvent: Ext.emptyFn,
    enable: function() {
        this.disabled = false
    },
    disable: function() {
        this.disabled = true
    }
});Ext.define("Ext.grid.feature.AbstractSummary", {
    extend: Ext.grid.feature.Feature,
    alias: "feature.abstractsummary",
    summaryRowCls: Ext.baseCSSPrefix + "grid-row-summary",
    summaryTableCls: Ext.plainTableCls + " " + Ext.baseCSSPrefix + "grid-table",
    summaryRowSelector: "." + Ext.baseCSSPrefix + "grid-row-summary",
    summaryRowTpl: {
        before: function(e, t) {
            if (e.record.isSummary && this.summaryFeature.showSummaryRow) {
                this.summaryFeature.outputSummaryRecord(e.record, e, t);
                return false
            }
        },
        priority: 1e3
    },
    showSummaryRow: true,
    init: function() {
        var e = this;
        e.view.summaryFeature = e;
        e.rowTpl = e.view.self.prototype.rowTpl;
        e.view.addRowTpl(e.summaryRowTpl).summaryFeature = e;
        e.summaryData = {}
    },
    toggleSummaryRow: function(e) {
        this.showSummaryRow = !!e
    },
    createRenderer: function(e, t) {
        var n = this,
        r = t.ownerGroup,
        i = r ? n.summaryData[r] : n.summaryData,
        s = e.dataIndex || e.id;
        return function() {
            return e.summaryRenderer ? e.summaryRenderer(t.get(s), i, s) : t.get(s)
        }
    },
    outputSummaryRecord: function(e, t, n) {
        var r = t.view,
        i = r.rowValues,
        s = t.columns || r.headerCt.getVisibleGridColumns(),
        o = s.length,
        u,
        a,
        f = {
            view: r,
            record: e,
            rowStyle: "",
            rowClasses: [this.summaryRowCls],
            itemClasses: [],
            recordIndex: -1,
            rowId: r.getRowId(e),
            columns: s
        };
        for (u = 0; u < o; u++) {
            a = s[u];
            a.savedRenderer = a.renderer;
            if (a.summaryType || a.summaryRenderer) {
                a.renderer = this.createRenderer(a, e)
            } else {
                a.renderer = Ext.emptyFn
            }
        }
        r.rowValues = f;
        r.self.prototype.rowTpl.applyOut(f, n);
        r.rowValues = i;
        for (u = 0; u < o; u++) {
            a = s[u];
            a.renderer = a.savedRenderer;
            a.savedRenderer = null
        }
    },
    getSummary: function(e, t, n, r) {
        var i = r.records;
        if (t) {
            if (Ext.isFunction(t)) {
                return e.getAggregate(t, null, i, [n])
            }
            switch (t) {
            case "count":
                return i.length;
            case "min":
                return e.getMin(i, n);
            case "max":
                return e.getMax(i, n);
            case "sum":
                return e.getSum(i, n);
            case "average":
                return e.getAverage(i, n);
            default:
                return ""
            }
        }
    },
    generateSummaryData: function() {
        var e = this,
        t = e.view.store,
        n = t.groups.items,
        r = t.proxy.reader,
        i = n.length,
        s = e.getGroupField(),
        o = {},
        u = e.lockingPartner,
        a,
        f,
        l,
        c,
        h,
        p,
        d,
        v;
        if (e.remoteRoot && r.rawData) {
            p = true;
            v = {};
            c = r.root;
            r.root = e.remoteRoot;
            r.buildExtractors(true);
            h = r.getRoot(r.rawData) || [];
            i = h.length;
            if (!r.convertRecordData) {
                r.buildExtractors()
            }
            for (a = 0; a < i; ++a) {
                d = {};
                r.convertRecordData(d, h[a]);
                v[d[s]] = d
            }
            r.root = c;
            r.buildExtractors(true)
        }
        for (a = 0; a < i; ++a) {
            f = n[a];
            if (p || f.isDirty() || !f.hasAggregate()) {
                l = e.populateRecord(f, v);
                if (!u || e.view.ownerCt === e.view.ownerCt.ownerLockable.normalGrid) {
                    f.commit()
                }
            } else {
                l = f.getAggregateRecord()
            }
            o[f.key] = l
        }
        return o
    },
    setSummaryData: function(e, t, n, r) {
        if (r) {
            if (!this.summaryData[r]) {
                this.summaryData[r] = {}
            }
            this.summaryData[r][t] = n
        } else {
            this.summaryData[t] = n
        }
    },
    populateRecord: function(e, t) {
        var n = this,
        r = n.grid.ownerLockable ? n.grid.ownerLockable.view: n.view,
        i = n.view.store,
        s = e.getAggregateRecord(),
        o = r.headerCt.getGridColumns(),
        u = o.length,
        a = e.key,
        f,
        l,
        c,
        h,
        p,
        d;
        s.beginEdit();
        if (t) {
            f = t[a];
            for (l in f) {
                if (f.hasOwnProperty(l)) {
                    if (l !== s.idProperty) {
                        s.set(l, f[l])
                    }
                }
            }
        }
        for (c = 0; c < u; ++c) {
            h = o[c];
            p = h.dataIndex || h.id;
            if (!t) {
                d = n.getSummary(i, h.summaryType, p, e);
                s.set(p, d)
            } else {
                d = s.get(p)
            }
            n.setSummaryData(s, h.id, d, a)
        }
        s.ownerGroup = a;
        s.endEdit(true);
        s.commit();
        return s
    }
});Ext.define("Ext.grid.feature.GroupStore", {
    extend: Ext.util.Observable,
    isStore: true,
    defaultViewSize: 100,
    isFeatureStore: true,
    constructor: function(e, t) {
        var n = this;
        n.callParent();
        n.groupingFeature = e;
        n.bindStore(t)
    },
    bindStore: function(e) {
        var t = this;
        if (t.store) {
            Ext.destroy(t.storeListeners);
            t.store = null
        }
        if (e) {
            t.storeListeners = e.on({
                bulkremove: t.onBulkRemove,
                add: t.onAdd,
                update: t.onUpdate,
                refresh: t.onRefresh,
                clear: t.onClear,
                scope: t,
                destroyable: true
            });
            t.store = e;
            t.processStore(e)
        }
    },
    processStore: function(e) {
        var t = this,
        n = e.getGroups(),
        r = n.length,
        i,
        s,
        o,
        u = t.data,
        a = t.groupingFeature.groupCache,
        f = t.groupingFeature.clearGroupCache(),
        l = t.groupingFeature.startCollapsed;
        if (u) {
            u.clear()
        } else {
            u = t.data = new Ext.util.MixedCollection(false, Ext.data.Store.recordIdFn)
        }
        if (e.getCount()) {
            t.groupingFeature.startCollapsed = false;
            for (i = 0; i < r; i++) {
                s = n[i];
                f[s.name] = s;
                s.isCollapsed = l || a[s.name] && a[s.name].isCollapsed;
                if (s.isCollapsed) {
                    s.placeholder = o = new e.model(null, "group-" + s.name + "-placeholder");
                    o.set(e.getGroupField(), s.name);
                    o.rows = o.children = s.children;
                    o.isCollapsedPlaceholder = true;
                    u.add(o)
                } else {
                    u.insert(t.data.length, s.children)
                }
            }
        }
    },
    isCollapsed: function(e) {
        return this.groupingFeature.groupCache[e].isCollapsed
    },
    isInCollapsedGroup: function(e) {
        var t = this.store,
        n;
        if (t.isGrouped() && (n = this.groupingFeature.groupCache[e.get(t.getGroupField())])) {
            return n.isCollapsed || false
        }
        return false
    },
    getCount: function() {
        return this.data.getCount()
    },
    getTotalCount: function() {
        return this.data.getCount()
    },
    rangeCached: function(e, t) {
        return t < this.getCount()
    },
    getRange: function(e, t, n) {
        var r = this.data.getRange(e, t);
        if (n && n.callback) {
            n.callback.call(n.scope || this, r, e, t, n)
        }
        return r
    },
    getAt: function(e) {
        return this.getRange(e, e)[0]
    },
    getById: function(e) {
        return this.store.getById(e)
    },
    getByInternalId: function(e) {
        return (this.store.snapshot || this.data).get(e) || null
    },
    expandGroup: function(e) {
        var t = this,
        n;
        if (typeof e === "string") {
            e = t.groupingFeature.groupCache[e]
        }
        if (e && e.children.length && (n = t.data.indexOf(e.placeholder)) !== -1) {
            e.isCollapsed = false;
            t.isExpandingOrCollapsing = 1;
            t.data.removeAt(n);
            t.data.insert(n, e.children);
            t.fireEvent("replace", t, n, [e.placeholder], e.children);
            t.fireEvent("groupexpand", t, e);
            t.isExpandingOrCollapsing = 0
        }
    },
    collapseGroup: function(e) {
        var t = this,
        n, r, i;
        if (typeof e === "string") {
            e = t.groupingFeature.groupCache[e]
        }
        if (e && (i = e.children.length) && (n = t.data.indexOf(e.children[0])) !== -1) {
            e.isCollapsed = true;
            t.isExpandingOrCollapsing = 2;
            t.data.removeRange(n, i);
            t.data.insert(n, r = t.getGroupPlaceholder(e));
            t.fireEvent("replace", t, n, e.children, [r]);
            t.fireEvent("groupcollapse", t, e);
            t.isExpandingOrCollapsing = 0
        }
    },
    getGroupPlaceholder: function(e) {
        if (!e.placeholder) {
            var t = e.placeholder = new this.store.model(null, "group-" + e.name + "-placeholder");
            t.set(this.store.getGroupField(), e.name);
            t.rows = t.children = e.children;
            t.isCollapsedPlaceholder = true
        }
        return e.placeholder
    },
    indexOf: function(e) {
        if (!e.isCollapsedPlaceholder) {
            return this.data.indexOf(e)
        }
        return - 1
    },
    indexOfTotal: function(e) {
        return this.store.indexOf(e)
    },
    onRefresh: function(e) {
        this.processStore(this.store);
        this.fireEvent("refresh", this)
    },
    onBulkRemove: function(e, t, n, r, i) {
        this.processStore(this.store);
        if (i) {
            this.fireEvent("replace", this, this.indexOf(t[0]), t, [])
        } else {
            this.fireEvent("refresh", this)
        }
    },
    onClear: function(e, t, n) {
        this.processStore(this.store);
        this.fireEvent("clear", this)
    },
    onAdd: function(e, t, n) {
        this.processStore(this.store);
        this.fireEvent("replace", this, this.indexOf(t[0]), [], t)
    },
    onUpdate: function(e, t, n, r) {
        var i = this,
        s, o, u;
        if (e.isGrouped()) {
            s = t.group = i.groupingFeature.getRecordGroup(t);
            if (r && Ext.Array.contains(r, i.groupingFeature.getGroupField())) {
                return i.onRefresh(i.store)
            }
            if (s.isCollapsed) {
                i.fireEvent("update", i, s.placeholder)
            } else {
                Ext.suspendLayouts();
                i.fireEvent("update", i, t, n, r);
                o = s.children[0];
                u = s.children[s.children.length - 1];
                if (o !== t) {
                    o.group = s;
                    i.fireEvent("update", i, o, "edit");
                    delete o.group
                }
                if (u !== t && u !== o && i.groupingFeature.showSummaryRow) {
                    u.group = s;
                    i.fireEvent("update", i, u, "edit");
                    delete u.group
                }
                Ext.resumeLayouts(true)
            }
            delete t.group
        } else {
            i.fireEvent("update", i, t, n, r)
        }
    }
});Ext.define("Ext.grid.feature.Grouping", {
    extend: Ext.grid.feature.Feature,
    mixins: {
        summary: Ext.grid.feature.AbstractSummary
    },
    alias: "feature.grouping",
    eventPrefix: "group",
    groupCls: Ext.baseCSSPrefix + "grid-group-hd",
    eventSelector: "." + Ext.baseCSSPrefix + "grid-group-hd",
    refreshData: {},
    groupInfo: {},
    wrapsItem: true,
    groupHeaderTpl: "{columnName}: {name}",
    depthToIndent: 17,
    collapsedCls: Ext.baseCSSPrefix + "grid-group-collapsed",
    hdCollapsedCls: Ext.baseCSSPrefix + "grid-group-hd-collapsed",
    hdNotCollapsibleCls: Ext.baseCSSPrefix + "grid-group-hd-not-collapsible",
    collapsibleCls: Ext.baseCSSPrefix + "grid-group-hd-collapsible",
    ctCls: Ext.baseCSSPrefix + "group-hd-container",
    groupByText: "Group by this field",
    showGroupsText: "Show in groups",
    hideGroupedHeader: false,
    startCollapsed: false,
    enableGroupingMenu: true,
    enableNoGroups: true,
    collapsible: true,
    expandTip: "Click to expand. CTRL key collapses all others",
    collapseTip: "Click to collapse. CTRL/click collapses all others",
    showSummaryRow: false,
    tableTpl: {
        before: function(e) {
            if (this.groupingFeature.disabled || e.rows.length === 1 && e.rows[0].isSummary) {
                return
            }
            this.groupingFeature.setup(e.rows, e.view.rowValues)
        },
        after: function(e) {
            if (this.groupingFeature.disabled || e.rows.length === 1 && e.rows[0].isSummary) {
                return
            }
            this.groupingFeature.cleanup(e.rows, e.view.rowValues)
        },
        priority: 200
    },
    groupTpl: ["{%", "var me = this.groupingFeature;", "if (me.disabled) {", "values.needsWrap = false;", "} else {", "me.setupRowData(values.record, values.rowIndex, values);", "}", "%}", '<tpl if="needsWrap">', '<tr {[values.isCollapsedGroup ? ("id=\\"" + values.rowId + "\\"") : ""]} data-boundView="{view.id}" data-recordId="{record.internalId:htmlEncode}" data-recordIndex="{[values.isCollapsedGroup ? -1 : values.recordIndex]}" ', 'class="{[values.itemClasses.join(" ")]} ', Ext.baseCSSPrefix, 'grid-wrap-row<tpl if="!summaryRecord"> ', Ext.baseCSSPrefix, 'grid-group-row</tpl>" {ariaRowAttr}>', '<td class="', Ext.baseCSSPrefix, 'group-hd-container" colspan="{columns.length}" {ariaCellAttr}>', '<tpl if="isFirstRow">', "{%", 'var groupTitleStyle = (!values.view.lockingPartner || (values.view.ownerCt === values.view.ownerCt.ownerLockable.lockedGrid) || (values.view.lockingPartner.headerCt.getVisibleGridColumns().length === 0)) ? "" : "visibility:hidden";', "%}", '<div id="{groupId}" class="', Ext.baseCSSPrefix, 'grid-group-hd {collapsibleCls}" tabIndex="0" hidefocus="on" {ariaCellInnerAttr}>', '<div class="', Ext.baseCSSPrefix, 'grid-group-title" style="{[groupTitleStyle]}" {ariaGroupTitleAttr}>', '{[values.groupHeaderTpl.apply(values.groupInfo, parent) || "&#160;"]}', "</div>", "</div>", "</tpl>", '<tpl if="summaryRecord || !isCollapsedGroup">', '<table class="', Ext.baseCSSPrefix, "{view.id}-table ", Ext.baseCSSPrefix, "grid-table", '<tpl if="summaryRecord"> ', Ext.baseCSSPrefix, 'grid-table-summary</tpl>"', 'border="0" cellspacing="0" cellpadding="0" style="width:100%" {ariaSummaryTableAttr}>', "{[values.view.renderColumnSizer(out)]}", '<tpl if="!isCollapsedGroup">', "{%", "values.itemClasses.length = 0;", "this.nextTpl.applyOut(values, out, parent);", "%}", "</tpl>", '<tpl if="summaryRecord">', "{%me.outputSummaryRecord(values.summaryRecord, values, out);%}", "</tpl>", "</table>", "</tpl>", "</td>", "</tr>", "<tpl else>", "{%this.nextTpl.applyOut(values, out, parent);%}", "</tpl>", {
        priority: 200,
        syncRowHeights: function(e, t) {
            e = Ext.fly(e, "syncDest");
            t = Ext.fly(t, "sycSrc");
            var n = this.owner,
            r = e.down(n.eventSelector, true),
            i,
            s = e.down(n.summaryRowSelector, true),
            o,
            u,
            a;
            if (r && (i = t.down(n.eventSelector, true))) {
                r.style.height = i.style.height = "";
                if ((u = r.offsetHeight) > (a = i.offsetHeight)) {
                    Ext.fly(i).setHeight(u)
                } else {
                    if (a > u) {
                        Ext.fly(r).setHeight(a)
                    }
                }
            }
            if (s && (o = t.down(n.summaryRowSelector, true))) {
                s.style.height = o.style.height = "";
                if ((u = s.offsetHeight) > (a = o.offsetHeight)) {
                    Ext.fly(o).setHeight(u)
                } else {
                    if (a > u) {
                        Ext.fly(s).setHeight(a)
                    }
                }
            }
        },
        syncContent: function(e, t) {
            e = Ext.fly(e, "syncDest");
            t = Ext.fly(t, "sycSrc");
            var n = this.owner,
            r = e.down(n.eventSelector, true),
            i = t.down(n.eventSelector, true),
            s = e.down(n.summaryRowSelector, true),
            o = t.down(n.summaryRowSelector, true);
            if (r && i) {
                Ext.fly(r).syncContent(i)
            }
            if (s && o) {
                Ext.fly(s).syncContent(o)
            }
        }
    }],
    constructor: function() {
        this.groupCache = {};
        this.callParent(arguments)
    },
    init: function(e) {
        var t = this,
        n = t.view,
        r = n.store;
        if (r.isGrouped()) {
            n.isGrouping = true
        }
        if (t.lockingPartner && t.lockingPartner.groupCache) {
            t.groupCache = t.lockingPartner.groupCache
        }
        t.mixins.summary.init.call(t);
        t.callParent(arguments);
        n.headerCt.on({
            columnhide: t.onColumnHideShow,
            columnshow: t.onColumnHideShow,
            columnmove: t.onColumnMove,
            scope: t
        });
        n.addTableTpl(t.tableTpl).groupingFeature = t;
        n.addRowTpl(Ext.XTemplate.getTpl(t, "groupTpl")).groupingFeature = t;
        n.preserveScrollOnRefresh = true;
        if (r.buffered) {
            t.collapsible = false
        } else {
            if (this.lockingPartner && this.lockingPartner.dataSource) {
                t.dataSource = n.dataSource = this.lockingPartner.dataSource
            } else {
                t.dataSource = n.dataSource = new Ext.grid.feature.GroupStore(t, r)
            }
        }
        t.grid.on({
            reconfigure: t.onReconfigure
        });
        n.on({
            afterrender: t.afterViewRender,
            scope: t,
            single: true
        })
    },
    indexOf: function(e) {
        return this.dataSource.indexOf(e)
    },
    isInCollapsedGroup: function(e) {
        var t, n = this.view.store;
        if (n.isGrouped() && (t = this.getGroup(e))) {
            return t.isCollapsed || false
        }
        return false
    },
    clearGroupCache: function() {
        var e = this,
        t = e.groupCache = {};
        if (e.lockingPartner) {
            e.lockingPartner.groupCache = t
        }
        return t
    },
    vetoEvent: function(e, t, n, r) {
        if (r.type !== "mouseover" && r.type !== "mouseout" && r.type !== "mouseenter" && r.type !== "mouseleave" && r.getTarget(this.eventSelector)) {
            return false
        }
    },
    enable: function() {
        var e = this,
        t = e.view,
        n = t.store,
        r;
        t.isGrouping = true;
        if (e.lastGroupers) {
            e.block();
            n.group(e.lastGroupers);
            e.lastGroupers = null;
            e.unblock()
        }
        e.callParent();
        r = e.view.headerCt.getMenu().down("#groupToggleMenuItem");
        if (r) {
            r.setChecked(true, true)
        }
        e.refreshIf()
    },
    disable: function() {
        var e = this,
        t = e.view,
        n = t.store,
        r, i = n.groupers.getRange();
        t.isGrouping = false;
        if (i.length) {
            e.lastGroupers = i;
            e.block();
            n.clearGrouping();
            e.unblock()
        }
        e.callParent();
        r = e.view.headerCt.getMenu().down("#groupToggleMenuItem");
        if (r) {
            r.setChecked(false, true)
        }
        e.refreshIf()
    },
    refreshIf: function() {
        var e = this.grid.ownerCt,
        t = this.view;
        if (!t.store.remoteGroup && !this.blockRefresh) {
            if (e && e.lockable) {
                e.view.refresh()
            } else {
                t.refresh()
            }
        }
    },
    afterViewRender: function() {
        var e = this,
        t = e.view;
        t.on({
            scope: e,
            groupclick: e.onGroupClick
        });
        if (e.enableGroupingMenu) {
            e.injectGroupingMenu()
        }
        e.pruneGroupedHeader();
        e.lastGroupers = e.view.store.groupers.getRange();
        e.block();
        e.onGroupChange();
        e.unblock();
        if (e.disabled) {
            e.disable()
        }
    },
    injectGroupingMenu: function() {
        var e = this,
        t = e.view.headerCt;
        t.showMenuBy = e.showMenuBy;
        t.getMenuItems = e.getMenuItems()
    },
    onColumnHideShow: function(e, t) {
        var n = this.view,
        r = n.headerCt,
        i = r.getMenu(),
        s = i.activeHeader,
        o = i.down("#groupMenuItem"),
        u,
        a = this.grid.getVisibleColumnManager().getColumns().length,
        f,
        l,
        c;
        if (s && o) {
            u = s.groupable === false || s.dataIndex == null || this.view.headerCt.getVisibleGridColumns().length < 2 ? "disable": "enable";
            o[u]()
        }
        if (n.rendered) {
            f = n.el.query("." + this.ctCls);
            for (c = 0, l = f.length; c < l; ++c) {
                f[c].colSpan = a
            }
        }
    },
    onColumnMove: function() {
        var e = this,
        t = e.view.store,
        n, r, i, s, o;
        if (t.isGrouped()) {
            n = e.groupCache;
            Ext.suspendLayouts();
            for (r in n) {
                if (n.hasOwnProperty(r)) {
                    i = n[r];
                    s = i.children[0];
                    o = i.children[i.children.length - 1];
                    t.fireEvent("update", t, s, "edit", null);
                    if (o !== s && e.showSummaryRow) {
                        t.fireEvent("update", t, o, "edit", null)
                    }
                }
            }
            Ext.resumeLayouts(true)
        }
    },
    showMenuBy: function(e, t) {
        var n = this.getMenu(),
        r = n.down("#groupMenuItem"),
        i = t.groupable === false || t.dataIndex == null || this.view.headerCt.getVisibleGridColumns().length < 2 ? "disable": "enable",
        s = n.down("#groupToggleMenuItem"),
        o = this.view.store.isGrouped();
        r[i]();
        if (s) {
            s.setChecked(o, true);
            s[o ? "enable": "disable"]()
        }
        Ext.grid.header.Container.prototype.showMenuBy.apply(this, arguments)
    },
    getMenuItems: function() {
        var e = this,
        t = e.groupByText,
        n = e.disabled || !e.getGroupField(),
        r = e.showGroupsText,
        i = e.enableNoGroups,
        s = e.view.headerCt.getMenuItems;
        return function() {
            var o = s.call(this);
            o.push("-", {
                iconCls: Ext.baseCSSPrefix + "group-by-icon",
                itemId: "groupMenuItem",
                text: t,
                handler: e.onGroupMenuItemClick,
                scope: e
            });
            if (i) {
                o.push({
                    itemId: "groupToggleMenuItem",
                    text: r,
                    checked: !n,
                    checkHandler: e.onGroupToggleMenuItemClick,
                    scope: e
                })
            }
            return o
        }
    },
    onGroupMenuItemClick: function(e, t) {
        var n = this,
        r = e.parentMenu,
        i = r.activeHeader,
        s = n.view,
        o = s.store;
        n.lastGroupers = null;
        n.block();
        n.enable();
        o.group(i.dataIndex);
        n.pruneGroupedHeader();
        n.unblock();
        n.refreshIf()
    },
    block: function(e) {
        this.blockRefresh = this.view.blockRefresh = true;
        if (this.lockingPartner && !e) {
            this.lockingPartner.block(true)
        }
    },
    unblock: function(e) {
        this.blockRefresh = this.view.blockRefresh = false;
        if (this.lockingPartner && !e) {
            this.lockingPartner.unblock(true)
        }
    },
    onGroupToggleMenuItemClick: function(e, t) {
        this[t ? "enable": "disable"]()
    },
    pruneGroupedHeader: function() {
        var e = this,
        t = e.getGroupedHeader();
        if (e.hideGroupedHeader && t) {
            Ext.suspendLayouts();
            if (e.prunedHeader && e.prunedHeader !== t) {
                e.prunedHeader.show()
            }
            e.prunedHeader = t;
            t.hide();
            Ext.resumeLayouts(true)
        }
    },
    getHeaderNode: function(e) {
        return Ext.get(this.createGroupId(e))
    },
    getGroup: function(e) {
        if (e.isModel) {
            e = e.get(this.view.store.getGroupField())
        }
        var t = this.groupCache,
        n = t[e];
        if (!n) {
            n = t[e] = {
                isCollapsed: false
            }
        }
        return n
    },
    isExpanded: function(e) {
        return ! this.getGroup(e).isCollapsed
    },
    expand: function(e, t) {
        this.doCollapseExpand(false, e, t)
    },
    expandAll: function() {
        var e = this,
        t = e.groupCache,
        n, r = e.lockingPartner;
        for (n in t) {
            if (t.hasOwnProperty(n)) {
                t[n].isCollapsed = false
            }
        }
        Ext.suspendLayouts();
        e.dataSource.onRefresh();
        Ext.resumeLayouts(true);
        for (n in t) {
            if (t.hasOwnProperty(n)) {
                e.afterCollapseExpand(false, n);
                if (r) {
                    r.afterCollapseExpand(false, n)
                }
            }
        }
    },
    collapse: function(e, t) {
        this.doCollapseExpand(true, e, t)
    },
    isAllCollapsed: function() {
        var e = this,
        t = e.groupCache,
        n;
        for (n in t) {
            if (t.hasOwnProperty(n)) {
                if (!t[n].isCollapsed) {
                    return false
                }
            }
        }
        return true
    },
    isAllExpanded: function() {
        var e = this,
        t = e.groupCache,
        n;
        for (n in t) {
            if (t.hasOwnProperty(n)) {
                if (t[n].isCollapsed) {
                    return false
                }
            }
        }
        return true
    },
    collapseAll: function() {
        var e = this,
        t = e.groupCache,
        n, r = e.lockingPartner;
        for (n in t) {
            if (t.hasOwnProperty(n)) {
                t[n].isCollapsed = true
            }
        }
        Ext.suspendLayouts();
        e.dataSource.onRefresh();
        if (r && !r.isAllCollapsed()) {
            r.collapseAll()
        }
        Ext.resumeLayouts(true);
        for (n in t) {
            if (t.hasOwnProperty(n)) {
                e.afterCollapseExpand(true, n);
                if (r) {
                    r.afterCollapseExpand(true, n)
                }
            }
        }
    },
    doCollapseExpand: function(e, t, n) {
        var r = this,
        i = r.lockingPartner,
        s = r.groupCache[t];
        if (s.isCollapsed !== e) {
            Ext.suspendLayouts();
            if (e) {
                r.dataSource.collapseGroup(s)
            } else {
                r.dataSource.expandGroup(s)
            }
            Ext.resumeLayouts(true);
            r.afterCollapseExpand(e, t, n);
            if (i) {
                i.afterCollapseExpand(e, t, false)
            }
        }
    },
    afterCollapseExpand: function(e, t, n) {
        var r = this,
        i = r.view,
        s;
        s = Ext.get(this.getHeaderNode(t));
        i.fireEvent(e ? "groupcollapse": "groupexpand", i, s, t);
        if (n) {
            s.up(i.getItemSelector()).scrollIntoView(i.el, null, true)
        }
    },
    onGroupChange: function() {
        var e = this,
        t = e.getGroupField(),
        n,
        r,
        i,
        s;
        if (e.hideGroupedHeader) {
            if (e.lastGroupers && e.lastGroupers.length) {
                n = e.getMenuItem(e.lastGroupers[0].property);
                if (n) {
                    s = true
                }
            }
            if (t) {
                r = e.view.headerCt.getVisibleGridColumns();
                i = r.length === 1 && r[0].dataIndex === t;
                n = e.getMenuItem(t);
                if (n && !i) {
                    s = false
                }
            }
            if (n && n.checked !== s) {
                n.setChecked(s)
            }
        }
        e.refreshIf();
        e.lastGroupers = e.view.store.groupers.getRange()
    },
    getMenuItem: function(e) {
        var t = this.view,
        n = t.headerCt.down("gridcolumn[dataIndex=" + e + "]"),
        r = t.headerCt.getMenu();
        return n ? r.down("menuitem[headerId=" + n.id + "]") : null
    },
    onGroupKey: function(e, t) {
        var n = this,
        r = n.getGroupName(t.target);
        if (r) {
            n.onGroupClick(n.view, t.target, r, t)
        }
    },
    onGroupClick: function(e, t, n, r) {
        var i = this,
        s = i.groupCache,
        o = !i.isExpanded(n),
        u;
        if (i.collapsible) {
            if (r.ctrlKey) {
                Ext.suspendLayouts();
                for (u in s) {
                    if (u === n) {
                        if (o) {
                            i.expand(n)
                        }
                    } else {
                        if (!s[u].isCollapsed) {
                            i.doCollapseExpand(true, u, false)
                        }
                    }
                }
                Ext.resumeLayouts(true);
                return
            }
            if (o) {
                i.expand(n)
            } else {
                i.collapse(n)
            }
        }
    },
    setupRowData: function(e, t, n) {
        var r = this,
        i = n.recordIndex,
        s = r.refreshData,
        o = r.groupInfo,
        u = s.header,
        a = s.groupField,
        f = r.view.store,
        l = r.view.dataSource,
        c, h, p, d;
        n.isCollapsedGroup = false;
        n.summaryRecord = null;
        if (s.doGrouping) {
            c = r.view.store.groupers.first();
            if (e.children) {
                h = c.getGroupString(e.children[0]);
                n.isFirstRow = n.isLastRow = true;
                n.itemClasses.push(r.hdCollapsedCls);
                n.isCollapsedGroup = n.needsWrap = true;
                n.groupInfo = o;
                o.groupField = a;
                o.name = h;
                o.groupValue = e.children[0].get(a);
                o.columnName = u ? u.text: a;
                n.collapsibleCls = r.collapsible ? r.collapsibleCls: r.hdNotCollapsibleCls;
                n.groupId = r.createGroupId(h);
                o.rows = o.children = e.children;
                if (r.showSummaryRow) {
                    n.summaryRecord = s.summaryData[h]
                }
                return
            }
            h = c.getGroupString(e);
            if (e.group) {
                n.isFirstRow = e === e.group.children[0];
                n.isLastRow = e === e.group.children[e.group.children.length - 1]
            } else {
                n.isFirstRow = i === 0;
                if (!n.isFirstRow) {
                    p = f.getAt(i - 1);
                    if (p) {
                        n.isFirstRow = !p.isEqual(c.getGroupString(p), h)
                    }
                }
                n.isLastRow = i == (f.buffered ? f.getTotalCount() : f.getCount()) - 1;
                if (!n.isLastRow) {
                    d = f.getAt(i + 1);
                    if (d) {
                        n.isLastRow = !d.isEqual(c.getGroupString(d), h)
                    }
                }
            }
            if (n.isFirstRow) {
                o.groupField = a;
                o.name = h;
                o.groupValue = e.get(a);
                o.columnName = u ? u.text: a;
                n.collapsibleCls = r.collapsible ? r.collapsibleCls: r.hdNotCollapsibleCls;
                n.groupId = r.createGroupId(h);
                if (!r.isExpanded(h)) {
                    n.itemClasses.push(r.hdCollapsedCls);
                    n.isCollapsedGroup = true
                }
                if (l.buffered) {
                    o.rows = o.children = []
                } else {
                    o.rows = o.children = r.getRecordGroup(e).children
                }
                n.groupInfo = o
            }
            if (n.isLastRow) {
                if (r.showSummaryRow) {
                    n.summaryRecord = s.summaryData[h]
                }
            }
            n.needsWrap = n.isFirstRow || n.summaryRecord
        }
    },
    setup: function(e, t) {
        var n = this,
        r = n.refreshData,
        i = !n.disabled && n.view.isGrouping;
        n.skippedRows = 0;
        if (t.view.bufferedRenderer) {
            t.view.bufferedRenderer.variableRowHeight = true
        }
        r.groupField = n.getGroupField();
        r.header = n.getGroupedHeader(r.groupField);
        r.doGrouping = i;
        t.groupHeaderTpl = Ext.XTemplate.getTpl(n, "groupHeaderTpl");
        if (i && n.showSummaryRow) {
            r.summaryData = n.generateSummaryData()
        }
    },
    cleanup: function(e, t) {
        var n = this.refreshData;
        t.groupInfo = t.groupHeaderTpl = t.isFirstRow = null;
        n.groupField = n.header = null
    },
    getGroupName: function(e) {
        var t = this,
        n = t.view,
        r = t.eventSelector,
        i, s, o;
        s = Ext.fly(e).findParent(r);
        if (!s) {
            o = Ext.fly(e).findParent(n.itemSelector);
            if (o) {
                s = o.down(r, true)
            }
        }
        if (s) {
            i = s.id.split(n.id + "-hd-");
            if (i.length === 2) {
                return Ext.htmlDecode(i[1])
            }
        }
    },
    getRecordGroup: function(e) {
        var t = this.view.store.groupers.first();
        if (t) {
            return this.groupCache[t.getGroupString(e)]
        }
    },
    createGroupId: function(e) {
        return this.view.id + "-hd-" + Ext.htmlEncode(e)
    },
    createGroupCls: function(e) {
        return this.view.id + "-" + Ext.htmlEncode(e) + "-item"
    },
    getGroupField: function() {
        return this.view.store.getGroupField()
    },
    getGroupedHeader: function(e) {
        var t = this,
        n = t.view.headerCt,
        r = t.lockingPartner,
        i, s;
        e = e || this.getGroupField();
        if (e) {
            i = "[dataIndex=" + e + "]";
            s = n.down(i);
            if (!s && r) {
                s = r.view.headerCt.down(i)
            }
        }
        return s || null
    },
    getFireEventArgs: function(e, t, n, r) {
        return [e, t, n, this.getGroupName(n), r]
    },
    destroy: function() {
        var e = this,
        t = e.dataSource;
        e.view = e.prunedHeader = e.grid = e.groupCache = e.dataSource = null;
        e.callParent();
        if (t) {
            t.bindStore(null)
        }
    },
    onReconfigure: function(e, t, n, r, i) {
        var s;
        if (t && t !== r) {
            s = t.buffered;
            if (s !== r.buffered) {
                Ext.Error.raise("Cannot reconfigure grouping switching between buffered and non-buffered stores")
            }
            if (s || e.findPlugin("bufferedrenderer")) {
                e.view.dataSource.bindStore(t)
            }
        }
    }
});Ext.define("Ext.grid.feature.GroupingSummary", {
    extend: Ext.grid.feature.Grouping,
    alias: "feature.groupingsummary",
    showSummaryRow: true,
    vetoEvent: function(e, t, n, r) {
        var i = this.callParent(arguments);
        if (i !== false) {
            if (r.getTarget(this.summaryRowSelector)) {
                i = false
            }
        }
        return i
    }
});Ext.define("Ext.grid.feature.RowWrap", {
    extend: Ext.grid.feature.Feature,
    alias: "feature.rowwrap",
    rowWrapTd: "td." + Ext.baseCSSPrefix + "grid-rowwrap",
    hasFeatureEvent: false,
    tableTpl: {
        before: function(e, t) {
            if (e.view.bufferedRenderer) {
                e.view.bufferedRenderer.variableRowHeight = true
            }
        },
        priority: 200
    },
    wrapTpl: ['<tr data-boundView="{view.id}" data-recordId="{record.internalId}" data-recordIndex="{recordIndex}" class="{[values.itemClasses.join(" ")]} ', Ext.baseCSSPrefix, 'grid-wrap-row" {ariaRowAttr}>', '<td class="', Ext.baseCSSPrefix, "grid-rowwrap ", Ext.baseCSSPrefix, 'grid-td" colspan="{columns.length}" {ariaCellAttr}>', '<table class="', Ext.baseCSSPrefix, "{view.id}-table ", Ext.baseCSSPrefix, 'grid-table" border="0" cellspacing="0" cellpadding="0" style="width:100%" {ariaCellInnerTableAttr}>', "{[values.view.renderRowWrapColumnSizer(out)]}", "{%", "values.itemClasses.length = 0;", "this.nextTpl.applyOut(values, out, parent)", "%}", "</table>", "</td>", "</tr>", {
        priority: 200
    }],
    getTargetSelector: function() {
        return this.itemSelector
    },
    init: function(e) {
        var t = this,
        n = t.view;
        n.addTableTpl(t.tableTpl);
        n.addRowTpl(Ext.XTemplate.getTpl(t, "wrapTpl"));
        n.renderRowWrapColumnSizer = t.view.renderColumnSizer;
        n.renderColumnSizer = Ext.emptyFn;
        n.isRowWrapped = true;
        n.getTargetSelector = t.getTargetSelector
    }
});Ext.define("Ext.grid.feature.RowBody", {
    extend: Ext.grid.feature.RowWrap,
    alias: "feature.rowbody",
    rowBodyCls: Ext.baseCSSPrefix + "grid-row-body",
    rowBodyHiddenCls: Ext.baseCSSPrefix + "grid-row-body-hidden",
    rowBodyTdSelector: "td." + Ext.baseCSSPrefix + "grid-cell-rowbody",
    eventPrefix: "rowbody",
    eventSelector: "tr." + Ext.baseCSSPrefix + "grid-rowbody-tr",
    hasFeatureEvent: true,
    colSpanDecrement: 0,
    tableTpl: {
        before: function(e, t) {
            if (!this.rowBody) {
                return
            }
            var n = e.view,
            r = n.rowValues;
            this.rowBody.setup(e.rows, r)
        },
        after: function(e, t) {
            if (!this.rowBody) {
                return
            }
            var n = e.view,
            r = n.rowValues;
            this.rowBody.cleanup(e.rows, r)
        },
        priority: 100
    },
    extraRowTpl: ["{%", "values.view.rowBodyFeature.setupRowData(values.record, values.recordIndex, values);", "this.nextTpl.applyOut(values, out, parent);", "%}", '<tr class="', Ext.baseCSSPrefix, 'grid-rowbody-tr {rowBodyCls}" {ariaRowAttr}>', '<td class="', Ext.baseCSSPrefix, "grid-cell-rowbody", '" colspan="{rowBodyColspan}" {ariaCellAttr}>', '<div class="', Ext.baseCSSPrefix, "grid-rowbody", ' {rowBodyDivCls}" {ariaCellInnerAttr}>{rowBody}</div>', "</td>", "</tr>", {
        priority: 100,
        syncRowHeights: function(e, t) {
            var n = this.owner,
            r = Ext.fly(e).down(n.eventSelector, true),
            i,
            s,
            o;
            if (r && (i = Ext.fly(t).down(n.eventSelector, true))) {
                if ((s = r.offsetHeight) > (o = i.offsetHeight)) {
                    Ext.fly(i).setHeight(s)
                } else {
                    if (o > s) {
                        Ext.fly(r).setHeight(o)
                    }
                }
            }
        },
        syncContent: function(e, t) {
            var n = this.owner,
            r = Ext.fly(e).down(n.eventSelector, true),
            i;
            if (r && (i = Ext.fly(t).down(n.eventSelector, true))) {
                Ext.fly(r).syncContent(i)
            }
        }
    }],
    init: function(e) {
        var t = this,
        n = t.view = e.getView();
        n.rowBodyFeature = t;
        t.mon(e.getStore(), "remove", t.onStoreRemove, t);
        n.headerCt.on({
            columnschanged: t.onColumnsChanged,
            scope: t
        });
        n.addTableTpl(t.tableTpl).rowBody = t;
        n.addRowTpl(Ext.XTemplate.getTpl(this, "extraRowTpl"));
        n.mouseOverOutBuffer = 0;
        t.callParent(arguments)
    },
    onStoreRemove: function(e, t, n) {
        var r = this.view,
        i;
        if (r.rendered) {
            i = r.getNode(n);
            if (i) {
                i = Ext.fly(i).next(this.eventSelector);
                if (i) {
                    i.remove()
                }
            }
        }
    },
    getSelectedRow: function(e, t) {
        var n = e.getNode(t, false);
        if (n) {
            return Ext.fly(n).down(this.eventSelector)
        }
        return null
    },
    onColumnsChanged: function(e) {
        var t = this.view.el.query(this.rowBodyTdSelector),
        n = e.getVisibleGridColumns().length,
        r = t.length,
        i;
        for (i = 0; i < r; ++i) {
            t[i].colSpan = n
        }
    },
    setupRowData: function(e, t, n) {
        if (this.getAdditionalData) {
            Ext.apply(n, this.getAdditionalData(e.data, t, e, n))
        }
    },
    setup: function(e, t) {
        t.rowBodyCls = this.rowBodyCls;
        t.rowBodyColspan = t.view.getGridColumns().length - this.colSpanDecrement
    },
    cleanup: function(e, t) {
        t.rowBodyCls = t.rowBodyColspan = t.rowBody = null
    }
});Ext.define("Ext.grid.feature.Summary", {
    extend: Ext.grid.feature.AbstractSummary,
    alias: "feature.summary",
    dock: undefined,
    dockedSummaryCls: Ext.baseCSSPrefix + "docked-summary",
    panelBodyCls: Ext.baseCSSPrefix + "summary-",
    scrollPadProperty: "padding-right",
    hasFeatureEvent: false,
    init: function(e) {
        var t = this,
        n = t.view;
        t.callParent(arguments);
        if (t.dock) {
            e.headerCt.on({
                add: t.onStoreUpdate,
                afterlayout: t.onStoreUpdate,
                scope: t
            });
            e.on({
                beforerender: function() {
                    var r = [t.summaryTableCls];
                    if (n.columnLines) {
                        r[r.length] = n.ownerCt.colLinesCls
                    }
                    t.summaryBar = e.addDocked({
                        childEls: ["innerCt"],
                        renderTpl: ['<div id="{id}-innerCt" role="presentation">', '<table cellPadding="0" cellSpacing="0" class="' + r.join(" ") + '">', '<tr class="' + t.summaryRowCls + '"></tr>', "</table>", "</div>"],
                        style: "overflow:hidden",
                        itemId: "summaryBar",
                        cls: [t.dockedSummaryCls, t.dockedSummaryCls + "-" + t.dock],
                        xtype: "component",
                        dock: t.dock,
                        weight: 1e7
                    })[0]
                },
                afterrender: function() {
                    e.body.addCls(t.panelBodyCls + t.dock);
                    n.mon(n.el, {
                        scroll: t.onViewScroll,
                        scope: t
                    });
                    t.onStoreUpdate()
                },
                single: true
            });
            e.headerCt.afterComponentLayout = Ext.Function.createSequence(e.headerCt.afterComponentLayout,
            function() {
                var e = this.getTableWidth(),
                r = t.summaryBar.innerCt,
                i;
                if (n.hasVerticalScroll()) {
                    i = Ext.getScrollbarSize().width;
                    e -= i;
                    r.down("table").setStyle(t.scrollPadProperty, i + "px")
                }
                r.setWidth(e)
            })
        } else {
            t.view.addFooterFn(t.renderTFoot)
        }
        e.on({
            columnmove: t.onStoreUpdate,
            scope: t
        });
        n.mon(n.store, {
            update: t.onStoreUpdate,
            datachanged: t.onStoreUpdate,
            scope: t
        })
    },
    renderTFoot: function(e, t) {
        var n = e.view,
        r = n.findFeature("summary");
        if (r.showSummaryRow) {
            t.push("<tfoot>");
            r.outputSummaryRecord(r.createSummaryRecord(n), e, t);
            t.push("</tfoot>")
        }
    },
    toggleSummaryRow: function(e) {
        var t = this,
        n = t.summaryBar;
        t.callParent(arguments);
        if (n) {
            n.setVisible(t.showSummaryRow);
            t.onViewScroll()
        }
    },
    vetoEvent: function(e, t, n, r) {
        return ! r.getTarget(this.summaryRowSelector)
    },
    onViewScroll: function() {
        this.summaryBar.el.dom.scrollLeft = this.view.el.dom.scrollLeft
    },
    createSummaryRecord: function(e) {
        var t = e.headerCt.getVisibleGridColumns(),
        n = {
            records: e.store.getRange()
        },
        r = t.length,
        i,
        s,
        o = this.summaryRecord || (this.summaryRecord = new e.store.model(null, e.id + "-summary-record")),
        u,
        a;
        o.beginEdit();
        for (i = 0; i < r; i++) {
            s = t[i];
            u = s.dataIndex || s.id;
            a = this.getSummary(e.store, s.summaryType, u, n);
            o.set(u, a);
            this.setSummaryData(o, s.id, a)
        }
        o.endEdit(true);
        o.commit(true);
        o.isSummary = true;
        return o
    },
    onStoreUpdate: function() {
        var e = this,
        t = e.view,
        n = e.createSummaryRecord(t),
        r = t.createRowElement(n, -1),
        i,
        s;
        if (!t.rendered) {
            return
        }
        if (e.dock) {
            i = e.summaryBar.el.down("." + e.summaryRowCls, true)
        } else {
            i = e.view.getNode(n)
        }
        if (i) {
            s = i.parentNode;
            s.insertBefore(r, i);
            s.removeChild(i)
        }
        if (e.dock) {
            e.onColumnHeaderLayout()
        }
    },
    onColumnHeaderLayout: function() {
        var e = this.view,
        t = e.headerCt.getVisibleGridColumns(),
        n,
        r = t.length,
        i,
        s = this.summaryBar.el,
        o;
        for (i = 0; i < r; i++) {
            n = t[i];
            o = s.down(e.getCellSelector(n));
            if (o) {
                if (n.hidden) {
                    o.setDisplayed(false)
                } else {
                    o.setDisplayed(true);
                    o.setWidth(n.width || (n.lastBox ? n.lastBox.width: 100))
                }
            }
        }
    }
});Ext.define("Ext.grid.locking.HeaderContainer", {
    extend: Ext.grid.header.Container,
    constructor: function(e) {
        var t = this,
        n, r, i = [],
        s = e.lockedGrid,
        o = e.normalGrid;
        t.lockable = e;
        t.callParent();
        s.visibleColumnManager.rootColumns = o.visibleColumnManager.rootColumns = e.visibleColumnManager = t.visibleColumnManager = new Ext.grid.ColumnManager(true, s.headerCt, o.headerCt);
        s.columnManager.rootColumns = o.columnManager.rootColumns = e.columnManager = t.columnManager = new Ext.grid.ColumnManager(false, s.headerCt, o.headerCt);
        n = s.headerCt.events;
        for (r in n) {
            if (n.hasOwnProperty(r)) {
                i.push(r)
            }
        }
        t.relayEvents(s.headerCt, i);
        t.relayEvents(o.headerCt, i)
    },
    getRefItems: function() {
        return this.lockable.lockedGrid.headerCt.getRefItems().concat(this.lockable.normalGrid.headerCt.getRefItems())
    },
    getGridColumns: function() {
        return this.lockable.lockedGrid.headerCt.getGridColumns().concat(this.lockable.normalGrid.headerCt.getGridColumns())
    },
    getColumnsState: function() {
        var e = this,
        t = e.lockable.lockedGrid.headerCt.getColumnsState(),
        n = e.lockable.normalGrid.headerCt.getColumnsState();
        return t.concat(n)
    },
    applyColumnsState: function(e) {
        var t = this,
        n = t.lockable.lockedGrid,
        r = n.headerCt,
        i = t.lockable.normalGrid.headerCt,
        s = Ext.Array.toValueMap(r.items.items, "headerId"),
        o = Ext.Array.toValueMap(i.items.items, "headerId"),
        u = [],
        a = [],
        f = 1,
        l = e.length,
        c,
        h,
        p,
        d;
        for (c = 0; c < l; c++) {
            d = e[c];
            p = s[d.id];
            h = p || o[d.id];
            if (h) {
                if (h.applyColumnState) {
                    h.applyColumnState(d)
                }
                if (h.locked === undefined) {
                    h.locked = !!p
                }
                if (h.locked) {
                    u.push(h);
                    if (!h.hidden && typeof h.width == "number") {
                        f += h.width
                    }
                } else {
                    a.push(h)
                }
            }
        }
        if (u.length + a.length == r.items.getCount() + i.items.getCount()) {
            r.removeAll(false);
            i.removeAll(false);
            r.add(u);
            i.add(a);
            n.setWidth(f)
        }
    }
});Ext.define("Ext.grid.locking.View", {
    alternateClassName: "Ext.grid.LockingView",
    mixins: {
        observable: Ext.util.Observable,
        bindable: Ext.util.Bindable
    },
    isLockingView: true,
    loadMask: true,
    eventRelayRe: /^(beforeitem|beforecontainer|item|container|cell|refresh)/,
    constructor: function(e) {
        var t = this,
        n = [],
        r = t.eventRelayRe,
        i,
        s,
        o,
        u;
        t.panel = e.panel;
        e.locked.viewConfig.bindStore = e.normal.viewConfig.bindStore = Ext.emptyFn;
        e.locked.viewConfig.beforeLayout = e.normal.viewConfig.beforeLayout = t.beforeLayout;
        t.lockedGrid = t.panel.lockedGrid = Ext.ComponentManager.create(e.locked);
        t.lockedView = i = t.lockedGrid.getView();
        if (t.lockedGrid.isTree) {
            t.lockedView.animate = false;
            e.normal.store = i.store;
            e.normal.viewConfig.stripeRows = t.lockedView.stripeRows;
            e.normal.rowLines = t.lockedGrid.rowLines
        }
        t.normalGrid = t.panel.normalGrid = Ext.ComponentManager.create(e.normal);
        i.lockingPartner = s = t.normalView = t.normalGrid.getView();
        s.lockingPartner = i;
        t.deferInitialRefresh = s.deferInitialRefresh && i.deferInitialRefresh;
        t.loadMask = e.loadMask !== undefined ? e.loadMask: t.loadMask;
        t.mixins.observable.constructor.call(t);
        o = i.events;
        for (u in o) {
            if (o.hasOwnProperty(u) && r.test(u)) {
                n.push(u)
            }
        }
        t.relayEvents(i, n);
        t.relayEvents(s, n);
        s.on({
            scope: t,
            itemmouseleave: t.onItemMouseLeave,
            itemmouseenter: t.onItemMouseEnter
        });
        i.on({
            scope: t,
            itemmouseleave: t.onItemMouseLeave,
            itemmouseenter: t.onItemMouseEnter
        });
        t.panel.on({
            render: t.onPanelRender,
            scope: t
        });
        t.loadingText = s.loadingText;
        t.loadingCls = s.loadingCls;
        t.loadingUseMsg = s.loadingUseMsg;
        t.bindStore(s.dataSource, true, "dataSource")
    },
    beforeLayout: function() {
        var e = this.ownerCt.ownerLockable.view,
        t = e.lockedGrid.view,
        n = e.normalGrid.view;
        if (e.lockedGrid.isVisible()) {
            if (t.refreshNeeded) {
                t.doFirstRefresh(t.dataSource)
            }
        }
        if (n.refreshNeeded) {
            n.doFirstRefresh(n.dataSource)
        }
    },
    onPanelRender: function() {
        var e = this,
        t = e.loadMask,
        n = {
            target: e.panel,
            msg: e.loadingText,
            msgCls: e.loadingCls,
            useMsg: e.loadingUseMsg,
            store: e.panel.store
        };
        e.el = e.panel.body;
        e.fireEvent("render", e);
        if (t) {
            if (Ext.isObject(t)) {
                n = Ext.apply(n, t)
            }
            e.loadMask = new Ext.LoadMask(n)
        }
    },
    getRefOwner: function() {
        return this.panel
    },
    getGridColumns: function() {
        var e = this.lockedGrid.headerCt.getVisibleGridColumns();
        return e.concat(this.normalGrid.headerCt.getVisibleGridColumns())
    },
    getEl: function(e) {
        return this.getViewForColumn(e).getEl()
    },
    getViewForColumn: function(e) {
        var t = this.lockedView,
        n;
        t.headerCt.cascade(function(t) {
            if (t === e) {
                n = true;
                return false
            }
        });
        return n ? t: this.normalView
    },
    onItemMouseEnter: function(e, t) {
        var n = this,
        r = n.lockedView,
        i = n.normalView,
        s;
        if (e.trackOver) {
            if (e !== r) {
                i = r
            }
            s = i.getNode(t, false);
            i.highlightItem(s)
        }
    },
    onItemMouseLeave: function(e, t) {
        var n = this,
        r = n.lockedView,
        i = n.normalView;
        if (e.trackOver) {
            if (e !== r) {
                i = r
            }
            i.clearHighlight()
        }
    },
    relayFn: function(e, t) {
        t = t || [];
        var n = this.lockedView;
        n[e].apply(n, t);
        n = this.normalView;
        n[e].apply(n, t)
    },
    getSelectionModel: function() {
        return this.panel.getSelectionModel()
    },
    getStore: function() {
        return this.panel.store
    },
    bindStore: function(e, t, n) {
        var r = this;
        r.mixins.bindable.bindStore.apply(r, arguments);
        if (!t) {
            r.getSelectionModel().bindStore(e)
        }
        if (r.componentLayoutCounter) {
            Ext.suspendLayouts();
            r.normalView.doFirstRefresh(e);
            r.lockedView.doFirstRefresh(e);
            Ext.resumeLayouts(true)
        }
    },
    getStoreListeners: function() {
        var e = this;
        return {
            idchanged: e.onIdChanged,
            refresh: e.onDataRefresh,
            replace: e.onReplace,
            add: e.onAdd,
            bulkremove: e.onRemove,
            update: e.onUpdate,
            clear: e.refresh
        }
    },
    onIdChanged: function(e, t, n) {
        this.relayFn("onIdChanged", arguments)
    },
    onDataRefresh: function(e, t, n) {
        this.relayFn("onDataRefresh", arguments)
    },
    onReplace: function(e, t, n) {
        this.relayFn("onReplace", arguments)
    },
    onAdd: function(e, t, n) {
        this.relayFn("onAdd", arguments)
    },
    onRemove: function(e, t, n) {
        this.relayFn("onRemove", arguments)
    },
    onUpdate: function(e, t, n) {
        this.relayFn("onUpdate", arguments)
    },
    refresh: function(e, t, n) {
        this.relayFn("refresh", arguments)
    },
    getNode: function(e, t) {
        return this.normalView.getNode(e, t)
    },
    getCell: function(e, t) {
        var n = this.getViewForColumn(t),
        r = n.getNode(e, true);
        return Ext.fly(r).down(t.getCellSelector())
    },
    indexOf: function(e) {
        var t = this.lockedView.indexOf(e);
        if (!t) {
            t = this.normalView.indexOf(e)
        }
        return t
    },
    focus: function() {
        var e = this.getSelectionModel().getCurrentPosition(),
        t = e ? e.view: this.normalView;
        t.focus()
    },
    focusRow: function(e) {
        this.normalView.focusRow(e)
    },
    focusCell: function(e) {
        e.view.focusCell(e)
    },
    isVisible: function(e) {
        return this.panel.isVisible(e)
    },
    getCellByPosition: function(e, t) {
        var n = e.column,
        r = this.lockedGrid.getColumnManager().getColumns().length;
        if (n >= r) {
            e = Ext.apply({},
            e);
            e.column -= r;
            return this.normalView.getCellByPosition(e, t)
        } else {
            return this.lockedView.getCellByPosition(e, t)
        }
    },
    getRecord: function(e) {
        var t = this.lockedView.getRecord(e);
        if (!t) {
            t = this.normalView.getRecord(e)
        }
        return t
    },
    scrollBy: function() {
        var e = this.normalView;
        e.scrollBy.apply(e, arguments)
    },
    addElListener: function(e, t, n) {
        this.relayFn("addElListener", arguments)
    },
    refreshNode: function() {
        this.relayFn("refreshNode", arguments)
    },
    addRowCls: function() {
        this.relayFn("addRowCls", arguments)
    },
    removeRowCls: function() {
        this.relayFn("removeRowCls", arguments)
    },
    destroy: function() {
        var e = this,
        t = e.loadMask;
        this.isDestroyed = true;
        e.clearListeners();
        if (t && t.bindStore) {
            t.bindStore(null)
        }
    }
},
function() {
    this.borrow(Ext.AbstractComponent, ["up"]);
    this.borrow(Ext.view.AbstractView, ["doFirstRefresh", "applyFirstRefresh"])
});Ext.define("Ext.grid.locking.Lockable", {
    alternateClassName: "Ext.grid.Lockable",
    supportsOverflowX: "overflow-x" in document.documentElement.style,
    syncRowHeight: true,
    headerCounter: 0,
    scrollDelta: 40,
    lockedGridCls: Ext.baseCSSPrefix + "grid-inner-locked",
    normalGridCls: Ext.baseCSSPrefix + "grid-inner-normal",
    unlockText: "Unlock",
    lockText: "Lock",
    bothCfgCopy: ["invalidateScrollerOnRefresh", "hideHeaders", "enableColumnHide", "enableColumnMove", "enableColumnResize", "sortableColumns", "multiColumnSort", "columnLines", "rowLines", "deferRowRender"],
    normalCfgCopy: ["verticalScroller", "verticalScrollDock", "verticalScrollerType", "scroll"],
    lockedCfgCopy: [],
    determineXTypeToCreate: function(e) {
        var t = this,
        n, r, i, s, o;
        if (t.subGridXType) {
            n = t.subGridXType
        } else {
            if (!e) {
                return "gridpanel"
            }
            r = this.getXTypes().split("/");
            i = r.length;
            s = r[i - 1];
            o = r[i - 2];
            if (o !== "tablepanel") {
                n = o
            } else {
                n = s
            }
        }
        return n
    },
    injectLockable: function() {
        this.lockable = true;
        this.hasView = true;
        var e = this,
        t = Ext.getScrollbarSize().height,
        n = e.store = Ext.StoreManager.lookup(e.store),
        r = e.getSelectionModel(),
        i,
        s,
        o,
        u,
        a,
        f,
        l,
        c,
        h,
        p,
        d,
        v = e.viewConfig,
        m = v && v.loadMask,
        g = m !== undefined ? m: e.loadMask,
        y = e.findPlugin("bufferedrenderer");
        i = e.constructLockableFeatures();
        if (e.features) {
            e.features = null
        }
        s = e.constructLockablePlugins();
        e.plugins = s.topPlugins;
        o = Ext.apply({
            id: e.id + "-locked",
            isLocked: true,
            ownerLockable: e,
            xtype: e.determineXTypeToCreate(true),
            store: n,
            scrollerOwner: false,
            animate: false,
            scroll: t ? false: "vertical",
            selModel: r,
            border: false,
            cls: e.lockedGridCls,
            isLayoutRoot: function() {
                return this.floatedFromCollapse || e.normalGrid.floatedFromCollapse
            },
            features: i.lockedFeatures,
            plugins: s.lockedPlugins
        },
        e.lockedGridConfig);
        u = Ext.apply({
            id: e.id + "-normal",
            isLocked: false,
            ownerLockable: e,
            xtype: e.determineXTypeToCreate(),
            store: n,
            scrollerOwner: false,
            selModel: r,
            border: false,
            cls: e.normalGridCls,
            isLayoutRoot: function() {
                return this.floatedFromCollapse || e.lockedGrid.floatedFromCollapse
            },
            features: i.normalFeatures,
            plugins: s.normalPlugins
        },
        e.normalGridConfig);
        e.addCls(Ext.baseCSSPrefix + "grid-locked");
        Ext.copyTo(u, e, e.bothCfgCopy, true);
        Ext.copyTo(o, e, e.bothCfgCopy, true);
        Ext.copyTo(u, e, e.normalCfgCopy, true);
        Ext.copyTo(o, e, e.lockedCfgCopy, true);
        for (a = 0; a < e.normalCfgCopy.length; a++) {
            delete e[e.normalCfgCopy[a]]
        }
        for (a = 0; a < e.lockedCfgCopy.length; a++) {
            delete e[e.lockedCfgCopy[a]]
        }
        e.addEvents("processcolumns", "lockcolumn", "unlockcolumn");
        e.addStateEvents(["lockcolumn", "unlockcolumn"]);
        f = e.processColumns(e.columns, o);
        o.columns = f.locked;
        if (!o.columns.items.length) {
            o.hidden = true
        }
        u.columns = f.normal;
        u.flex = 1;
        o.viewConfig = e.lockedViewConfig || {};
        u.viewConfig = e.normalViewConfig || {};
        o.viewConfig.loadingUseMsg = false;
        o.viewConfig.loadMask = false;
        if (t && !e.supportsOverflowX) {
            o.viewConfig.style = "border-bottom:" + t + "px solid #f6f6f6;" + (o.viewConfig.style || "");
            u.viewConfig.style = "border-bottom:" + t + "px solid #f6f6f6;" + (o.viewConfig.style || "")
        }
        u.viewConfig.loadMask = false;
        Ext.applyIf(o.viewConfig, v);
        Ext.applyIf(u.viewConfig, v);
        if (!e.initialConfig.layout) {
            e.layout = {
                type: "hbox",
                align: "stretch"
            }
        }
        e.getLayout();
        if (e.layout.type === "border") {
            if (e.split) {
                o.split = true
            }
            if (!u.title) {
                o.header = false
            }
            if (!o.region) {
                o.region = "west"
            }
            if (!u.region) {
                u.region = "center"
            }
            e.addCls(Ext.baseCSSPrefix + "grid-locked-split")
        }
        if (! (e.layout instanceof Ext.layout.container.Box)) {
            e.split = false
        }
        e.view = new Ext.grid.locking.View({
            loadMask: g,
            locked: o,
            normal: u,
            panel: e
        });
        h = e.lockedGrid.getView();
        p = e.normalGrid.getView();
        d = y ? {}: {
            scroll: {
                fn: e.onLockedViewScroll,
                element: "el",
                scope: e
            }
        };
        if (t) {
            e.lockedGrid.on({
                afterlayout: e.afterLockedViewLayout,
                scope: e
            });
            h.getOverflowStyle();
            if (h.scrollFlags.y) {
                e.lockedGrid.headerCt.forceFit = true
            } else {
                d.mousewheel = {
                    fn: e.onLockedViewMouseWheel,
                    element: "el",
                    scope: e
                }
            }
        }
        h.on(d);
        d = y ? {}: {
            scroll: {
                fn: e.onNormalViewScroll,
                element: "el",
                scope: e
            },
            scope: e
        };
        p.on(d);
        l = e.lockedGrid.headerCt;
        c = e.normalGrid.headerCt;
        e.headerCt = e.view.headerCt = new Ext.grid.locking.HeaderContainer(e);
        l.lockedCt = true;
        l.lockableInjected = true;
        c.lockableInjected = true;
        l.on({
            add: {
                buffer: 1,
                scope: e,
                fn: e.onLockedHeaderAdd
            },
            columnshow: e.onLockedHeaderShow,
            columnhide: e.onLockedHeaderHide,
            sortchange: e.onLockedHeaderSortChange,
            columnresize: e.onLockedHeaderResize,
            scope: e
        });
        c.on({
            sortchange: e.onNormalHeaderSortChange,
            scope: e
        });
        e.modifyHeaderCt();
        e.items = [e.lockedGrid];
        if (e.split) {
            e.addCls(Ext.baseCSSPrefix + "grid-locked-split");
            e.items[1] = {
                xtype: "splitter"
            }
        }
        e.items.push(e.normalGrid);
        e.relayHeaderCtEvents(l);
        e.relayHeaderCtEvents(c);
        e.storeRelayers = e.relayEvents(n, ["filterchange", "groupchange"]);
        e.gridRelayers = e.relayEvents(e.normalGrid, ["viewready"])
    },
    getLockingViewConfig: function() {
        return {
            xclass: "Ext.grid.locking.View",
            locked: this.lockedGrid,
            normal: this.normalGrid,
            panel: this
        }
    },
    processColumns: function(e, t) {
        var n = this,
        r, i, s, o = new Ext.grid.header.Container,
        u = [],
        a = [],
        f = {
            itemId: "lockedHeaderCt",
            stretchMaxPartner: "^^>>#normalHeaderCt",
            items: u
        },
        l = {
            itemId: "normalHeaderCt",
            stretchMaxPartner: "^^>>#lockedHeaderCt",
            items: a
        },
        c = {
            lockedWidth: t.width || 0,
            locked: f,
            normal: l
        },
        h = n.shrinkWrapLocked = !(t.width || t.flex),
        p;
        if (Ext.isObject(e)) {
            Ext.applyIf(f, e);
            Ext.applyIf(l, e);
            p = Ext.apply({},
            e);
            delete p.items;
            Ext.apply(o, p);
            e = e.items
        }
        for (r = 0, i = e.length; r < i; ++r) {
            s = e[r];
            if (!s.isComponent) {
                s = o.lookupComponent(o.applyDefaults(s))
            }
            s.processed = true;
            if (s.locked || s.autoLock) {
                if (h && !s.hidden) {
                    c.lockedWidth += n.getColumnWidth(s) || o.defaultWidth
                }
                u.push(s)
            } else {
                a.push(s)
            }
            if (!s.headerId) {
                s.headerId = (s.initialConfig || s).id || "h" + ++n.headerCounter
            }
        }
        n.fireEvent("processcolumns", n, u, a);
        o.destroy();
        if (h) {
            t.width = c.lockedWidth += Ext.num(n.getSelectionModel().headerWidth, 0) + (u.length ? 1 : 0)
        }
        return c
    },
    getColumnWidth: function(e) {
        var t = e.width || 0,
        n, r, i;
        if (!t && e.isGroupHeader) {
            n = e.items.items;
            r = n.length;
            for (i = 0; i < r; i++) {
                t += this.getColumnWidth(n[i])
            }
        }
        return t
    },
    afterLockedViewLayout: function() {
        var e = this,
        t = e.lockedGrid.getView(),
        n = e.normalGrid.getView(),
        r = t.el,
        i = n.el,
        s = Ext.getScrollbarSize().height,
        o = t.scrollFlags.x && e.lockedGrid.headerCt.tooNarrow ? s: 0,
        u = n.scrollFlags.x && e.normalGrid.headerCt.tooNarrow ? s: 0;
        if (o !== u) {
            if (o) {
                if (e.supportsOverflowX) {
                    i.dom.style.overflowX = "scroll";
                    t.getOverflowEl().setStyle(t.getOverflowStyle())
                } else {
                    i.dom.style.borderBottomWidth = o + "px";
                    r.dom.style.borderBottomWidth = "0px"
                }
            } else {
                if (e.supportsOverflowX) {
                    r.dom.style.overflowX = "scroll";
                    n.getOverflowEl().setStyle(n.getOverflowStyle())
                } else {
                    r.dom.style.borderBottomWidth = u + "px";
                    i.dom.style.borderBottomWidth = "0px"
                }
            }
        } else {
            if (e.supportsOverflowX) {
                t.getOverflowEl().dom.style.overflowX = u ? "scroll": "";
                n.getOverflowEl().setStyle(n.getOverflowStyle())
            } else {
                i.dom.style.borderBottomWidth = r.dom.style.borderBottomWidth = "0px"
            }
        }
        if (!Ext.isBorderBox && !e.supportsOverflowX) {
            r.setHeight(t.lastBox.height);
            i.setHeight(n.lastBox.height)
        }
    },
    onLockedViewMouseWheel: function(e) {
        var t = this,
        n = -t.scrollDelta * e.getWheelDeltas().y,
        r = t.lockedGrid.getView().el.dom,
        i,
        s;
        if (!t.ignoreMousewheel) {
            if (r) {
                i = r.scrollTop !== r.scrollHeight - r.clientHeight;
                s = r.scrollTop !== 0
            }
            if (n < 0 && s || n > 0 && i) {
                e.stopEvent();
                r.scrollTop += n;
                t.normalGrid.getView().el.dom.scrollTop = r.scrollTop;
                t.onNormalViewScroll()
            }
        }
    },
    onLockedViewScroll: function() {
        var e = this,
        t = e.normalGrid.getView().el.dom,
        n = e.lockedGrid.getView().el.dom;
        if (t.scrollTop !== n.scrollTop) {
            t.scrollTop = n.scrollTop
        }
    },
    onNormalViewScroll: function() {
        var e = this,
        t = e.normalGrid.getView().el.dom,
        n = e.lockedGrid.getView().el.dom;
        if (t.scrollTop !== n.scrollTop) {
            n.scrollTop = t.scrollTop
        }
    },
    syncRowHeights: function() {
        var e = this,
        t, n = e.lockedGrid.getView(),
        r = e.normalGrid.getView(),
        i = n.all.slice(),
        s = r.all.slice(),
        o = i.length,
        u;
        if (s.length === o) {
            for (t = 0; t < o; t++) {
                r.syncRowHeights(i[t], s[t])
            }
            u = r.el.dom.scrollTop;
            r.el.dom.scrollTop = u;
            n.el.dom.scrollTop = u
        }
    },
    modifyHeaderCt: function() {
        var e = this;
        e.lockedGrid.headerCt.getMenuItems = e.getMenuItems(e.lockedGrid.headerCt.getMenuItems, true);
        e.normalGrid.headerCt.getMenuItems = e.getMenuItems(e.normalGrid.headerCt.getMenuItems, false);
        e.lockedGrid.headerCt.showMenuBy = Ext.Function.createInterceptor(e.lockedGrid.headerCt.showMenuBy, e.showMenuBy);
        e.normalGrid.headerCt.showMenuBy = Ext.Function.createInterceptor(e.normalGrid.headerCt.showMenuBy, e.showMenuBy)
    },
    onUnlockMenuClick: function() {
        this.unlock()
    },
    onLockMenuClick: function() {
        this.lock()
    },
    showMenuBy: function(e, t) {
        var n = this.getMenu(),
        r = n.down("#unlockItem"),
        i = n.down("#lockItem"),
        s = r.prev();
        if (t.lockable === false) {
            s.hide();
            r.hide();
            i.hide()
        } else {
            s.show();
            r.show();
            i.show();
            if (!r.initialConfig.disabled) {
                r.setDisabled(t.lockable === false)
            }
            if (!i.initialConfig.disabled) {
                i.setDisabled(!t.isLockable())
            }
        }
    },
    getMenuItems: function(e, t) {
        var n = this,
        r = n.unlockText,
        i = n.lockText,
        s = Ext.baseCSSPrefix + "hmenu-unlock",
        o = Ext.baseCSSPrefix + "hmenu-lock",
        u = Ext.Function.bind(n.onUnlockMenuClick, n),
        a = Ext.Function.bind(n.onLockMenuClick, n);
        return function() {
            var n = e.call(this);
            n.push("-", {
                itemId: "unlockItem",
                iconCls: s,
                text: r,
                handler: u,
                disabled: !t
            });
            n.push({
                itemId: "lockItem",
                iconCls: o,
                text: i,
                handler: a,
                disabled: t
            });
            return n
        }
    },
    syncLockedWidth: function() {
        var e = this,
        t = e.lockedGrid,
        n = t.view,
        r = n.el.dom,
        i = e.normalGrid,
        s = t.headerCt.getVisibleGridColumns().length,
        o = i.headerCt.getVisibleGridColumns().length;
        Ext.suspendLayouts();
        if (o) {
            i.show();
            if (s) {
                if (e.shrinkWrapLocked && !t.headerCt.forceFit) {
                    delete t.flex;
                    t.setWidth(t.headerCt.getTableWidth() + t.el.getBorderWidth("lr"))
                }
                t.addCls(e.lockedGridCls);
                t.show();
                if (e.split) {
                    e.child("splitter").show()
                }
            } else {
                t.getView().clearViewEl();
                t.hide();
                if (e.split) {
                    e.child("splitter").hide()
                }
            }
            n.el.setStyle(n.getOverflowStyle());
            e.ignoreMousewheel = n.scrollFlags.y
        } else {
            i.hide();
            r.style.borderBottomWidth = "0";
            t.flex = 1;
            delete t.width;
            t.removeCls(e.lockedGridCls);
            t.show();
            n.el.setStyle(i.view.getOverflowStyle());
            e.ignoreMousewheel = true
        }
        Ext.resumeLayouts(true);
        return [s, o]
    },
    onLockedHeaderAdd: function() {
        if (!this.ignoreAddLockedColumn) {
            this.syncLockedWidth()
        }
    },
    onLockedHeaderResize: function() {
        this.syncLockedWidth()
    },
    onLockedHeaderHide: function() {
        this.syncLockedWidth()
    },
    onLockedHeaderShow: function() {
        this.syncLockedWidth()
    },
    onLockedHeaderSortChange: Ext.emptyFn,
    onNormalHeaderSortChange: Ext.emptyFn,
    lock: function(e, t, n) {
        var r = this,
        i = r.normalGrid,
        s = r.lockedGrid,
        o = i.view,
        u = s.view,
        a = i.headerCt,
        f, l;
        e = e || a.getMenu().activeHeader;
        n = n || s.headerCt;
        l = e.ownerCt;
        if (!e.isLockable()) {
            return
        }
        if (e.flex) {
            e.width = e.getWidth();
            e.flex = null
        }
        Ext.suspendLayouts();
        o.blockRefresh = u.blockRefresh = true;
        l.remove(e, false);
        e.locked = true;
        r.ignoreAddLockedColumn = true;
        if (Ext.isDefined(t)) {
            n.insert(t, e)
        } else {
            n.add(e)
        }
        r.ignoreAddLockedColumn = false;
        o.blockRefresh = u.blockRefresh = false;
        f = r.syncLockedWidth();
        if (f[0]) {
            s.getView().refresh()
        }
        if (f[1]) {
            i.getView().refresh()
        }
        Ext.resumeLayouts(true);
        r.fireEvent("lockcolumn", r, e)
    },
    unlock: function(e, t, n) {
        var r = this,
        i = r.normalGrid,
        s = r.lockedGrid,
        o = i.view,
        u = s.view,
        a = s.headerCt,
        f;
        if (!Ext.isDefined(t)) {
            t = 0
        }
        e = e || a.getMenu().activeHeader;
        n = n || i.headerCt;
        Ext.suspendLayouts();
        o.blockRefresh = u.blockRefresh = true;
        e.ownerCt.remove(e, false);
        e.locked = false;
        n.insert(t, e);
        o.blockRefresh = u.blockRefresh = false;
        f = r.syncLockedWidth();
        if (f[0]) {
            s.getView().refresh()
        }
        if (f[1]) {
            i.getView().refresh()
        }
        Ext.resumeLayouts(true);
        r.fireEvent("unlockcolumn", r, e)
    },
    reconfigureLockable: function(e, t) {
        var n = this,
        r = n.store,
        i = n.lockedGrid,
        s = n.normalGrid;
        Ext.suspendLayouts();
        if (t) {
            i.headerCt.removeAll();
            s.headerCt.removeAll();
            t = n.processColumns(t, i);
            n.ignoreAddLockedColumn = true;
            i.headerCt.add(t.locked.items);
            n.ignoreAddLockedColumn = false;
            s.headerCt.add(t.normal.items);
            n.syncLockedWidth()
        }
        if (e && e !== r) {
            e = Ext.data.StoreManager.lookup(e);
            n.store = e;
            i.bindStore(e);
            s.bindStore(e)
        } else {
            i.getView().refresh();
            s.getView().refresh()
        }
        Ext.resumeLayouts(true)
    },
    constructLockableFeatures: function() {
        var e = this.features,
        t, n, r, i, s = 0,
        o;
        if (e) {
            if (!Ext.isArray(e)) {
                e = [e]
            }
            r = [];
            i = [];
            o = e.length;
            for (; s < o; s++) {
                t = e[s];
                if (!t.isFeature) {
                    t = Ext.create("feature." + t.ftype, t)
                }
                switch (t.lockableScope) {
                case "locked":
                    r.push(t);
                    break;
                case "normal":
                    i.push(t);
                    break;
                default:
                    t.lockableScope = "both";
                    r.push(t);
                    i.push(n = t.clone());
                    n.lockingPartner = t;
                    t.lockingPartner = n
                }
            }
        }
        return {
            normalFeatures: i,
            lockedFeatures: r
        }
    },
    constructLockablePlugins: function() {
        var e = this.plugins,
        t, n, r, i, s, o, u = 0,
        a, f, l;
        if (e) {
            if (!Ext.isArray(e)) {
                e = [e]
            }
            i = [];
            s = [];
            o = [];
            a = e.length;
            for (; u < a; u++) {
                t = e[u];
                if (t.init) {
                    f = t.lockableScope
                } else {
                    l = t.ptype ? Ext.ClassManager.getByAlias("plugin." + t.ptype) : Ext.ClassManager.get(t.xclass);
                    f = l.prototype.lockableScope
                }
                switch (f) {
                case "both":
                    s.push(r = t.clonePlugin());
                    o.push(n = t.clonePlugin());
                    r.lockingPartner = n;
                    n.lockingPartner = r;
                    Ext.destroy(t);
                    break;
                case "locked":
                    s.push(t);
                    break;
                case "normal":
                    o.push(t);
                    break;
                default:
                    i.push(t)
                }
            }
        }
        return {
            topPlugins:
            i,
            normalPlugins: o,
            lockedPlugins: s
        }
    },
    destroyLockable: function() {
        Ext.destroy(this.view, this.headerCt)
    }
},
function() {
    this.borrow(Ext.AbstractComponent, ["constructPlugin"])
});Ext.define("Ext.tree.View", {
    extend: Ext.view.Table,
    alias: "widget.treeview",
    isTreeView: true,
    loadingCls: Ext.baseCSSPrefix + "grid-tree-loading",
    expandedCls: Ext.baseCSSPrefix + "grid-tree-node-expanded",
    leafCls: Ext.baseCSSPrefix + "grid-tree-node-leaf",
    expanderSelector: "." + Ext.baseCSSPrefix + "tree-expander",
    checkboxSelector: "." + Ext.baseCSSPrefix + "tree-checkbox",
    expanderIconOverCls: Ext.baseCSSPrefix + "tree-expander-over",
    nodeAnimWrapCls: Ext.baseCSSPrefix + "tree-animator-wrap",
    ariaRole: "tree",
    loadMask: false,
    rootVisible: true,
    deferInitialRefresh: false,
    expandDuration: 250,
    collapseDuration: 250,
    toggleOnDblClick: true,
    stripeRows: false,
    uiFields: ["expanded", "loaded", "checked", "expandable", "leaf", "icon", "iconCls", "loading", "qtip", "qtitle"],
    treeRowTpl: ["{%", "this.processRowValues(values);", "this.nextTpl.applyOut(values, out, parent);", "%}", {
        priority: 10,
        processRowValues: function(e) {
            var t = e.record,
            n = e.view;
            e.rowAttr["data-qtip"] = t.get("qtip") || "";
            e.rowAttr["data-qtitle"] = t.get("qtitle") || "";
            if (t.isExpanded()) {
                e.rowClasses.push(n.expandedCls)
            }
            if (t.isLeaf()) {
                e.rowClasses.push(n.leafCls)
            }
            if (t.isLoading()) {
                e.rowClasses.push(n.loadingCls)
            }
        }
    }],
    initComponent: function() {
        var e = this,
        t = e.panel.getStore(),
        n = e.store;
        if (e.initialConfig.animate === undefined) {
            e.animate = Ext.enableFx
        }
        if (!n || n === t) {
            e.store = n = new Ext.data.NodeStore({
                treeStore: t,
                recursive: true,
                autoDestroy: t ? t.autoDestroy: true,
                rootVisible: e.rootVisible
            })
        }
        if (e.node) {
            e.setRootNode(e.node)
        }
        e.animQueue = {};
        e.animWraps = {};
        e.addEvents("afteritemexpand", "afteritemcollapse", "nodedragover");
        e.callParent(arguments);
        e.addRowTpl(Ext.XTemplate.getTpl(e, "treeRowTpl"))
    },
    onBeforeFill: function(e, t) {
        this.store.suspendEvents()
    },
    onFillComplete: function(e, t, n) {
        var r = this,
        i = r.store,
        s = i.indexOf(n[0]);
        i.resumeEvents();
        t.triggerUIUpdate();
        if (!n.length || s === -1) {
            return
        }
        r.onAdd(r.store, n, s);
        r.refreshPartner()
    },
    onBeforeSort: function() {
        this.store.suspendEvents()
    },
    onSort: function(e) {
        if (e.isStore) {
            this.store.resumeEvents();
            this.refresh();
            this.refreshPartner()
        }
    },
    refreshPartner: function() {
        var e = this.lockingPartner;
        if (e) {
            e.refresh()
        }
    },
    getMaskStore: function() {
        return this.panel.getStore()
    },
    afterRender: function() {
        var e = this;
        e.callParent(arguments);
        e.el.on({
            scope: e,
            delegate: e.expanderSelector,
            mouseover: e.onExpanderMouseOver,
            mouseout: e.onExpanderMouseOut,
            click: {
                delegate: e.checkboxSelector,
                fn: e.onCheckboxChange,
                scope: e
            }
        })
    },
    afterComponentLayout: function() {
        this.callParent(arguments);
        var e = this.stretcher;
        if (e) {
            e.setWidth(this.getWidth() - Ext.getScrollbarSize().width)
        }
    },
    processUIEvent: function(e) {
        if (e.getTarget("." + this.nodeAnimWrapCls, this.el)) {
            return false
        }
        return this.callParent(arguments)
    },
    onClear: function() {
        this.store.removeAll()
    },
    setRootNode: function(e) {
        var t = this;
        t.store.setNode(e);
        t.node = e
    },
    onCheckboxChange: function(e, t) {
        var n = this,
        r = e.getTarget(n.getItemSelector(), n.getTargetEl());
        if (r) {
            n.onCheckChange(n.getRecord(r))
        }
    },
    onCheckChange: function(e) {
        var t = e.get("checked");
        if (Ext.isBoolean(t)) {
            t = !t;
            e.set("checked", t);
            this.fireEvent("checkchange", e, t)
        }
    },
    getChecked: function() {
        var e = [];
        this.node.cascadeBy(function(t) {
            if (t.get("checked")) {
                e.push(t)
            }
        });
        return e
    },
    isItemChecked: function(e) {
        return e.get("checked")
    },
    createAnimWrap: function(e, t) {
        var n = this,
        r = n.getNode(e, !n.isRowWrapped),
        i,
        s,
        o = [];
        n.renderColumnSizer(o);
        s = Ext.get(r);
        i = s.insertSibling({
            role: "presentation",
            tag: "tr",
            html: ['<td colspan="' + n.panel.headerCt.getColumnCount() + '" role="presentation">', '<div class="' + n.nodeAnimWrapCls + '" role="presentation">', '<table class="' + Ext.baseCSSPrefix + n.id + "-table " + Ext.baseCSSPrefix + 'grid-table" style="border:0" cellspacing="0" cellpadding="0" role="presentation">', o.join(""), "<tbody></tbody></table>", "</div>", "</td>"].join("")
        },
        "after");
        return {
            record: e,
            node: r,
            el: i,
            expanding: false,
            collapsing: false,
            animating: false,
            animateEl: i.down("div"),
            targetEl: i.down("tbody")
        }
    },
    getAnimWrap: function(e, t) {
        if (!this.animate) {
            return null
        }
        var n = this.animWraps,
        r = n[e.internalId];
        if (t !== false) {
            while (!r && e) {
                e = e.parentNode;
                if (e) {
                    r = n[e.internalId]
                }
            }
        }
        return r
    },
    doAdd: function(e, t) {
        if (!e.length) {
            return
        }
        var n = this,
        r = n.bufferRender(e, t, true),
        i = e[0],
        s = i.parentNode,
        o = n.all,
        u,
        a = n.getAnimWrap(s),
        f,
        l,
        c;
        if (!a || !a.expanding) {
            return n.callParent(arguments)
        }
        s = a.record;
        f = a.targetEl;
        l = f.dom.childNodes;
        c = l.length;
        u = t - n.indexInStore(s) - 1;
        if (!c || u >= c) {
            f.appendChild(r)
        } else {
            Ext.fly(l[u]).insertSibling(r, "before", true)
        }
        o.insert(t, r);
        if (a.isAnimating) {
            n.onExpand(s)
        }
    },
    onRemove: function(e, t, n) {
        var r = this,
        i, s;
        if (r.viewReady) {
            i = r.store.getCount() === 0;
            if (i) {
                r.refresh()
            } else {
                for (s = n.length - 1; s >= 0; --s) {
                    r.doRemove(t[s], n[s])
                }
            }
            if (r.hasListeners.itemremove) {
                for (s = n.length - 1; s >= 0; --s) {
                    r.fireEvent("itemremove", t[s], n[s])
                }
            }
        }
    },
    doRemove: function(e, t) {
        var n = this,
        r = n.all,
        i = n.getAnimWrap(e),
        s = r.item(t),
        o = s ? s.dom: null;
        if (!o || !i || !i.collapsing) {
            return n.callParent(arguments)
        }
        i.targetEl.dom.insertBefore(o, i.targetEl.dom.firstChild);
        r.removeElement(t)
    },
    onBeforeExpand: function(e, t, n) {
        var r = this,
        i;
        if (r.rendered && r.all.getCount() && r.animate) {
            if (r.getNode(e)) {
                i = r.getAnimWrap(e, false);
                if (!i) {
                    i = r.animWraps[e.internalId] = r.createAnimWrap(e);
                    i.animateEl.setHeight(0)
                } else {
                    if (i.collapsing) {
                        i.targetEl.select(r.itemSelector).remove()
                    }
                }
                i.expanding = true;
                i.collapsing = false
            }
        }
    },
    onExpand: function(e) {
        var t = this,
        n = t.animQueue,
        r = e.getId(),
        i = t.getNode(e),
        s = i ? t.indexOf(i) : -1,
        o,
        u,
        a,
        f = Ext.isIEQuirks ? 1 : 0;
        if (t.singleExpand) {
            t.ensureSingleExpand(e)
        }
        if (s === -1) {
            return
        }
        o = t.getAnimWrap(e, false);
        if (!o) {
            t.refreshSelection();
            e.isExpandingOrCollapsing = false;
            t.fireEvent("afteritemexpand", e, s, i);
            t.refreshSize();
            return
        }
        u = o.animateEl;
        a = o.targetEl;
        u.stopAnimation();
        n[r] = true;
        u.dom.style.height = f + "px";
        u.animate({
            from: {
                height: f
            },
            to: {
                height: a.getHeight()
            },
            duration: t.expandDuration,
            listeners: {
                afteranimate: function() {
                    var e = a.query(t.itemSelector);
                    if (e.length) {
                        o.el.insertSibling(e, "before", true)
                    }
                    o.el.remove();
                    t.refreshSize();
                    delete t.animWraps[o.record.internalId];
                    delete n[r]
                }
            },
            callback: function() {
                t.refreshSelection();
                e.isExpandingOrCollapsing = false;
                t.fireEvent("afteritemexpand", e, s, i)
            }
        });
        o.isAnimating = true
    },
    onBeforeCollapse: function(e, t, n, r, i) {
        var s = this,
        o;
        if (s.rendered && s.all.getCount()) {
            if (s.animate) {
                if (Ext.Array.contains(e.stores, s.store)) {
                    o = s.getAnimWrap(e);
                    if (!o) {
                        o = s.animWraps[e.internalId] = s.createAnimWrap(e, n)
                    } else {
                        if (o.expanding) {
                            o.targetEl.select(this.itemSelector).remove()
                        }
                    }
                    o.expanding = false;
                    o.collapsing = true;
                    o.callback = r;
                    o.scope = i
                }
            } else {
                s.onCollapseCallback = r;
                s.onCollapseScope = i
            }
            s.onRowDeselect(s.indexOf(e.firstChild))
        }
    },
    onCollapse: function(e) {
        var t = this,
        n = t.animQueue,
        r = e.getId(),
        i = t.getNode(e),
        s = i ? t.indexOf(i) : -1,
        o = t.getAnimWrap(e),
        u;
        if (!t.all.getCount() || !Ext.Array.contains(e.stores, t.store)) {
            return
        }
        if (!o) {
            t.refreshSelection();
            e.isExpandingOrCollapsing = false;
            t.fireEvent("afteritemcollapse", e, s, i);
            t.refreshSize();
            Ext.callback(t.onCollapseCallback, t.onCollapseScope);
            t.onCollapseCallback = t.onCollapseScope = null;
            return
        }
        u = o.animateEl;
        n[r] = true;
        u.stopAnimation();
        u.animate({
            to: {
                height: Ext.isIEQuirks ? 1 : 0
            },
            duration: t.collapseDuration,
            listeners: {
                afteranimate: function() {
                    o.el.remove();
                    if (!t.isDestroyed) {
                        t.refreshSize()
                    }
                    delete t.animWraps[o.record.internalId];
                    delete n[r]
                }
            },
            callback: function() {
                t.refreshSelection();
                e.isExpandingOrCollapsing = false;
                t.fireEvent("afteritemcollapse", e, s, i);
                Ext.callback(o.callback, o.scope);
                o.callback = o.scope = null
            }
        });
        o.isAnimating = true
    },
    isAnimating: function(e) {
        return !! this.animQueue[e.getId()]
    },
    expand: function(e, t, n, r) {
        var i = this,
        s = !!i.animate,
        o;
        if (!s || !e.isExpandingOrCollapsing) {
            if (!e.isLeaf()) {
                e.isExpandingOrCollapsing = s
            }
            Ext.suspendLayouts();
            o = e.expand(t, n, r);
            Ext.resumeLayouts(true);
            return o
        }
    },
    collapse: function(e, t, n, r) {
        var i = this,
        s = !!i.animate;
        if (!s || !e.isExpandingOrCollapsing) {
            if (!e.isLeaf()) {
                e.isExpandingOrCollapsing = s
            }
            return e.collapse(t, n, r)
        }
    },
    toggle: function(e, t, n, r) {
        if (e.isExpanded()) {
            this.collapse(e, t, n, r)
        } else {
            this.expand(e, t, n, r)
        }
    },
    onItemDblClick: function(e, t, n) {
        var r = this,
        i = r.editingPlugin;
        r.callParent(arguments);
        if (r.toggleOnDblClick && e.isExpandable() && !(i && i.clicksToEdit === 2)) {
            r.toggle(e)
        }
    },
    onBeforeItemMouseDown: function(e, t, n, r) {
        if (r.getTarget(this.expanderSelector, t)) {
            return false
        }
        return this.callParent(arguments)
    },
    onItemClick: function(e, t, n, r) {
        if (r.getTarget(this.expanderSelector, t) && e.isExpandable()) {
            this.toggle(e, r.ctrlKey);
            return false
        }
        return this.callParent(arguments)
    },
    onExpanderMouseOver: function(e, t) {
        e.getTarget(this.cellSelector, 10, true).addCls(this.expanderIconOverCls)
    },
    onExpanderMouseOut: function(e, t) {
        e.getTarget(this.cellSelector, 10, true).removeCls(this.expanderIconOverCls)
    },
    getStoreListeners: function() {
        var e = this,
        t = e.callParent(arguments);
        return Ext.apply(t, {
            beforeexpand: e.onBeforeExpand,
            expand: e.onExpand,
            beforecollapse: e.onBeforeCollapse,
            collapse: e.onCollapse,
            write: e.onStoreWrite,
            datachanged: e.onStoreDataChanged
        })
    },
    onBindStore: function() {
        var e = this,
        t = e.getTreeStore();
        e.callParent(arguments);
        e.mon(t, {
            scope: e,
            beforefill: e.onBeforeFill,
            fillcomplete: e.onFillComplete
        });
        if (!t.remoteSort) {
            e.mon(t, {
                scope: e,
                beforesort: e.onBeforeSort,
                sort: e.onSort
            })
        }
    },
    onUnbindStore: function() {
        var e = this,
        t = e.getTreeStore();
        e.callParent(arguments);
        e.mun(t, {
            scope: e,
            beforefill: e.onBeforeFill,
            fillcomplete: e.onFillComplete
        });
        if (!t.remoteSort) {
            e.mun(t, {
                scope: e,
                beforesort: e.onBeforeSort,
                sort: e.onSort
            })
        }
    },
    getTreeStore: function() {
        return this.panel.store
    },
    ensureSingleExpand: function(e) {
        var t = e.parentNode;
        if (t) {
            t.eachChild(function(t) {
                if (t !== e && t.isExpanded()) {
                    t.collapse()
                }
            })
        }
    },
    shouldUpdateCell: function(e, t, n) {
        if (n) {
            var r = 0,
            i = n.length;
            for (; r < i; ++r) {
                if (Ext.Array.contains(this.uiFields, n[r])) {
                    return true
                }
            }
        }
        return this.callParent(arguments)
    },
    onStoreWrite: function(e, t) {
        var n = this.panel.store;
        n.fireEvent("write", n, t)
    },
    onStoreDataChanged: function(e, t) {
        var n = this.panel.store;
        n.fireEvent("datachanged", n)
    }
});Ext.define("Ext.grid.plugin.BufferedRendererTreeView", {
    override: "Ext.tree.View",
    onRemove: function(e, t, n, r, i) {
        var s = this,
        o = s.bufferedRenderer;
        if (s.rendered && o) {
            if (i) {
                o.onReplace(e, n[0], t, [])
            } else {
                o.refreshView()
            }
        } else {
            s.callParent([e, t, n])
        }
    }
});Ext.define("Ext.grid.plugin.BufferedRenderer", {
    extend: Ext.AbstractPlugin,
    alias: "plugin.bufferedrenderer",
    lockableScope: "both",
    percentageFromEdge: .35,
    variableRowHeight: false,
    numFromEdge: 8,
    trailingBufferZone: 10,
    leadingBufferZone: 20,
    synchronousRender: true,
    scrollToLoadBuffer: 200,
    viewSize: 0,
    rowHeight: 21,
    position: 0,
    lastScrollDirection: 1,
    bodyTop: 0,
    init: function(e) {
        var t = this,
        n = e.view,
        r = {
            scroll: {
                fn: t.onViewScroll,
                element: "el",
                scope: t
            },
            boxready: t.onViewResize,
            resize: t.onViewResize,
            refresh: t.onViewRefresh,
            scope: t,
            destroyable: true
        },
        i = n.initialConfig;
        if (!t.variableRowHeight && e.ownerLockable) {
            e.ownerLockable.syncRowHeight = false
        }
        if (e.isTree || e.ownerLockable && e.ownerLockable.isTree) {
            n.blockRefresh = false
        }
        if (n.positionBody) {
            r.refresh = t.onViewRefresh
        }
        t.grid = e;
        t.view = n;
        t.isRTL = n.getHierarchyState().rtl;
        n.bufferedRenderer = t;
        n.preserveScrollOnRefresh = true;
        n.animate = false;
        t.bindStore(n.dataSource);
        n.getViewRange = function() {
            return t.getViewRange()
        };
        t.position = 0;
        t.gridListeners = e.on("reconfigure", t.onReconfigure, t);
        t.viewListeners = n.on(r)
    },
    bindStore: function(e) {
        var t = this,
        n = t.view,
        r = n.dataSource,
        i = r && r.isFeatureStore;
        if (i === e.isFeatureStore) {
            if (t.store) {
                t.unbindStore()
            }
            t.storeListeners = e.on({
                scope: t,
                clear: t.onStoreClear,
                destroyable: true
            });
            t.store = e
        }
        if (t.view.componentLayout.layoutCount) {
            t.onViewResize(t.view, 0, t.view.getHeight())
        }
    },
    onReconfigure: function(e, t) {
        if (t && t !== this.store) {
            this.bindStore(t)
        }
    },
    unbindStore: function() {
        this.storeListeners.destroy();
        this.store = null
    },
    onStoreClear: function() {
        var e = this;
        if (e.view.rendered && !e.store.isDestroyed) {
            if (e.scrollTop !== 0) {
                e.ignoreNextScrollEvent = true;
                e.view.el.dom.scrollTop = 0
            }
            e.bodyTop = e.scrollTop = e.position = e.scrollHeight = 0;
            e.lastScrollDirection = e.scrollOffset = null;
            delete e.rowHeight
        }
    },
    onViewRefresh: function() {
        var e = this,
        t = e.view,
        n = e.scrollHeight,
        r;
        if (t.all.getCount()) {
            delete e.rowHeight
        }
        r = e.getScrollHeight();
        if (!n || r != n) {
            e.stretchView(t, r)
        }
        if (e.scrollTop !== t.el.dom.scrollTop) {
            e.onViewScroll()
        } else {
            if (!e.hasOwnProperty("bodyTop")) {
                e.bodyTop = t.all.startIndex * e.rowHeight;
                t.el.dom.scrollTop = e.bodyTop
            }
            e.setBodyTop(e.bodyTop);
            if (t.all.getCount()) {
                e.viewSize = 0;
                e.onViewResize(t, null, t.getHeight())
            }
        }
    },
    onViewResize: function(e, t, n, r, i) {
        var s = this,
        o;
        s.tableTopBorderWidth = e.body.getBorderWidth("t");
        if (!i || n !== i) {
            o = Math.ceil(n / s.rowHeight) + s.trailingBufferZone + s.leadingBufferZone;
            s.viewSize = s.setViewSize(o)
        }
    },
    stretchView: function(e, t) {
        var n = this,
        r = n.store.buffered ? n.store.getTotalCount() : n.store.getCount(),
        i,
        s;
        if (n.stretcher) {
            n.stretcher.dom.style.marginTop = (r <= n.viewSize ? 0 : t - 1) + "px"
        } else {
            s = e.el;
            if (e.refreshCounter) {
                e.fixedNodes++
            }
            if (r && n.view.all.endIndex === r - 1) {
                t = n.bodyTop + e.body.dom.offsetHeight
            }
            i = {
                style: {
                    width: "1px",
                    height: "1px",
                    marginTop: t - 1 + "px",
                    position: "absolute"
                }
            };
            i.style[n.isRTL ? "right": "left"] = 0;
            this.stretcher = s.createChild(i, s.dom.firstChild)
        }
    },
    setViewSize: function(e) {
        if (e !== this.viewSize) {
            this.scrollTop = this.view.el.dom.scrollTop;
            var t = this,
            n = t.store,
            r = t.view.all.getCount(),
            i,
            s,
            o = t.lockingPartner;
            t.viewSize = n.viewSize = e;
            if (r) {
                i = t.view.all.startIndex;
                s = Math.min(i + e - 1, (n.buffered ? n.getTotalCount() : n.getCount()) - 1);
                if (o) {
                    o.disable()
                }
                t.renderRange(i, s);
                if (o) {
                    o.enable()
                }
            }
        }
        return e
    },
    getViewRange: function() {
        var e = this,
        t = e.view.all,
        n = e.store,
        r = t.getCount() ? t.startIndex: t.startIndex = (n.currentPage - 1) * n.pageSize;
        if (t.getCount()) {
            r = t.startIndex
        } else {
            if (!n.currentPage) {
                n.currentPage = 1
            }
            r = t.startIndex = (n.currentPage - 1) * (n.pageSize || 1);
            n.currentPage = 1
        }
        if (n.data.getCount()) {
            return n.getRange(r, r + (e.viewSize || n.defaultViewSize) - 1)
        } else {
            return []
        }
    },
    onReplace: function(e, t, n, r) {
        var i = this,
        s = i.view,
        o = s.all,
        u = i.viewSize,
        a, f, l;
        i.position = s.el.dom.scrollTop;
        l = t + (n && n.length ? n.length - 1 : 0);
        if (l < o.startIndex || t > o.startIndex + u - 1) {
            i.stretchView(s, i.getScrollHeight());
            return
        }
        if (t <= o.startIndex && l >= o.endIndex) {
            i.refreshView()
        } else {
            if (t < o.startIndex) {
                f = l - o.startIndex + 1;
                if (f <= 0) {
                    i.refreshView()
                } else {
                    t = Math.max(t - f - i.trailingBufferZone, 0);
                    l = Math.min(t + u, e.getCount()) - 1;
                    i.setBodyTop(t * i.rowHeight);
                    i.renderRange(t, l)
                }
            } else {
                a = t + r.length - 1 - o.endIndex;
                if (a > 0) {
                    t = Math.max(i.getFirstVisibleRowIndex() - i.trailingBufferZone, 0);
                    l = Math.min(t + u, e.getCount() - 1);
                    o.removeRange(null, null, true);
                    i.renderRange(t, l);
                    s.selModel.onLastFocusChanged(null, s.selModel.lastFocused, true)
                } else {
                    i.refreshView()
                }
            }
        }
        i.stretchView(s, i.getScrollHeight())
    },
    scrollTo: function(e, t, n, r) {
        var i = this,
        s = i.view,
        o = s.el.dom,
        u = i.store,
        a = u.buffered ? u.getTotalCount() : u.getCount(),
        f,
        l,
        c,
        h,
        p,
        d,
        v,
        m;
        if ((d = s.dataSource.groupingFeature) && d.collapsible !== false) {
            e = Math.min(Math.max(e, 0), s.store.getCount() - 1);
            m = s.store.getAt(e);
            v = d.getGroup(m);
            if (v.isCollapsed) {
                d.expand(v.name);
                a = u.buffered ? u.getTotalCount() : u.getCount()
            }
            e = d.indexOf(m)
        } else {
            e = Math.min(Math.max(e, 0), a - 1)
        }
        f = Math.max(Math.min(e - Math.floor((i.leadingBufferZone + i.trailingBufferZone) / 2), a - i.viewSize + 1), 0);
        p = Math.max(f * i.rowHeight - i.tableTopBorderWidth, 0);
        l = Math.min(f + i.viewSize - 1, a - 1);
        u.getRange(f, l, {
            callback: function(a, f, l) {
                i.renderRange(f, l, true);
                c = u.data.getRange(e, e)[0];
                h = s.getNode(c, false);
                s.body.dom.style.top = p + "px";
                i.position = i.scrollTop = o.scrollTop = p = Math.min(Math.max(0, p - s.body.getOffsetsTo(h)[1]), o.scrollHeight - o.clientHeight);
                if (Ext.isIE) {
                    o.scrollTop = p
                }
                if (t) {
                    s.selModel.select(c)
                }
                if (n) {
                    n.call(r || i, e, c)
                }
            }
        })
    },
    onViewScroll: function(e, t) {
        var n = this,
        r = n.store,
        i = r.buffered ? r.getTotalCount() : r.getCount(),
        s,
        o,
        u = n.scrollTop = n.view.el.dom.scrollTop,
        a = false;
        if (n.ignoreNextScrollEvent) {
            n.ignoreNextScrollEvent = false;
            return
        }
        if (! (n.disabled || i < n.viewSize)) {
            s = u - n.position;
            o = s > 0 ? 1 : -1;
            if (Math.abs(s) >= 20 || o !== n.lastScrollDirection) {
                n.lastScrollDirection = o;
                n.handleViewScroll(n.lastScrollDirection);
                a = true
            }
        }
        if (!a) {
            if (n.lockingPartner && n.lockingPartner.scrollTop !== u) {
                n.lockingPartner.view.el.dom.scrollTop = u
            }
        }
    },
    handleViewScroll: function(e) {
        var t = this,
        n = t.view.all,
        r = t.store,
        i = t.viewSize,
        s = r.buffered ? r.getTotalCount() : r.getCount(),
        o,
        u;
        if (e == -1) {
            if (n.startIndex) {
                if (t.getFirstVisibleRowIndex() - n.startIndex < t.numFromEdge) {
                    o = Math.max(0, t.getLastVisibleRowIndex() + t.trailingBufferZone - i)
                }
            }
        } else {
            if (n.endIndex < s - 1) {
                if (n.endIndex - t.getLastVisibleRowIndex() < t.numFromEdge) {
                    o = Math.max(0, t.getFirstVisibleRowIndex() - t.trailingBufferZone)
                }
            }
        }
        if (o != null) {
            u = Math.min(o + i - 1, s - 1);
            if (o !== n.startIndex || u !== n.endIndex) {
                t.renderRange(o, u);
                return
            }
        }
        if (t.lockingPartner && t.lockingPartner.view.el && t.lockingPartner.scrollTop !== t.scrollTop) {
            t.lockingPartner.view.el.dom.scrollTop = t.scrollTop
        }
    },
    refreshView: function() {
        var e = this,
        t = e.view.selModel,
        n = e.view.all,
        r = e.store,
        i = r.getCount() - 1,
        s = Math.max(0, Math.min(n.startIndex, i - e.viewSize + 1)),
        o = Math.min(n.startIndex + e.viewSize - 1, i);
        n.removeRange(null, null, true);
        e.renderRange(s, o, true);
        t.onLastFocusChanged(null, t.lastFocused, true)
    },
    renderRange: function(e, t, n) {
        var r = this,
        i = r.view.all,
        s = r.store;
        if (! (e === i.startIndex && t === i.endIndex)) {
            if (s.rangeCached(e, t)) {
                r.cancelLoad();
                if (r.synchronousRender || n) {
                    r.onRangeFetched(null, e, t)
                } else {
                    if (!r.renderTask) {
                        r.renderTask = new Ext.util.DelayedTask(r.onRangeFetched, r, null, false)
                    }
                    r.renderTask.delay(1, null, null, [null, e, t])
                }
            } else {
                r.attemptLoad(e, t)
            }
        }
    },
    onRangeFetched: function(e, t, n, r) {
        var i = this,
        s = i.view,
        o, u = s.all,
        a, f = 0,
        l = t * i.rowHeight - i.tableTopBorderWidth,
        c, h = i.lockingPartner,
        p, d, v;
        if (s.isDestroyed) {
            return
        }
        if (!e) {
            e = i.store.getRange(t, n);
            if (!e) {
                return
            }
        }
        if (t < u.startIndex && n > u.endIndex) {
            d = u.startIndex - t;
            u.clear(true);
            p = Ext.Array.slice(s.doAdd(e, t), 0, d);
            for (v = 0; v < p.length; v++) {
                f -= p[v].offsetHeight
            }
            i.setBodyTop(i.bodyTop + f);
            return
        }
        if (t > u.endIndex || n < u.startIndex) {
            u.clear(true);
            c = l
        }
        if (!u.getCount()) {
            s.doAdd(e, t)
        } else {
            if (n > u.endIndex) {
                a = Math.max(t - u.startIndex, 0);
                if (i.variableRowHeight) {
                    f = u.item(u.startIndex + a, true).offsetTop
                }
                u.scroll(Ext.Array.slice(e, u.endIndex + 1 - t), 1, a, t, n);
                if (i.variableRowHeight) {
                    c = i.bodyTop + f
                } else {
                    c = l
                }
            } else {
                a = Math.max(u.endIndex - n, 0);
                o = u.startIndex;
                u.scroll(Ext.Array.slice(e, 0, u.startIndex - t), -1, a, t, n);
                if (i.variableRowHeight) {
                    c = i.bodyTop - u.item(o, true).offsetTop
                } else {
                    c = l
                }
            }
        }
        i.position = i.scrollTop;
        if (s.positionBody) {
            i.setBodyTop(c, l)
        }
        if (h && !h.disabled && !r) {
            h.onRangeFetched(e, t, n, true);
            if (h.scrollTop !== i.scrollTop) {
                h.view.el.dom.scrollTop = i.scrollTop
            }
        }
    },
    setBodyTop: function(e, t) {
        var n = this,
        r = n.view,
        i = n.store,
        s = r.body.dom,
        o;
        e = Math.floor(e);
        if (t !== undefined) {
            o = e - t;
            e = t
        }
        s.style.position = "absolute";
        s.style.top = (n.bodyTop = Math.max(e, 0)) + "px";
        if (n.isRTL && Ext.supports.xOriginBug && r.scrollFlags.y) {
            s.style.right = -Ext.getScrollbarSize().width + "px"
        }
        if (o) {
            n.scrollTop = n.position = r.el.dom.scrollTop -= o
        }
        if (r.all.endIndex === (i.buffered ? i.getTotalCount() : i.getCount()) - 1) {
            n.stretchView(r, n.bodyTop + s.offsetHeight)
        }
    },
    getFirstVisibleRowIndex: function(e, t, n, r) {
        var i = this,
        s = i.view,
        o = s.all,
        u = o.elements,
        a = s.el.dom.clientHeight,
        f, l;
        if (o.getCount() && i.variableRowHeight) {
            if (!arguments.length) {
                e = o.startIndex;
                t = o.endIndex;
                n = i.scrollTop;
                r = n + a;
                if (i.bodyTop > r || i.bodyTop + s.body.getHeight() < n) {
                    return Math.floor(i.scrollTop / i.rowHeight)
                }
                f = e + Math.min(i.numFromEdge + (i.lastScrollDirection == -1 ? i.leadingBufferZone: i.trailingBufferZone), Math.floor((t - e) / 2))
            } else {
                f = e + Math.floor((t - e) / 2)
            }
            l = i.bodyTop + u[f].offsetTop;
            if (l + u[f].offsetHeight < n) {
                return i.getFirstVisibleRowIndex(f + 1, t, n, r)
            }
            if (l <= n) {
                return f
            } else {
                if (f !== e) {
                    return i.getFirstVisibleRowIndex(e, f - 1, n, r)
                }
            }
        }
        return Math.floor(i.scrollTop / i.rowHeight)
    },
    getLastVisibleRowIndex: function(e, t, n, r) {
        var i = this,
        s = i.view,
        o = s.all,
        u = o.elements,
        a = s.el.dom.clientHeight,
        f, l, c;
        if (o.getCount() && i.variableRowHeight) {
            if (!arguments.length) {
                e = o.startIndex;
                t = o.endIndex;
                n = i.scrollTop;
                r = n + a;
                if (i.bodyTop > r || i.bodyTop + s.body.getHeight() < n) {
                    return Math.floor(i.scrollTop / i.rowHeight) + Math.ceil(a / i.rowHeight)
                }
                f = t - Math.min(i.numFromEdge + (i.lastScrollDirection == 1 ? i.leadingBufferZone: i.trailingBufferZone), Math.floor((t - e) / 2))
            } else {
                f = e + Math.floor((t - e) / 2)
            }
            l = i.bodyTop + u[f].offsetTop;
            if (l > r) {
                return i.getLastVisibleRowIndex(e, f - 1, n, r)
            }
            c = l + u[f].offsetHeight;
            if (c >= r) {
                return f
            } else {
                if (f !== t) {
                    return i.getLastVisibleRowIndex(f + 1, t, n, r)
                }
            }
        }
        return i.getFirstVisibleRowIndex() + Math.ceil(a / i.rowHeight)
    },
    getScrollHeight: function() {
        var e = this,
        t = e.view,
        n = e.store,
        r = !e.hasOwnProperty("rowHeight"),
        i = e.store.getCount();
        if (!i) {
            return 0
        }
        if (r) {
            if (t.all.getCount()) {
                e.rowHeight = Math.floor(t.body.getHeight() / t.all.getCount())
            }
        }
        return this.scrollHeight = Math.floor((n.buffered ? n.getTotalCount() : n.getCount()) * e.rowHeight)
    },
    attemptLoad: function(e, t) {
        var n = this;
        if (n.scrollToLoadBuffer) {
            if (!n.loadTask) {
                n.loadTask = new Ext.util.DelayedTask(n.doAttemptLoad, n, [])
            }
            n.loadTask.delay(n.scrollToLoadBuffer, n.doAttemptLoad, n, [e, t])
        } else {
            n.store.getRange(e, t, {
                callback: n.onRangeFetched,
                scope: n,
                fireEvent: false
            })
        }
    },
    cancelLoad: function() {
        if (this.loadTask) {
            this.loadTask.cancel()
        }
    },
    doAttemptLoad: function(e, t) {
        this.store.getRange(e, t, {
            callback: this.onRangeFetched,
            scope: this,
            fireEvent: false
        })
    },
    destroy: function() {
        var e = this,
        t = e.view;
        if (t && t.el) {
            t.el.un("scroll", e.onViewScroll, e)
        }
        Ext.destroy(e.viewListeners, e.storeListeners, e.gridListeners)
    }
});Ext.define("Ext.grid.plugin.Editing", {
    alias: "editing.editing",
    extend: Ext.AbstractPlugin,
    mixins: {
        observable: Ext.util.Observable
    },
    clicksToEdit: 2,
    triggerEvent: undefined,
    relayedEvents: ["beforeedit", "edit", "validateedit", "canceledit"],
    defaultFieldXType: "textfield",
    editStyle: "",
    constructor: function(e) {
        var t = this;
        t.addEvents("beforeedit", "edit", "validateedit", "canceledit");
        t.callParent(arguments);
        t.mixins.observable.constructor.call(t);
        t.on("edit",
        function(e, n) {
            t.fireEvent("afteredit", e, n)
        })
    },
    init: function(e) {
        var t = this;
        t.grid = e;
        t.view = e.view;
        t.initEvents();
        t.mon(e, {
            beforereconfigure: t.onBeforeReconfigure,
            reconfigure: t.onReconfigure,
            scope: t,
            beforerender: {
                fn: t.onReconfigure,
                single: true,
                scope: t
            }
        });
        e.relayEvents(t, t.relayedEvents);
        if (t.grid.ownerLockable) {
            t.grid.ownerLockable.relayEvents(t, t.relayedEvents)
        }
        e.isEditable = true;
        e.editingPlugin = e.view.editingPlugin = t
    },
    onBeforeReconfigure: function() {
        this.reconfiguring = true
    },
    onReconfigure: function() {
        this.initFieldAccessors(this.grid.getTopLevelColumnManager().getColumns());
        delete this.reconfiguring
    },
    destroy: function() {
        var e = this,
        t = e.grid;
        Ext.destroy(e.keyNav);
        e.clearListeners();
        if (t) {
            t.editingPlugin = t.view.editingPlugin = e.grid = e.view = e.editor = e.keyNav = null
        }
    },
    getEditStyle: function() {
        return this.editStyle
    },
    initFieldAccessors: function(e) {
        if (e.isGroupHeader) {
            e = e.getGridColumns()
        } else {
            if (!Ext.isArray(e)) {
                e = [e]
            }
        }
        var t = this,
        n, r = e.length,
        i;
        for (n = 0; n < r; n++) {
            i = e[n];
            if (!i.getEditor) {
                i.getEditor = function(e, n) {
                    return t.getColumnField(this, n)
                }
            }
            if (!i.hasEditor) {
                i.hasEditor = function() {
                    return t.hasColumnField(this)
                }
            }
            if (!i.setEditor) {
                i.setEditor = function(e) {
                    t.setColumnField(this, e)
                }
            }
        }
    },
    removeFieldAccessors: function(e) {
        if (e.isGroupHeader) {
            e = e.getGridColumns()
        } else {
            if (!Ext.isArray(e)) {
                e = [e]
            }
        }
        var t, n = e.length,
        r;
        for (t = 0; t < n; t++) {
            r = e[t];
            r.getEditor = r.hasEditor = r.setEditor = r.field = r.editor = null
        }
    },
    getColumnField: function(e, t) {
        var n = e.field;
        if (! (n && n.isFormField)) {
            n = e.field = this.createColumnField(e, t)
        }
        return n
    },
    hasColumnField: function(e) {
        return !! (e.field && e.field.isComponent)
    },
    setColumnField: function(e, t) {
        e.field = t;
        e.field = this.createColumnField(e)
    },
    createColumnField: function(e, t) {
        var n = e.field,
        r;
        if (!n && e.editor) {
            n = e.editor;
            e.editor = null
        }
        if (!n && t) {
            n = t
        }
        if (n) {
            r = e.dataIndex;
            if (n.isComponent) {
                n.column = e
            } else {
                if (Ext.isString(n)) {
                    n = {
                        name: r,
                        xtype: n,
                        column: e
                    }
                } else {
                    n = Ext.apply({
                        name: r,
                        column: e
                    },
                    n)
                }
                n = Ext.ComponentManager.create(n, this.defaultFieldXType)
            }
            n.dataIndex = r;
            n.isEditorComponent = true;
            e.field = n
        }
        return n
    },
    initEvents: function() {
        var e = this;
        e.initEditTriggers();
        e.initCancelTriggers()
    },
    initCancelTriggers: Ext.emptyFn,
    initEditTriggers: function() {
        var e = this,
        t = e.view;
        if (e.triggerEvent == "cellfocus") {
            e.mon(t, "cellfocus", e.onCellFocus, e)
        } else {
            if (e.triggerEvent == "rowfocus") {
                e.mon(t, "rowfocus", e.onRowFocus, e)
            } else {
                if (t.getSelectionModel().isCellModel) {
                    t.onCellFocus = Ext.Function.bind(e.beforeViewCellFocus, e)
                }
                e.mon(t, e.triggerEvent || "cell" + (e.clicksToEdit === 1 ? "click": "dblclick"), e.onCellClick, e)
            }
        }
        e.initAddRemoveHeaderEvents();
        t.on("render", e.initKeyNavHeaderEvents, e, {
            single: true
        })
    },
    beforeViewCellFocus: function(e) {
        if (this.view.selModel.keyNavigation || !this.editing || !this.isCellEditable || !this.isCellEditable(e.row, e.columnHeader)) {
            this.view.focusCell.apply(this.view, arguments)
        }
    },
    onRowFocus: function(e, t, n) {
        this.startEdit(t, 0)
    },
    onCellFocus: function(e, t, n) {
        this.startEdit(n.row, n.column)
    },
    onCellClick: function(e, t, n, r, i, s, o) {
        var u = e.expanderSelector,
        a = e.ownerCt.getColumnManager().getHeaderAtIndex(n),
        f = a.getEditor(r);
        if (this.shouldStartEdit(f) && (!u || !o.getTarget(u))) {
            this.startEdit(r, a)
        }
    },
    initAddRemoveHeaderEvents: function() {
        var e = this,
        t = e.grid.headerCt;
        e.mon(t, {
            scope: e,
            add: e.onColumnAdd,
            columnmove: e.onColumnMove,
            beforedestroy: e.beforeGridHeaderDestroy
        })
    },
    initKeyNavHeaderEvents: function() {
        var e = this;
        e.keyNav = Ext.create("Ext.util.KeyNav", e.view.el, {
            defaultEventAction: false,
            enter: e.onEnterKey,
            esc: e.onEscKey,
            scope: e
        })
    },
    onColumnAdd: function(e, t) {
        this.initFieldAccessors(t)
    },
    onColumnMove: Ext.emptyFn,
    onEnterKey: function(e) {
        var t = this,
        n = t.grid,
        r = n.getSelectionModel(),
        i,
        s,
        o;
        if (r.getCurrentPosition && (s = r.getCurrentPosition())) {
            i = s.record;
            o = s.columnHeader
        } else {
            i = r.getLastSelected();
            o = n.getColumnManager().getHeaderAtIndex(0)
        }
        if (i && o) {
            t.startEdit(i, o)
        }
        if (!this.activeEditor || this.activeEditor.field.xtype != "textarea") {
            e.stopEvent()
        }
    },
    onEscKey: function(e) {
        e.stopEvent();
        return this.cancelEdit()
    },
    beforeEdit: Ext.emptyFn,
    shouldStartEdit: function(e) {
        return !! e
    },
    startEdit: function(e, t) {
        var n = this,
        r, i = n.grid.lockable ? n.grid: n.view;
        if (!i.componentLayoutCounter) {
            i.on({
                boxready: Ext.Function.bind(n.startEdit, n, [e, t]),
                single: true
            });
            return false
        }
        if (n.grid.collapsed || !n.grid.view.isVisible(true)) {
            return false
        }
        r = n.getEditingContext(e, t);
        if (r == null) {
            return false
        }
        if (!n.preventBeforeCheck) {
            if (n.beforeEdit(r) === false || n.fireEvent("beforeedit", n, r) === false || r.cancel) {
                return false
            }
        }
        return r
    },
    getEditingContext: function(e, t) {
        var n = this,
        r = n.grid,
        i = r.columnManager,
        s, o, u, a;
        if (Ext.isNumber(t)) {
            t = i.getHeaderAtIndex(t)
        }
        if (!t) {
            return
        }
        if (t.hidden) {
            t = t.next(":not([hidden])") || t.prev(":not([hidden])")
        }
        s = t.getOwnerHeaderCt().view;
        o = s.getNode(e, true);
        if (!o) {
            return
        }
        a = i.getHeaderIndex(t);
        if (Ext.isNumber(e)) {
            u = e;
            e = s.getRecord(o)
        } else {
            u = s.indexOf(o)
        }
        if (!e) {
            return
        }
        return {
            grid: r,
            view: s,
            store: s.dataSource,
            record: e,
            field: t.dataIndex,
            value: e.get(t.dataIndex),
            row: o,
            column: t,
            rowIdx: u,
            colIdx: a
        }
    },
    cancelEdit: function() {
        var e = this;
        e.editing = false;
        e.fireEvent("canceledit", e, e.context)
    },
    completeEdit: function() {
        var e = this;
        if (e.editing && e.validateEdit()) {
            e.fireEvent("edit", e, e.context)
        }
        e.context = null;
        e.editing = false
    },
    validateEdit: function() {
        var e = this,
        t = e.context;
        return e.fireEvent("validateedit", e, t) !== false && !t.cancel
    }
});Ext.define("Ext.grid.plugin.CellEditing", {
    alias: "plugin.cellediting",
    extend: Ext.grid.plugin.Editing,
    lockableScope: "both",
    init: function(e) {
        var t = this,
        n = t.lockingPartner;
        t.callParent(arguments);
        if (n) {
            if (n.editors) {
                t.editors = n.editors
            } else {
                t.editors = n.editors = new Ext.util.MixedCollection(false,
                function(e) {
                    return e.editorId
                })
            }
        } else {
            t.editors = new Ext.util.MixedCollection(false,
            function(e) {
                return e.editorId
            })
        }
    },
    beforeGridHeaderDestroy: function(e) {
        var t = this,
        n = t.grid.getColumnManager().getColumns(),
        r = n.length,
        i,
        s,
        o;
        for (i = 0; i < r; i++) {
            s = n[i];
            o = t.editors.getByKey(s.getItemId());
            if (!o && s.hasEditor && s.hasEditor()) {
                o = s.getEditor()
            }
            Ext.destroy(o);
            t.removeFieldAccessors(s)
        }
    },
    onReconfigure: function(e, t, n) {
        if (n) {
            this.editors.clear()
        }
        this.callParent()
    },
    destroy: function() {
        var e = this;
        if (e.editors) {
            e.editors.each(Ext.destroy, Ext);
            e.editors.clear()
        }
        e.callParent(arguments)
    },
    initCancelTriggers: function() {
        var e = this,
        t = e.grid,
        n = t.view;
        e.mon(t, {
            columnresize: e.cancelEdit,
            columnmove: e.cancelEdit,
            scope: e
        })
    },
    isCellEditable: function(e, t) {
        var n = this,
        r = n.getEditingContext(e, t);
        if (n.grid.view.isVisible(true) && r) {
            t = r.column;
            e = r.record;
            if (t && n.getEditor(e, t)) {
                return true
            }
        }
    },
    startEdit: function(e, t, n) {
        var r = this,
        i, s, o;
        if (!n) {
            r.preventBeforeCheck = true;
            n = r.callParent(arguments);
            delete r.preventBeforeCheck;
            if (n === false) {
                return false
            }
        }
        if (n && r.grid.view.isVisible(true)) {
            e = n.record;
            t = n.column;
            n.originalValue = n.value = e.get(t.dataIndex);
            s = t && t.getEditor(e) && !(r.beforeEdit(n) === false || r.fireEvent("beforeedit", r, n) === false || n.cancel);
            if (s) {
                o = r.getEditor(e, t);
                i = o.editing
            } else {
                return false
            }
            r.completeEdit();
            r.context = n;
            r.grid.view.cancelFocus();
            r.view.scrollCellIntoView(r.getCell(e, t));
            if (o) {
                if (Ext.isIE && i) {
                    o.selectSameEditor = true
                }
                r.showEditor(o, n, n.value);
                return true
            }
            return false
        }
    },
    showEditor: function(e, t, n) {
        var r = this,
        i = t.record,
        s = t.column,
        o = r.grid.getSelectionModel(),
        u = o.preventFocus,
        a = o.getCurrentPosition();
        if (!s.up(r.view.ownerCt)) {
            return r.lockingPartner.showEditor(e, r.lockingPartner.getEditingContext(a.record, a.columnHeader), n)
        }
        r.setEditingContext(t);
        r.setActiveEditor(e);
        r.setActiveRecord(i);
        r.setActiveColumn(s);
        if (!a || !o.isCellSelected(r.view, i, s)) {
            o.preventFocus = true;
            o.selectByPosition({
                row: i,
                column: s,
                view: r.view
            },
            true);
            o.preventFocus = u
        }
        if (Ext.isIE && Ext.EventObject.type === "click") {
            Ext.Function.defer(e.startEdit, 1, e, [r.getCell(i, s), n, t])
        } else {
            e.startEdit(r.getCell(i, s), n, t)
        }
        r.editing = true;
        r.scroll = r.view.el.getScroll()
    },
    completeEdit: function(e) {
        var t = this.getActiveEditor();
        if (t) {
            t.completeEdit(e);
            this.editing = false
        }
    },
    setEditingContext: function(e) {
        this.context = e;
        if (this.lockingPartner) {
            this.lockingPartner.context = e
        }
    },
    setActiveEditor: function(e) {
        this.activeEditor = e;
        if (this.lockingPartner) {
            this.lockingPartner.activeEditor = e
        }
    },
    getActiveEditor: function() {
        return this.activeEditor
    },
    setActiveColumn: function(e) {
        this.activeColumn = e;
        if (this.lockingPartner) {
            this.lockingPartner.activeColumn = e
        }
    },
    getActiveColumn: function() {
        return this.activeColumn
    },
    setActiveRecord: function(e) {
        this.activeRecord = e;
        if (this.lockingPartner) {
            this.lockingPartner.activeRecord = e
        }
    },
    getActiveRecord: function() {
        return this.activeRecord
    },
    getEditor: function(e, t) {
        var n = this,
        r = n.editors,
        i = t.getItemId(),
        s = r.getByKey(i),
        o = n.grid.ownerLockable || n.grid;
        if (n.grid instanceof Ext.grid.property.Grid) {
            s = null;
            i = e.get("name")
        }
        if (!s) {
            s = t.getEditor(e);
            if (!s) {
                return false
            }
            if (s instanceof Ext.grid.CellEditor) {
                s.floating = true
            } else {
                s = new Ext.grid.CellEditor({
                    floating: true,
                    editorId: i,
                    field: s
                })
            }
            s.field.excludeForm = true;
            s.noReposition = true;
            o.add(s);
            s.on({
                scope: n,
                specialkey: n.onSpecialKey,
                complete: n.onEditComplete,
                canceledit: n.cancelEdit
            });
            t.on("removed", n.cancelActiveEdit, n);
            r.add(s)
        }
        if (t.isTreeColumn) {
            s.isForTree = t.isTreeColumn;
            s.addCls(Ext.baseCSSPrefix + "tree-cell-editor")
        }
        s.setGrid(n.grid);
        s.editingPlugin = n;
        return s
    },
    cancelActiveEdit: function(e) {
        var t = this.context;
        if (t && t.column === e) {
            this.cancelEdit()
        }
    },
    setColumnField: function(e, t) {
        var n = this.editors.getByKey(e.getItemId());
        Ext.destroy(n, e.field);
        this.editors.removeAtKey(e.getItemId());
        this.callParent(arguments)
    },
    getCell: function(e, t) {
        return this.grid.getView().getCell(e, t)
    },
    onSpecialKey: function(e, t, n) {
        var r;
        if (n.getKey() === n.TAB) {
            n.stopEvent();
            if (e) {
                e.onEditorTab(n)
            }
            r = e.up("tablepanel").getSelectionModel();
            if (r.onEditorTab) {
                return r.onEditorTab(e.editingPlugin, n)
            }
        }
    },
    onEditComplete: function(e, t, n) {
        var r = this,
        i = r.getActiveColumn(),
        s = r.context,
        o;
        if (i) {
            o = s.record;
            r.setActiveEditor(null);
            r.setActiveColumn(null);
            r.setActiveRecord(null);
            s.value = t;
            if (!r.validateEdit()) {
                r.editing = false;
                return
            }
            if (!o.isEqual(t, n)) {
                o.set(i.dataIndex, t)
            }
            s.view.focusRow(s.rowIdx, 100);
            r.fireEvent("edit", r, s);
            r.editing = false
        }
    },
    cancelEdit: function() {
        var e = this,
        t = e.context,
        n = e.getActiveEditor();
        e.setActiveEditor(null);
        e.setActiveColumn(null);
        e.setActiveRecord(null);
        if (n) {
            if (n.field) {
                e.context.value = "editedValue" in n ? n.editedValue: n.getValue();
                n.cancelEdit()
            }
            t.view.focusRow(t.rowIdx, 100);
            e.callParent(arguments);
            return
        }
        return true
    },
    startEditByPosition: function(e) {
        var t = this.grid.getColumnManager(),
        n,
        r;
        if (!e.isCellContext) {
            e = (new Ext.grid.CellContext(this.view)).setPosition(e)
        }
        n = t.getHeaderIndex(e.columnHeader);
        e.setColumn(t.getVisibleHeaderClosestToIndex(n));
        return this.startEdit(e.record, e.columnHeader)
    }
});Ext.define("Ext.grid.plugin.DivRenderer", {
    alias: "plugin.divrenderer",
    extend: Ext.AbstractPlugin,
    tableTpl: ['<div id="{view.id}-table" class="', Ext.baseCSSPrefix, "{view.id}-table ", Ext.baseCSSPrefix, 'grid-table" style="{tableStyle}" {ariaTableAttr}>', "{%", "values.view.renderRows(values.rows, values.viewStartIndex, out);", "%}", "</div>", {
        priority: 0
    }],
    rowTpl: ["{%", 'var dataRowCls = values.recordIndex === -1 ? "" : " ' + Ext.baseCSSPrefix + 'grid-data-row";', "%}", '<dl {[values.rowId ? ("id=\\"" + values.rowId + "\\"") : ""]} ', 'data-boundView="{view.id}" ', 'data-recordId="{record.internalId}" ', 'data-recordIndex="{recordIndex}" ', 'class="{[values.itemClasses.join(" ")]} {[values.rowClasses.join(" ")]}{[dataRowCls]}" ', 'style="position:relative" ', "{rowAttr:attributes} {ariaRowAttr}>", '<tpl for="columns">{%', "parent.view.renderCell(values, parent.record, parent.recordIndex, xindex - 1, out, parent)", "%}", "</tpl>", "</dl>", {
        priority: 0
    }],
    cellTpl: ['<dt class="{tdCls}" {tdAttr} data-cellIndex="{cellIndex}" {ariaCellAttr}>', '<div {unselectableAttr} class="' + Ext.baseCSSPrefix + 'grid-cell-inner"', 'style="text-align:{align};<tpl if="style">{style}</tpl>" {ariaCellInnerAttr}>{value}</div>', "</dt>", {
        priority: 0
    }],
    selectors: {
        bodySelector: "div",
        nodeContainerSelector: "div",
        itemSelector: "dl." + Ext.baseCSSPrefix + "grid-row",
        dataRowSelector: "dl." + Ext.baseCSSPrefix + "grid-data-row",
        cellSelector: "dt." + Ext.baseCSSPrefix + "grid-cell",
        innerSelector: "div." + Ext.baseCSSPrefix + "grid-cell-inner",
        getNodeContainerSelector: function() {
            return this.getBodySelector()
        },
        getNodeContainer: function() {
            return this.el.getById(this.id + "-table", true)
        }
    },
    init: function(e) {
        var t = e.getView();
        t.tableTpl = Ext.XTemplate.getTpl(this, "tableTpl");
        t.rowTpl = Ext.XTemplate.getTpl(this, "rowTpl");
        t.cellTpl = Ext.XTemplate.getTpl(this, "cellTpl");
        Ext.apply(t, this.selectors)
    }
});Ext.define("Ext.grid.plugin.DragDrop", {
    extend: Ext.AbstractPlugin,
    alias: "plugin.gridviewdragdrop",
    dragText: "{0} selected row{1}",
    ddGroup: "GridDD",
    enableDrop: true,
    enableDrag: true,
    containerScroll: false,
    init: function(e) {
        e.on("render", this.onViewRender, this, {
            single: true
        })
    },
    destroy: function() {
        Ext.destroy(this.dragZone, this.dropZone)
    },
    enable: function() {
        var e = this;
        if (e.dragZone) {
            e.dragZone.unlock()
        }
        if (e.dropZone) {
            e.dropZone.unlock()
        }
        e.callParent()
    },
    disable: function() {
        var e = this;
        if (e.dragZone) {
            e.dragZone.lock()
        }
        if (e.dropZone) {
            e.dropZone.lock()
        }
        e.callParent()
    },
    onViewRender: function(e) {
        var t = this,
        n;
        if (t.enableDrag) {
            if (t.containerScroll) {
                n = e.getEl()
            }
            t.dragZone = new Ext.view.DragZone(Ext.apply({
                view: e,
                ddGroup: t.dragGroup || t.ddGroup,
                dragText: t.dragText,
                containerScroll: t.containerScroll,
                scrollEl: n
            },
            t.dragZone))
        }
        if (t.enableDrop) {
            t.dropZone = new Ext.grid.ViewDropZone(Ext.apply({
                view: e,
                ddGroup: t.dropGroup || t.ddGroup
            },
            t.dropZone))
        }
    }
});Ext.define("Ext.grid.plugin.RowEditing", {
    extend: Ext.grid.plugin.Editing,
    alias: "plugin.rowediting",
    lockableScope: "top",
    editStyle: "row",
    autoCancel: true,
    errorSummary: true,
    constructor: function() {
        var e = this;
        e.callParent(arguments);
        if (!e.clicksToMoveEditor) {
            e.clicksToMoveEditor = e.clicksToEdit
        }
        e.autoCancel = !!e.autoCancel
    },
    destroy: function() {
        Ext.destroy(this.editor);
        this.callParent(arguments)
    },
    onBeforeReconfigure: function() {
        this.callParent(arguments);
        this.cancelEdit()
    },
    onReconfigure: function(e, t, n) {
        var r = this.editor;
        this.callParent(arguments);
        if (n && r && r.rendered) {
            r.needsSyncFieldWidths = true
        }
    },
    shouldStartEdit: function(e) {
        return true
    },
    startEdit: function(e, t) {
        var n = this,
        r = n.getEditor(),
        i;
        if (Ext.isEmpty(t)) {
            t = n.grid.getTopLevelVisibleColumnManager().getHeaderAtIndex(0)
        }
        if (r.beforeEdit() !== false) {
            i = n.callParent([e, t]);
            if (i) {
                n.context = i;
                if (n.lockingPartner) {
                    n.lockingPartner.cancelEdit()
                }
                r.startEdit(i.record, i.column, i);
                n.editing = true;
                return true
            }
        }
        return false
    },
    cancelEdit: function() {
        var e = this;
        if (e.editing) {
            e.getContextFieldValues();
            e.getEditor().cancelEdit();
            e.callParent(arguments);
            return
        }
        return true
    },
    onEnter: function(e) {
        if (this.editor.down("#cancel").owns(e)) {
            return this.cancelEdit()
        } else {
            this.completeEdit()
        }
    },
    completeEdit: function() {
        var e = this;
        if (e.editing && e.validateEdit()) {
            e.editing = false;
            e.fireEvent("edit", e, e.context)
        }
    },
    validateEdit: function() {
        this.getContextFieldValues();
        return this.callParent(arguments) && this.getEditor().completeEdit()
    },
    getEditor: function() {
        var e = this;
        if (!e.editor) {
            e.editor = e.initEditor()
        }
        return e.editor
    },
    getContextFieldValues: function() {
        var e = this.editor,
        t = this.context,
        n = t.record,
        r = {},
        i = {},
        s = e.query(">[isFormField]"),
        o = s.length,
        u,
        a,
        f;
        for (u = 0; u < o; u++) {
            f = s[u];
            a = f.dataIndex;
            r[a] = f.getValue();
            i[a] = n.get(a)
        }
        Ext.apply(t, {
            newValues: r,
            originalValues: i
        })
    },
    initEditor: function() {
        return new Ext.grid.RowEditor(this.initEditorConfig())
    },
    initEditorConfig: function() {
        var e = this,
        t = e.grid,
        n = e.view,
        r = t.headerCt,
        i = ["saveBtnText", "cancelBtnText", "errorsText", "dirtyText"],
        s,
        o = i.length,
        u = {
            autoCancel: e.autoCancel,
            errorSummary: e.errorSummary,
            fields: r.getGridColumns(),
            hidden: true,
            view: n,
            editingPlugin: e
        },
        a;
        for (s = 0; s < o; s++) {
            a = i[s];
            if (Ext.isDefined(e[a])) {
                u[a] = e[a]
            }
        }
        return u
    },
    initEditTriggers: function() {
        var e = this,
        t = e.view,
        n = e.clicksToMoveEditor === 1 ? "click": "dblclick";
        e.callParent(arguments);
        if (e.clicksToMoveEditor !== e.clicksToEdit) {
            e.mon(t, "cell" + n, e.moveEditorByClick, e)
        }
        t.on({
            render: function() {
                e.mon(e.grid.headerCt, {
                    scope: e,
                    columnresize: e.onColumnResize,
                    columnhide: e.onColumnHide,
                    columnshow: e.onColumnShow
                })
            },
            single: true
        })
    },
    startEditByClick: function() {
        var e = this;
        if (!e.editing || e.clicksToMoveEditor === e.clicksToEdit) {
            e.callParent(arguments)
        }
    },
    moveEditorByClick: function() {
        var e = this;
        if (e.editing) {
            e.superclass.onCellClick.apply(e, arguments)
        }
    },
    onColumnAdd: function(e, t) {
        if (t.isHeader) {
            var n = this,
            r;
            n.initFieldAccessors(t);
            r = n.editor;
            if (r) {
                r.onColumnAdd(t)
            }
        }
    },
    beforeGridHeaderDestroy: function(e) {
        var t = this.grid.getColumnManager().getColumns(),
        n = t.length,
        r,
        i,
        s;
        for (r = 0; r < n; r++) {
            i = t[r];
            if (i.hasEditor) {
                if (i.hasEditor() && (s = i.getEditor())) {
                    s.destroy()
                }
                this.removeFieldAccessors(i)
            }
        }
    },
    onColumnResize: function(e, t, n) {
        if (t.isHeader) {
            var r = this,
            i = r.getEditor();
            if (i) {
                i.onColumnResize(t, n)
            }
        }
    },
    onColumnHide: function(e, t) {
        var n = this,
        r = n.getEditor();
        if (r) {
            r.onColumnHide(t)
        }
    },
    onColumnShow: function(e, t) {
        var n = this,
        r = n.getEditor();
        if (r) {
            r.onColumnShow(t)
        }
    },
    onColumnMove: function(e, t, n, r) {
        var i = this,
        s = i.getEditor();
        i.initFieldAccessors(t);
        if (s) {
            s.onColumnMove(t, n, r)
        }
    },
    setColumnField: function(e, t) {
        var n = this,
        r = n.getEditor();
        if (r) {
            r.destroyColumnEditor(e)
        }
        n.callParent(arguments);
        if (r) {
            r.insertColumnEditor(e)
        }
    },
    createColumnField: function(e, t) {
        var n = this.editor,
        r;
        if (n) {
            r = n.getDefaultFieldCfg()
        }
        return this.callParent([e, t || r])
    }
});Ext.define("Ext.grid.plugin.RowExpander", {
    extend: Ext.AbstractPlugin,
    lockableScope: "normal",
    alias: "plugin.rowexpander",
    columnWidth: 24,
    rowBodyTpl: null,
    lockedTpl: null,
    expandOnEnter: true,
    expandOnDblClick: true,
    selectRowOnExpand: false,
    rowBodyTrSelector: "." + Ext.baseCSSPrefix + "grid-rowbody-tr",
    rowBodyHiddenCls: Ext.baseCSSPrefix + "grid-row-body-hidden",
    rowCollapsedCls: Ext.baseCSSPrefix + "grid-row-collapsed",
    addCollapsedCls: {
        before: function(e, t) {
            var n = this.rowExpander;
            if (!n.recordsExpanded[e.record.internalId]) {
                e.itemClasses.push(n.rowCollapsedCls)
            }
        },
        priority: 500
    },
    setCmp: function(e) {
        var t = this,
        n = [],
        r,
        i;
        t.callParent(arguments);
        t.recordsExpanded = {};
        i = t.rowBodyTpl = Ext.XTemplate.getTpl(t, "rowBodyTpl");
        r = {
            ftype: "rowbody",
            recordsExpanded: t.recordsExpanded,
            rowBodyHiddenCls: t.rowBodyHiddenCls,
            rowCollapsedCls: t.rowCollapsedCls,
            setupRowData: t.getRowBodyFeatureData,
            setup: t.setup
        };
        n.push(Ext.apply({
            lockableScope: "normal",
            getRowBodyContents: function(e) {
                return i.applyTemplate(e.getData())
            }
        },
        r));
        if (t.lockedTpl) {
            n.push(Ext.apply({
                lockableScope: "locked",
                getRowBodyContents: function(e) {
                    return t.lockedTpl.applyTemplate(e.getData())
                }
            },
            r))
        }
        if (e.features) {
            e.features = Ext.Array.push(n, e.features)
        } else {
            e.features = n
        }
    },
    init: function(e) {
        var t = this,
        n = e,
        r, i, s;
        if (e.lockable) {
            e = e.lockedGrid
        }
        t.callParent(arguments);
        t.grid = e;
        r = t.view = e.getView();
        t.addExpander();
        t.bindView(r);
        r.addRowTpl(t.addCollapsedCls).rowExpander = t;
        if (e.ownerLockable) {
            n = e.ownerLockable;
            n.syncRowHeight = false;
            s = n.lockedGrid.getView();
            t.bindView(s);
            s.addRowTpl(t.addCollapsedCls).rowExpander = t;
            n.mon(n, "columnschanged", t.refreshRowHeights, t);
            n.mon(n.store, "datachanged", t.refreshRowHeights, t)
        }
        n.on("beforereconfigure", t.beforeReconfigure, t)
    },
    beforeReconfigure: function(e, t, n, r, i) {
        var s = this.getHeaderConfig();
        s.locked = true;
        n.unshift(s)
    },
    addExpander: function() {
        var e = this,
        t = e.grid,
        n = e.getHeaderConfig();
        if (t.ownerLockable) {
            t = t.ownerLockable.lockedGrid;
            t.width += n.width;
            t.hidden = false
        }
        t.headerCt.insert(0, n);
        t.getSelectionModel().injectCheckbox = 1
    },
    getRowBodyFeatureData: function(e, t, n) {
        var r = this;
        r.self.prototype.setupRowData.apply(r, arguments);
        n.rowBody = r.getRowBodyContents(e);
        n.rowBodyCls = r.recordsExpanded[e.internalId] ? "": r.rowBodyHiddenCls
    },
    setup: function(e, t) {
        var n = this;
        n.self.prototype.setup.apply(n, arguments);
        if (!n.grid.ownerLockable) {
            t.rowBodyColspan -= 1
        }
    },
    bindView: function(e) {
        if (this.expandOnEnter) {
            e.on("itemkeydown", this.onKeyDown, this)
        }
        if (this.expandOnDblClick) {
            e.on("itemdblclick", this.onDblClick, this)
        }
    },
    onKeyDown: function(e, t, n, r, i) {
        if (i.getKey() == i.ENTER) {
            var s = e.store,
            o = e.getSelectionModel().getSelection(),
            u = o.length,
            a = 0;
            for (; a < u; a++) {
                r = s.indexOf(o[a]);
                this.toggleRow(r, o[a])
            }
        }
    },
    onDblClick: function(e, t, n, r, i) {
        this.toggleRow(r, t)
    },
    toggleRow: function(e, t) {
        var n = this,
        r = n.view,
        i = r.getNode(e),
        s = Ext.fly(i, "_rowExpander"),
        o,
        u = s.down(n.rowBodyTrSelector, true),
        a = s.hasCls(n.rowCollapsedCls),
        f = a ? "removeCls": "addCls",
        l,
        c,
        h = r.getSizeModel().height.shrinkWrap,
        p,
        d;
        Ext.suspendLayouts();
        s[f](n.rowCollapsedCls);
        Ext.fly(u)[f](n.rowBodyHiddenCls);
        n.recordsExpanded[t.internalId] = a;
        if (h) {
            r.refreshSize()
        }
        if (n.grid.ownerLockable) {
            s.setHeight("");
            d = s.getHeight();
            l = n.grid.ownerLockable;
            c = l.getView();
            r = l.lockedGrid.view;
            s.setHeight(a ? d: "");
            o = Ext.fly(r.getNode(e), "_rowExpander");
            o[f](n.rowCollapsedCls);
            if (n.lockedTpl) {
                u = o.down(n.rowBodyTrSelector, true);
                Ext.fly(u)[f](n.rowBodyHiddenCls);
                p = o.getHeight();
                if (a) {
                    if (p > d) {
                        s.setHeight(p)
                    } else {
                        o.setHeight(d)
                    }
                } else {
                    o.setHeight("")
                }
            } else {
                o.setHeight(a ? d: "")
            }
            if (h) {
                r.refreshSize()
            }
        } else {
            c = r
        }
        c.fireEvent(a ? "expandbody": "collapsebody", s.dom, t, u);
        Ext.resumeLayouts(true)
    },
    refreshRowHeights: function() {
        Ext.globalEvents.on({
            idle: this.doRefreshRowHeights,
            scope: this,
            single: true
        })
    },
    doRefreshRowHeights: function() {
        var e = this,
        t = e.recordsExpanded,
        n, r, i = e.grid.ownerLockable.lockedGrid.view,
        s = e.grid.ownerLockable.normalGrid.view,
        o, u, a, f;
        for (n in t) {
            if (t.hasOwnProperty(n)) {
                r = this.view.store.data.get(n);
                u = i.getNode(r, false);
                o = s.getNode(r, false);
                u.style.height = o.style.height = "";
                a = u.offsetHeight;
                f = o.offsetHeight;
                if (f > a) {
                    u.style.height = f + "px"
                } else {
                    if (a > f) {
                        o.style.height = a + "px"
                    }
                }
            }
        }
    },
    getHeaderConfig: function() {
        var e = this;
        return {
            width: e.columnWidth,
            lockable: false,
            sortable: false,
            resizable: false,
            draggable: false,
            hideable: false,
            menuDisabled: true,
            tdCls: Ext.baseCSSPrefix + "grid-cell-special",
            innerCls: Ext.baseCSSPrefix + "grid-cell-inner-row-expander",
            renderer: function(t, n) {
                if (!e.grid.ownerLockable) {
                    n.tdAttr += ' rowspan="2"'
                }
                return '<div class="' + Ext.baseCSSPrefix + 'grid-row-expander" role="presentation"></div>'
            },
            processEvent: function(t, n, r, i, s, o, u) {
                if (o.getTarget("." + Ext.baseCSSPrefix + "grid-row-expander")) {
                    if (t == "click") {
                        e.toggleRow(i, u);
                        return e.selectRowOnExpand
                    }
                }
            }
        }
    }
});Ext.define("Ext.grid.property.Grid", {
    extend: Ext.grid.Panel,
    alias: "widget.propertygrid",
    alternateClassName: "Ext.grid.PropertyGrid",
    valueField: "value",
    nameField: "name",
    inferTypes: true,
    enableColumnMove: false,
    columnLines: true,
    stripeRows: false,
    trackMouseOver: false,
    clicksToEdit: 1,
    enableHdMenu: false,
    gridCls: Ext.baseCSSPrefix + "property-grid",
    initComponent: function() {
        var e = this;
        e.source = e.source || {};
        e.addCls(e.gridCls);
        e.plugins = e.plugins || [];
        e.plugins.push(new Ext.grid.plugin.CellEditing({
            clicksToEdit: e.clicksToEdit,
            startEdit: function(t, n) {
                return this.self.prototype.startEdit.call(this, t, e.valueColumn)
            }
        }));
        e.selModel = {
            selType: "cellmodel",
            onCellSelect: function(t) {
                t.columnHeader = e.valueColumn;
                t.column = e.valueColumn.getVisibleIndex();
                return this.self.prototype.onCellSelect.call(this, t)
            }
        };
        e.sourceConfig = Ext.apply({},
        e.sourceConfig);
        if (!e.store) {
            e.propStore = e.store = new Ext.grid.property.Store(e, e.source)
        }
        e.configure(e.sourceConfig);
        if (e.sortableColumns) {
            e.store.sort("name", "ASC")
        }
        e.columns = new Ext.grid.property.HeaderContainer(e, e.store);
        e.addEvents("beforepropertychange", "propertychange");
        e.callParent();
        e.getView().walkCells = this.walkCells;
        e.editors = {
            date: new Ext.grid.CellEditor({
                field: new Ext.form.field.Date({
                    selectOnFocus: true
                })
            }),
            string: new Ext.grid.CellEditor({
                field: new Ext.form.field.Text({
                    selectOnFocus: true
                })
            }),
            number: new Ext.grid.CellEditor({
                field: new Ext.form.field.Number({
                    selectOnFocus: true
                })
            }),
            "boolean": new Ext.grid.CellEditor({
                field: new Ext.form.field.ComboBox({
                    editable: false,
                    store: [[true, e.headerCt.trueText], [false, e.headerCt.falseText]]
                })
            })
        };
        e.store.on("update", e.onUpdate, e)
    },
    configure: function(e) {
        var t = this,
        n = t.store,
        r = 0,
        i = t.store.getCount(),
        s = t.nameField,
        o = t.valueField,
        u,
        a,
        f,
        l;
        t.configureLegacy(e);
        if (t.inferTypes) {
            for (; r < i; ++r) {
                f = n.getAt(r);
                u = f.get(s);
                if (!t.getConfig(u, "type")) {
                    a = f.get(o);
                    if (Ext.isDate(a)) {
                        l = "date"
                    } else {
                        if (Ext.isNumber(a)) {
                            l = "number"
                        } else {
                            if (Ext.isBoolean(a)) {
                                l = "boolean"
                            } else {
                                l = "string"
                            }
                        }
                    }
                    t.setConfig(u, "type", l)
                }
            }
        }
    },
    getConfig: function(e, t, n) {
        var r = this.sourceConfig[e],
        i;
        if (r) {
            i = r[t]
        }
        return i || n
    },
    setConfig: function(e, t, n) {
        var r = this.sourceConfig,
        i = r[e];
        if (!i) {
            i = r[e] = {
                __copied: true
            }
        } else {
            if (!i.__copied) {
                i = Ext.apply({
                    __copied: true
                },
                i);
                r[e] = i
            }
        }
        i[t] = n;
        return n
    },
    configureLegacy: function(e) {
        var t = this;
        t.copyLegacyObject(e, t.customRenderers, "renderer");
        t.copyLegacyObject(e, t.customEditors, "editor");
        t.copyLegacyObject(e, t.propertyNames, "displayName")
    },
    copyLegacyObject: function(e, t, n) {
        var r;
        for (r in t) {
            if (t.hasOwnProperty(r)) {
                if (!e[r]) {
                    e[r] = {}
                }
                e[r][n] = t[r]
            }
        }
    },
    onUpdate: function(e, t, n) {
        var r = this,
        i, s;
        if (r.rendered && n == Ext.data.Model.EDIT) {
            i = t.get(r.valueField);
            s = t.modified.value;
            if (r.fireEvent("beforepropertychange", r.source, t.getId(), i, s) !== false) {
                if (r.source) {
                    r.source[t.getId()] = i
                }
                t.commit();
                r.fireEvent("propertychange", r.source, t.getId(), i, s)
            } else {
                t.reject()
            }
        }
    },
    walkCells: function(e, t, n, r, i, s) {
        var o = this,
        u = o.ownerCt.valueColumn;
        if (t == "left") {
            t = "up"
        } else {
            if (t == "right") {
                t = "down"
            }
        }
        e = Ext.view.Table.prototype.walkCells.call(o, e, t, n, r, i, s);
        e.columnHeader = u;
        e.column = u.getVisibleIndex();
        return e
    },
    getCellEditor: function(e, t) {
        var n = this,
        r = e.get(n.nameField),
        i = e.get(n.valueField),
        s = n.getConfig(r, "editor"),
        o = n.getConfig(r, "type"),
        u = n.editors;
        if (s) {
            if (! (s instanceof Ext.grid.CellEditor)) {
                if (! (s instanceof Ext.form.field.Base)) {
                    s = Ext.ComponentManager.create(s, "textfield")
                }
                s = n.setConfig(r, "editor", new Ext.grid.CellEditor({
                    field: s
                }))
            }
        } else {
            if (o) {
                switch (o) {
                case "date":
                    s = u.date;
                    break;
                case "number":
                    s = u.number;
                    break;
                case "boolean":
                    s = n.editors["boolean"];
                    break;
                default:
                    s = u.string
                }
            } else {
                if (Ext.isDate(i)) {
                    s = u.date
                } else {
                    if (Ext.isNumber(i)) {
                        s = u.number
                    } else {
                        if (Ext.isBoolean(i)) {
                            s = u["boolean"]
                        } else {
                            s = u.string
                        }
                    }
                }
            }
        }
        s.editorId = r;
        return s
    },
    beforeDestroy: function() {
        var e = this;
        e.callParent();
        e.destroyEditors(e.editors);
        e.destroyEditors(e.customEditors);
        delete e.source
    },
    destroyEditors: function(e) {
        for (var t in e) {
            if (e.hasOwnProperty(t)) {
                Ext.destroy(e[t])
            }
        }
    },
    setSource: function(e, t) {
        var n = this;
        n.source = e;
        if (t !== undefined) {
            n.sourceConfig = Ext.apply({},
            t);
            n.configure(n.sourceConfig)
        }
        n.propStore.setSource(e)
    },
    getSource: function() {
        return this.propStore.getSource()
    },
    setProperty: function(e, t, n) {
        this.propStore.setValue(e, t, n)
    },
    removeProperty: function(e) {
        this.propStore.remove(e)
    }
});Ext.define("Ext.grid.property.HeaderContainer", {
    extend: Ext.grid.header.Container,
    alternateClassName: "Ext.grid.PropertyColumnModel",
    nameWidth: 115,
    nameText: "Name",
    valueText: "Value",
    dateFormat: "m/j/Y",
    trueText: "true",
    falseText: "false",
    nameColumnCls: Ext.baseCSSPrefix + "grid-property-name",
    nameColumnInnerCls: Ext.baseCSSPrefix + "grid-cell-inner-property-name",
    constructor: function(e, t) {
        var n = this;
        n.grid = e;
        n.store = t;
        n.callParent([{
            isRootHeader: true,
            enableColumnResize: Ext.isDefined(e.enableColumnResize) ? e.enableColumnResize: n.enableColumnResize,
            enableColumnMove: Ext.isDefined(e.enableColumnMove) ? e.enableColumnMove: n.enableColumnMove,
            items: [{
                header: n.nameText,
                width: e.nameColumnWidth || n.nameWidth,
                sortable: e.sortableColumns,
                dataIndex: e.nameField,
                renderer: Ext.Function.bind(n.renderProp, n),
                itemId: e.nameField,
                menuDisabled: true,
                tdCls: n.nameColumnCls,
                innerCls: n.nameColumnInnerCls
            },
            {
                header: n.valueText,
                renderer: Ext.Function.bind(n.renderCell, n),
                getEditor: Ext.Function.bind(n.getCellEditor, n),
                sortable: e.sortableColumns,
                flex: 1,
                fixed: true,
                dataIndex: e.valueField,
                itemId: e.valueField,
                menuDisabled: true
            }]
        }]);
        n.grid.valueColumn = n.items.items[1]
    },
    getCellEditor: function(e) {
        return this.grid.getCellEditor(e, this)
    },
    renderProp: function(e) {
        return this.getPropertyName(e)
    },
    renderCell: function(e, t, n) {
        var r = this,
        i = r.grid,
        s = i.getConfig(n.get(i.nameField), "renderer"),
        o = e;
        if (s) {
            return s.apply(r, arguments)
        }
        if (Ext.isDate(e)) {
            o = r.renderDate(e)
        } else {
            if (Ext.isBoolean(e)) {
                o = r.renderBool(e)
            }
        }
        return Ext.util.Format.htmlEncode(o)
    },
    renderDate: Ext.util.Format.date,
    renderBool: function(e) {
        return this[e ? "trueText": "falseText"]
    },
    getPropertyName: function(e) {
        return this.grid.getConfig(e, "displayName", e)
    }
});Ext.define("Ext.grid.property.Property", {
    extend: Ext.data.Model,
    alternateClassName: "Ext.PropGridProperty",
    fields: [{
        name: "name",
        type: "string"
    },
    {
        name: "value"
    }],
    idProperty: "name"
});Ext.define("Ext.grid.property.Store", {
    extend: Ext.data.Store,
    alternateClassName: "Ext.grid.PropertyStore",
    sortOnLoad: false,
    constructor: function(e, t) {
        var n = this;
        n.grid = e;
        n.source = t;
        n.callParent([{
            data: t,
            model: Ext.grid.property.Property,
            proxy: n.getProxy()
        }])
    },
    getProxy: function() {
        if (!this.proxy) {
            Ext.grid.property.Store.prototype.proxy = new Ext.data.proxy.Memory({
                model: Ext.grid.property.Property,
                reader: this.getReader()
            })
        }
        return this.proxy
    },
    getReader: function() {
        if (!this.reader) {
            Ext.grid.property.Store.prototype.reader = new Ext.data.reader.Reader({
                model: Ext.grid.property.Property,
                buildExtractors: Ext.emptyFn,
                read: function(e) {
                    return this.readRecords(e)
                },
                readRecords: function(e) {
                    var t, n, r = {
                        records: [],
                        success: true
                    };
                    for (n in e) {
                        if (e.hasOwnProperty(n)) {
                            t = e[n];
                            if (this.isEditableValue(t)) {
                                r.records.push(new Ext.grid.property.Property({
                                    name: n,
                                    value: t
                                },
                                n))
                            }
                        }
                    }
                    r.total = r.count = r.records.length;
                    return new Ext.data.ResultSet(r)
                },
                isEditableValue: function(e) {
                    return Ext.isPrimitive(e) || Ext.isDate(e) || e === null
                }
            })
        }
        return this.reader
    },
    setSource: function(e) {
        var t = this;
        t.source = e;
        t.suspendEvents();
        t.removeAll();
        t.proxy.data = e;
        t.load();
        t.resumeEvents();
        t.fireEvent("datachanged", t);
        t.fireEvent("refresh", t)
    },
    getProperty: function(e) {
        return Ext.isNumber(e) ? this.getAt(e) : this.getById(e)
    },
    setValue: function(e, t, n) {
        var r = this,
        i = r.getRec(e);
        if (i) {
            i.set("value", t);
            r.source[e] = t
        } else {
            if (n) {
                r.source[e] = t;
                i = new Ext.grid.property.Property({
                    name: e,
                    value: t
                },
                e);
                r.add(i)
            }
        }
    },
    remove: function(e) {
        var t = this.getRec(e);
        if (t) {
            this.callParent([t]);
            delete this.source[e]
        }
    },
    getRec: function(e) {
        return this.getById(e)
    },
    getSource: function() {
        return this.source
    }
});Ext.define("Ext.layout.ClassList",
function() {
    var e = Ext.String.splitWords,
    t = Ext.Array.toMap;
    return {
        dirty: false,
        constructor: function(n) {
            this.owner = n;
            this.map = t(this.classes = e(n.el.className))
        },
        add: function(e) {
            var t = this;
            if (!t.map[e]) {
                t.map[e] = true;
                t.classes.push(e);
                if (!t.dirty) {
                    t.dirty = true;
                    t.owner.markDirty()
                }
            }
        },
        addMany: function(t) {
            Ext.each(e(t), this.add, this)
        },
        contains: function(e) {
            return this.map[e]
        },
        flush: function() {
            this.owner.el.className = this.classes.join(" ");
            this.dirty = false
        },
        remove: function(e) {
            var t = this;
            if (t.map[e]) {
                delete t.map[e];
                t.classes = Ext.Array.filter(t.classes,
                function(t) {
                    return t != e
                });
                if (!t.dirty) {
                    t.dirty = true;
                    t.owner.markDirty()
                }
            }
        },
        removeMany: function(n) {
            var r = this,
            i = t(e(n));
            r.classes = Ext.Array.filter(r.classes,
            function(e) {
                if (!i[e]) {
                    return true
                }
                delete r.map[e];
                if (!r.dirty) {
                    r.dirty = true;
                    r.owner.markDirty()
                }
                return false
            })
        }
    }
} ());Ext.define("Ext.util.Queue", {
    constructor: function() {
        this.clear()
    },
    add: function(e) {
        var t = this,
        n = t.getKey(e);
        if (!t.map[n]) {++t.length;
            t.items.push(e);
            t.map[n] = e
        }
        return e
    },
    clear: function() {
        var e = this,
        t = e.items;
        e.items = [];
        e.map = {};
        e.length = 0;
        return t
    },
    contains: function(e) {
        var t = this.getKey(e);
        return this.map.hasOwnProperty(t)
    },
    getCount: function() {
        return this.length
    },
    getKey: function(e) {
        return e.id
    },
    remove: function(e) {
        var t = this,
        n = t.getKey(e),
        r = t.items,
        i;
        if (t.map[n]) {
            i = Ext.Array.indexOf(r, e);
            Ext.Array.erase(r, i, 1);
            delete t.map[n]; --t.length
        }
        return e
    }
});Ext.define("Ext.layout.ContextItem", {
    heightModel: null,
    widthModel: null,
    sizeModel: null,
    optOut: false,
    ownerSizePolicy: null,
    boxChildren: null,
    boxParent: null,
    isBorderBoxValue: null,
    children: [],
    dirty: null,
    dirtyCount: 0,
    hasRawContent: true,
    isContextItem: true,
    isTopLevel: false,
    consumersContentHeight: 0,
    consumersContentWidth: 0,
    consumersContainerHeight: 0,
    consumersContainerWidth: 0,
    consumersHeight: 0,
    consumersWidth: 0,
    ownerCtContext: null,
    remainingChildDimensions: 0,
    props: null,
    state: null,
    wrapsComponent: false,
    constructor: function(e) {
        var t = this,
        n = Ext.layout.SizeModel.sizeModels,
        r = n.configured,
        i = n.shrinkWrap,
        s, o, u, a, f, l, c, h, p, d, v, m, g, y;
        Ext.apply(t, e);
        s = t.el;
        t.id = s.id;
        t.flushedProps = {};
        t.props = f = {};
        t.styles = {};
        c = t.target;
        if (!c.isComponent) {
            o = s.lastBox
        } else {
            t.wrapsComponent = true;
            t.framing = c.frameSize || null;
            t.isComponentChild = c.ownerLayout && c.ownerLayout.isComponentLayout;
            o = c.lastBox;
            u = c.ownerCt;
            if (u && (a = u.el && t.context.items[u.el.id])) {
                t.ownerCtContext = a
            }
            t.sizeModel = l = c.getSizeModel(a && a.widthModel.pairsByHeightOrdinal[a.heightModel.ordinal]);
            t.widthModel = m = l.width;
            t.heightModel = g = l.height;
            if (o && o.invalid === false) {
                d = c.width === (h = o.width);
                v = c.height === (p = o.height);
                if (m === i && g === i) {
                    y = true
                } else {
                    if (m === r && d) {
                        y = g === i || g === r && v
                    }
                }
                if (y) {
                    t.optOut = true;
                    f.width = h;
                    f.height = p
                }
            }
        }
        t.lastBox = o
    },
    init: function(e, t) {
        var n = this,
        r = n.props,
        i = n.dirty,
        s = n.ownerCtContext,
        o = n.target.ownerLayout,
        u = !n.state,
        a = e || u,
        f, l, c, h, p, d, v = n.heightModel,
        m = n.widthModel,
        g, y, b = 0;
        n.dirty = n.invalid = false;
        n.props = {};
        n.remainingChildDimensions = 0;
        if (n.boxChildren) {
            n.boxChildren.length = 0
        }
        if (!u) {
            n.clearAllBlocks("blocks");
            n.clearAllBlocks("domBlocks")
        }
        if (!n.wrapsComponent) {
            return a
        }
        d = n.target;
        n.state = {};
        if (u) {
            if (d.beforeLayout && d.beforeLayout !== Ext.emptyFn) {
                d.beforeLayout()
            }
            if (!s && (h = d.ownerCt)) {
                s = n.context.items[h.el.id]
            }
            if (s) {
                n.ownerCtContext = s;
                n.isBoxParent = d.ownerLayout.isItemBoxParent(n)
            } else {
                n.isTopLevel = true
            }
            n.frameBodyContext = n.getEl("frameBody")
        } else {
            s = n.ownerCtContext;
            n.isTopLevel = !s;
            f = n.children;
            for (l = 0, c = f.length; l < c; ++l) {
                f[l].init(true)
            }
        }
        n.hasRawContent = !(d.isContainer && d.items.items.length > 0);
        if (e) {
            n.widthModel = n.heightModel = null;
            p = d.getSizeModel(s && s.widthModel.pairsByHeightOrdinal[s.heightModel.ordinal]);
            if (u) {
                n.sizeModel = p
            }
            n.widthModel = p.width;
            n.heightModel = p.height;
            if (s && !n.isComponentChild) {
                s.remainingChildDimensions += 2
            }
        } else {
            if (r) {
                n.recoverProp("x", r, i);
                n.recoverProp("y", r, i);
                if (n.widthModel.calculated) {
                    n.recoverProp("width", r, i)
                } else {
                    if ("width" in r) {++b
                    }
                }
                if (n.heightModel.calculated) {
                    n.recoverProp("height", r, i)
                } else {
                    if ("height" in r) {++b
                    }
                }
                if (s && !n.isComponentChild) {
                    s.remainingChildDimensions += b
                }
            }
        }
        if (r && o && o.manageMargins) {
            n.recoverProp("margin-top", r, i);
            n.recoverProp("margin-right", r, i);
            n.recoverProp("margin-bottom", r, i);
            n.recoverProp("margin-left", r, i)
        }
        if (t) {
            g = t.heightModel;
            y = t.widthModel;
            if (y && g && m && v) {
                if (m.shrinkWrap && v.shrinkWrap) {
                    if (y.constrainedMax && g.constrainedMin) {
                        g = null
                    }
                }
            }
            if (y) {
                n.widthModel = y
            }
            if (g) {
                n.heightModel = g
            }
            if (t.state) {
                Ext.apply(n.state, t.state)
            }
        }
        return a
    },
    initContinue: function(e) {
        var t = this,
        n = t.ownerCtContext,
        r = t.target,
        i = t.widthModel,
        s = r.getHierarchyState(),
        o;
        if (i.fixed) {
            s.inShrinkWrapTable = false
        } else {
            delete s.inShrinkWrapTable
        }
        if (e) {
            if (n && i.shrinkWrap) {
                o = n.isBoxParent ? n: n.boxParent;
                if (o) {
                    o.addBoxChild(t)
                }
            } else {
                if (i.natural) {
                    t.boxParent = n
                }
            }
        }
        return e
    },
    initDone: function(e) {
        var t = this,
        n = t.props,
        r = t.state;
        if (t.remainingChildDimensions === 0) {
            n.containerChildrenSizeDone = true
        }
        if (e) {
            n.containerLayoutDone = true
        }
        if (t.boxChildren && t.boxChildren.length && t.widthModel.shrinkWrap) {
            t.el.setWidth(1e4);
            r.blocks = (r.blocks || 0) + 1
        }
    },
    initAnimation: function() {
        var e = this,
        t = e.target,
        n = e.ownerCtContext;
        if (n && n.isTopLevel) {
            e.animatePolicy = t.ownerLayout.getAnimatePolicy(e)
        } else {
            if (!n && t.isCollapsingOrExpanding && t.animCollapse) {
                e.animatePolicy = t.componentLayout.getAnimatePolicy(e)
            }
        }
        if (e.animatePolicy) {
            e.context.queueAnimation(e)
        }
    },
    addCls: function(e) {
        this.getClassList().addMany(e)
    },
    removeCls: function(e) {
        this.getClassList().removeMany(e)
    },
    addBlock: function(e, t, n) {
        var r = this,
        i = r[e] || (r[e] = {}),
        s = i[n] || (i[n] = {});
        if (!s[t.id]) {
            s[t.id] = t; ++t.blockCount; ++r.context.blockCount
        }
    },
    addBoxChild: function(e) {
        var t = this,
        n, r = e.widthModel;
        e.boxParent = this;
        e.measuresBox = r.shrinkWrap ? e.hasRawContent: r.natural;
        if (e.measuresBox) {
            n = t.boxChildren;
            if (n) {
                n.push(e)
            } else {
                t.boxChildren = [e]
            }
        }
    },
    addPositionStyles: function(e, t) {
        var n = t.x,
        r = t.y,
        i = 0;
        if (n !== undefined) {
            e.left = n + "px"; ++i
        }
        if (r !== undefined) {
            e.top = r + "px"; ++i
        }
        return i
    },
    addTrigger: function(e, t) {
        var n = this,
        r = t ? "domTriggers": "triggers",
        i = n[r] || (n[r] = {}),
        s = n.context,
        o = s.currentLayout,
        u = i[e] || (i[e] = {});
        if (!u[o.id]) {
            u[o.id] = o; ++o.triggerCount;
            u = s.triggers[t ? "dom": "data"]; (u[o.id] || (u[o.id] = [])).push({
                item: this,
                prop: e
            });
            if (n.props[e] !== undefined) {
                if (!t || !(n.dirty && e in n.dirty)) {++o.firedTriggers
                }
            }
        }
    },
    boxChildMeasured: function() {
        var e = this,
        t = e.state,
        n = t.boxesMeasured = (t.boxesMeasured || 0) + 1;
        if (n == e.boxChildren.length) {
            t.clearBoxWidth = 1; ++e.context.progressCount;
            e.markDirty()
        }
    },
    borderNames: ["border-top-width", "border-right-width", "border-bottom-width", "border-left-width"],
    marginNames: ["margin-top", "margin-right", "margin-bottom", "margin-left"],
    paddingNames: ["padding-top", "padding-right", "padding-bottom", "padding-left"],
    trblNames: ["top", "right", "bottom", "left"],
    cacheMissHandlers: {
        borderInfo: function(e) {
            var t = e.getStyles(e.borderNames, e.trblNames);
            t.width = t.left + t.right;
            t.height = t.top + t.bottom;
            return t
        },
        marginInfo: function(e) {
            var t = e.getStyles(e.marginNames, e.trblNames);
            t.width = t.left + t.right;
            t.height = t.top + t.bottom;
            return t
        },
        paddingInfo: function(e) {
            var t = e.frameBodyContext || e,
            n = t.getStyles(e.paddingNames, e.trblNames);
            n.width = n.left + n.right;
            n.height = n.top + n.bottom;
            return n
        }
    },
    checkCache: function(e) {
        return this.cacheMissHandlers[e](this)
    },
    clearAllBlocks: function(e) {
        var t = this[e],
        n;
        if (t) {
            for (n in t) {
                this.clearBlocks(e, n)
            }
        }
    },
    clearBlocks: function(e, t) {
        var n = this[e],
        r = n && n[t],
        i,
        s,
        o;
        if (r) {
            delete n[t];
            i = this.context;
            for (o in r) {
                s = r[o]; --i.blockCount;
                if (!--s.blockCount && !s.pending && !s.done) {
                    i.queueLayout(s)
                }
            }
        }
    },
    block: function(e, t) {
        this.addBlock("blocks", e, t)
    },
    domBlock: function(e, t) {
        this.addBlock("domBlocks", e, t)
    },
    fireTriggers: function(e, t) {
        var n = this[e],
        r = n && n[t],
        i = this.context,
        s,
        o;
        if (r) {
            for (o in r) {
                s = r[o]; ++s.firedTriggers;
                if (!s.done && !s.blockCount && !s.pending) {
                    i.queueLayout(s)
                }
            }
        }
    },
    flush: function() {
        var e = this,
        t = e.dirty,
        n = e.state,
        r = e.el;
        e.dirtyCount = 0;
        if (e.classList && e.classList.dirty) {
            e.classList.flush()
        }
        if ("attributes" in e) {
            r.set(e.attributes);
            delete e.attributes
        }
        if ("innerHTML" in e) {
            r.innerHTML = e.innerHTML;
            delete e.innerHTML
        }
        if (n && n.clearBoxWidth) {
            n.clearBoxWidth = 0;
            e.el.setStyle("width", null);
            if (!--n.blocks) {
                e.context.queueItemLayouts(e)
            }
        }
        if (t) {
            delete e.dirty;
            e.writeProps(t, true)
        }
    },
    flushAnimations: function() {
        var e = this,
        t = e.previousSize,
        n, r, i, s, o, u, a, f, l, c, h;
        if (t) {
            n = e.target;
            r = n.getAnimationProps();
            i = r.duration;
            s = Ext.Object.getKeys(e.animatePolicy);
            o = Ext.apply({},
            {
                from: {},
                to: {},
                duration: i || Ext.fx.Anim.prototype.duration
            },
            r);
            for (u = 0, a = 0, f = s.length; a < f; a++) {
                l = s[a];
                c = t[l];
                h = e.peek(l);
                if (c != h) {
                    l = e.translateProps[l] || l;
                    o.from[l] = c;
                    o.to[l] = h; ++u
                }
            }
            if (u) {
                if (e.isCollapsingOrExpanding === 1) {
                    n.componentLayout.undoLayout(e)
                } else {
                    e.writeProps(o.from)
                }
                e.el.animate(o);
                Ext.fx.Manager.getFxQueue(e.el.id)[0].on({
                    afteranimate: function() {
                        if (e.isCollapsingOrExpanding === 1) {
                            n.componentLayout.redoLayout(e);
                            n.afterCollapse(true)
                        } else {
                            if (e.isCollapsingOrExpanding === 2) {
                                n.afterExpand(true)
                            }
                        }
                    }
                })
            }
        }
    },
    getBorderInfo: function() {
        var e = this,
        t = e.borderInfo;
        if (!t) {
            e.borderInfo = t = e.checkCache("borderInfo")
        }
        return t
    },
    getClassList: function() {
        return this.classList || (this.classList = new Ext.layout.ClassList(this))
    },
    getEl: function(e, t) {
        var n = this,
        r, i, s;
        if (e) {
            if (e.dom) {
                i = e
            } else {
                r = n.target;
                if (t) {
                    r = t
                }
                i = r[e];
                if (typeof i == "function") {
                    i = i.call(r);
                    if (i === n.el) {
                        return this
                    }
                }
            }
            if (i) {
                s = n.context.getEl(n, i)
            }
        }
        return s || null
    },
    getFrameInfo: function() {
        var e = this,
        t = e.frameInfo,
        n, r;
        if (!t) {
            n = e.framing;
            r = e.getBorderInfo();
            e.frameInfo = t = n ? {
                top: n.top + r.top,
                right: n.right + r.right,
                bottom: n.bottom + r.bottom,
                left: n.left + r.left,
                width: n.width + r.width,
                height: n.height + r.height
            }: r
        }
        return t
    },
    getMarginInfo: function() {
        var e = this,
        t = e.marginInfo,
        n, r, i, s, o;
        if (!t) {
            if (!e.wrapsComponent) {
                t = e.checkCache("marginInfo")
            } else {
                n = e.target;
                s = n.ownerLayout;
                o = s ? s.id: null;
                r = s && s.manageMargins;
                t = n.margin$;
                if (t && t.ownerId !== o) {
                    t = null
                }
                if (!t) {
                    t = e.parseMargins(n, n.margin) || e.checkCache("marginInfo");
                    if (r) {
                        i = e.parseMargins(n, n.margins, s.defaultMargins);
                        if (i) {
                            t = {
                                top: t.top + i.top,
                                right: t.right + i.right,
                                bottom: t.bottom + i.bottom,
                                left: t.left + i.left
                            }
                        }
                        e.setProp("margin-top", 0);
                        e.setProp("margin-right", 0);
                        e.setProp("margin-bottom", 0);
                        e.setProp("margin-left", 0)
                    }
                    t.ownerId = o;
                    n.margin$ = t
                }
                t.width = t.left + t.right;
                t.height = t.top + t.bottom
            }
            e.marginInfo = t
        }
        return t
    },
    clearMarginCache: function() {
        delete this.marginInfo;
        delete this.target.margin$
    },
    getPaddingInfo: function() {
        var e = this,
        t = e.paddingInfo;
        if (!t) {
            e.paddingInfo = t = e.checkCache("paddingInfo")
        }
        return t
    },
    getProp: function(e) {
        var t = this,
        n = t.props[e];
        t.addTrigger(e);
        return n
    },
    getDomProp: function(e) {
        var t = this,
        n = t.dirty && e in t.dirty ? undefined: t.props[e];
        t.addTrigger(e, true);
        return n
    },
    getStyle: function(e) {
        var t = this,
        n = t.styles,
        r, i;
        if (e in n) {
            i = n[e]
        } else {
            r = t.styleInfo[e];
            i = t.el.getStyle(e);
            if (r && r.parseInt) {
                i = parseInt(i, 10) || 0
            }
            n[e] = i
        }
        return i
    },
    getStyles: function(e, t) {
        var n = this,
        r = n.styles,
        i = {},
        s = 0,
        o = e.length,
        u, a, f, l, c, h, p, d;
        t = t || e;
        for (u = 0; u < o; ++u) {
            l = e[u];
            if (l in r) {
                i[t[u]] = r[l]; ++s;
                if (u && s == 1) {
                    a = e.slice(0, u);
                    f = t.slice(0, u)
                }
            } else {
                if (s) { (a || (a = [])).push(l); (f || (f = [])).push(t[u])
                }
            }
        }
        if (s < o) {
            a = a || e;
            f = f || t;
            h = n.styleInfo;
            p = n.el.getStyle(a);
            for (u = a.length; u--;) {
                l = a[u];
                c = h[l];
                d = p[l];
                if (c && c.parseInt) {
                    d = parseInt(d, 10) || 0
                }
                i[f[u]] = d;
                r[l] = d
            }
        }
        return i
    },
    hasProp: function(e) {
        return this.getProp(e) != null
    },
    hasDomProp: function(e) {
        return this.getDomProp(e) != null
    },
    invalidate: function(e) {
        this.context.queueInvalidate(this, e)
    },
    markDirty: function() {
        if (++this.dirtyCount == 1) {
            this.context.queueFlush(this)
        }
    },
    onBoxMeasured: function() {
        var e = this.boxParent,
        t = this.state;
        if (e && e.widthModel.shrinkWrap && !t.boxMeasured && this.measuresBox) {
            t.boxMeasured = 1;
            e.boxChildMeasured()
        }
    },
    parseMargins: function(e, t, n) {
        if (t === true) {
            t = 5
        }
        var r = typeof t,
        i;
        if (r == "string" || r == "number") {
            i = e.parseBox(t)
        } else {
            if (t || n) {
                i = {
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: 0
                };
                if (n) {
                    Ext.apply(i, this.parseMargins(e, n))
                }
                if (t) {
                    t = Ext.apply(i, e.parseBox(t))
                }
            }
        }
        return i
    },
    peek: function(e) {
        return this.props[e]
    },
    recoverProp: function(e, t, n) {
        var r = this,
        i = r.props,
        s;
        if (e in t) {
            i[e] = t[e];
            if (n && e in n) {
                s = r.dirty || (r.dirty = {});
                s[e] = n[e]
            }
        }
    },
    redo: function(e) {
        var t = this,
        n, r, i;
        t.revertProps(t.props);
        if (e && t.wrapsComponent) {
            if (t.childItems) {
                for (i = 0, n = t.childItems, r = n.length; i < r; i++) {
                    n[i].redo(e)
                }
            }
            for (i = 0, n = t.children, r = n.length; i < r; i++) {
                n[i].redo()
            }
        }
    },
    removeEl: function(e, t) {
        var n = this,
        r, i;
        if (e) {
            if (e.dom) {
                i = e
            } else {
                r = n.target;
                if (t) {
                    r = t
                }
                i = r[e];
                if (typeof i == "function") {
                    i = i.call(r);
                    if (i === n.el) {
                        return this
                    }
                }
            }
            if (i) {
                n.context.removeEl(n, i)
            }
        }
    },
    revertProps: function(e) {
        var t, n = this.flushedProps,
        r = {};
        for (t in e) {
            if (n.hasOwnProperty(t)) {
                r[t] = e[t]
            }
        }
        this.writeProps(r)
    },
    setAttribute: function(e, t) {
        var n = this;
        if (!n.attributes) {
            n.attributes = {}
        }
        n.attributes[e] = t;
        n.markDirty()
    },
    setBox: function(e) {
        var t = this;
        if ("left" in e) {
            t.setProp("x", e.left)
        }
        if ("top" in e) {
            t.setProp("y", e.top)
        }
        t.setSize(e.width, e.height)
    },
    setContentHeight: function(e, t) {
        if (!t && this.hasRawContent) {
            return 1
        }
        return this.setProp("contentHeight", e)
    },
    setContentWidth: function(e, t) {
        if (!t && this.hasRawContent) {
            return 1
        }
        return this.setProp("contentWidth", e)
    },
    setContentSize: function(e, t, n) {
        return this.setContentWidth(e, n) + this.setContentHeight(t, n) == 2
    },
    setProp: function(e, t, n) {
        var r = this,
        i = typeof t,
        s, o;
        if (i == "undefined" || i === "number" && isNaN(t)) {
            return 0
        }
        if (r.props[e] === t) {
            return 1
        }
        r.props[e] = t; ++r.context.progressCount;
        if (n === false) {
            r.fireTriggers("domTriggers", e);
            r.clearBlocks("domBlocks", e)
        } else {
            o = r.styleInfo[e];
            if (o) {
                if (!r.dirty) {
                    r.dirty = {}
                }
                if (e == "width" || e == "height") {
                    s = r.isBorderBoxValue;
                    if (s === null) {
                        r.isBorderBoxValue = s = !!r.el.isBorderBox()
                    }
                    if (!s) {
                        r.borderInfo || r.getBorderInfo();
                        r.paddingInfo || r.getPaddingInfo()
                    }
                }
                r.dirty[e] = t;
                r.markDirty()
            }
        }
        r.fireTriggers("triggers", e);
        r.clearBlocks("blocks", e);
        return 1
    },
    setHeight: function(e, t) {
        var n = this,
        r = n.target,
        i = n.ownerCtContext,
        s, o, u, a, f;
        if (e < 0) {
            e = 0
        }
        if (!n.wrapsComponent) {
            if (!n.setProp("height", e, t)) {
                return NaN
            }
        } else {
            u = n.collapsedVert ? 0 : r.minHeight || 0;
            e = Ext.Number.constrain(e, u, r.maxHeight);
            a = n.props.height;
            if (!n.setProp("height", e, t)) {
                return NaN
            }
            if (i && !n.isComponentChild && isNaN(a)) {
                f = --i.remainingChildDimensions;
                if (!f) {
                    i.setProp("containerChildrenSizeDone", true)
                }
            }
            s = n.frameBodyContext;
            if (s) {
                o = n.getFrameInfo();
                s.setHeight(e - o.height, t)
            }
        }
        return e
    },
    setWidth: function(e, t) {
        var n = this,
        r = n.target,
        i = n.ownerCtContext,
        s, o, u, a, f;
        if (e < 0) {
            e = 0
        }
        if (!n.wrapsComponent) {
            if (!n.setProp("width", e, t)) {
                return NaN
            }
        } else {
            u = n.collapsedHorz ? 0 : r.minWidth || 0;
            e = Ext.Number.constrain(e, u, r.maxWidth);
            a = n.props.width;
            if (!n.setProp("width", e, t)) {
                return NaN
            }
            if (i && !n.isComponentChild && isNaN(a)) {
                f = --i.remainingChildDimensions;
                if (!f) {
                    i.setProp("containerChildrenSizeDone", true)
                }
            }
            s = n.frameBodyContext;
            if (s) {
                o = n.getFrameInfo();
                s.setWidth(e - o.width, t)
            }
        }
        return e
    },
    setSize: function(e, t, n) {
        this.setWidth(e, n);
        this.setHeight(t, n)
    },
    translateProps: {
        x: "left",
        y: "top"
    },
    undo: function(e) {
        var t = this,
        n, r, i;
        t.revertProps(t.lastBox);
        if (e && t.wrapsComponent) {
            if (t.childItems) {
                for (i = 0, n = t.childItems, r = n.length; i < r; i++) {
                    n[i].undo(e)
                }
            }
            for (i = 0, n = t.children, r = n.length; i < r; i++) {
                n[i].undo()
            }
        }
    },
    unsetProp: function(e) {
        var t = this.dirty;
        delete this.props[e];
        if (t) {
            delete t[e]
        }
    },
    writeProps: function(e, t) {
        if (! (e && typeof e == "object")) {
            return
        }
        var n = this,
        r = n.el,
        i = {},
        s = 0,
        o = n.styleInfo,
        u, a, f, l = e.width,
        c = e.height,
        h = n.isBorderBoxValue,
        p = n.target,
        d = Math.max,
        v = 0,
        m = 0,
        g, y, b, w, E, S;
        if ("displayed" in e) {
            r.setDisplayed(e.displayed)
        }
        for (a in e) {
            if (t) {
                n.fireTriggers("domTriggers", a);
                n.clearBlocks("domBlocks", a);
                n.flushedProps[a] = 1
            }
            u = o[a];
            if (u && u.dom) {
                if (u.suffix && (f = parseInt(e[a], 10))) {
                    i[a] = f + u.suffix
                } else {
                    i[a] = e[a]
                }++s
            }
        }
        if ("x" in e || "y" in e) {
            if (p.isComponent) {
                p.setPosition(e.x, e.y)
            } else {
                s += n.addPositionStyles(i, e)
            }
        }
        if (!h && (l > 0 || c > 0)) {
            if (!n.frameBodyContext) {
                v = n.paddingInfo.width;
                m = n.paddingInfo.height
            }
            if (l) {
                l = d(parseInt(l, 10) - (n.borderInfo.width + v), 0);
                i.width = l + "px"; ++s
            }
            if (c) {
                c = d(parseInt(c, 10) - (n.borderInfo.height + m), 0);
                i.height = c + "px"; ++s
            }
        }
        if (n.wrapsComponent && Ext.isIE9 && Ext.isStrict) {
            if ((g = l !== undefined && n.hasOverflowY) || (y = c !== undefined && n.hasOverflowX)) {
                b = n.isAbsolute;
                if (b === undefined) {
                    b = false;
                    S = n.target.getTargetEl();
                    E = S.getStyle("position");
                    if (E == "absolute") {
                        E = S.getStyle("box-sizing");
                        b = E == "border-box"
                    }
                    n.isAbsolute = b
                }
                if (b) {
                    w = Ext.getScrollbarSize();
                    if (g) {
                        l = parseInt(l, 10) + w.width;
                        i.width = l + "px"; ++s
                    }
                    if (y) {
                        c = parseInt(c, 10) + w.height;
                        i.height = c + "px"; ++s
                    }
                }
            }
        }
        if (s) {
            r.setStyle(i)
        }
    }
},
function() {
    var e = {
        dom: true,
        parseInt: true,
        suffix: "px"
    },
    t = {
        dom: true
    },
    n = {
        dom: false
    };
    this.prototype.styleInfo = {
        containerChildrenSizeDone: n,
        containerLayoutDone: n,
        displayed: n,
        done: n,
        x: n,
        y: n,
        columnWidthsDone: n,
        left: e,
        top: e,
        right: e,
        bottom: e,
        width: e,
        height: e,
        "border-top-width": e,
        "border-right-width": e,
        "border-bottom-width": e,
        "border-left-width": e,
        "margin-top": e,
        "margin-right": e,
        "margin-bottom": e,
        "margin-left": e,
        "padding-top": e,
        "padding-right": e,
        "padding-bottom": e,
        "padding-left": e,
        "line-height": t,
        display: t
    }
});Ext.define("Ext.layout.Context", {
    remainingLayouts: 0,
    state: 0,
    constructor: function(e) {
        var t = this;
        Ext.apply(t, e);
        t.items = {};
        t.layouts = {};
        t.blockCount = 0;
        t.cycleCount = 0;
        t.flushCount = 0;
        t.calcCount = 0;
        t.animateQueue = t.newQueue();
        t.completionQueue = t.newQueue();
        t.finalizeQueue = t.newQueue();
        t.finishQueue = t.newQueue();
        t.flushQueue = t.newQueue();
        t.invalidateData = {};
        t.layoutQueue = t.newQueue();
        t.invalidQueue = [];
        t.triggers = {
            data: {},
            dom: {}
        }
    },
    callLayout: function(e, t) {
        this.currentLayout = e;
        e[t](this.getCmp(e.owner))
    },
    cancelComponent: function(e, t, n) {
        var r = this,
        i = e,
        s = !e.isComponent,
        o = s ? i.length: 1,
        u,
        a,
        f,
        l,
        c,
        h,
        p,
        d,
        v,
        m;
        for (u = 0; u < o; ++u) {
            if (s) {
                e = i[u]
            }
            if (n && e.ownerCt) {
                m = this.items[e.ownerCt.el.id];
                if (m) {
                    Ext.Array.remove(m.childItems, r.getCmp(e))
                }
            }
            if (!t) {
                p = r.invalidQueue;
                f = p.length;
                if (f) {
                    r.invalidQueue = h = [];
                    for (a = 0; a < f; ++a) {
                        d = p[a];
                        v = d.item.target;
                        if (v != e && !v.isDescendant(e)) {
                            h.push(d)
                        }
                    }
                }
            }
            c = e.componentLayout;
            r.cancelLayout(c);
            if (c.getLayoutItems) {
                l = c.getLayoutItems();
                if (l.length) {
                    r.cancelComponent(l, true)
                }
            }
            if (e.isContainer && !e.collapsed) {
                c = e.layout;
                r.cancelLayout(c);
                l = c.getVisibleItems();
                if (l.length) {
                    r.cancelComponent(l, true)
                }
            }
        }
    },
    cancelLayout: function(e) {
        var t = this;
        t.completionQueue.remove(e);
        t.finalizeQueue.remove(e);
        t.finishQueue.remove(e);
        t.layoutQueue.remove(e);
        if (e.running) {
            t.layoutDone(e)
        }
        e.ownerContext = null
    },
    clearTriggers: function(e, t) {
        var n = e.id,
        r = this.triggers[t ? "dom": "data"],
        i = r && r[n],
        s = i && i.length || 0,
        o,
        u,
        a;
        for (o = 0; o < s; ++o) {
            a = i[o];
            u = a.item;
            r = t ? u.domTriggers: u.triggers;
            delete r[a.prop][n]
        }
    },
    flush: function() {
        var e = this,
        t = e.flushQueue.clear(),
        n = t.length,
        r;
        if (n) {++e.flushCount;
            for (r = 0; r < n; ++r) {
                t[r].flush()
            }
        }
    },
    flushAnimations: function() {
        var e = this,
        t = e.animateQueue.clear(),
        n = t.length,
        r;
        if (n) {
            for (r = 0; r < n; r++) {
                if (t[r].target.animate !== false) {
                    t[r].flushAnimations()
                }
            }
            Ext.fx.Manager.runner()
        }
    },
    flushInvalidates: function() {
        var e = this,
        t = e.invalidQueue,
        n = t && t.length,
        r, i, s, o;
        e.invalidQueue = [];
        if (n) {
            i = [];
            for (o = 0; o < n; ++o) {
                r = (s = t[o]).item.target;
                if (!r.container.isDetachedBody) {
                    i.push(r);
                    if (s.options) {
                        e.invalidateData[r.id] = s.options
                    }
                }
            }
            e.invalidate(i, null)
        }
    },
    flushLayouts: function(e, t, n) {
        var r = this,
        i = n ? r[e].items: r[e].clear(),
        s = i.length,
        o,
        u;
        if (s) {
            for (o = 0; o < s; ++o) {
                u = i[o];
                if (!u.running) {
                    r.callLayout(u, t)
                }
            }
            r.currentLayout = null
        }
    },
    getCmp: function(e) {
        return this.getItem(e, e.el)
    },
    getEl: function(e, t) {
        var n = this.getItem(t, t);
        if (!n.parent) {
            n.parent = e;
            if (e.children.length) {
                e.children.push(n)
            } else {
                e.children = [n]
            }
        }
        return n
    },
    getItem: function(e, t) {
        var n = t.id,
        r = this.items,
        i = r[n] || (r[n] = new Ext.layout.ContextItem({
            context: this,
            target: e,
            el: t
        }));
        return i
    },
    handleFailure: function() {
        var e = this.layouts,
        t, n;
        Ext.failedLayouts = (Ext.failedLayouts || 0) + 1;
        for (n in e) {
            t = e[n];
            if (e.hasOwnProperty(n)) {
                t.running = false;
                t.ownerContext = null
            }
        }
    },
    invalidate: function(e, t) {
        var n = this,
        r = !e.isComponent,
        i, s, o, u, a, f, l, c, h, p, d;
        for (o = 0, l = r ? e.length: 1; o < l; ++o) {
            u = r ? e[o] : e;
            if (u.rendered && !u.hidden) {
                a = n.getCmp(u);
                c = u.componentLayout;
                s = !c.ownerContext;
                h = u.isContainer && !u.collapsed ? u.layout: null;
                p = n.invalidateData[a.id];
                delete n.invalidateData[a.id];
                d = a.init(t, p);
                if (p) {
                    n.processInvalidate(p, a, "before")
                }
                if (c.beforeLayoutCycle) {
                    c.beforeLayoutCycle(a)
                }
                if (h && h.beforeLayoutCycle) {
                    h.beforeLayoutCycle(a)
                }
                d = a.initContinue(d);
                i = true;
                if (c.getLayoutItems) {
                    c.renderChildren();
                    f = c.getLayoutItems();
                    if (f.length) {
                        n.invalidate(f, true)
                    }
                }
                if (h) {
                    i = false;
                    h.renderChildren();
                    f = h.getVisibleItems();
                    if (f.length) {
                        n.invalidate(f, true)
                    }
                }
                a.initDone(i);
                n.resetLayout(c, a, s);
                if (h) {
                    n.resetLayout(h, a, s)
                }
                a.initAnimation();
                if (p) {
                    n.processInvalidate(p, a, "after")
                }
            }
        }
        n.currentLayout = null
    },
    layoutDone: function(e) {
        var t = e.ownerContext;
        e.running = false;
        if (e.isComponentLayout) {
            if (t.measuresBox) {
                t.onBoxMeasured()
            }
            t.setProp("done", true)
        } else {
            t.setProp("containerLayoutDone", true)
        }--this.remainingLayouts; ++this.progressCount
    },
    newQueue: function() {
        return new Ext.util.Queue
    },
    processInvalidate: function(e, t, n) {
        if (e[n]) {
            var r = this,
            i = r.currentLayout;
            r.currentLayout = e.layout || null;
            e[n](t, e);
            r.currentLayout = i
        }
    },
    queueAnimation: function(e) {
        this.animateQueue.add(e)
    },
    queueCompletion: function(e) {
        this.completionQueue.add(e)
    },
    queueFinalize: function(e) {
        this.finalizeQueue.add(e)
    },
    queueFlush: function(e) {
        this.flushQueue.add(e)
    },
    chainFns: function(e, t, n) {
        var r = this,
        i = e.layout,
        s = t.layout,
        o = e[n],
        u = t[n];
        return function(n) {
            var f = r.currentLayout;
            if (o) {
                r.currentLayout = i;
                o.call(e.scope || e, n, e)
            }
            r.currentLayout = s;
            u.call(t.scope || t, n, t);
            r.currentLayout = f
        }
    },
    queueInvalidate: function(e, t) {
        var n = this,
        r = [],
        i = n.invalidQueue,
        s = i.length,
        o,
        u,
        a,
        f,
        l;
        if (e.isComponent) {
            e = n.getCmp(o = e)
        } else {
            o = e.target
        }
        e.invalid = true;
        while (s--) {
            u = i[s];
            a = u.item.target;
            if (o.isDescendant(a)) {
                return
            }
            if (a == o) {
                if (! (f = u.options)) {
                    u.options = t
                } else {
                    if (t) {
                        if (t.widthModel) {
                            f.widthModel = t.widthModel
                        }
                        if (t.heightModel) {
                            f.heightModel = t.heightModel
                        }
                        if (! (l = f.state)) {
                            f.state = t.state
                        } else {
                            if (t.state) {
                                Ext.apply(l, t.state)
                            }
                        }
                        if (t.before) {
                            f.before = n.chainFns(f, t, "before")
                        }
                        if (t.after) {
                            f.after = n.chainFns(f, t, "after")
                        }
                    }
                }
                return
            }
            if (!a.isDescendant(o)) {
                r.push(u)
            }
        }
        r.push({
            item: e,
            options: t
        });
        n.invalidQueue = r
    },
    queueItemLayouts: function(e) {
        var t = e.isComponent ? e: e.target,
        n = t.componentLayout;
        if (!n.pending && !n.invalid && !n.done) {
            this.queueLayout(n)
        }
        n = t.layout;
        if (n && !n.pending && !n.invalid && !n.done) {
            this.queueLayout(n)
        }
    },
    queueLayout: function(e) {
        this.layoutQueue.add(e);
        e.pending = true
    },
    removeEl: function(e, t) {
        var n = t.id,
        r = e.children,
        i = this.items;
        if (r) {
            Ext.Array.remove(r, i[n])
        }
        delete i[n]
    },
    resetLayout: function(e, t, n) {
        var r = this;
        r.currentLayout = e;
        e.done = false;
        e.pending = true;
        e.firedTriggers = 0;
        r.layoutQueue.add(e);
        if (n) {
            r.layouts[e.id] = e;
            e.running = true;
            if (e.finishedLayout) {
                r.finishQueue.add(e)
            }++r.remainingLayouts; ++e.layoutCount;
            e.ownerContext = t;
            e.beginCount = 0;
            e.blockCount = 0;
            e.calcCount = 0;
            e.triggerCount = 0;
            if (!e.initialized) {
                e.initLayout()
            }
            e.beginLayout(t)
        } else {++e.beginCount;
            if (!e.running) {++r.remainingLayouts;
                e.running = true;
                if (e.isComponentLayout) {
                    t.unsetProp("done")
                }
                r.completionQueue.remove(e);
                r.finalizeQueue.remove(e)
            }
        }
        e.beginLayoutCycle(t, n)
    },
    run: function() {
        var e = this,
        t = false,
        n = 100;
        e.flushInvalidates();
        e.state = 1;
        e.totalCount = e.layoutQueue.getCount();
        e.flush();
        while ((e.remainingLayouts || e.invalidQueue.length) && n--) {
            if (e.invalidQueue.length) {
                e.flushInvalidates()
            }
            if (e.runCycle()) {
                t = false
            } else {
                if (!t) {
                    e.flush();
                    t = true;
                    e.flushLayouts("completionQueue", "completeLayout")
                } else {
                    if (!e.invalidQueue.length) {
                        e.state = 2;
                        break
                    }
                }
            }
            if (! (e.remainingLayouts || e.invalidQueue.length)) {
                e.flush();
                e.flushLayouts("completionQueue", "completeLayout");
                e.flushLayouts("finalizeQueue", "finalizeLayout")
            }
        }
        return e.runComplete()
    },
    runComplete: function() {
        var e = this;
        e.state = 2;
        if (e.remainingLayouts) {
            e.handleFailure();
            return false
        }
        e.flush();
        e.flushLayouts("finishQueue", "finishedLayout", true);
        e.flushLayouts("finishQueue", "notifyOwner");
        e.flush();
        e.flushAnimations();
        return true
    },
    runCycle: function() {
        var e = this,
        t = e.layoutQueue.clear(),
        n = t.length,
        r; ++e.cycleCount;
        e.progressCount = 0;
        for (r = 0; r < n; ++r) {
            e.runLayout(e.currentLayout = t[r])
        }
        e.currentLayout = null;
        return e.progressCount > 0
    },
    runLayout: function(e) {
        var t = this,
        n = t.getCmp(e.owner);
        e.pending = false;
        if (n.state.blocks) {
            return
        }
        e.done = true; ++e.calcCount; ++t.calcCount;
        e.calculate(n);
        if (e.done) {
            t.layoutDone(e);
            if (e.completeLayout) {
                t.queueCompletion(e)
            }
            if (e.finalizeLayout) {
                t.queueFinalize(e)
            }
        } else {
            if (!e.pending && !e.invalid && !(e.blockCount + e.triggerCount - e.firedTriggers)) {
                t.queueLayout(e)
            }
        }
    },
    setItemSize: function(e, t, n) {
        var r = e,
        i = 1,
        s, o;
        if (e.isComposite) {
            r = e.elements;
            i = r.length;
            e = r[0]
        } else {
            if (!e.dom && !e.el) {
                i = r.length;
                e = r[0]
            }
        }
        for (o = 0; o < i;) {
            s = this.get(e);
            s.setSize(t, n);
            e = r[++o]
        }
    }
});Ext.define("Ext.layout.component.FieldSet", {
    extend: Ext.layout.component.Body,
    alias: ["layout.fieldset"],
    type: "fieldset",
    defaultCollapsedWidth: 100,
    beforeLayoutCycle: function(e) {
        if (e.target.collapsed) {
            e.heightModel = this.sizeModels.shrinkWrap
        }
    },
    beginLayoutCycle: function(e) {
        var t = e.target,
        n;
        this.callParent(arguments);
        if (t.collapsed) {
            e.setContentHeight(0);
            e.restoreMinHeight = t.minHeight;
            delete t.minHeight;
            if (e.widthModel.shrinkWrap) {
                n = t.lastComponentSize;
                e.setContentWidth(n && n.contentWidth || this.defaultCollapsedWidth)
            }
        }
    },
    finishedLayout: function(e) {
        var t = this.owner,
        n = e.restoreMinHeight;
        this.callParent(arguments);
        if (n) {
            t.minHeight = n
        }
    },
    calculateOwnerHeightFromContentHeight: function(e, t) {
        var n = e.getBorderInfo(),
        r = e.target.legend;
        return e.getProp("contentHeight") + e.getPaddingInfo().height + (Ext.isIEQuirks || Ext.isIE8m ? e.bodyContext.getPaddingInfo().top: 0) + (r ? r.getHeight() : n.top) + n.bottom
    },
    publishInnerHeight: function(e, t) {
        var n = e.target.legend;
        if (n) {
            t -= n.getHeight()
        }
        this.callParent([e, t])
    },
    getLayoutItems: function() {
        var e = this.owner.legend;
        return e ? [e] : []
    }
});Ext.define("Ext.layout.component.field.Slider", {
    alias: ["layout.sliderfield"],
    extend: Ext.layout.component.field.Field,
    type: "sliderfield",
    beginLayout: function(e) {
        this.callParent(arguments);
        e.endElContext = e.getEl("endEl");
        e.innerElContext = e.getEl("innerEl");
        e.bodyElContext = e.getEl("bodyEl")
    },
    publishInnerHeight: function(e, t) {
        var n = t - this.measureLabelErrorHeight(e),
        r,
        i;
        if (this.owner.vertical) {
            r = e.endElContext.getPaddingInfo();
            i = e.inputContext.getPaddingInfo();
            e.innerElContext.setHeight(n - i.height - r.height)
        } else {
            e.bodyElContext.setHeight(n)
        }
    },
    publishInnerWidth: function(e, t) {
        if (!this.owner.vertical) {
            var n = e.endElContext.getPaddingInfo(),
            r = e.inputContext.getPaddingInfo();
            e.innerElContext.setWidth(t - r.left - n.right - e.labelContext.getProp("width"))
        }
    },
    beginLayoutFixed: function(e, t, n) {
        var r = this,
        i = r.ieInputWidthAdjustment;
        if (i) {
            r.owner.bodyEl.setStyle("padding-right", i + "px")
        }
        r.callParent(arguments)
    }
});Ext.define("Ext.layout.container.Absolute", {
    alias: "layout.absolute",
    extend: Ext.layout.container.Anchor,
    alternateClassName: "Ext.layout.AbsoluteLayout",
    targetCls: Ext.baseCSSPrefix + "abs-layout-ct",
    itemCls: Ext.baseCSSPrefix + "abs-layout-item",
    ignoreOnContentChange: true,
    type: "absolute",
    adjustWidthAnchor: function(e, t) {
        var n = this.targetPadding,
        r = t.getStyle("left");
        return e - r + n.left
    },
    adjustHeightAnchor: function(e, t) {
        var n = this.targetPadding,
        r = t.getStyle("top");
        return e - r + n.top
    },
    isItemLayoutRoot: function(e) {
        return this.ignoreOnContentChange || this.callParent(arguments)
    },
    isItemShrinkWrap: function(e) {
        return true
    },
    beginLayout: function(e) {
        var t = this,
        n = t.getTarget();
        t.callParent(arguments);
        if (n.dom !== document.body) {
            n.position()
        }
        t.targetPadding = e.targetContext.getPaddingInfo()
    },
    isItemBoxParent: function(e) {
        return true
    },
    onContentChange: function() {
        if (this.ignoreOnContentChange) {
            return false
        }
        return this.callParent(arguments)
    },
    calculateContentSize: function(e, t) {
        var n = this,
        r = (t || 0) | ((e.widthModel.shrinkWrap ? 1 : 0) | (e.heightModel.shrinkWrap ? 2 : 0)),
        i = r & 1 || undefined,
        s = r & 2 || undefined,
        o = e.childItems,
        u = o.length,
        a = 0,
        f = 0,
        l = 0,
        c = e.props,
        h,
        p,
        d,
        v,
        m,
        g,
        y;
        if (i) {
            if (isNaN(c.contentWidth)) {++l
            } else {
                i = undefined
            }
        }
        if (s) {
            if (isNaN(c.contentHeight)) {++l
            } else {
                s = undefined
            }
        }
        if (l) {
            for (m = 0; m < u; ++m) {
                d = o[m];
                p = d.target;
                v = s && d.getProp("height");
                y = i && d.getProp("width");
                g = d.getMarginInfo();
                v += g.bottom;
                y += g.right;
                a = Math.max(a, (p.y || 0) + v);
                f = Math.max(f, (p.x || 0) + y);
                if (isNaN(a) && isNaN(f)) {
                    n.done = false;
                    return
                }
            }
            if (i || s) {
                h = e.targetContext.getPaddingInfo()
            }
            if (i && !e.setContentWidth(f + h.width)) {
                n.done = false
            }
            if (s && !e.setContentHeight(a + h.height)) {
                n.done = false
            }
        }
    }
});Ext.define("Ext.layout.container.Accordion", {
    extend: Ext.layout.container.VBox,
    alias: ["layout.accordion"],
    alternateClassName: "Ext.layout.AccordionLayout",
    targetCls: Ext.baseCSSPrefix + "accordion-layout-ct",
    itemCls: [Ext.baseCSSPrefix + "box-item", Ext.baseCSSPrefix + "accordion-item"],
    align: "stretch",
    fill: true,
    titleCollapse: true,
    hideCollapseTool: false,
    collapseFirst: undefined,
    animate: true,
    activeOnTop: false,
    multi: false,
    defaultAnimatePolicy: {
        y: true,
        height: true
    },
    constructor: function() {
        var e = this;
        e.callParent(arguments);
        if (!e.multi && e.animate) {
            e.animatePolicy = Ext.apply({},
            e.defaultAnimatePolicy)
        } else {
            e.animatePolicy = null
        }
    },
    beforeRenderItems: function(e) {
        var t = this,
        n = e.length,
        r = 0,
        i = t.owner,
        s = t.collapseFirst,
        o = Ext.isDefined(s),
        u = t.getExpanded(true)[0],
        a = t.multi,
        f;
        for (; r < n; r++) {
            f = e[r];
            if (!f.rendered) {
                if (!a || f.collapsible !== false) {
                    f.collapsible = true
                }
                if (f.collapsible) {
                    if (o) {
                        f.collapseFirst = s
                    }
                    if (t.hideCollapseTool) {
                        f.hideCollapseTool = t.hideCollapseTool;
                        f.titleCollapse = true
                    } else {
                        if (t.titleCollapse && f.titleCollapse === undefined) {
                            f.titleCollapse = t.titleCollapse
                        }
                    }
                }
                delete f.hideHeader;
                delete f.width;
                f.title = f.title || "&#160;";
                f.addBodyCls(Ext.baseCSSPrefix + "accordion-body");
                if (!a) {
                    if (u) {
                        f.collapsed = u !== f
                    } else {
                        if (f.hasOwnProperty("collapsed") && f.collapsed === false) {
                            u = f
                        } else {
                            f.collapsed = true
                        }
                    }
                    i.mon(f, "show", t.onComponentShow, t)
                }
                f.headerOverCls = Ext.baseCSSPrefix + "accordion-hd-over"
            }
        }
        if (!t.processing && !a) {
            if (!u) {
                if (n) {
                    e[0].collapsed = false
                }
            } else {
                if (t.activeOnTop) {
                    u.collapsed = false;
                    t.configureItem(u);
                    if (i.items.indexOf(u) > 0) {
                        i.insert(0, u)
                    }
                }
            }
        }
    },
    getItemsRenderTree: function(e) {
        this.beforeRenderItems(e);
        return this.callParent(arguments)
    },
    renderItems: function(e, t) {
        this.beforeRenderItems(e);
        this.callParent(arguments)
    },
    configureItem: function(e) {
        this.callParent(arguments);
        e.animCollapse = e.border = false;
        if (this.fill) {
            e.flex = 1
        }
    },
    beginLayout: function(e) {
        this.callParent(arguments);
        this.updatePanelClasses(e)
    },
    updatePanelClasses: function(e) {
        var t = e.visibleItems,
        n = t.length,
        r = true,
        i, s, o;
        for (i = 0; i < n; i++) {
            s = t[i];
            o = s.header;
            o.addCls(Ext.baseCSSPrefix + "accordion-hd");
            if (r) {
                o.removeCls(Ext.baseCSSPrefix + "accordion-hd-sibling-expanded")
            } else {
                o.addCls(Ext.baseCSSPrefix + "accordion-hd-sibling-expanded")
            }
            if (i + 1 == n && s.collapsed) {
                o.addCls(Ext.baseCSSPrefix + "accordion-hd-last-collapsed")
            } else {
                o.removeCls(Ext.baseCSSPrefix + "accordion-hd-last-collapsed")
            }
            r = s.collapsed
        }
    },
    onBeforeComponentExpand: function(e) {
        var t = this,
        n = t.owner,
        r = t.multi,
        i = t.animate,
        s = !r && !t.animate && t.activeOnTop,
        o, u;
        if (!t.processing) {
            t.processing = true;
            u = n.deferLayouts;
            n.deferLayouts = true;
            if (!r) {
                o = t.getExpanded()[0];
                if (o && o !== e) {
                    o.collapse()
                }
            }
            if (s) {
                Ext.suspendLayouts();
                n.insert(0, e);
                Ext.resumeLayouts()
            }
            n.deferLayouts = u;
            t.processing = false
        }
    },
    onBeforeComponentCollapse: function(e) {
        var t = this,
        n = t.owner,
        r, i, s;
        if (t.owner.items.getCount() === 1) {
            return false
        }
        if (!t.processing) {
            t.processing = true;
            s = n.deferLayouts;
            n.deferLayouts = true;
            r = e.next() || e.prev();
            if (t.multi) {
                i = t.getExpanded();
                if (i.length === 1) {
                    r.expand()
                }
            } else {
                if (r) {
                    r.expand()
                }
            }
            n.deferLayouts = s;
            t.processing = false
        }
    },
    onComponentShow: function(e) {
        this.onBeforeComponentExpand(e)
    },
    onRemove: function(e, t) {
        var n = this,
        r;
        n.callParent(arguments);
        if (!n.owner.destroying && !n.multi && !e.collapsed) {
            r = n.owner.items.first();
            if (r) {
                r.expand()
            }
        }
    },
    getExpanded: function(e) {
        var t = this.owner.items.items,
        n = t.length,
        r = 0,
        i = [],
        s,
        o;
        for (; r < n; ++r) {
            o = t[r];
            if (!o.hidden) {
                if (e) {
                    s = o.hasOwnProperty("collapsed") && o.collapsed === false
                } else {
                    s = !o.collapsed
                }
                if (s) {
                    i.push(o)
                }
            }
        }
        return i
    }
});Ext.define("Ext.resizer.Splitter", {
    extend: Ext.Component,
    alias: "widget.splitter",
    childEls: ["collapseEl"],
    renderTpl: ['<tpl if="collapsible===true">', '<div id="{id}-collapseEl" role="presentation" class="', Ext.baseCSSPrefix, "collapse-el ", Ext.baseCSSPrefix, 'layout-split-{collapseDir}{childElCls}">&#160;', "</div>", "</tpl>"],
    baseCls: Ext.baseCSSPrefix + "splitter",
    collapsedClsInternal: Ext.baseCSSPrefix + "splitter-collapsed",
    canResize: true,
    collapsible: false,
    collapseOnDblClick: true,
    defaultSplitMin: 40,
    defaultSplitMax: 1e3,
    collapseTarget: "next",
    horizontal: false,
    vertical: false,
    size: 5,
    tracker: null,
    ariaRole: "separator",
    getTrackerConfig: function() {
        return Ext.apply({
            xclass: "Ext.resizer.SplitterTracker",
            el: this.el,
            splitter: this
        },
        this.tracker)
    },
    beforeRender: function() {
        var e = this,
        t = e.getCollapseTarget();
        e.callParent();
        if (t.collapsed) {
            e.addCls(e.collapsedClsInternal)
        }
        if (!e.canResize) {
            e.addCls(e.baseCls + "-noresize")
        }
        Ext.applyIf(e.renderData, {
            collapseDir: e.getCollapseDirection(),
            collapsible: e.collapsible || t.collapsible
        });
        e.protoEl.unselectable()
    },
    onRender: function() {
        var e = this,
        t, n;
        e.callParent(arguments);
        if (e.performCollapse !== false) {
            if (e.renderData.collapsible) {
                e.mon(e.collapseEl, "click", e.toggleTargetCmp, e)
            }
            if (e.collapseOnDblClick) {
                e.mon(e.el, "dblclick", e.toggleTargetCmp, e)
            }
        }
        e.mon(e.getCollapseTarget(), {
            collapse: e.onTargetCollapse,
            expand: e.onTargetExpand,
            beforeexpand: e.onBeforeTargetExpand,
            beforecollapse: e.onBeforeTargetCollapse,
            scope: e
        });
        if (e.canResize) {
            e.tracker = Ext.create(e.getTrackerConfig());
            e.relayEvents(e.tracker, ["beforedragstart", "dragstart", "dragend"])
        }
        t = e.collapseEl;
        if (t) {
            t.lastCollapseDirCls = e.collapseDirProps[e.collapseDirection].cls
        }
    },
    getCollapseDirection: function() {
        var e = this,
        t = e.collapseDirection,
        n, r, i, s;
        if (!t) {
            n = e.collapseTarget;
            if (n.isComponent) {
                t = n.collapseDirection
            }
            if (!t) {
                s = e.ownerCt.layout.type;
                if (n.isComponent) {
                    i = e.ownerCt.items;
                    r = Number(i.indexOf(n) === i.indexOf(e) - 1) << 1 | Number(s === "hbox")
                } else {
                    r = Number(e.collapseTarget === "prev") << 1 | Number(s === "hbox")
                }
                t = ["bottom", "right", "top", "left"][r]
            }
            e.collapseDirection = t
        }
        e.setOrientation(t === "top" || t === "bottom" ? "horizontal": "vertical");
        return t
    },
    getCollapseTarget: function() {
        var e = this;
        return e.collapseTarget.isComponent ? e.collapseTarget: e.collapseTarget === "prev" ? e.previousSibling() : e.nextSibling()
    },
    setCollapseEl: function(e) {
        var t = this.collapseEl;
        if (t) {
            t.setDisplayed(e)
        }
    },
    onBeforeTargetExpand: function(e) {
        this.setCollapseEl("none")
    },
    onBeforeTargetCollapse: function() {
        this.setCollapseEl("none")
    },
    onTargetCollapse: function(e) {
        this.el.addCls([this.collapsedClsInternal, this.collapsedCls]);
        this.setCollapseEl("")
    },
    onTargetExpand: function(e) {
        this.el.removeCls([this.collapsedClsInternal, this.collapsedCls]);
        this.setCollapseEl("")
    },
    collapseDirProps: {
        top: {
            cls: Ext.baseCSSPrefix + "layout-split-top"
        },
        right: {
            cls: Ext.baseCSSPrefix + "layout-split-right"
        },
        bottom: {
            cls: Ext.baseCSSPrefix + "layout-split-bottom"
        },
        left: {
            cls: Ext.baseCSSPrefix + "layout-split-left"
        }
    },
    orientationProps: {
        horizontal: {
            opposite: "vertical",
            fixedAxis: "height",
            stretchedAxis: "width"
        },
        vertical: {
            opposite: "horizontal",
            fixedAxis: "width",
            stretchedAxis: "height"
        }
    },
    applyCollapseDirection: function() {
        var e = this,
        t = e.collapseEl,
        n = e.collapseDirProps[e.collapseDirection],
        r;
        if (t) {
            r = t.lastCollapseDirCls;
            if (r) {
                t.removeCls(r)
            }
            t.addCls(t.lastCollapseDirCls = n.cls)
        }
    },
    applyOrientation: function() {
        var e = this,
        t = e.orientation,
        n = e.orientationProps[t],
        r = e.size,
        i = n.fixedAxis,
        s = n.stretchedAxis,
        o = e.baseCls + "-";
        e[t] = true;
        e[n.opposite] = false;
        if (!e.hasOwnProperty(i) || e[i] === "100%") {
            e[i] = r
        }
        if (!e.hasOwnProperty(s) || e[s] === r) {
            e[s] = "100%"
        }
        e.removeCls(o + n.opposite);
        e.addCls(o + t)
    },
    setOrientation: function(e) {
        var t = this;
        if (t.orientation !== e) {
            t.orientation = e;
            t.applyOrientation()
        }
    },
    updateOrientation: function() {
        delete this.collapseDirection;
        this.getCollapseDirection();
        this.applyCollapseDirection()
    },
    toggleTargetCmp: function(e, t) {
        var n = this.getCollapseTarget(),
        r = n.placeholder,
        i;
        if (Ext.isFunction(n.expand) && Ext.isFunction(n.collapse)) {
            if (r && !r.hidden) {
                i = true
            } else {
                i = !n.hidden
            }
            if (i) {
                if (n.collapsed) {
                    n.expand()
                } else {
                    if (n.collapseDirection) {
                        n.collapse()
                    } else {
                        n.collapse(this.renderData.collapseDir)
                    }
                }
            }
        }
    },
    setSize: function() {
        var e = this;
        e.callParent(arguments);
        if (Ext.isIE && e.el) {
            e.el.repaint()
        }
    },
    beforeDestroy: function() {
        Ext.destroy(this.tracker);
        this.callParent()
    }
});Ext.define("Ext.resizer.BorderSplitter", {
    extend: Ext.resizer.Splitter,
    alias: "widget.bordersplitter",
    collapseTarget: null,
    getTrackerConfig: function() {
        var e = this.callParent();
        e.xclass = "Ext.resizer.BorderSplitterTracker";
        return e
    }
});Ext.define("Ext.layout.container.Border", {
    extend: Ext.layout.container.Container,
    alias: "layout.border",
    alternateClassName: "Ext.layout.BorderLayout",
    targetCls: Ext.baseCSSPrefix + "border-layout-ct",
    itemCls: [Ext.baseCSSPrefix + "border-item", Ext.baseCSSPrefix + "box-item"],
    type: "border",
    isBorderLayout: true,
    padding: undefined,
    percentageRe: /(\d+)%/,
    horzPositionProp: "left",
    padOnContainerProp: "left",
    padNotOnContainerProp: "right",
    axisProps: {
        horz: {
            borderBegin: "west",
            borderEnd: "east",
            horizontal: true,
            posProp: "x",
            sizeProp: "width",
            sizePropCap: "Width"
        },
        vert: {
            borderBegin: "north",
            borderEnd: "south",
            horizontal: false,
            posProp: "y",
            sizeProp: "height",
            sizePropCap: "Height"
        }
    },
    centerRegion: null,
    manageMargins: true,
    panelCollapseAnimate: true,
    panelCollapseMode: "placeholder",
    regionWeights: {
        north: 20,
        south: 10,
        center: 0,
        west: -10,
        east: -20
    },
    beginAxis: function(e, t, n) {
        var r = this,
        i = r.axisProps[n],
        s = !i.horizontal,
        o = i.sizeProp,
        u = 0,
        a = e.childItems,
        f = a.length,
        l,
        c,
        h,
        p,
        d,
        v,
        m,
        g,
        y,
        b,
        w;
        for (c = 0; c < f; ++c) {
            h = a[c];
            d = h.target;
            h.layoutPos = {};
            if (d.region) {
                h.region = v = d.region;
                h.isCenter = d.isCenter;
                h.isHorz = d.isHorz;
                h.isVert = d.isVert;
                h.weight = d.weight || r.regionWeights[v] || 0;
                t[d.id] = h;
                if (d.isCenter) {
                    l = h;
                    p = d.flex;
                    e.centerRegion = l;
                    continue
                }
                if (s !== h.isVert) {
                    continue
                }
                h.reverseWeighting = v == i.borderEnd;
                g = d[o];
                y = typeof g;
                if (!d.collapsed) {
                    if (y == "string" && (m = r.percentageRe.exec(g))) {
                        h.percentage = parseInt(m[1], 10)
                    } else {
                        if (d.flex) {
                            u += h.flex = d.flex
                        }
                    }
                }
            }
        }
        if (l) {
            b = l.target;
            if (w = b.placeholderFor) {
                if (!p && s === w.collapsedVertical()) {
                    p = 0;
                    l.collapseAxis = n
                }
            } else {
                if (b.collapsed && s === b.collapsedVertical()) {
                    p = 0;
                    l.collapseAxis = n
                }
            }
        }
        if (p == null) {
            p = 1
        }
        u += p;
        return Ext.apply({
            before: s ? "top": "left",
            totalFlex: u
        },
        i)
    },
    beginLayout: function(e) {
        var t = this,
        n = t.getLayoutItems(),
        r = t.padding,
        i = typeof r,
        s = false,
        o,
        u,
        a,
        f,
        l,
        c,
        h,
        p,
        d;
        if (r) {
            if (i == "string" || i == "number") {
                r = Ext.util.Format.parseBox(r)
            }
        } else {
            r = e.getEl("getTargetEl").getPaddingInfo();
            s = true
        }
        e.outerPad = r;
        e.padOnContainer = s;
        for (f = 0, a = n.length; f < a; ++f) {
            u = n[f];
            c = t.getSplitterTarget(u);
            if (c) {
                h = undefined;
                p = !!u.hidden;
                if (!c.split) {
                    if (c.isCollapsingOrExpanding) {
                        h = !!c.collapsed
                    }
                } else {
                    if (p !== c.hidden) {
                        h = !c.hidden
                    }
                }
                if (h) {
                    u.show()
                } else {
                    if (h === false) {
                        u.hide()
                    }
                }
            }
        }
        t.callParent(arguments);
        n = e.childItems;
        a = n.length;
        l = {};
        e.borderAxisHorz = t.beginAxis(e, l, "horz");
        e.borderAxisVert = t.beginAxis(e, l, "vert");
        for (f = 0; f < a; ++f) {
            o = n[f];
            c = t.getSplitterTarget(o.target);
            if (c) {
                d = l[c.id];
                if (!d) {
                    d = e.getEl(c.el, t);
                    d.region = c.region
                }
                o.collapseTarget = c = d;
                o.weight = c.weight;
                o.reverseWeighting = c.reverseWeighting;
                c.splitter = o;
                o.isHorz = c.isHorz;
                o.isVert = c.isVert
            }
        }
        t.sortWeightedItems(n, "reverseWeighting");
        t.setupSplitterNeighbors(n)
    },
    calculate: function(e) {
        var t = this,
        n = t.getContainerSize(e),
        r = e.childItems,
        i = r.length,
        s = e.borderAxisHorz,
        o = e.borderAxisVert,
        u = e.outerPad,
        a = e.padOnContainer,
        f,
        l,
        c,
        h,
        p,
        d;
        s.begin = u[t.padOnContainerProp];
        o.begin = u.top;
        p = s.end = s.flexSpace = n.width + (a ? u[t.padOnContainerProp] : -u[t.padNotOnContainerProp]);
        d = o.end = o.flexSpace = n.height + (a ? u.top: -u.bottom);
        for (f = 0; f < i; ++f) {
            l = r[f];
            c = l.getMarginInfo();
            if (l.isHorz || l.isCenter) {
                s.addUnflexed(c.width);
                p -= c.width
            }
            if (l.isVert || l.isCenter) {
                o.addUnflexed(c.height);
                d -= c.height
            }
            if (!l.flex && !l.percentage) {
                if (l.isHorz || l.isCenter && l.collapseAxis === "horz") {
                    h = l.getProp("width");
                    s.addUnflexed(h);
                    if (l.collapseTarget) {
                        p -= h
                    }
                } else {
                    if (l.isVert || l.isCenter && l.collapseAxis === "vert") {
                        h = l.getProp("height");
                        o.addUnflexed(h);
                        if (l.collapseTarget) {
                            d -= h
                        }
                    }
                }
            }
        }
        for (f = 0; f < i; ++f) {
            l = r[f];
            c = l.getMarginInfo();
            if (l.percentage) {
                if (l.isHorz) {
                    h = Math.ceil(p * l.percentage / 100);
                    h = l.setWidth(h);
                    s.addUnflexed(h)
                } else {
                    if (l.isVert) {
                        h = Math.ceil(d * l.percentage / 100);
                        h = l.setHeight(h);
                        o.addUnflexed(h)
                    }
                }
            }
        }
        for (f = 0; f < i; ++f) {
            l = r[f];
            if (!l.isCenter) {
                t.calculateChildAxis(l, s);
                t.calculateChildAxis(l, o)
            }
        }
        if (t.finishAxis(e, o) + t.finishAxis(e, s) < 2) {
            t.done = false
        } else {
            t.finishPositions(r)
        }
    },
    calculateChildAxis: function(e, t) {
        var n = e.collapseTarget,
        r = "set" + t.sizePropCap,
        i = t.sizeProp,
        s = e.getMarginInfo()[i],
        o,
        u,
        a,
        f,
        l;
        if (n) {
            o = n.region
        } else {
            o = e.region;
            a = e.flex
        }
        u = o == t.borderBegin;
        if (!u && o != t.borderEnd) {
            e[r](t.end - t.begin - s);
            f = t.begin
        } else {
            if (a) {
                l = Math.ceil(t.flexSpace * (a / t.totalFlex));
                l = e[r](l)
            } else {
                if (e.percentage) {
                    l = e.peek(i)
                } else {
                    l = e.getProp(i)
                }
            }
            l += s;
            if (u) {
                f = t.begin;
                t.begin += l
            } else {
                t.end = f = t.end - l
            }
        }
        e.layoutPos[t.posProp] = f
    },
    finishAxis: function(e, t) {
        var n = t.end - t.begin,
        r = e.centerRegion;
        if (r) {
            r["set" + t.sizePropCap](n - r.getMarginInfo()[t.sizeProp]);
            r.layoutPos[t.posProp] = t.begin
        }
        return Ext.isNumber(n) ? 1 : 0
    },
    finishPositions: function(e) {
        var t = e.length,
        n, r, i = this.horzPositionProp;
        for (n = 0; n < t; ++n) {
            r = e[n];
            r.setProp("x", r.layoutPos.x + r.marginInfo[i]);
            r.setProp("y", r.layoutPos.y + r.marginInfo.top)
        }
    },
    getLayoutItems: function() {
        var e = this.owner,
        t = e && e.items && e.items.items || [],
        n = t.length,
        r = [],
        i = 0,
        s,
        o;
        for (; i < n; i++) {
            s = t[i];
            o = s.placeholderFor;
            if (s.hidden || (!s.floated || s.isCollapsingOrExpanding === 2) && !(o && o.isCollapsingOrExpanding === 2)) {
                r.push(s)
            }
        }
        return r
    },
    getPlaceholder: function(e) {
        return e.getPlaceholder && e.getPlaceholder()
    },
    getSplitterTarget: function(e) {
        var t = e.collapseTarget;
        if (t && t.collapsed) {
            return t.placeholder || t
        }
        return t
    },
    isItemBoxParent: function(e) {
        return true
    },
    isItemShrinkWrap: function(e) {
        return true
    },
    insertSplitter: function(e, t, n, r) {
        var i = e.region,
        s = Ext.apply({
            xtype: "bordersplitter",
            collapseTarget: e,
            id: e.id + "-splitter",
            hidden: n,
            canResize: e.splitterResize !== false,
            splitterFor: e
        },
        r),
        o = t + (i === "south" || i === "east" ? 0 : 1);
        if (e.collapseMode === "mini") {
            s.collapsedCls = e.collapsedCls
        }
        e.splitter = this.owner.add(o, s)
    },
    onAdd: function(e, t) {
        var n = this,
        r = e.placeholderFor,
        i = e.region,
        s, o, u, a;
        n.callParent(arguments);
        if (i) {
            Ext.apply(e, n.regionFlags[i]);
            if (e.initBorderRegion) {
                e.initBorderRegion()
            }
            s = i === "center";
            if (s) {
                n.centerRegion = e
            } else {
                o = e.split;
                u = !!e.hidden;
                if (typeof o === "object") {
                    a = o;
                    o = true
                }
                if ((e.isHorz || e.isVert) && (o || e.collapseMode == "mini")) {
                    n.insertSplitter(e, t, u || !o, a)
                }
            }
            if (!s && !e.hasOwnProperty("collapseMode")) {
                e.collapseMode = n.panelCollapseMode
            }
            if (!e.hasOwnProperty("animCollapse")) {
                if (e.collapseMode !== "placeholder") {
                    e.animCollapse = false
                } else {
                    e.animCollapse = n.panelCollapseAnimate
                }
            }
        } else {
            if (r) {
                Ext.apply(e, n.regionFlags[r.region]);
                e.region = r.region;
                e.weight = r.weight
            }
        }
    },
    onDestroy: function() {
        this.centerRegion = null;
        this.callParent()
    },
    onRemove: function(e, t) {
        var n = this,
        r = e.region,
        i = e.splitter,
        s = n.owner,
        o = s.destroying,
        u;
        if (r) {
            if (e.isCenter) {
                n.centerRegion = null
            }
            delete e.isCenter;
            delete e.isHorz;
            delete e.isVert;
            if (i && !s.destroying) {
                s.doRemove(i, true)
            }
            delete e.splitter
        }
        n.callParent(arguments);
        if (!o && !t && e.rendered) {
            u = e.getEl();
            u.setStyle("top", "");
            u.setStyle(n.horzPositionProp, "")
        }
    },
    regionMeta: {
        center: {
            splitterDelta: 0
        },
        north: {
            splitterDelta: 1
        },
        south: {
            splitterDelta: -1
        },
        west: {
            splitterDelta: 1
        },
        east: {
            splitterDelta: -1
        }
    },
    regionFlags: {
        center: {
            isCenter: true,
            isHorz: false,
            isVert: false
        },
        north: {
            isCenter: false,
            isHorz: false,
            isVert: true,
            collapseDirection: "top"
        },
        south: {
            isCenter: false,
            isHorz: false,
            isVert: true,
            collapseDirection: "bottom"
        },
        west: {
            isCenter: false,
            isHorz: true,
            isVert: false,
            collapseDirection: "left"
        },
        east: {
            isCenter: false,
            isHorz: true,
            isVert: false,
            collapseDirection: "right"
        }
    },
    setupSplitterNeighbors: function(e) {
        var t = {},
        n = e.length,
        r = this.touchedRegions,
        i, s, o, u, a, f, l, c, h;
        for (i = 0; i < n; ++i) {
            f = e[i].target;
            l = f.region;
            if (f.isCenter) {
                o = f
            } else {
                if (l) {
                    h = r[l];
                    for (s = 0, u = h.length; s < u; ++s) {
                        a = t[h[s]];
                        if (a) {
                            a.neighbors.push(f)
                        }
                    }
                    if (f.placeholderFor) {
                        c = f.placeholderFor.splitter
                    } else {
                        c = f.splitter
                    }
                    if (c) {
                        c.neighbors = []
                    }
                    t[l] = c
                }
            }
        }
        if (o) {
            h = r.center;
            for (s = 0, u = h.length; s < u; ++s) {
                a = t[h[s]];
                if (a) {
                    a.neighbors.push(o)
                }
            }
        }
    },
    touchedRegions: {
        center: ["north", "south", "east", "west"],
        north: ["north", "east", "west"],
        south: ["south", "east", "west"],
        east: ["east", "north", "south"],
        west: ["west", "north", "south"]
    },
    sizePolicies: {
        vert: {
            readsWidth: 0,
            readsHeight: 1,
            setsWidth: 1,
            setsHeight: 0
        },
        horz: {
            readsWidth: 1,
            readsHeight: 0,
            setsWidth: 0,
            setsHeight: 1
        },
        flexAll: {
            readsWidth: 0,
            readsHeight: 0,
            setsWidth: 1,
            setsHeight: 1
        }
    },
    getItemSizePolicy: function(e) {
        var t = this,
        n = this.sizePolicies,
        r, i, s, o;
        if (e.isCenter) {
            o = e.placeholderFor;
            if (o) {
                if (o.collapsedVertical()) {
                    return n.vert
                }
                return n.horz
            }
            if (e.collapsed) {
                if (e.collapsedVertical()) {
                    return n.vert
                }
                return n.horz
            }
            return n.flexAll
        }
        r = e.collapseTarget;
        if (r) {
            return r.isVert ? n.vert: n.horz
        }
        if (e.region) {
            if (e.isVert) {
                i = e.height;
                s = n.vert
            } else {
                i = e.width;
                s = n.horz
            }
            if (e.flex || typeof i == "string" && t.percentageRe.test(i)) {
                return n.flexAll
            }
            return s
        }
        return t.autoSizePolicy
    }
},
function() {
    var e = {
        addUnflexed: function(e) {
            this.flexSpace = Math.max(this.flexSpace - e, 0)
        }
    },
    t = this.prototype.axisProps;
    Ext.apply(t.horz, e);
    Ext.apply(t.vert, e)
});Ext.define("Ext.layout.container.Card", {
    extend: Ext.layout.container.Fit,
    alternateClassName: "Ext.layout.CardLayout",
    alias: "layout.card",
    type: "card",
    hideInactive: true,
    deferredRender: false,
    getRenderTree: function() {
        var e = this,
        t = e.getActiveItem();
        if (t) {
            if (t.hasListeners.beforeactivate && t.fireEvent("beforeactivate", t) === false) {
                t = e.activeItem = e.owner.activeItem = null
            } else {
                if (t.hasListeners.activate) {
                    t.on({
                        boxready: function() {
                            t.fireEvent("activate", t)
                        },
                        single: true
                    })
                }
            }
            if (e.deferredRender) {
                if (t) {
                    return e.getItemsRenderTree([t])
                }
            } else {
                return e.callParent(arguments)
            }
        }
    },
    renderChildren: function() {
        var e = this,
        t = e.getActiveItem();
        if (!e.deferredRender) {
            e.callParent()
        } else {
            if (t) {
                e.renderItems([t], e.getRenderTarget())
            }
        }
    },
    isValidParent: function(e, t, n) {
        var r = e.el ? e.el.dom: Ext.getDom(e);
        return r && r.parentNode === (t.dom || t) || false
    },
    getActiveItem: function() {
        var e = this,
        t = e.parseActiveItem(e.activeItem || e.owner && e.owner.activeItem);
        if (t && e.owner.items.indexOf(t) != -1) {
            e.activeItem = t
        } else {
            e.activeItem = null
        }
        return e.activeItem
    },
    parseActiveItem: function(e) {
        if (e && e.isComponent) {
            return e
        } else {
            if (typeof e == "number" || e === undefined) {
                return this.getLayoutItems()[e || 0]
            } else {
                return this.owner.getComponent(e)
            }
        }
    },
    configureItem: function(e) {
        if (e === this.getActiveItem()) {
            e.hidden = false
        } else {
            e.hidden = true
        }
        this.callParent(arguments)
    },
    onRemove: function(e) {
        this.callParent(arguments);
        if (e === this.activeItem) {
            this.activeItem = null
        }
    },
    getAnimation: function(e, t) {
        var n = (e || {}).cardSwitchAnimation;
        if (n === false) {
            return false
        }
        return n || t.cardSwitchAnimation
    },
    getNext: function() {
        var e = arguments[0],
        t = this.getLayoutItems(),
        n = Ext.Array.indexOf(t, this.activeItem);
        return t[n + 1] || (e ? t[0] : false)
    },
    next: function() {
        var e = arguments[0],
        t = arguments[1];
        return this.setActiveItem(this.getNext(t), e)
    },
    getPrev: function() {
        var e = arguments[0],
        t = this.getLayoutItems(),
        n = Ext.Array.indexOf(t, this.activeItem);
        return t[n - 1] || (e ? t[t.length - 1] : false)
    },
    prev: function() {
        var e = arguments[0],
        t = arguments[1];
        return this.setActiveItem(this.getPrev(t), e)
    },
    setActiveItem: function(e) {
        var t = this,
        n = t.owner,
        r = t.activeItem,
        i = n.rendered,
        s = n.items.items.length,
        o;
        e = t.parseActiveItem(e);
        o = n.items.indexOf(e);
        if (o == -1) {
            o = s;
            Ext.suspendLayouts();
            e = n.add(e);
            Ext.resumeLayouts()
        }
        if (s == 1) {
            r = null
        }
        if (e && r != e) {
            if (e.fireEvent("beforeactivate", e, r) === false) {
                return false
            }
            if (r && r.fireEvent("beforedeactivate", r, e) === false) {
                return false
            }
            if (i) {
                Ext.suspendLayouts();
                if (!e.rendered) {
                    t.renderItem(e, t.getRenderTarget(), n.items.length)
                }
                if (r) {
                    if (t.hideInactive) {
                        r.hide();
                        r.hiddenByLayout = true
                    }
                    r.fireEvent("deactivate", r, e)
                }
                if (e.hidden) {
                    e.show()
                }
                if (!e.hidden) {
                    t.activeItem = e
                }
                Ext.resumeLayouts(true)
            } else {
                t.activeItem = e
            }
            e.fireEvent("activate", e, r);
            return t.activeItem
        }
        return false
    }
});Ext.define("Ext.layout.container.Column", {
    extend: Ext.layout.container.Auto,
    alias: ["layout.column"],
    alternateClassName: "Ext.layout.ColumnLayout",
    type: "column",
    itemCls: Ext.baseCSSPrefix + "column",
    targetCls: Ext.baseCSSPrefix + "column-layout-ct",
    columnWidthSizePolicy: {
        readsWidth: 0,
        readsHeight: 1,
        setsWidth: 1,
        setsHeight: 0
    },
    createsInnerCt: true,
    manageOverflow: true,
    isItemShrinkWrap: function(e) {
        return true
    },
    getItemSizePolicy: function(e, t) {
        if (e.columnWidth) {
            if (!t) {
                t = this.owner.getSizeModel()
            }
            if (!t.width.shrinkWrap) {
                return this.columnWidthSizePolicy
            }
        }
        return this.autoSizePolicy
    },
    calculateItems: function(e, t) {
        var n = this,
        r = e.targetContext,
        i = e.childItems,
        s = i.length,
        o = 0,
        u = t.gotWidth,
        a, f, l, c, h, p;
        if (u === false) {
            r.domBlock(n, "width");
            a = true
        } else {
            if (u) {
                f = t.width
            } else {
                return true
            }
        }
        for (l = 0; l < s; ++l) {
            c = i[l];
            h = c.getMarginInfo().width;
            if (!c.widthModel.calculated) {
                p = c.getProp("width");
                if (typeof p != "number") {
                    c.block(n, "width");
                    a = true
                }
                o += p + h
            }
        }
        if (!a) {
            f = f < o ? 0 : f - o;
            for (l = 0; l < s; ++l) {
                c = i[l];
                if (c.widthModel.calculated) {
                    h = c.marginInfo.width;
                    p = c.target.columnWidth;
                    p = Math.floor(p * f) - h;
                    p = c.setWidth(p);
                    o += p + h
                }
            }
            e.setContentWidth(o + e.paddingContext.getPaddingInfo().width)
        }
        return ! a
    },
    setCtSizeIfNeeded: function(e, t) {
        var n = this,
        r = e.paddingContext.getPaddingInfo();
        n.callParent(arguments);
        if ((Ext.isIEQuirks || Ext.isIE7m) && n.isShrinkWrapTpl && r.right) {
            e.outerCtContext.setProp("width", t.width + r.left)
        }
    }
});Ext.define("Ext.layout.container.Form", {
    alias: "layout.form",
    extend: Ext.layout.container.Container,
    alternateClassName: "Ext.layout.FormLayout",
    tableCls: Ext.baseCSSPrefix + "form-layout-table",
    type: "form",
    createsInnerCt: true,
    manageOverflow: true,
    lastOverflowAdjust: {
        width: 0,
        height: 0
    },
    childEls: ["formTable"],
    padRow: '<tr role="presentation"><td class="' + Ext.baseCSSPrefix + 'form-item-pad" colspan="3" role="presentation"></td></tr>',
    renderTpl: ['<table id="{ownerId}-formTable" class="{tableCls}" style="width:100%" cellpadding="0" role="presentation">', "{%this.renderBody(out,values)%}", "</table>", "{%this.renderPadder(out,values)%}"],
    getRenderData: function() {
        var e = this.callParent();
        e.tableCls = this.tableCls;
        return e
    },
    calculate: function(e) {
        var t = this,
        n = t.getContainerSize(e, true),
        r,
        i,
        s = 0,
        o,
        u = e.sizeModel.height.shrinkWrap;
        if (u) {
            if (e.hasDomProp("containerChildrenSizeDone")) {
                e.setProp("contentHeight", t.formTable.dom.offsetHeight + e.targetContext.getPaddingInfo().height)
            } else {
                t.done = false
            }
        }
        if (n.gotWidth) {
            r = t.formTable.dom.offsetWidth;
            i = e.childItems;
            for (o = i.length; s < o; ++s) {
                i[s].setWidth(r, false)
            }
        } else {
            t.done = false
        }
    },
    getRenderTarget: function() {
        return this.formTable
    },
    getRenderTree: function() {
        var e = this,
        t = e.callParent(arguments),
        n,
        r;
        for (n = 0, r = t.length; n < r; n++) {
            t[n] = e.transformItemRenderTree(t[n])
        }
        return t
    },
    transformItemRenderTree: function(e) {
        if (e.tag && e.tag == "table") {
            e.tag = "tbody";
            e.role = "presentation";
            delete e.cellspacing;
            delete e.cellpadding;
            if (Ext.isIE6) {
                e.cn = this.padRow
            }
            return e
        }
        return {
            tag: "tbody",
            role: "presentation",
            cn: {
                tag: "tr",
                role: "presentation",
                cn: {
                    tag: "td",
                    role: "presentation",
                    colspan: 3,
                    style: "width:100%",
                    cn: e
                }
            }
        }
    },
    isValidParent: function(e, t, n) {
        return true
    },
    isItemShrinkWrap: function(e) {
        return (e.shrinkWrap === true ? 3 : e.shrinkWrap || 0) & 2
    },
    getItemSizePolicy: function(e) {
        return {
            setsWidth: 1,
            setsHeight: 0
        }
    },
    beginLayoutCycle: function(e, t) {
        var n = this.overflowPadderEl;
        if (n) {
            n.setStyle("display", "none")
        }
        if (!e.state.overflowAdjust) {
            e.state.overflowAdjust = this.lastOverflowAdjust
        }
    },
    calculateOverflow: function(e, t, n) {
        var r = this,
        i = e.targetContext,
        s = r.manageOverflow,
        o = e.state,
        u = o.overflowAdjust,
        a, f, l, c, h, p, d, v, m, g, y, b, w;
        if (s && !o.secondPass && !r.reserveScrollbar) {
            b = r.getOverflowXStyle(e) === "auto";
            w = r.getOverflowYStyle(e) === "auto";
            if (!t.gotWidth) {
                b = false
            }
            if (!t.gotHeight) {
                w = false
            }
            if (b || w) {
                p = Ext.getScrollbarSize();
                d = e.peek("contentWidth");
                v = e.peek("contentHeight");
                c = i.getPaddingInfo();
                d -= c.width;
                v -= c.height;
                m = t.width;
                g = t.height;
                y = r.getScrollbarsNeeded(m, g, d, v);
                o.overflowState = y;
                if (typeof n == "number") {
                    y &= ~n
                }
                u = {
                    width: b && y & 2 ? p.width: 0,
                    height: w && y & 1 ? p.height: 0
                };
                if (u.width !== r.lastOverflowAdjust.width || u.height !== r.lastOverflowAdjust.height) {
                    r.done = false;
                    e.invalidate({
                        state: {
                            overflowAdjust: u,
                            overflowState: o.overflowState,
                            secondPass: true
                        }
                    })
                }
            }
        }
        if (!r.done) {
            return
        }
        l = e.padElContext || (e.padElContext = e.getEl("overflowPadderEl", r));
        if (l) {
            y = o.overflowState;
            a = e.peek("contentWidth");
            f = 1;
            if (y) {
                c = i.getPaddingInfo();
                h = r.scrollRangeFlags;
                if (y & 2 && h & 1) {
                    f += c.bottom
                }
                if (y & 1 && h & 4) {
                    a += c.right
                }
                l.setProp("display", "");
                l.setSize(a, f)
            } else {
                l.setProp("display", "none")
            }
        }
    },
    completeLayout: function(e) {
        this.lastOverflowAdjust = e.state.overflowAdjust
    },
    doRenderPadder: function(e, t) {
        var n = t.$layout,
        r = n.owner,
        i = n.getScrollRangeFlags();
        if (n.manageOverflow) {
            if (i & 5) {
                e.push('<div id="', r.id, '-overflowPadderEl" role="presentation"', 'style="font-size: 1px; height: 1px; margin-top: -1px; position: relative; z-index: -99999');
                e.push('"></div>');
                n.scrollRangeFlags = i
            }
        }
    },
    getContainerSize: function(e, t, n) {
        var r = e.targetContext,
        i = r.getFrameInfo(),
        s = r.getPaddingInfo(),
        o = 0,
        u = 0,
        a = n ? null: e.state.overflowAdjust,
        f,
        l,
        c,
        h;
        if (!e.widthModel.shrinkWrap) {++u;
            c = t ? r.getDomProp("width") : r.getProp("width");
            f = typeof c == "number";
            if (f) {++o;
                c -= i.width + s.width;
                if (a) {
                    c -= a.width
                }
            }
        }
        if (!e.heightModel.shrinkWrap) {++u;
            h = t ? r.getDomProp("height") : r.getProp("height");
            l = typeof h == "number";
            if (l) {++o;
                h -= i.height + s.height;
                if (a) {
                    h -= a.height
                }
            }
        }
        return {
            width: c,
            height: h,
            needed: u,
            got: o,
            gotAll: o == u,
            gotWidth: f,
            gotHeight: l
        }
    },
    getOverflowXStyle: function(e) {
        var t = this;
        return t.overflowXStyle || (t.overflowXStyle = t.owner.scrollFlags.overflowX || e.targetContext.getStyle("overflow-x"))
    },
    getOverflowYStyle: function(e) {
        var t = this;
        return t.overflowYStyle || (t.overflowYStyle = t.owner.scrollFlags.overflowY || e.targetContext.getStyle("overflow-y"))
    },
    getScrollRangeFlags: function() {
        var e = -1;
        return function() {
            if (e < 0) {
                var t = Ext.getBody().createChild({
                    cls: Ext.baseCSSPrefix + "border-box",
                    role: "presentation",
                    style: {
                        width: "100px",
                        height: "100px",
                        padding: "10px",
                        overflow: "auto"
                    },
                    children: [{
                        role: "presentation",
                        style: {
                            border: "1px solid red",
                            width: "150px",
                            height: "150px",
                            margin: "0 5px 5px 0"
                        }
                    }]
                }),
                n = t.dom.scrollHeight,
                r = t.dom.scrollWidth,
                i = {
                    175 : 0,
                    165 : 1,
                    170 : 2,
                    160 : 3
                },
                s = {
                    175 : 0,
                    165 : 4,
                    170 : 8,
                    160 : 12
                };
                e = (i[n] || 0) | (s[r] || 0);
                t.remove()
            }
            return e
        }
    } (),
    initLayout: function() {
        var e = this,
        t = Ext.getScrollbarSize().width;
        e.callParent();
        if (t && e.manageOverflow && !e.hasOwnProperty("lastOverflowAdjust")) {
            if (e.owner.scrollFlags.y || e.reserveScrollbar) {
                e.lastOverflowAdjust = {
                    width: t,
                    height: 0
                }
            }
        }
    },
    setupRenderTpl: function(e) {
        this.callParent(arguments);
        e.renderPadder = this.doRenderPadder
    }
});Ext.define("Ext.menu.Item", {
    extend: Ext.Component,
    alias: "widget.menuitem",
    alternateClassName: "Ext.menu.TextItem",
    isMenuItem: true,
    mixins: {
        queryable: Ext.Queryable
    },
    activeCls: Ext.baseCSSPrefix + "menu-item-active",
    ariaRole: "menuitem",
    canActivate: true,
    clickHideDelay: 0,
    destroyMenu: true,
    disabledCls: Ext.baseCSSPrefix + "menu-item-disabled",
    hideOnClick: true,
    menuAlign: "tl-tr?",
    menuExpandDelay: 200,
    menuHideDelay: 200,
    tooltipType: "qtip",
    arrowCls: Ext.baseCSSPrefix + "menu-item-arrow",
    baseIconCls: Ext.baseCSSPrefix + "menu-item-icon",
    textCls: Ext.baseCSSPrefix + "menu-item-text",
    indentCls: Ext.baseCSSPrefix + "menu-item-indent",
    indentNoSeparatorCls: Ext.baseCSSPrefix + "menu-item-indent-no-separator",
    indentRightIconCls: Ext.baseCSSPrefix + "menu-item-indent-right-icon",
    indentRightArrowCls: Ext.baseCSSPrefix + "menu-item-indent-right-arrow",
    linkCls: Ext.baseCSSPrefix + "menu-item-link",
    childEls: ["itemEl", "iconEl", "textEl", "arrowEl"],
    renderTpl: ['<tpl if="plain">', "{text}", "<tpl else>", '<a id="{id}-itemEl"', ' class="{linkCls} {childElCls}"', ' href="{href}" role="presentation" ', '<tpl if="hrefTarget"> target="{hrefTarget}"</tpl>', ' hidefocus="true"', ' unselectable="on"', '<tpl if="tabIndex">', ' tabIndex="{tabIndex}"', "</tpl>", ">", '<span id="{id}-textEl" class="{textCls} {indentCls}{childElCls}" unselectable="on">{text}</span>', '<tpl if="hasIcon">', '<div role="presentation" id="{id}-iconEl" class="{baseIconCls}', '{[values.rightIcon ? "-right" : ""]} {iconCls}', '{childElCls} {glyphCls}" style="<tpl if="icon">background-image:url({icon});</tpl>', '<tpl if="glyph && glyphFontFamily">font-family:{glyphFontFamily};</tpl>">', '<tpl if="glyph">&#{glyph};</tpl>', "</div>", "</tpl>", '<tpl if="showCheckbox">', '<div role="presentation" id="{id}-checkEl" class="{baseIconCls}', '{[(values.hasIcon && !values.rightIcon) ? "-right" : ""]} ', '{groupCls} {checkboxCls}{childElCls}">', "</div>", "</tpl>", '<tpl if="hasMenu">', '<div role="presentation" id="{id}-arrowEl" class="{arrowCls}{childElCls}"></div>', "</tpl>", "</a>", "</tpl>"],
    maskOnDisable: false,
    iconAlign: "left",
    activate: function(e) {
        var t = this;
        if (e || !t.activated && t.canActivate && t.rendered && !t.isDisabled() && t.isVisible()) {
            if (!t.plain) {
                t.el.addCls(t.activeCls)
            }
            t.focus(false, true);
            t.activated = true;
            if (t.hasListeners.activate) {
                t.fireEvent("activate", t)
            }
        }
    },
    getFocusEl: function() {
        return this.itemEl
    },
    deactivate: function() {
        var e = this,
        t;
        if (e.activated) {
            t = e.up("");
            if (!e.plain) {
                e.el.removeCls(e.activeCls)
            }
            if (t) {
                t.focus(false, true)
            }
            e.hideMenu();
            e.activated = false;
            if (e.hasListeners.deactivate) {
                e.fireEvent("deactivate", e)
            }
        }
    },
    deferHideMenu: function() {
        if (this.menu.isVisible()) {
            this.menu.hide()
        }
    },
    cancelDeferHide: function() {
        clearTimeout(this.hideMenuTimer)
    },
    deferHideParentMenus: function() {
        var e;
        Ext.menu.Manager.hideAll();
        if (!Ext.Element.getActiveElement()) {
            e = this.up(":not([hidden])");
            if (e) {
                e.focus()
            }
        }
    },
    expandMenu: function(e) {
        var t = this;
        if (t.menu) {
            t.cancelDeferHide();
            if (e === 0) {
                t.doExpandMenu()
            } else {
                clearTimeout(t.expandMenuTimer);
                t.expandMenuTimer = Ext.defer(t.doExpandMenu, Ext.isNumber(e) ? e: t.menuExpandDelay, t)
            }
        }
    },
    doExpandMenu: function() {
        var e = this,
        t = e.menu;
        if (e.activated && (!t.rendered || !t.isVisible())) {
            e.parentMenu.activeChild = t;
            t.ownerCmp = t.ownerItem = e;
            t.parentMenu = e.parentMenu;
            t.constrainTo = document.body;
            t.showBy(e, e.menuAlign)
        }
    },
    getRefItems: function(e) {
        var t = this.menu,
        n;
        if (t) {
            n = t.getRefItems(e);
            n.unshift(t)
        }
        return n || []
    },
    hideMenu: function(e) {
        var t = this;
        if (t.menu) {
            clearTimeout(t.expandMenuTimer);
            t.hideMenuTimer = Ext.defer(t.deferHideMenu, Ext.isNumber(e) ? e: t.menuHideDelay, t)
        }
    },
    initComponent: function() {
        var e = this,
        t = Ext.baseCSSPrefix,
        n = [t + "menu-item"],
        r;
        e.addEvents("activate", "click", "deactivate", "textchange", "iconchange");
        if (e.plain) {
            n.push(t + "menu-item-plain")
        }
        if (e.cls) {
            n.push(e.cls)
        }
        e.cls = n.join(" ");
        if (e.menu) {
            r = e.menu;
            delete e.menu;
            e.setMenu(r)
        }
        e.callParent(arguments)
    },
    onClick: function(e) {
        var t = this,
        n = t.clickHideDelay,
        r = e.browserEvent,
        i;
        if (!t.href || t.disabled) {
            e.stopEvent()
        }
        if (t.disabled || t.handlingClick) {
            return
        }
        if (t.hideOnClick) {
            if (!n) {
                t.deferHideParentMenus()
            } else {
                t.deferHideParentMenusTimer = Ext.defer(t.deferHideParentMenus, n, t)
            }
        }
        Ext.callback(t.handler, t.scope || t, [t, e]);
        t.fireEvent("click", t, e);
        if (Ext.isIE9m || Ext.isIEQuirks) {
            i = r.returnValue === false ? true: false
        } else {
            i = !!r.defaultPrevented
        }
        if (t.href && !i) {
            t.handlingClick = true;
            t.itemEl.dom.click();
            delete t.handlingClick
        }
        if (!t.hideOnClick) {
            t.focus()
        }
    },
    onRemoved: function() {
        var e = this;
        if (e.activated && e.parentMenu.activeItem === e) {
            e.parentMenu.deactivateActiveItem()
        }
        e.callParent(arguments);
        e.parentMenu = e.ownerCmp = e.ownerButton = null
    },
    beforeDestroy: function() {
        var e = this;
        if (e.rendered) {
            e.clearTip()
        }
        e.callParent()
    },
    onDestroy: function() {
        var e = this;
        clearTimeout(e.expandMenuTimer);
        e.cancelDeferHide();
        clearTimeout(e.deferHideParentMenusTimer);
        e.setMenu(null);
        e.callParent(arguments)
    },
    beforeRender: function() {
        var e = this,
        t = e.glyph,
        n = Ext._glyphFontFamily,
        r = !!(e.icon || e.iconCls || t),
        i = !!e.menu,
        s = e.iconAlign === "right" && !i,
        o = e.isMenuCheckItem,
        u = [],
        a = e.ownerCt,
        f = a.plain,
        l;
        e.callParent();
        if (r) {
            if (i && e.showCheckbox) {
                r = false
            }
        }
        if (typeof t === "string") {
            l = t.split("@");
            t = l[0];
            n = l[1]
        }
        if (!f || r && !s || o) {
            if (a.showSeparator && !f) {
                u.push(e.indentCls)
            } else {
                u.push(e.indentNoSeparatorCls)
            }
        }
        if (i) {
            u.push(e.indentRightArrowCls)
        } else {
            if (r && (s || o)) {
                u.push(e.indentRightIconCls)
            }
        }
        Ext.applyIf(e.renderData, {
            href: e.href || "#",
            hrefTarget: e.hrefTarget,
            icon: e.icon,
            iconCls: e.iconCls,
            glyph: t,
            glyphCls: t ? Ext.baseCSSPrefix + "menu-item-glyph": undefined,
            glyphFontFamily: n,
            hasIcon: r,
            hasMenu: i,
            indent: !f || r || o,
            isCheckItem: o,
            rightIcon: s,
            plain: e.plain,
            text: e.text,
            arrowCls: e.arrowCls,
            baseIconCls: e.baseIconCls,
            textCls: e.textCls,
            indentCls: u.join(" "),
            linkCls: e.linkCls,
            groupCls: e.group ? e.groupCls: "",
            tabIndex: e.tabIndex
        })
    },
    onRender: function() {
        var e = this;
        e.callParent(arguments);
        if (e.tooltip) {
            e.setTooltip(e.tooltip, true)
        }
    },
    setMenu: function(e, t) {
        var n = this,
        r = n.menu,
        i = n.arrowEl;
        if (r) {
            r.ownerCmp = r.ownerItem = r.parentMenu = null;
            if (t === true || t !== false && n.destroyMenu) {
                Ext.destroy(r)
            }
        }
        if (e) {
            n.menu = Ext.menu.Manager.get(e);
            n.menu.ownerCmp = n.menu.ownerItem = n
        } else {
            n.menu = null
        }
        if (n.rendered && !n.destroying && i) {
            i[n.menu ? "addCls": "removeCls"](n.arrowCls)
        }
    },
    setHandler: function(e, t) {
        this.handler = e || null;
        this.scope = t
    },
    setIcon: function(e) {
        var t = this.iconEl,
        n = this.icon;
        if (t) {
            t.src = e || Ext.BLANK_IMAGE_URL
        }
        this.icon = e;
        this.fireEvent("iconchange", this, n, e)
    },
    setIconCls: function(e) {
        var t = this,
        n = t.iconEl,
        r = t.iconCls;
        if (n) {
            if (t.iconCls) {
                n.removeCls(t.iconCls)
            }
            if (e) {
                n.addCls(e)
            }
        }
        t.iconCls = e;
        t.fireEvent("iconchange", t, r, e)
    },
    setText: function(e) {
        var t = this,
        n = t.textEl || t.el,
        r = t.text;
        t.text = e;
        if (t.rendered) {
            n.update(e || "");
            t.ownerCt.updateLayout()
        }
        t.fireEvent("textchange", t, r, e)
    },
    getTipAttr: function() {
        return this.tooltipType == "qtip" ? "data-qtip": "title"
    },
    clearTip: function() {
        if (Ext.quickTipsActive && Ext.isObject(this.tooltip)) {
            Ext.tip.QuickTipManager.unregister(this.itemEl)
        }
    },
    setTooltip: function(e, t) {
        var n = this;
        if (n.rendered) {
            if (!t) {
                n.clearTip()
            }
            if (Ext.quickTipsActive && Ext.isObject(e)) {
                Ext.tip.QuickTipManager.register(Ext.apply({
                    target: n.itemEl.id
                },
                e));
                n.tooltip = e
            } else {
                n.itemEl.dom.setAttribute(n.getTipAttr(), e)
            }
        } else {
            n.tooltip = e
        }
        return n
    }
});Ext.define("Ext.menu.CheckItem", {
    extend: Ext.menu.Item,
    alias: "widget.menucheckitem",
    checkedCls: Ext.baseCSSPrefix + "menu-item-checked",
    uncheckedCls: Ext.baseCSSPrefix + "menu-item-unchecked",
    groupCls: Ext.baseCSSPrefix + "menu-group-icon",
    hideOnClick: false,
    checkChangeDisabled: false,
    ariaRole: "menuitemcheckbox",
    childEls: ["itemEl", "iconEl", "textEl", "checkEl"],
    showCheckbox: true,
    isMenuCheckItem: true,
    checkboxCls: Ext.baseCSSPrefix + "menu-item-checkbox",
    initComponent: function() {
        var e = this;
        e.checked = !!e.checked;
        e.addEvents("beforecheckchange", "checkchange");
        e.callParent(arguments);
        Ext.menu.Manager.registerCheckable(e);
        if (e.group) {
            if (e.initialConfig.hideOnClick !== false) {
                e.hideOnClick = true
            }
        }
    },
    beforeRender: function() {
        var e = this;
        e.callParent();
        Ext.apply(e.renderData, {
            checkboxCls: e.checkboxCls,
            showCheckbox: e.showCheckbox
        })
    },
    afterRender: function() {
        var e = this;
        e.callParent();
        e.checked = !e.checked;
        e.setChecked(!e.checked, true);
        if (e.checkChangeDisabled) {
            e.disableCheckChange()
        }
    },
    disableCheckChange: function() {
        var e = this,
        t = e.checkEl;
        if (t) {
            t.addCls(e.disabledCls)
        }
        if (! (Ext.isIE10p || Ext.isIE9 && Ext.isStrict) && e.rendered) {
            e.el.repaint()
        }
        e.checkChangeDisabled = true
    },
    enableCheckChange: function() {
        var e = this,
        t = e.checkEl;
        if (t) {
            t.removeCls(e.disabledCls)
        }
        e.checkChangeDisabled = false
    },
    onClick: function(e) {
        var t = this;
        if (!t.disabled && !t.checkChangeDisabled && !(t.checked && t.group)) {
            t.setChecked(!t.checked)
        }
        this.callParent([e])
    },
    onDestroy: function() {
        Ext.menu.Manager.unregisterCheckable(this);
        this.callParent(arguments)
    },
    setChecked: function(e, t) {
        var n = this,
        r = n.checkedCls,
        i = n.uncheckedCls,
        s = n.el;
        if (n.checked !== e && (t || n.fireEvent("beforecheckchange", n, e) !== false)) {
            if (s) {
                if (e) {
                    s.addCls(r);
                    s.removeCls(i)
                } else {
                    s.addCls(i);
                    s.removeCls(r)
                }
            }
            n.checked = e;
            Ext.menu.Manager.onCheckChange(n, e);
            if (!t) {
                Ext.callback(n.checkHandler, n.scope || n, [n, e]);
                n.fireEvent("checkchange", n, e)
            }
        }
    }
});Ext.define("Ext.menu.KeyNav", {
    extend: Ext.util.KeyNav,
    constructor: function(e) {
        var t = this;
        t.menu = e.target;
        t.callParent([Ext.apply({
            down: t.down,
            enter: t.enter,
            esc: t.escape,
            left: t.left,
            right: t.right,
            space: t.enter,
            tab: t.tab,
            up: t.up
        },
        e)])
    },
    down: function(e) {
        var t = this,
        n = t.menu.focusedItem;
        if (n && e.getKey() == Ext.EventObject.DOWN && t.isWhitelisted(n)) {
            return true
        }
        t.focusNextItem(1)
    },
    enter: function(e) {
        var t = this.menu,
        n = t.focusedItem;
        if (t.activeItem) {
            t.onClick(e)
        } else {
            if (n && n.isFormField) {
                return true
            }
        }
    },
    escape: function(e) {
        Ext.menu.Manager.hideAll()
    },
    focusNextItem: function(e) {
        var t = this.menu,
        n = t.items,
        r = t.focusedItem,
        i = r ? n.indexOf(r) : -1,
        s = i + e,
        o = n.length,
        u = 0,
        a;
        while (u < o && s !== i) {
            if (s < 0) {
                s = o - 1
            } else {
                if (s >= o) {
                    s = 0
                }
            }
            a = n.getAt(s);
            if (t.canActivateItem(a)) {
                t.setActiveItem(a);
                break
            }
            s += e; ++u
        }
    },
    isWhitelisted: function(e) {
        var t = Ext.FocusManager;
        return t && t.isWhitelisted(e)
    },
    left: function(e) {
        var t = this.menu,
        n = t.focusedItem;
        if (n && this.isWhitelisted(n)) {
            return true
        }
        if (t.parentMenu) {
            t.hide();
            t.parentMenu.focus()
        }
    },
    right: function(e) {
        var t = this.menu,
        n = t.focusedItem,
        r = t.activeItem,
        i;
        if (n && this.isWhitelisted(n)) {
            return true
        }
        if (r) {
            i = t.activeItem.menu;
            if (i) {
                r.expandMenu(0);
                i.setActiveItem(i.child(":focusable"))
            }
        }
    },
    tab: function(e) {
        var t = this;
        if (e.shiftKey) {
            t.up(e)
        } else {
            t.down(e)
        }
    },
    up: function(e) {
        var t = this,
        n = t.menu.focusedItem;
        if (n && e.getKey() == Ext.EventObject.UP && t.isWhitelisted(n)) {
            return true
        }
        t.focusNextItem( - 1)
    }
});Ext.define("Ext.menu.Separator", {
    extend: Ext.menu.Item,
    alias: "widget.menuseparator",
    canActivate: false,
    focusable: false,
    hideOnClick: false,
    plain: true,
    separatorCls: Ext.baseCSSPrefix + "menu-item-separator",
    text: "&#160;",
    ariaRole: "separator",
    beforeRender: function(e, t) {
        var n = this;
        n.callParent();
        n.addCls(n.separatorCls)
    }
});Ext.define("Ext.menu.Menu", {
    extend: Ext.panel.Panel,
    alias: "widget.menu",
    enableKeyNav: true,
    allowOtherMenus: false,
    ariaRole: "menu",
    floating: true,
    constrain: true,
    hidden: true,
    hideMode: "visibility",
    ignoreParentClicks: false,
    isMenu: true,
    showSeparator: true,
    minWidth: undefined,
    defaultMinWidth: 120,
    defaultAlign: "tl-bl?",
    initComponent: function() {
        var e = this,
        t = Ext.baseCSSPrefix,
        n = [t + "menu"],
        r = e.bodyCls ? [e.bodyCls] : [],
        i = e.floating !== false;
        e.addEvents("click", "mouseenter", "mouseleave", "mouseover");
        Ext.menu.Manager.register(e);
        if (e.plain) {
            n.push(t + "menu-plain")
        }
        e.cls = n.join(" ");
        r.push(t + "menu-body", Ext.dom.Element.unselectableCls);
        e.bodyCls = r.join(" ");
        if (!e.layout) {
            e.layout = {
                type: "vbox",
                align: "stretchmax",
                overflowHandler: "Scroller"
            }
        }
        if (i) {
            if (e.minWidth === undefined) {
                e.minWidth = e.defaultMinWidth
            }
        } else {
            e.hidden = !!e.initialConfig.hidden;
            e.constrain = false
        }
        e.callParent(arguments);
        Ext.override(e.getLayout(), {
            configureItem: e.configureItem
        })
    },
    initFloatConstrain: Ext.emptyFn,
    initHierarchyEvents: Ext.emptyFn,
    getHierarchyState: function() {
        var e = this.callParent();
        e.hidden = this.hidden;
        return e
    },
    beforeRender: function() {
        this.callParent(arguments);
        if (!this.getSizeModel().width.shrinkWrap) {
            this.layout.align = "stretch"
        }
    },
    onBoxReady: function() {
        var e = this;
        e.callParent(arguments);
        if (e.showSeparator) {
            e.iconSepEl = e.layout.getElementTarget().insertFirst({
                role: "presentation",
                cls: Ext.baseCSSPrefix + "menu-icon-separator",
                html: "&#160;"
            })
        }
        e.mon(e.el, {
            click: e.onClick,
            mouseover: e.onMouseOver,
            scope: e
        });
        e.mouseMonitor = e.el.monitorMouseLeave(100, e.onMouseLeave, e);
        if (e.enableKeyNav) {
            e.keyNav = new Ext.menu.KeyNav({
                target: e,
                keyMap: e.getKeyMap()
            })
        }
    },
    canActivateItem: function(e) {
        return e && !e.isDisabled() && e.isVisible() && (e.canActivate || !e.isMenuItem)
    },
    deactivateActiveItem: function(e) {
        var t = this,
        n = t.activeItem,
        r = t.focusedItem;
        if (n) {
            n.deactivate();
            if (!n.activated) {
                delete t.activeItem
            }
        }
        if (r && e) {
            r.blur();
            delete t.focusedItem
        }
    },
    getFocusEl: function() {
        return this.focusedItem || this.items.items[0]
    },
    hide: function() {
        this.deactivateActiveItem(true);
        this.callParent(arguments)
    },
    getItemFromEvent: function(e) {
        var t = this,
        n = t.layout.getRenderTarget().dom,
        r = e.getTarget();
        while (r.parentNode !== n) {
            r = r.parentNode;
            if (!r) {
                return
            }
        }
        return Ext.getCmp(r.id)
    },
    lookupComponent: function(e) {
        var t = this;
        if (typeof e == "string") {
            e = t.lookupItemFromString(e)
        } else {
            if (Ext.isObject(e)) {
                e = t.lookupItemFromObject(e)
            }
        }
        e.minWidth = e.minWidth || t.minWidth;
        return e
    },
    lookupItemFromObject: function(e) {
        var t = this;
        if (!e.isComponent) {
            if (!e.xtype) {
                e = Ext.create("Ext.menu." + (Ext.isBoolean(e.checked) ? "Check": "") + "Item", e)
            } else {
                e = Ext.ComponentManager.create(e, e.xtype)
            }
        }
        if (e.isMenuItem) {
            e.parentMenu = t
        }
        return e
    },
    lookupItemFromString: function(e) {
        return e == "separator" || e == "-" ? new Ext.menu.Separator: new Ext.menu.Item({
            canActivate: false,
            hideOnClick: false,
            plain: true,
            text: e
        })
    },
    configureItem: function(e) {
        var t = this,
        n = t.owner,
        r = Ext.baseCSSPrefix,
        i;
        if (t.owner.items.getCount() > 1 && !e.rendered && !e.isMenuItem && !e.dock) {
            i = [r + "menu-item-cmp"];
            if (!n.plain && (e.indent !== false || e.iconCls === "no-icon")) {
                i.push(r + "menu-item-indent")
            }
            if (e.rendered) {
                e.el.addCls(i)
            } else {
                e.cls = (e.cls || "") + " " + i.join(" ")
            }
        }
        this.callParent(arguments)
    },
    onClick: function(e) {
        var t = this,
        n;
        if (t.disabled) {
            e.stopEvent();
            return
        }
        n = e.type === "click" ? t.getItemFromEvent(e) : t.activeItem;
        if (n && n.isMenuItem) {
            if (!n.menu || !t.ignoreParentClicks) {
                n.onClick(e)
            } else {
                e.stopEvent()
            }
        }
        if (!n || n.disabled) {
            n = undefined
        }
        t.fireEvent("click", t, n, e)
    },
    onDestroy: function() {
        var e = this;
        Ext.menu.Manager.unregister(e);
        e.parentMenu = e.ownerCmp = e.ownerButton = null;
        if (e.rendered) {
            e.el.un(e.mouseMonitor);
            Ext.destroy(e.keyNav);
            e.keyNav = null
        }
        e.callParent(arguments)
    },
    onMouseLeave: function(e) {
        var t = this;
        t.deactivateActiveItem();
        if (t.disabled) {
            return
        }
        t.fireEvent("mouseleave", t, e)
    },
    onMouseOver: function(e) {
        var t = this,
        n = e.getRelatedTarget(),
        r = !t.el.contains(n),
        i = t.getItemFromEvent(e),
        s = t.parentMenu,
        o = t.ownerCmp;
        if (r && s) {
            s.setActiveItem(o);
            o.cancelDeferHide();
            s.mouseMonitor.mouseenter()
        }
        if (t.disabled) {
            return
        }
        if (i && !i.activated) {
            t.setActiveItem(i);
            if (i.activated && i.expandMenu) {
                i.expandMenu()
            }
        }
        if (r) {
            t.fireEvent("mouseenter", t, e)
        }
        t.fireEvent("mouseover", t, i, e)
    },
    setActiveItem: function(e) {
        var t = this;
        if (e && e != t.activeItem) {
            t.deactivateActiveItem();
            if (t.canActivateItem(e)) {
                if (e.activate) {
                    e.activate(true);
                    if (e.activated) {
                        t.activeItem = e;
                        t.focusedItem = e
                    }
                } else {
                    e.focus();
                    t.focusedItem = e
                }
            }
        }
    },
    beforeShow: function() {
        var e = this,
        t;
        if (e.floating) {
            e.savedMaxHeight = e.maxHeight;
            t = e.container.getViewSize().height;
            e.maxHeight = Math.min(e.maxHeight || t, t)
        }
        e.callParent(arguments)
    },
    afterShow: function() {
        var e = this;
        e.callParent(arguments);
        if (e.floating) {
            e.maxHeight = e.savedMaxHeight
        }
    }
});Ext.define("Ext.menu.ColorPicker", {
    extend: Ext.menu.Menu,
    alias: "widget.colormenu",
    hideOnClick: true,
    pickerId: null,
    initComponent: function() {
        var e = this,
        t = Ext.apply({},
        e.initialConfig);
        delete t.listeners;
        Ext.apply(e, {
            plain: true,
            showSeparator: false,
            bodyPadding: 0,
            items: Ext.applyIf({
                cls: Ext.baseCSSPrefix + "menu-color-item",
                margin: 0,
                id: e.pickerId,
                xtype: "colorpicker"
            },
            t)
        });
        e.callParent(arguments);
        e.picker = e.down("colorpicker");
        e.relayEvents(e.picker, ["select"]);
        if (e.hideOnClick) {
            e.on("select", e.hidePickerOnSelect, e)
        }
    },
    hidePickerOnSelect: function() {
        Ext.menu.Manager.hideAll()
    }
});Ext.define("Ext.menu.DatePicker", {
    extend: Ext.menu.Menu,
    alias: "widget.datemenu",
    hideOnClick: true,
    pickerId: null,
    initComponent: function() {
        var e = this,
        t = Ext.apply({},
        e.initialConfig);
        delete t.listeners;
        Ext.apply(e, {
            showSeparator: false,
            plain: true,
            bodyPadding: 0,
            items: Ext.applyIf({
                cls: Ext.baseCSSPrefix + "menu-date-item",
                margin: 0,
                border: false,
                id: e.pickerId,
                xtype: "datepicker"
            },
            t)
        });
        e.callParent(arguments);
        e.picker = e.down("datepicker");
        e.relayEvents(e.picker, ["select"]);
        if (e.hideOnClick) {
            e.on("select", e.hidePickerOnSelect, e)
        }
    },
    hidePickerOnSelect: function() {
        Ext.menu.Manager.hideAll()
    }
});Ext.define("Ext.panel.Tool", {
    extend: Ext.Component,
    alias: "widget.tool",
    isTool: true,
    baseCls: Ext.baseCSSPrefix + "tool",
    disabledCls: Ext.baseCSSPrefix + "tool-disabled",
    toolPressedCls: Ext.baseCSSPrefix + "tool-pressed",
    toolOverCls: Ext.baseCSSPrefix + "tool-over",
    ariaRole: "button",
    childEls: ["toolEl"],
    renderTpl: ['<img id="{id}-toolEl" src="{blank}" class="{baseCls}-img {baseCls}-{type}{childElCls}" role="presentation"/>'],
    toolOwner: null,
    tooltipType: "qtip",
    stopEvent: true,
    height: 15,
    width: 15,
    initComponent: function() {
        var e = this;
        e.addEvents("click");
        e.type = e.type || e.id;
        Ext.applyIf(e.renderData, {
            baseCls: e.baseCls,
            blank: Ext.BLANK_IMAGE_URL,
            type: e.type
        });
        e.tooltip = e.tooltip || e.qtip;
        e.callParent()
    },
    afterRender: function() {
        var e = this,
        t;
        e.callParent(arguments);
        e.el.on({
            click: e.onClick,
            mousedown: e.onMouseDown,
            mouseover: e.onMouseOver,
            mouseout: e.onMouseOut,
            scope: e
        });
        if (e.tooltip) {
            if (Ext.quickTipsActive && Ext.isObject(e.tooltip)) {
                Ext.tip.QuickTipManager.register(Ext.apply({
                    target: e.id
                },
                e.tooltip))
            } else {
                t = e.tooltipType == "qtip" ? "data-qtip": "title";
                e.el.dom.setAttribute(t, e.tooltip)
            }
        }
    },
    getFocusEl: function() {
        return this.el
    },
    setType: function(e) {
        var t = this,
        n = t.type;
        t.type = e;
        if (t.rendered) {
            if (n) {
                t.toolEl.removeCls(t.baseCls + "-" + n)
            }
            t.toolEl.addCls(t.baseCls + "-" + e)
        } else {
            t.renderData.type = e
        }
        return t
    },
    onClick: function(e, t) {
        var n = this;
        if (n.disabled) {
            return false
        }
        n.el.removeCls(n.toolPressedCls);
        n.el.removeCls(n.toolOverCls);
        if (n.stopEvent !== false) {
            e.stopEvent()
        }
        if (n.handler) {
            Ext.callback(n.handler, n.scope || n, [e, t, n.ownerCt, n])
        } else {
            if (n.callback) {
                Ext.callback(n.callback, n.scope || n, [n.toolOwner || n.ownerCt, n, e])
            }
        }
        n.fireEvent("click", n, e);
        return true
    },
    onDestroy: function() {
        var e = this;
        if (Ext.quickTipsActive && Ext.isObject(e.tooltip)) {
            Ext.tip.QuickTipManager.unregister(e.id)
        }
        if (e.keyMap) {
            e.keyMap.destroy()
        }
        delete e.toolOwner;
        e.callParent()
    },
    onMouseDown: function() {
        if (this.disabled) {
            return false
        }
        this.el.addCls(this.toolPressedCls)
    },
    onMouseOver: function() {
        if (this.disabled) {
            return false
        }
        this.el.addCls(this.toolOverCls)
    },
    onMouseOut: function() {
        this.el.removeCls(this.toolOverCls)
    }
});Ext.define("Ext.resizer.SplitterTracker", {
    extend: Ext.dd.DragTracker,
    enabled: true,
    overlayCls: Ext.baseCSSPrefix + "resizable-overlay",
    createDragOverlay: function() {
        var e;
        e = this.overlay = Ext.getBody().createChild({
            role: "presentation",
            cls: this.overlayCls,
            html: "&#160;"
        });
        e.unselectable();
        e.setSize(Ext.Element.getViewWidth(true), Ext.Element.getViewHeight(true));
        e.show()
    },
    getPrevCmp: function() {
        var e = this.getSplitter();
        return e.previousSibling(":not([hidden])")
    },
    getNextCmp: function() {
        var e = this.getSplitter();
        return e.nextSibling(":not([hidden])")
    },
    onBeforeStart: function(e) {
        var t = this,
        n = t.getPrevCmp(),
        r = t.getNextCmp(),
        i = t.getSplitter().collapseEl,
        s = e.getTarget(),
        o;
        if (!n || !r) {
            return false
        }
        if (i && s === t.getSplitter().collapseEl.dom) {
            return false
        }
        if (r.collapsed || n.collapsed) {
            return false
        }
        t.prevBox = n.getEl().getBox();
        t.nextBox = r.getEl().getBox();
        t.constrainTo = o = t.calculateConstrainRegion();
        if (!o) {
            return false
        }
        return o
    },
    onStart: function(e) {
        var t = this.getSplitter();
        this.createDragOverlay();
        t.addCls(t.baseCls + "-active")
    },
    calculateConstrainRegion: function() {
        var e = this,
        t = e.getSplitter(),
        n = t.getWidth(),
        r = t.defaultSplitMin,
        i = t.orientation,
        s = e.prevBox,
        o = e.getPrevCmp(),
        u = e.nextBox,
        a = e.getNextCmp(),
        f,
        l,
        c;
        if (i === "vertical") {
            c = {
                prevCmp: o,
                nextCmp: a,
                prevBox: s,
                nextBox: u,
                defaultMin: r,
                splitWidth: n
            };
            f = new Ext.util.Region(s.y, e.getVertPrevConstrainRight(c), s.bottom, e.getVertPrevConstrainLeft(c));
            l = new Ext.util.Region(u.y, e.getVertNextConstrainRight(c), u.bottom, e.getVertNextConstrainLeft(c))
        } else {
            f = new Ext.util.Region(s.y + (o.minHeight || r), s.right, (o.maxHeight ? s.y + o.maxHeight: u.bottom - (a.minHeight || r)) + n, s.x);
            l = new Ext.util.Region((a.maxHeight ? u.bottom - a.maxHeight: s.y + (o.minHeight || r)) - n, u.right, u.bottom - (a.minHeight || r), u.x)
        }
        return f.intersect(l)
    },
    performResize: function(e, t) {
        var n = this,
        r = n.getSplitter(),
        i = r.orientation,
        s = n.getPrevCmp(),
        o = n.getNextCmp(),
        u = r.ownerCt,
        a = u.query(">[flex]"),
        f = a.length,
        l = i === "vertical",
        c = 0,
        h = l ? "width": "height",
        p = 0,
        d,
        v;
        for (; c < f; c++) {
            d = a[c];
            v = l ? d.getWidth() : d.getHeight();
            p += v;
            d.flex = v
        }
        t = l ? t[0] : t[1];
        if (s) {
            v = n.prevBox[h] + t;
            if (s.flex) {
                s.flex = v
            } else {
                s[h] = v
            }
        }
        if (o) {
            v = n.nextBox[h] - t;
            if (o.flex) {
                o.flex = v
            } else {
                o[h] = v
            }
        }
        u.updateLayout()
    },
    endDrag: function() {
        var e = this;
        if (e.overlay) {
            e.overlay.remove();
            delete e.overlay
        }
        e.callParent(arguments)
    },
    onEnd: function(e) {
        var t = this,
        n = t.getSplitter();
        n.removeCls(n.baseCls + "-active");
        t.performResize(e, t.getResizeOffset())
    },
    onDrag: function(e) {
        var t = this,
        n = t.getOffset("dragTarget"),
        r = t.getSplitter(),
        i = r.getEl(),
        s = r.orientation;
        if (s === "vertical") {
            i.setX(t.startRegion.left + n[0])
        } else {
            i.setY(t.startRegion.top + n[1])
        }
    },
    getSplitter: function() {
        return this.splitter
    },
    getVertPrevConstrainRight: function(e) {
        return (e.prevCmp.maxWidth ? e.prevBox.x + e.prevCmp.maxWidth: e.nextBox.right - (e.nextCmp.minWidth || e.defaultMin)) + e.splitWidth
    },
    getVertPrevConstrainLeft: function(e) {
        return e.prevBox.x + (e.prevCmp.minWidth || e.defaultMin)
    },
    getVertNextConstrainRight: function(e) {
        return e.nextBox.right - (e.nextCmp.minWidth || e.defaultMin)
    },
    getVertNextConstrainLeft: function(e) {
        return (e.nextCmp.maxWidth ? e.nextBox.right - e.nextCmp.maxWidth: e.prevBox.x + (e.prevBox.minWidth || e.defaultMin)) - e.splitWidth
    },
    getResizeOffset: function() {
        return this.getOffset("dragTarget")
    }
});Ext.define("Ext.resizer.BorderSplitterTracker", {
    extend: Ext.resizer.SplitterTracker,
    getPrevCmp: null,
    getNextCmp: null,
    calculateConstrainRegion: function() {
        var e = this,
        t = e.splitter,
        n = t.collapseTarget,
        r = t.defaultSplitMin,
        i = t.vertical ? "Width": "Height",
        s = "min" + i,
        o = "max" + i,
        u = "get" + i,
        a = t.neighbors,
        f = a.length,
        l = n.el.getBox(),
        c = l.x,
        h = l.y,
        p = l.right,
        d = l.bottom,
        v = t.vertical ? p - c: d - h,
        m,
        g,
        y,
        b,
        w,
        E,
        S;
        y = (n[s] || Math.min(v, r)) - v;
        b = n[o];
        if (!b) {
            b = 1e9
        } else {
            b -= v
        }
        S = v;
        for (m = 0; m < f; ++m) {
            g = a[m];
            v = g[u]();
            w = v - g[o];
            E = v - (g[s] || Math.min(v, r));
            if (!isNaN(w)) {
                if (y < w) {
                    y = w
                }
            }
            if (b > E) {
                b = E
            }
        }
        if (b - y < 2) {
            return null
        }
        l = new Ext.util.Region(h, p, d, c);
        e.constraintAdjusters[e.getCollapseDirection()](l, y, b, t);
        e.dragInfo = {
            minRange: y,
            maxRange: b,
            targetSize: S
        };
        return l
    },
    constraintAdjusters: {
        left: function(e, t, n, r) {
            e[0] = e.x = e.left = e.right + t;
            e.right += n + r.getWidth()
        },
        top: function(e, t, n, r) {
            e[1] = e.y = e.top = e.bottom + t;
            e.bottom += n + r.getHeight()
        },
        bottom: function(e, t, n, r) {
            e.bottom = e.top - t;
            e.top -= n + r.getHeight()
        },
        right: function(e, t, n, r) {
            e.right = e.left - t;
            e[0] = e.x = e.left = e.x - n + r.getWidth()
        }
    },
    onBeforeStart: function(e) {
        var t = this,
        n = t.splitter,
        r = n.collapseTarget,
        i = n.neighbors,
        s = t.getSplitter().collapseEl,
        o = e.getTarget(),
        u = i.length,
        a,
        f;
        if (s && o === n.collapseEl.dom) {
            return false
        }
        if (r.collapsed) {
            return false
        }
        for (a = 0; a < u; ++a) {
            f = i[a];
            if (f.collapsed && f.isHorz === r.isHorz) {
                return false
            }
        }
        if (! (t.constrainTo = t.calculateConstrainRegion())) {
            return false
        }
        return true
    },
    performResize: function(e, t) {
        var n = this,
        r = n.splitter,
        i = r.getCollapseDirection(),
        s = r.collapseTarget,
        o = n.splitAdjusters[r.vertical ? "horz": "vert"],
        u = t[o.index],
        a = n.dragInfo,
        f;
        if (i == "right" || i == "bottom") {
            u = -u
        }
        u = Math.min(Math.max(a.minRange, u), a.maxRange);
        if (u) { (f = r.ownerCt).suspendLayouts();
            o.adjustTarget(s, a.targetSize, u);
            f.resumeLayouts(true)
        }
    },
    splitAdjusters: {
        horz: {
            index: 0,
            adjustTarget: function(e, t, n) {
                e.flex = null;
                e.setSize(t + n)
            }
        },
        vert: {
            index: 1,
            adjustTarget: function(e, t, n) {
                e.flex = null;
                e.setSize(undefined, t + n)
            }
        }
    },
    getCollapseDirection: function() {
        return this.splitter.getCollapseDirection()
    }
});Ext.define("Ext.resizer.Handle", {
    extend: Ext.Component,
    handleCls: "",
    baseHandleCls: Ext.baseCSSPrefix + "resizable-handle",
    region: "",
    ariaRole: "presentation",
    beforeRender: function() {
        var e = this;
        e.callParent();
        e.protoEl.unselectable();
        e.addCls(e.baseHandleCls, e.baseHandleCls + "-" + e.region, e.handleCls)
    }
});Ext.define("Ext.resizer.ResizeTracker", {
    extend: Ext.dd.DragTracker,
    dynamic: true,
    preserveRatio: false,
    constrainTo: null,
    proxyCls: Ext.baseCSSPrefix + "resizable-proxy",
    constructor: function(e) {
        var t = this,
        n, r, i;
        if (!e.el) {
            if (e.target.isComponent) {
                t.el = e.target.getEl()
            } else {
                t.el = e.target
            }
        }
        this.callParent(arguments);
        if (t.preserveRatio && t.minWidth && t.minHeight) {
            n = t.minWidth / t.el.getWidth();
            r = t.minHeight / t.el.getHeight();
            if (r > n) {
                t.minWidth = t.el.getWidth() * r
            } else {
                t.minHeight = t.el.getHeight() * n
            }
        }
        if (t.throttle) {
            i = Ext.Function.createThrottled(function() {
                Ext.resizer.ResizeTracker.prototype.resize.apply(t, arguments)
            },
            t.throttle);
            t.resize = function(e, n, r) {
                if (r) {
                    Ext.resizer.ResizeTracker.prototype.resize.apply(t, arguments)
                } else {
                    i.apply(null, arguments)
                }
            }
        }
    },
    onBeforeStart: function(e) {
        this.startBox = this.target.getBox()
    },
    getProxy: function() {
        var e = this;
        if (!e.dynamic && !e.proxy) {
            e.proxy = e.createProxy(e.target || e.el);
            e.hideProxy = true
        }
        if (e.proxy) {
            e.proxy.show();
            return e.proxy
        }
    },
    createProxy: function(e) {
        var t, n = this.proxyCls;
        if (e.isComponent) {
            t = e.getProxy().addCls(n)
        } else {
            t = e.createProxy({
                tag: "div",
                role: "presentation",
                cls: n,
                id: e.id + "-rzproxy"
            },
            Ext.getBody())
        }
        t.removeCls(Ext.baseCSSPrefix + "proxy-el");
        return t
    },
    onStart: function(e) {
        this.activeResizeHandle = Ext.get(this.getDragTarget().id);
        if (!this.dynamic) {
            this.resize(this.startBox)
        }
    },
    onDrag: function(e) {
        if (this.dynamic || this.proxy) {
            this.updateDimensions(e)
        }
    },
    updateDimensions: function(e, t) {
        var n = this,
        r = n.activeResizeHandle.region,
        i = n.getOffset(n.constrainTo ? "dragTarget": null),
        s = n.startBox,
        o,
        u = 0,
        a = 0,
        f,
        l,
        c = 0,
        h = 0,
        p,
        d,
        v,
        m,
        g,
        y,
        b;
        r = n.convertRegionName(r);
        switch (r) {
        case "south":
            a = i[1];
            v = 2;
            break;
        case "north":
            a = -i[1];
            h = -a;
            v = 2;
            break;
        case "east":
            u = i[0];
            v = 1;
            break;
        case "west":
            u = -i[0];
            c = -u;
            v = 1;
            break;
        case "northeast":
            a = -i[1];
            h = -a;
            u = i[0];
            d = [s.x, s.y + s.height];
            v = 3;
            break;
        case "southeast":
            a = i[1];
            u = i[0];
            d = [s.x, s.y];
            v = 3;
            break;
        case "southwest":
            u = -i[0];
            c = -u;
            a = i[1];
            d = [s.x + s.width, s.y];
            v = 3;
            break;
        case "northwest":
            a = -i[1];
            h = -a;
            u = -i[0];
            c = -u;
            d = [s.x + s.width, s.y + s.height];
            v = 3;
            break
        }
        g = {
            width: s.width + u,
            height: s.height + a,
            x: s.x + c,
            y: s.y + h
        };
        if (g.width != n.target.width && n.widthIncrement > 1) {
            m = n.target.width % n.widthIncrement;
            if (m * 2 >= n.widthIncrement) {
                m -= n.widthIncrement
            }
            f = Ext.Number.snap(g.width, n.widthIncrement) + m
        } else {
            f = g.width
        }
        if (g.height != n.target.height && n.heightIncrement > 1) {
            m = n.target.height % n.heightIncrement;
            if (m * 2 >= n.heightIncrement) {
                m -= n.heightIncrement
            }
            l = Ext.Number.snap(g.height, n.heightIncrement) + m
        } else {
            l = g.height
        }
        if (f != g.width || l != g.height) {
            switch (r) {
            case "northeast":
                g.y -= l - g.height;
                break;
            case "north":
                g.y -= l - g.height;
                break;
            case "southwest":
                g.x -= f - g.width;
                break;
            case "west":
                g.x -= f - g.width;
                break;
            case "northwest":
                g.x -= f - g.width;
                g.y -= l - g.height
            }
            g.width = f;
            g.height = l
        }
        if (g.width < n.minWidth || g.width > n.maxWidth) {
            g.width = Ext.Number.constrain(g.width, n.minWidth, n.maxWidth);
            if (c) {
                g.x = s.x + (s.width - g.width)
            }
        } else {
            n.lastX = g.x
        }
        if (g.height < n.minHeight || g.height > n.maxHeight) {
            g.height = Ext.Number.constrain(g.height, n.minHeight, n.maxHeight);
            if (h) {
                g.y = s.y + (s.height - g.height)
            }
        } else {
            n.lastY = g.y
        }
        if (n.preserveRatio || e.shiftKey) {
            o = n.startBox.width / n.startBox.height;
            y = Math.min(Math.max(n.minHeight, g.width / o), n.maxHeight);
            b = Math.min(Math.max(n.minWidth, g.height * o), n.maxWidth);
            if (v == 1) {
                g.height = y
            } else {
                if (v == 2) {
                    g.width = b
                } else {
                    p = Math.abs(d[0] - this.lastXY[0]) / Math.abs(d[1] - this.lastXY[1]);
                    if (p > o) {
                        g.height = y
                    } else {
                        g.width = b
                    }
                    if (r == "northeast") {
                        g.y = s.y - (g.height - s.height)
                    } else {
                        if (r == "northwest") {
                            g.y = s.y - (g.height - s.height);
                            g.x = s.x - (g.width - s.width)
                        } else {
                            if (r == "southwest") {
                                g.x = s.x - (g.width - s.width)
                            }
                        }
                    }
                }
            }
        }
        n.setPosition = g.x !== n.startBox.x || g.y !== n.startBox.y;
        n.resize(g, t)
    },
    resize: function(e, t) {
        var n = this,
        r, i = n.setPosition;
        if (n.dynamic || !n.dynamic && t) {
            if (i) {
                n.target.setBox(e)
            } else {
                n.target.setSize(e.width, e.height)
            }
        }
        if (!t) {
            r = n.getProxy();
            if (r && r !== n.target) {
                if (i || n.hideProxy) {
                    r.setBox(e)
                } else {
                    r.setSize(e.width, e.height)
                }
            }
        }
    },
    onEnd: function(e) {
        this.updateDimensions(e, true);
        if (this.proxy && this.hideProxy) {
            this.proxy.hide()
        }
    },
    convertRegionName: function(e) {
        return e
    }
});Ext.define("Ext.resizer.Resizer", {
    mixins: {
        observable: Ext.util.Observable
    },
    alternateClassName: "Ext.Resizable",
    handleCls: Ext.baseCSSPrefix + "resizable-handle",
    overCls: Ext.baseCSSPrefix + "resizable-handle-over",
    pinnedCls: Ext.baseCSSPrefix + "resizable-pinned",
    wrapCls: Ext.baseCSSPrefix + "resizable-wrap",
    wrappedCls: Ext.baseCSSPrefix + "resizable-wrapped",
    delimiterRe: /(?:\s*[,;]\s*)|\s+/,
    dynamic: true,
    handles: "s e se",
    height: null,
    width: null,
    heightIncrement: 0,
    widthIncrement: 0,
    minHeight: 20,
    minWidth: 20,
    maxHeight: 1e4,
    maxWidth: 1e4,
    pinned: false,
    preserveRatio: false,
    transparent: false,
    possiblePositions: {
        n: "north",
        s: "south",
        e: "east",
        w: "west",
        se: "southeast",
        sw: "southwest",
        nw: "northwest",
        ne: "northeast"
    },
    ariaRole: "presentation",
    constructor: function(e) {
        var t = this,
        n, r, i = t.handles,
        s, o, u, a = 0,
        f, l, c = [],
        h,
        p,
        d,
        v,
        m = Ext.dom.Element.unselectableCls;
        t.addEvents("beforeresize", "resizedrag", "resize");
        if (Ext.isString(e) || Ext.isElement(e) || e.dom) {
            n = e;
            e = arguments[1] || {};
            e.target = n
        }
        t.mixins.observable.constructor.call(t, e);
        n = t.target;
        if (n) {
            if (n.isComponent) {
                n.addClsWithUI("resizable");
                if (n.minWidth) {
                    t.minWidth = n.minWidth
                }
                if (n.minHeight) {
                    t.minHeight = n.minHeight
                }
                if (n.maxWidth) {
                    t.maxWidth = n.maxWidth
                }
                if (n.maxHeight) {
                    t.maxHeight = n.maxHeight
                }
                if (n.floating) {
                    if (!t.hasOwnProperty("handles")) {
                        t.handles = "n ne e se s sw w nw"
                    }
                }
                t.el = n.getEl()
            } else {
                n = t.el = t.target = Ext.get(n)
            }
        } else {
            n = t.target = t.el = Ext.get(t.el)
        }
        t.el.addCls(Ext.AbstractComponent.prototype.borderBoxCls);
        if (Ext.isNumber(t.width)) {
            t.width = Ext.Number.constrain(t.width, t.minWidth, t.maxWidth)
        }
        if (Ext.isNumber(t.height)) {
            t.height = Ext.Number.constrain(t.height, t.minHeight, t.maxHeight)
        }
        if (t.width !== null || t.height !== null) {
            t.target.setSize(t.width, t.height)
        }
        r = t.el.dom.tagName.toUpperCase();
        if (r === "TEXTAREA" || r === "IMG" || r === "TABLE") {
            t.originalTarget = t.target;
            v = n.isComponent ? n.getEl() : n;
            t.el.addCls(t.wrappedCls);
            t.target = t.el = t.el.wrap({
                role: "presentation",
                cls: t.wrapCls,
                id: t.el.id + "-rzwrap",
                style: v.getStyles("margin-top", "margin-bottom")
            });
            t.el.setPositioning(v.getPositioning());
            v.clearPositioning();
            t.el.setBox(v.getBox());
            v.setStyle("position", "absolute");
            t.isTargetWrapped = true
        }
        t.el.position();
        if (t.pinned) {
            t.el.addCls(t.pinnedCls)
        }
        t.resizeTracker = new Ext.resizer.ResizeTracker({
            disabled: t.disabled,
            target: n,
            el: t.el,
            constrainTo: t.constrainTo,
            handleCls: t.handleCls,
            overCls: t.overCls,
            throttle: t.throttle,
            proxy: t.originalTarget ? t.el: null,
            dynamic: t.originalTarget ? true: t.dynamic,
            originalTarget: t.originalTarget,
            delegate: "." + t.handleCls,
            preserveRatio: t.preserveRatio,
            heightIncrement: t.heightIncrement,
            widthIncrement: t.widthIncrement,
            minHeight: t.minHeight,
            maxHeight: t.maxHeight,
            minWidth: t.minWidth,
            maxWidth: t.maxWidth
        });
        t.resizeTracker.on({
            mousedown: t.onBeforeResize,
            drag: t.onResize,
            dragend: t.onResizeEnd,
            scope: t
        });
        if (t.handles == "all") {
            t.handles = "n s e w ne nw se sw"
        }
        i = t.handles = t.handles.split(t.delimiterRe);
        o = t.possiblePositions;
        u = i.length;
        s = t.handleCls + " " + t.handleCls + "-{0}";
        if (t.target.isComponent) {
            d = t.target.baseCls;
            s += " " + d + "-handle " + d + "-handle-{0}";
            if (Ext.supports.CSS3BorderRadius) {
                s += " " + d + "-handle-{0}-br"
            }
        }
        h = Ext.isIE6 ? ' style="height:' + t.el.getHeight() + 'px"': "";
        for (; a < u; a++) {
            if (i[a] && o[i[a]]) {
                f = o[i[a]];
                if (f === "east" || f === "west") {
                    p = h
                } else {
                    p = ""
                }
                c.push('<div id="', t.el.id, "-", f, '-handle" class="', Ext.String.format(s, f), " ", m, '" unselectable="on" role="presentation"', p, "></div>")
            }
        }
        Ext.DomHelper.append(t.el, c.join(""));
        c.length = 0;
        for (a = 0; a < u; a++) {
            if (i[a] && o[i[a]]) {
                f = o[i[a]];
                l = t[f] = t.el.getById(t.el.id + "-" + f + "-handle");
                c.push(l);
                l.region = f;
                if (t.transparent) {
                    l.setOpacity(0)
                }
            }
        }
        t.resizeTracker.handleEls = c;
        t.forceHandlesHeight();
        t.fireEvent("afterrender", t)
    },
    disable: function() {
        this.resizeTracker.disable()
    },
    enable: function() {
        this.resizeTracker.enable()
    },
    onBeforeResize: function(e, t) {
        var n = this.el.getBox();
        return this.fireEvent("beforeresize", this, n.width, n.height, t)
    },
    onResize: function(e, t) {
        var n = this,
        r;
        n.forceHandlesHeight();
        if (n.hasListeners.resizedrag) {
            r = e.target.getBox();
            return n.fireEvent("resizedrag", n, r.width, r.height, t)
        }
    },
    onResizeEnd: function(e, t) {
        var n = this,
        r = n.el.getBox();
        n.forceHandlesHeight();
        return n.fireEvent("resize", n, r.width, r.height, t)
    },
    resizeTo: function(e, t) {
        var n = this;
        n.target.setSize(e, t);
        n.fireEvent("resize", n, e, t, null)
    },
    getEl: function() {
        return this.el
    },
    getTarget: function() {
        return this.target
    },
    destroy: function() {
        var e = this,
        t, n = e.handles,
        r = n.length,
        i = e.possiblePositions,
        s;
        e.resizeTracker.destroy();
        if (e.isTargetWrapped) {
            e.target.destroy()
        }
        for (t = 0; t < r; t++) {
            if (s = e[i[n[t]]]) {
                s.remove()
            }
        }
    },
    forceHandlesHeight: function() {
        var e = this,
        t;
        if (Ext.isIE6) {
            t = e.east;
            if (t) {
                t.setHeight(e.el.getHeight())
            }
            t = e.west;
            if (t) {
                t.setHeight(e.el.getHeight())
            }
            e.el.repaint()
        }
    }
});Ext.define("Ext.selection.CellModel", {
    extend: Ext.selection.Model,
    alias: "selection.cellmodel",
    isCellModel: true,
    enableKeyNav: true,
    preventWrap: false,
    noSelection: {
        row: -1,
        column: -1
    },
    constructor: function() {
        this.addEvents("deselect", "select");
        this.callParent(arguments)
    },
    bindComponent: function(e) {
        var t = this,
        n = e.ownerCt;
        t.primaryView = e;
        t.views = t.views || [];
        t.views.push(e);
        t.bindStore(e.getStore(), true);
        e.on({
            cellclick: t.onCellClick,
            refresh: t.onViewRefresh,
            scope: t
        });
        if (n.optimizedColumnMove !== false) {
            n.on("columnmove", t.onColumnMove, t)
        }
        if (t.enableKeyNav) {
            t.initKeyNav(e)
        }
    },
    initKeyNav: function(e) {
        var t = this;
        if (!e.rendered) {
            e.on("render", Ext.Function.bind(t.initKeyNav, t, [e], 0), t, {
                single: true
            });
            return
        }
        e.el.set({
            tabIndex: -1
        });
        t.keyNav = new Ext.util.KeyNav({
            target: e.el,
            ignoreInputFields: true,
            up: t.onKeyUp,
            down: t.onKeyDown,
            right: t.onKeyRight,
            left: t.onKeyLeft,
            tab: t.onKeyTab,
            scope: t
        })
    },
    getHeaderCt: function() {
        var e = this.getCurrentPosition(),
        t = e ? e.view: this.primaryView;
        return t.headerCt
    },
    onKeyUp: function(e) {
        this.doMove("up", e)
    },
    onKeyDown: function(e) {
        this.doMove("down", e)
    },
    onKeyLeft: function(e) {
        this.doMove("left", e)
    },
    onKeyRight: function(e) {
        this.doMove("right", e)
    },
    doMove: function(e, t) {
        this.keyNavigation = true;
        this.move(e, t);
        this.keyNavigation = false
    },
    selectWithEvent: function(e, t) {
        this.select(e)
    },
    select: function(e, t, n) {
        var r = this,
        i, s = r.getCurrentPosition(),
        o = r.view.store;
        if (e || e === 0) {
            if (e.isModel) {
                i = o.indexOf(e);
                if (i !== -1) {
                    e = {
                        row: i,
                        column: s ? s.column: 0
                    }
                } else {
                    e = null
                }
            } else {
                if (typeof e === "number") {
                    e = {
                        row: e,
                        column: 0
                    }
                }
            }
        }
        if (e) {
            r.selectByPosition(e, n)
        } else {
            r.deselect()
        }
    },
    deselect: function(e, t) {
        this.selectByPosition(null, t)
    },
    move: function(e, t) {
        var n = this,
        r = n.getCurrentPosition(),
        i;
        if (r) {
            i = r.view.walkCells(r, e, t, n.preventWrap);
            if (i) {
                return n.setCurrentPosition(i)
            }
        }
    },
    getCurrentPosition: function() {
        return this.selecting ? this.nextSelection: this.selection
    },
    setCurrentPosition: function(e, t, n) {
        var r = this,
        i = r.selection;
        r.lastSelection = i;
        if (e) {
            e = e.isCellContext ? e: (new Ext.grid.CellContext(r.primaryView)).setPosition(e)
        }
        if (!n && i) {
            if (e && e.record === i.record && e.columnHeader === i.columnHeader && e.view === i.view) {
                e = null
            } else {
                r.onCellDeselect(r.selection, t)
            }
        }
        if (e) {
            r.nextSelection = e;
            r.selecting = true;
            r.onCellSelect(r.nextSelection, t);
            r.selecting = false;
            return r.selection = e
        }
    },
    isCellSelected: function(e, t, n) {
        var r = this,
        i, s = r.getCurrentPosition();
        if (s && s.view === e) {
            i = (new Ext.grid.CellContext(e)).setPosition({
                row: t,
                column: n
            });
            return i.record === s.record && i.columnHeader === s.columnHeader
        }
    },
    onStoreRemove: function(e, t, n) {
        var r = this,
        i = r.getCurrentPosition();
        r.callParent(arguments);
        if (i && e.getCount() && e.indexOf(i.record) !== -1) {
            r.setCurrentPosition({
                row: i.record,
                column: i.columnHeader
            },
            true, true)
        } else {
            r.selection = null
        }
    },
    onStoreAdd: function() {
        var e = this,
        t = e.getCurrentPosition();
        e.callParent(arguments);
        if (t) {
            e.setCurrentPosition({
                row: t.record,
                column: t.columnHeader
            },
            true, true)
        } else {
            e.selection = null
        }
    },
    onCellClick: function(e, t, n, r, i, s, o) {
        var u;
        if (s !== -1) {
            u = (new Ext.grid.CellContext(e)).setPosition({
                view: e,
                row: i,
                column: e.ownerCt.getColumnManager().getHeaderAtIndex(n)
            });
            this.setCurrentPosition(u)
        }
    },
    onCellSelect: function(e, t) {
        if (e && e.row !== undefined && e.row > -1) {
            this.doSelect(e.record, false, t)
        }
    },
    onCellDeselect: function(e, t) {
        if (e && e.row !== undefined) {
            this.doDeselect(e.record, t)
        }
    },
    onSelectChange: function(e, t, n, r) {
        var i = this,
        s, o, u;
        if (t) {
            s = i.nextSelection;
            o = "select"
        } else {
            s = i.lastSelection || i.noSelection;
            o = "deselect"
        }
        u = s.view || i.primaryView;
        if ((n || i.fireEvent("before" + o, i, e, s.row, s.column)) !== false && r() !== false) {
            if (t) {
                if (!i.preventFocus) {
                    u.focusCell(s, true)
                }
                u.onCellSelect(s)
            } else {
                u.onCellDeselect(s);
                delete i.selection
            }
            if (!n) {
                i.fireEvent(o, i, e, s.row, s.column)
            }
        }
    },
    onKeyTab: function(e, t) {
        var n = this,
        r = n.getCurrentPosition(),
        i;
        if (r) {
            i = r.view.editingPlugin;
            if (i && n.wasEditing) {
                n.onEditorTab(i, e)
            } else {
                n.move(e.shiftKey ? "left": "right", e)
            }
        }
    },
    onEditorTab: function(e, t) {
        var n = this,
        r = t.shiftKey ? "left": "right",
        i = n.getCurrentPosition(),
        s = i.view.walkCells(i, r, t, n.preventWrap);
        if (s) {
            if (e.startEdit(s.record, s.columnHeader)) {
                n.wasEditing = false
            } else {
                n.setCurrentPosition(s);
                n.wasEditing = true
            }
        }
    },
    refresh: function() {
        var e = this.getCurrentPosition(),
        t;
        if (e && (t = this.store.indexOf(this.selected.last())) !== -1) {
            e.row = t
        }
    },
    onColumnMove: function(e, t, n, r) {
        var i = e.up("tablepanel");
        if (i) {
            this.onViewRefresh(i.view)
        }
    },
    onUpdate: function(e) {
        var t = this,
        n;
        if (t.isSelected(e)) {
            n = t.selecting ? t.nextSelection: t.selection;
            t.view.onCellSelect(n)
        }
    },
    onViewRefresh: function(e) {
        var t = this,
        n = t.getCurrentPosition(),
        r,
        i = e.headerCt,
        s,
        o;
        if (n && n.view === e) {
            s = n.record;
            o = n.columnHeader;
            if (!o.isDescendantOf(i)) {
                o = i.queryById(o.id) || i.down('[text="' + o.text + '"]') || i.down('[dataIndex="' + o.dataIndex + '"]')
            }
            if (n.record) {
                if (o && e.store.indexOfId(s.getId()) !== -1) {
                    r = (new Ext.grid.CellContext(e)).setPosition({
                        row: s,
                        column: o
                    });
                    t.setCurrentPosition(r)
                }
            } else {
                t.selection = null
            }
        }
    },
    selectByPosition: function(e, t) {
        this.setCurrentPosition(e, t)
    }
});Ext.define("Ext.selection.RowModel", {
    extend: Ext.selection.Model,
    alias: "selection.rowmodel",
    deltaScroll: 5,
    enableKeyNav: true,
    ignoreRightMouseSelection: false,
    isRowModel: true,
    constructor: function() {
        this.addEvents("beforedeselect", "beforeselect", "deselect", "select");
        this.views = [];
        this.callParent(arguments)
    },
    bindComponent: function(e) {
        var t = this;
        e.on({
            itemcontextmenu: t.onRowClick,
            itemclick: t.onRowClick,
            scope: t
        });
        if (t.enableKeyNav) {
            t.initKeyNav(e)
        }
    },
    initKeyNav: function(e) {
        var t = this;
        if (!e.rendered) {
            e.on("render", Ext.Function.bind(t.initKeyNav, t, [e], 0), t, {
                single: true
            });
            return
        }
        e.el.set({
            tabIndex: -1
        });
        t.keyNav = new Ext.util.KeyNav({
            target: e,
            ignoreInputFields: true,
            eventName: "itemkeydown",
            processEvent: function(e, t, n, r, i) {
                i.record = t;
                i.recordIndex = r;
                return i
            },
            up: t.onKeyUp,
            down: t.onKeyDown,
            right: t.onKeyRight,
            left: t.onKeyLeft,
            pageDown: t.onKeyPageDown,
            pageUp: t.onKeyPageUp,
            home: t.onKeyHome,
            end: t.onKeyEnd,
            space: t.onKeySpace,
            enter: t.onKeyEnter,
            A: {
                ctrl: true,
                handler: t.selectAll
            },
            scope: t
        })
    },
    onUpdate: function(e) {
        var t = this,
        n = t.view,
        r;
        if (n && t.isSelected(e)) {
            r = n.indexOf(e);
            n.onRowSelect(r);
            if (e === t.lastFocused) {
                n.onRowFocus(r, true)
            }
        }
    },
    getRowsVisible: function() {
        var e = false,
        t = this.views[0],
        n = t.all.first(),
        r,
        i;
        if (n) {
            r = n.getHeight();
            i = t.el.getHeight();
            e = Math.floor(i / r)
        }
        return e
    },
    onKeyEnd: function(e) {
        var t = this,
        n = t.views[0];
        if (n.bufferedRenderer) {
            n.bufferedRenderer.scrollTo(t.store.getCount() - 1, false,
            function(n, r) {
                t.afterKeyNavigate(e, r)
            })
        } else {
            t.afterKeyNavigate(e, n.walkRecs(e.record, n.dataSource.getCount() - 1 - n.dataSource.indexOf(e.record)))
        }
    },
    onKeyHome: function(e) {
        var t = this,
        n = t.views[0];
        if (n.bufferedRenderer) {
            n.bufferedRenderer.scrollTo(0, false,
            function(n, r) {
                t.afterKeyNavigate(e, r)
            })
        } else {
            t.afterKeyNavigate(e, n.walkRecs(e.record, -n.dataSource.indexOf(e.record)))
        }
    },
    onKeyPageUp: function(e) {
        var t = this,
        n = t.views[0],
        r = t.getRowsVisible(),
        i,
        s;
        if (r) {
            if (n.bufferedRenderer) {
                i = Math.max(e.recordIndex - r, 0); (t.lastKeyEvent || (t.lastKeyEvent = new Ext.EventObjectImpl)).setEvent(e.browserEvent);
                n.bufferedRenderer.scrollTo(i, false, t.afterBufferedScrollTo, t)
            } else {
                s = n.walkRecs(e.record, -r);
                t.afterKeyNavigate(e, s)
            }
        }
    },
    onKeyPageDown: function(e) {
        var t = this,
        n = t.views[0],
        r = t.getRowsVisible(),
        i,
        s;
        if (r) {
            if (n.bufferedRenderer) {
                i = Math.min(e.recordIndex + r, t.store.getCount() - 1); (t.lastKeyEvent || (t.lastKeyEvent = new Ext.EventObjectImpl)).setEvent(e.browserEvent);
                n.bufferedRenderer.scrollTo(i, false, t.afterBufferedScrollTo, t)
            } else {
                s = n.walkRecs(e.record, r);
                t.afterKeyNavigate(e, s)
            }
        }
    },
    onKeySpace: function(e) {
        var t = e.record || this.lastFocused;
        if (t) {
            this.afterKeyNavigate(e, t)
        }
    },
    onKeyEnter: Ext.emptyFn,
    onKeyUp: function(e) {
        var t = this.views[0].walkRecs(e.record, -1);
        if (t) {
            this.afterKeyNavigate(e, t)
        }
    },
    onKeyDown: function(e) {
        var t = e.record.isExpandingOrCollapsing ? null: this.views[0].walkRecs(e.record, 1);
        if (t) {
            this.afterKeyNavigate(e, t)
        }
    },
    afterBufferedScrollTo: function(e, t) {
        this.afterKeyNavigate(this.lastKeyEvent, t)
    },
    scrollByDeltaX: function(e) {
        var t = this.views[0],
        n = t.up(),
        r = n.horizontalScroller;
        if (r) {
            r.scrollByDeltaX(e)
        }
    },
    onKeyLeft: function(e) {
        this.scrollByDeltaX( - this.deltaScroll)
    },
    onKeyRight: function(e) {
        this.scrollByDeltaX(this.deltaScroll)
    },
    onRowClick: function(e, t, n, r, i) {
        if (r !== -1) {
            if (!this.allowRightMouseSelection(i)) {
                return
            }
            if (! (i.type === "contextmenu" && this.isSelected(t))) {
                this.processSelection(e, t, n, r, i)
            }
        }
    },
    processSelection: function(e, t, n, r, i) {
        this.selectWithEvent(t, i)
    },
    allowRightMouseSelection: function(e) {
        var t = this.ignoreRightMouseSelection && e.button !== 0;
        if (t) {
            t = this.hasSelection()
        }
        return ! t
    },
    onSelectChange: function(e, t, n, r) {
        var i = this,
        s = i.views,
        o = s.length,
        u = s[0].indexOf(e),
        a = t ? "select": "deselect",
        f = 0;
        if ((n || i.fireEvent("before" + a, i, e, u)) !== false && r() !== false) {
            for (; f < o; f++) {
                if (t) {
                    s[f].onRowSelect(u, n)
                } else {
                    s[f].onRowDeselect(u, n)
                }
            }
            if (!n) {
                i.fireEvent(a, i, e, u)
            }
        }
    },
    onLastFocusChanged: function(e, t, n) {
        var r = this.views,
        i = r.length,
        s, o = 0;
        if (e) {
            s = r[0].indexOf(e);
            if (s !== -1) {
                for (; o < i; o++) {
                    r[o].onRowFocus(s, false, true)
                }
            }
        }
        if (t) {
            s = r[0].indexOf(t);
            if (s !== -1) {
                for (o = 0; o < i; o++) {
                    r[o].onRowFocus(s, true, n)
                }
            }
        }
        this.callParent(arguments)
    },
    onEditorTab: function(e, t) {
        var n = this,
        r = e.context.view,
        i = e.getActiveRecord(),
        s = e.getActiveColumn(),
        o = r.getPosition(i, s),
        u = t.shiftKey ? "left": "right",
        a;
        do {
            a = o;
            o = r.walkCells(o, u, t, n.preventWrap);
            if (a && a.isEqual(o)) {
                return
            }
        } while ( o && (! o . columnHeader . getEditor ( i ) || !e.startEditByPosition(o)))
    },
    getCurrentPosition: function() {
        var e = this.selected.getAt(0);
        if (e) {
            return (new Ext.grid.CellContext(this.view)).setPosition(this.store.indexOf(e), 0)
        }
    },
    selectByPosition: function(e, t) {
        var n = new Ext.grid.CellContext(this.view);
        n.setPosition(e.row, e.column);
        this.select(n.record, t)
    },
    selectNext: function(e, t) {
        var n = this,
        r = n.store,
        i = n.getSelection(),
        s = i[i.length - 1],
        o = n.views[0].indexOf(s) + 1,
        u;
        if (o === r.getCount() || o === 0) {
            u = false
        } else {
            n.doSelect(o, e, t);
            u = true
        }
        return u
    },
    selectPrevious: function(e, t) {
        var n = this,
        r = n.getSelection(),
        i = r[0],
        s = n.views[0].indexOf(i) - 1,
        o;
        if (s < 0) {
            o = false
        } else {
            n.doSelect(s, e, t);
            o = true
        }
        return o
    },
    isRowSelected: function(e) {
        return this.isSelected(e)
    },
    isCellSelected: function(e, t, n) {
        return this.isSelected(t)
    }
});Ext.define("Ext.selection.TreeModel", {
    extend: Ext.selection.RowModel,
    alias: "selection.treemodel",
    constructor: function(e) {
        this.callParent(arguments);
        if (this.pruneRemoved) {
            this.pruneRemoved = false;
            this.pruneRemovedNodes = true
        }
    },
    bindStore: function(e, t) {
        var n = this;
        n.callParent(arguments);
        if (n.pruneRemovedNodes) {
            n.view.mon(n.treeStore, {
                remove: n.onNodeRemove,
                scope: n
            })
        }
    },
    onNodeRemove: function(e, t, n) {
        if (!n) {
            this.deselectDeletedRecords([t])
        }
    },
    onKeyRight: function(e, t) {
        this.navExpand(e, t)
    },
    navExpand: function(e, t) {
        var n = this,
        r = n.getLastFocused(),
        i = n.view;
        if (r) {
            if (r.isExpanded()) {
                n.onKeyDown(e, t)
            } else {
                if (r.isExpandable()) {
                    if (!i.isTreeView) {
                        i = i.lockingPartner
                    }
                    i.expand(r);
                    if (r) {
                        n.onLastFocusChanged(null, r)
                    }
                }
            }
        }
    },
    onKeyLeft: function(e, t) {
        this.navCollapse(e, t)
    },
    navCollapse: function(e, t) {
        var n = this,
        r = n.getLastFocused(),
        i = n.view,
        s;
        if (r) {
            s = r.parentNode;
            if (r.isExpanded()) {
                if (!i.isTreeView) {
                    i = i.lockingPartner
                }
                i.collapse(r);
                n.onLastFocusChanged(null, r)
            } else {
                if (s && !s.isRoot()) {
                    if (e.shiftKey) {
                        n.selectRange(s, r, e.ctrlKey, "up");
                        n.setLastFocused(s)
                    } else {
                        if (e.ctrlKey) {
                            n.setLastFocused(s)
                        } else {
                            n.select(s)
                        }
                    }
                }
            }
            this.onLastFocusChanged(null, r)
        }
    },
    onKeySpace: function(e, t) {
        if (e.record.data.checked != null) {
            this.toggleCheck(e)
        } else {
            this.callParent(arguments)
        }
    },
    onKeyEnter: function(e, t) {
        if (e.record.data.checked != null) {
            this.toggleCheck(e)
        } else {
            this.callParent(arguments)
        }
    },
    toggleCheck: function(e) {
        var t = this.view,
        n = this.getLastSelected();
        e.stopEvent();
        if (n) {
            if (!t.isTreeView) {
                t = t.lockingPartner
            }
            t.onCheckChange(n)
        }
    }
});Ext.define("Ext.slider.Thumb", {
    constructor: function(e) {
        var t = this;
        Ext.apply(t, e || {},
        {
            cls: Ext.baseCSSPrefix + "slider-thumb",
            constrain: false
        });
        t.callParent([e])
    },
    render: function() {
        var e = this;
        e.el = e.slider.innerEl.insertFirst(e.getElConfig());
        e.onRender()
    },
    onRender: function() {
        if (this.disabled) {
            this.disable()
        }
        this.initEvents()
    },
    getElConfig: function() {
        var e = this,
        t = e.slider,
        n = {};
        n[t.vertical ? "bottom": t.horizontalProp] = t.calculateThumbPosition(t.normalizeValue(e.value)) + "%";
        return {
            style: n,
            id: this.id,
            cls: this.cls,
            role: "presentation"
        }
    },
    move: function(e, t) {
        var n = this,
        r = n.el,
        i = n.slider,
        s = i.vertical ? "bottom": i.horizontalProp,
        o,
        u;
        e += "%";
        if (!t) {
            r.dom.style[s] = e
        } else {
            o = {};
            o[s] = e;
            if (!Ext.supports.GetPositionPercentage) {
                u = {};
                u[s] = r.dom.style[s]
            }
            new Ext.fx.Anim({
                target: r,
                duration: 350,
                from: u,
                to: o
            })
        }
    },
    enable: function() {
        var e = this;
        e.disabled = false;
        if (e.el) {
            e.el.removeCls(e.slider.disabledCls)
        }
    },
    disable: function() {
        var e = this;
        e.disabled = true;
        if (e.el) {
            e.el.addCls(e.slider.disabledCls)
        }
    },
    initEvents: function() {
        var e = this,
        t = e.el;
        e.tracker = new Ext.dd.DragTracker({
            onBeforeStart: Ext.Function.bind(e.onBeforeDragStart, e),
            onStart: Ext.Function.bind(e.onDragStart, e),
            onDrag: Ext.Function.bind(e.onDrag, e),
            onEnd: Ext.Function.bind(e.onDragEnd, e),
            tolerance: 3,
            autoStart: 300,
            overCls: Ext.baseCSSPrefix + "slider-thumb-over"
        });
        e.tracker.initEl(t)
    },
    onBeforeDragStart: function(e) {
        var t = this,
        n = t.el,
        r = t.tracker.getXY(),
        i = t.pointerOffset = n.getXY();
        if (t.disabled) {
            return false
        } else {
            i[0] += Math.floor(n.getWidth() / 2) - r[0];
            i[1] += Math.floor(n.getHeight() / 2) - r[1];
            t.slider.promoteThumb(t);
            return true
        }
    },
    onDragStart: function(e) {
        var t = this,
        n = t.slider;
        n.onDragStart(t, e);
        t.el.addCls(Ext.baseCSSPrefix + "slider-thumb-drag");
        t.dragging = t.slider.dragging = true;
        t.dragStartValue = t.value;
        n.fireEvent("dragstart", n, e, t)
    },
    onDrag: function(e) {
        var t = this,
        n = t.slider,
        r = t.index,
        i = t.getValueFromTracker(),
        s,
        o;
        if (i !== undefined) {
            if (t.constrain) {
                s = n.thumbs[r + 1];
                o = n.thumbs[r - 1];
                if (o !== undefined && i <= o.value) {
                    i = o.value
                }
                if (s !== undefined && i >= s.value) {
                    i = s.value
                }
            }
            n.setValue(r, i, false);
            n.fireEvent("drag", n, e, t)
        }
    },
    getValueFromTracker: function() {
        var e = this.slider,
        t = this.tracker.getXY(),
        n;
        t[0] += this.pointerOffset[0];
        t[1] += this.pointerOffset[1];
        n = e.getTrackpoint(t);
        if (n !== undefined) {
            return e.reversePixelValue(n)
        }
    },
    onDragEnd: function(e) {
        var t = this,
        n = t.slider,
        r = t.value;
        n.onDragEnd(t, e);
        t.el.removeCls(Ext.baseCSSPrefix + "slider-thumb-drag");
        t.dragging = n.dragging = false;
        n.fireEvent("dragend", n, e);
        if (t.dragStartValue != r) {
            n.fireEvent("changecomplete", n, r, t)
        }
    },
    destroy: function() {
        Ext.destroy(this.tracker)
    }
});Ext.define("Ext.slider.Tip", {
    extend: Ext.tip.Tip,
    minWidth: 10,
    alias: "widget.slidertip",
    offsets: null,
    align: null,
    position: "",
    defaultVerticalPosition: "left",
    defaultHorizontalPosition: "top",
    isSliderTip: true,
    init: function(e) {
        var t = this,
        n, r;
        if (!t.position) {
            t.position = e.vertical ? t.defaultVerticalPosition: t.defaultHorizontalPosition
        }
        switch (t.position) {
        case "top":
            r = [0, -10];
            n = "b-t?";
            break;
        case "bottom":
            r = [0, 10];
            n = "t-b?";
            break;
        case "left":
            r = [ - 10, 0];
            n = "r-l?";
            break;
        case "right":
            r = [10, 0];
            n = "l-r?"
        }
        if (!t.align) {
            t.align = n
        }
        if (!t.offsets) {
            t.offsets = r
        }
        e.on({
            scope: t,
            dragstart: t.onSlide,
            drag: t.onSlide,
            dragend: t.hide,
            destroy: t.destroy
        })
    },
    onSlide: function(e, t, n) {
        var r = this;
        r.show();
        r.update(r.getText(n));
        r.el.alignTo(n.el, r.align, r.offsets)
    },
    getText: function(e) {
        return String(e.value)
    }
});Ext.define("Ext.slider.Multi", {
    extend: Ext.form.field.Base,
    alias: "widget.multislider",
    alternateClassName: "Ext.slider.MultiSlider",
    childEls: ["endEl", "innerEl"],
    fieldSubTpl: ['<div id="{id}" role="{role}" {inputAttrTpl} class="' + Ext.baseCSSPrefix + "slider {fieldCls} {vertical}", '{childElCls}"', '<tpl if="tabIdx != null"> tabIndex="{tabIdx}"</tpl>', '<tpl if="isVertical"> aria-orientation="vertical"<tpl else> aria-orientation="horizontal"</tpl>', ">", '<div id="{cmpId}-endEl" class="' + Ext.baseCSSPrefix + 'slider-end" role="presentation">', '<div id="{cmpId}-innerEl" class="' + Ext.baseCSSPrefix + 'slider-inner" role="presentation">', "{%this.renderThumbs(out, values)%}", "</div>", "</div>", "</div>", {
        renderThumbs: function(e, t) {
            var n = t.$comp,
            r = 0,
            i = n.thumbs,
            s = i.length,
            o, u;
            for (; r < s; r++) {
                o = i[r];
                u = o.getElConfig();
                u.id = n.id + "-thumb-" + r;
                Ext.DomHelper.generateMarkup(u, e)
            }
        },
        disableFormats: true
    }],
    horizontalProp: "left",
    vertical: false,
    minValue: 0,
    maxValue: 100,
    decimalPrecision: 0,
    keyIncrement: 1,
    increment: 0,
    clickRange: [5, 15],
    clickToChange: true,
    animate: true,
    dragging: false,
    constrainThumbs: true,
    componentLayout: "sliderfield",
    useTips: true,
    tipText: null,
    ariaRole: "slider",
    initValue: function() {
        var e = this,
        t = Ext.value,
        n = t(e.values, [t(e.value, t(e.minValue, 0))]),
        r = 0,
        i = n.length;
        e.originalValue = n;
        for (; r < i; r++) {
            e.addThumb(e.normalizeValue(n[r]))
        }
    },
    initComponent: function() {
        var e = this,
        t, n, r, i, s;
        e.thumbs = [];
        e.keyIncrement = Math.max(e.increment, e.keyIncrement);
        e.addEvents("beforechange", "change", "changecomplete", "dragstart", "drag", "dragend");
        e.callParent();
        if (e.useTips) {
            if (Ext.isObject(e.useTips)) {
                t = Ext.apply({},
                e.useTips)
            } else {
                t = e.tipText ? {
                    getText: e.tipText
                }: {}
            }
            s = e.plugins = e.plugins || [];
            i = s.length;
            for (r = 0; r < i; r++) {
                if (s[r].isSliderTip) {
                    n = true;
                    break
                }
            }
            if (!n) {
                e.plugins.push(new Ext.slider.Tip(t))
            }
        }
    },
    addThumb: function(e) {
        var t = this,
        n = new Ext.slider.Thumb({
            ownerCt: t,
            ownerLayout: t.getComponentLayout(),
            value: e,
            slider: t,
            index: t.thumbs.length,
            constrain: t.constrainThumbs,
            disabled: !!t.readOnly
        });
        t.thumbs.push(n);
        if (t.rendered) {
            n.render()
        }
        return n
    },
    promoteThumb: function(e) {
        var t = this.thumbStack || (this.thumbStack = Ext.Array.slice(this.thumbs)),
        n = t.length,
        r = 1e4,
        i;
        if (t[0] !== e) {
            Ext.Array.remove(t, e);
            t.unshift(e)
        }
        for (i = 0; i < n; i++) {
            t[i].el.setStyle("zIndex", r);
            r -= 1e3
        }
    },
    getSubTplData: function() {
        var e = this;
        return Ext.apply(e.callParent(), {
            $comp: e,
            isVertical: e.vertical,
            vertical: e.vertical ? Ext.baseCSSPrefix + "slider-vert": Ext.baseCSSPrefix + "slider-horz",
            minValue: e.minValue,
            maxValue: e.maxValue,
            value: e.value,
            tabIdx: e.tabIndex,
            childElCls: ""
        })
    },
    onRender: function() {
        var e = this,
        t = e.thumbs,
        n = t.length,
        r = 0,
        i;
        e.callParent(arguments);
        for (r = 0; r < n; r++) {
            i = t[r];
            i.el = e.el.getById(e.id + "-thumb-" + r);
            i.onRender()
        }
    },
    initEvents: function() {
        var e = this;
        e.mon(e.el, {
            scope: e,
            mousedown: e.onMouseDown,
            keydown: e.onKeyDown
        })
    },
    onDragStart: Ext.emptyFn,
    onDragEnd: Ext.emptyFn,
    getTrackpoint: function(e) {
        var t = this,
        n = t.vertical,
        r = t.innerEl,
        i, s, o;
        if (n) {
            o = "top";
            i = r.getHeight()
        } else {
            o = t.horizontalProp;
            i = r.getWidth()
        }
        e = t.transformTrackPoints(r.translatePoints(e));
        s = Ext.Number.constrain(e[o], 0, i);
        return n ? i - s: s
    },
    transformTrackPoints: Ext.identityFn,
    onMouseDown: function(e) {
        var t = this,
        n = false,
        r = 0,
        i = t.thumbs,
        s = i.length,
        o;
        if (t.disabled) {
            return
        }
        for (; r < s; r++) {
            n = n || e.target == i[r].el.dom
        }
        if (t.clickToChange && !n) {
            o = t.getTrackpoint(e.getXY());
            if (o !== undefined) {
                t.onClickChange(o)
            }
        }
        t.focus()
    },
    onClickChange: function(e) {
        var t = this,
        n, r;
        n = t.getNearest(e);
        if (!n.disabled) {
            r = n.index;
            t.setValue(r, Ext.util.Format.round(t.reversePixelValue(e), t.decimalPrecision), undefined, true)
        }
    },
    getNearest: function(e) {
        var t = this,
        n = t.reversePixelValue(e),
        r = t.getRange() + 5,
        i = null,
        s = t.thumbs,
        o = 0,
        u = s.length,
        a,
        f,
        l;
        for (; o < u; o++) {
            a = t.thumbs[o];
            f = a.value;
            l = Math.abs(f - n);
            if (Math.abs(l <= r)) {
                i = a;
                r = l
            }
        }
        return i
    },
    onKeyDown: function(e) {
        var t = this,
        n, r;
        if (t.disabled || t.thumbs.length !== 1) {
            e.preventDefault();
            return
        }
        n = e.getKey();
        switch (n) {
        case e.UP:
        case e.RIGHT:
            e.stopEvent();
            r = e.ctrlKey ? t.maxValue: t.getValue(0) + t.keyIncrement;
            t.setValue(0, r, undefined, true);
            break;
        case e.DOWN:
        case e.LEFT:
            e.stopEvent();
            r = e.ctrlKey ? t.minValue: t.getValue(0) - t.keyIncrement;
            t.setValue(0, r, undefined, true);
            break;
        default:
            e.preventDefault()
        }
    },
    normalizeValue: function(e) {
        var t = this,
        n = t.zeroBasedSnapping ? "snap": "snapInRange";
        e = Ext.Number[n](e, t.increment, t.minValue, t.maxValue);
        e = Ext.util.Format.round(e, t.decimalPrecision);
        e = Ext.Number.constrain(e, t.minValue, t.maxValue);
        return e
    },
    setMinValue: function(e) {
        var t = this,
        n = t.thumbs,
        r = n.length,
        i, s;
        t.minValue = e;
        for (s = 0; s < r; ++s) {
            i = n[s];
            if (i.value < e) {
                t.setValue(s, e, false)
            }
        }
        t.syncThumbs()
    },
    setMaxValue: function(e) {
        var t = this,
        n = t.thumbs,
        r = n.length,
        i, s;
        t.maxValue = e;
        for (s = 0; s < r; ++s) {
            i = n[s];
            if (i.value > e) {
                t.setValue(s, e, false)
            }
        }
        t.syncThumbs()
    },
    setValue: function(e, t, n, r) {
        var i = this,
        s = i.thumbs,
        o, u, a, f;
        if (Ext.isArray(e)) {
            f = e;
            n = t;
            for (a = 0, u = f.length; a < u; ++a) {
                o = s[a];
                if (o) {
                    i.setValue(a, f[a], n)
                }
            }
            return i
        }
        o = i.thumbs[e];
        t = i.normalizeValue(t);
        if (t !== o.value && i.fireEvent("beforechange", i, t, o.value, o) !== false) {
            o.value = t;
            if (i.rendered) {
                o.move(i.calculateThumbPosition(t), Ext.isDefined(n) ? n !== false: i.animate);
                i.fireEvent("change", i, t, o);
                i.checkDirty();
                if (r) {
                    i.fireEvent("changecomplete", i, t, o)
                }
            }
        }
        return i
    },
    calculateThumbPosition: function(e) {
        var t = this,
        n = t.minValue,
        r = (e - n) / t.getRange() * 100;
        if (isNaN(r)) {
            r = n
        }
        return r
    },
    getRatio: function() {
        var e = this,
        t = e.innerEl,
        n = e.vertical ? t.getHeight() : t.getWidth(),
        r = e.getRange();
        return r === 0 ? n: n / r
    },
    getRange: function() {
        return this.maxValue - this.minValue
    },
    reversePixelValue: function(e) {
        return this.minValue + e / this.getRatio()
    },
    reversePercentageValue: function(e) {
        return this.minValue + this.getRange() * (e / 100)
    },
    onDisable: function() {
        var e = this,
        t = 0,
        n = e.thumbs,
        r = n.length,
        i, s, o;
        e.callParent();
        for (; t < r; t++) {
            i = n[t];
            s = i.el;
            i.disable();
            if (Ext.isIE) {
                o = s.getXY();
                s.hide();
                e.innerEl.addCls(e.disabledCls).dom.disabled = true;
                if (!e.thumbHolder) {
                    e.thumbHolder = e.endEl.createChild({
                        role: "presentation",
                        cls: Ext.baseCSSPrefix + "slider-thumb " + e.disabledCls
                    })
                }
                e.thumbHolder.show().setXY(o)
            }
        }
    },
    onEnable: function() {
        var e = this,
        t = 0,
        n = e.thumbs,
        r = n.length,
        i, s;
        this.callParent();
        for (; t < r; t++) {
            i = n[t];
            s = i.el;
            i.enable();
            if (Ext.isIE) {
                e.innerEl.removeCls(e.disabledCls).dom.disabled = false;
                if (e.thumbHolder) {
                    e.thumbHolder.hide()
                }
                s.show();
                e.syncThumbs()
            }
        }
    },
    syncThumbs: function() {
        if (this.rendered) {
            var e = this.thumbs,
            t = e.length,
            n = 0;
            for (; n < t; n++) {
                e[n].move(this.calculateThumbPosition(e[n].value))
            }
        }
    },
    getValue: function(e) {
        return Ext.isNumber(e) ? this.thumbs[e].value: this.getValues()
    },
    getValues: function() {
        var e = [],
        t = 0,
        n = this.thumbs,
        r = n.length;
        for (; t < r; t++) {
            e.push(n[t].value)
        }
        return e
    },
    getSubmitValue: function() {
        var e = this;
        return e.disabled || !e.submitValue ? null: e.getValue()
    },
    reset: function() {
        var e = this,
        t = [].concat(e.originalValue),
        n = 0,
        r = t.length,
        i;
        for (; n < r; n++) {
            i = t[n];
            e.setValue(n, i)
        }
        e.clearInvalid();
        delete e.wasValid
    },
    setReadOnly: function(e) {
        var t = this,
        n = t.thumbs,
        r = n.length,
        i = 0;
        t.callParent(arguments);
        e = t.readOnly;
        for (; i < r; ++i) {
            if (e) {
                n[i].disable()
            } else {
                n[i].enable()
            }
        }
    },
    beforeDestroy: function() {
        var e = this,
        t = e.thumbs,
        n = 0,
        r = t.length,
        i;
        Ext.destroy(e.innerEl, e.endEl, e.focusEl);
        for (; n < r; n++) {
            i = t[n];
            Ext.destroy(i)
        }
        e.callParent()
    }
});Ext.define("Ext.tab.Tab", {
    extend: Ext.button.Button,
    alias: "widget.tab",
    isTab: true,
    baseCls: Ext.baseCSSPrefix + "tab",
    closeElOverCls: Ext.baseCSSPrefix + "tab-close-btn-over",
    activeCls: "active",
    closableCls: "closable",
    closable: true,
    closeText: "Close Tab",
    active: false,
    childEls: ["closeEl"],
    scale: false,
    position: "top",
    ariaRole: "tab",
    initComponent: function() {
        var e = this;
        e.addEvents("activate", "deactivate", "beforeclose", "close");
        e.callParent(arguments);
        if (e.card) {
            e.setCard(e.card)
        }
        e.overCls = ["over", e.position + "-over"]
    },
    getTemplateArgs: function() {
        var e = this,
        t = e.callParent();
        t.closable = e.closable;
        t.closeText = e.closeText;
        return t
    },
    getFramingInfoCls: function() {
        return this.baseCls + "-" + this.ui + "-" + this.position
    },
    beforeRender: function() {
        var e = this,
        t = e.up("tabbar"),
        n = e.up("tabpanel");
        e.callParent();
        e.addClsWithUI(e.position);
        if (e.active) {
            e.addClsWithUI([e.activeCls, e.position + "-" + e.activeCls])
        }
        e.syncClosableUI();
        if (!e.minWidth) {
            e.minWidth = t ? t.minTabWidth: e.minWidth;
            if (!e.minWidth && n) {
                e.minWidth = n.minTabWidth
            }
            if (e.minWidth && e.iconCls) {
                e.minWidth += 25
            }
        }
        if (!e.maxWidth) {
            e.maxWidth = t ? t.maxTabWidth: e.maxWidth;
            if (!e.maxWidth && n) {
                e.maxWidth = n.maxTabWidth
            }
        }
    },
    onRender: function() {
        var e = this;
        e.setElOrientation();
        e.callParent(arguments);
        if (e.closable) {
            e.closeEl.addClsOnOver(e.closeElOverCls)
        }
        e.initKeyNav()
    },
    initKeyNav: function() {
        var e = this;
        e.keyNav = new Ext.util.KeyNav(e.el, {
            enter: e.onEnterKey,
            del: e.onDeleteKey,
            scope: e
        })
    },
    setElOrientation: function() {
        var e = this.position;
        if (e === "left" || e === "right") {
            this.el.setVertical(e === "right" ? 90 : 270)
        }
    },
    enable: function(e) {
        var t = this;
        t.callParent(arguments);
        t.removeClsWithUI(t.position + "-disabled");
        return t
    },
    disable: function(e) {
        var t = this;
        t.callParent(arguments);
        t.addClsWithUI(t.position + "-disabled");
        return t
    },
    onDestroy: function() {
        var e = this;
        Ext.destroy(e.keyNav);
        delete e.keyNav;
        e.callParent(arguments)
    },
    setClosable: function(e) {
        var t = this;
        e = !arguments.length || !!e;
        if (t.closable != e) {
            t.closable = e;
            if (t.card) {
                t.card.closable = e
            }
            t.syncClosableUI();
            if (t.rendered) {
                t.syncClosableElements();
                t.updateLayout()
            }
        }
    },
    syncClosableElements: function() {
        var e = this,
        t = e.closeEl;
        if (e.closable) {
            if (!t) {
                t = e.closeEl = e.btnWrap.insertSibling({
                    tag: "a",
                    role: "presentation",
                    cls: e.baseCls + "-close-btn",
                    href: "#",
                    title: e.closeText
                },
                "after")
            }
            t.addClsOnOver(e.closeElOverCls)
        } else {
            if (t) {
                t.remove();
                delete e.closeEl
            }
        }
    },
    syncClosableUI: function() {
        var e = this,
        t = [e.closableCls, e.closableCls + "-" + e.position];
        if (e.closable) {
            e.addClsWithUI(t)
        } else {
            e.removeClsWithUI(t)
        }
    },
    setCard: function(e) {
        var t = this;
        t.card = e;
        t.setText(t.title || e.title);
        t.setIconCls(t.iconCls || e.iconCls);
        t.setIcon(t.icon || e.icon);
        t.setGlyph(t.glyph || e.glyph)
    },
    onCloseClick: function() {
        var e = this;
        if (e.fireEvent("beforeclose", e) !== false) {
            if (e.tabBar) {
                if (e.tabBar.closeTab(e) === false) {
                    return
                }
            } else {
                e.fireClose()
            }
        }
    },
    fireClose: function() {
        this.fireEvent("close", this)
    },
    onEnterKey: function(e) {
        var t = this;
        if (t.tabBar) {
            t.tabBar.onClick(e, t.el)
        }
    },
    onDeleteKey: function(e) {
        if (this.closable) {
            this.onCloseClick()
        }
    },
    afterClick: function(e) {
        if (!e) {
            this.focus()
        }
    },
    activate: function(e) {
        var t = this;
        t.active = true;
        t.addClsWithUI([t.activeCls, t.position + "-" + t.activeCls]);
        if (e !== true) {
            t.fireEvent("activate", t)
        }
    },
    deactivate: function(e) {
        var t = this;
        t.active = false;
        t.removeClsWithUI([t.activeCls, t.position + "-" + t.activeCls]);
        if (e !== true) {
            t.fireEvent("deactivate", t)
        }
    }
});Ext.define("Ext.util.Point", {
    extend: Ext.util.Region,
    statics: {
        fromEvent: function(e) {
            e = e.browserEvent || e;
            e = e.changedTouches && e.changedTouches.length > 0 ? e.changedTouches[0] : e;
            return new this(e.pageX, e.pageY)
        }
    },
    constructor: function(e, t) {
        this.callParent([t, e, t, e])
    },
    toString: function() {
        return "Point[" + this.x + "," + this.y + "]"
    },
    equals: function(e) {
        return this.x == e.x && this.y == e.y
    },
    isWithin: function(e, t) {
        if (!Ext.isObject(t)) {
            t = {
                x: t,
                y: t
            }
        }
        return this.x <= e.x + t.x && this.x >= e.x - t.x && this.y <= e.y + t.y && this.y >= e.y - t.y
    },
    isContainedBy: function(e) {
        if (! (e instanceof Ext.util.Region)) {
            e = Ext.get(e.el || e).getRegion()
        }
        return e.contains(this)
    },
    roundedEquals: function(e) {
        return Math.round(this.x) == Math.round(e.x) && Math.round(this.y) == Math.round(e.y)
    }
},
function() {
    this.prototype.translate = Ext.util.Region.prototype.translateBy
});Ext.define("Ext.tab.Bar", {
    extend: Ext.panel.Header,
    alias: "widget.tabbar",
    baseCls: Ext.baseCSSPrefix + "tab-bar",
    isTabBar: true,
    defaultType: "tab",
    plain: false,
    ariaRole: "tablist",
    childEls: ["body", "strip"],
    renderTpl: ['<div id="{id}-body" role="presentation" class="{baseCls}-body {bodyCls} {bodyTargetCls}{childElCls}', '<tpl if="ui"> {baseCls}-body-{ui}', '<tpl for="uiCls"> {parent.baseCls}-body-{parent.ui}-{.}</tpl>', '</tpl>"<tpl if="bodyStyle"> style="{bodyStyle}"</tpl>>', "{%this.renderContainer(out,values)%}", "</div>", '<div id="{id}-strip" role="presentation" class="{baseCls}-strip {baseCls}-strip-{dock}{childElCls}', '<tpl if="ui"> {baseCls}-strip-{ui}', '<tpl for="uiCls"> {parent.baseCls}-strip-{parent.ui}-{.}</tpl>', '</tpl>">', "</div>"],
    _reverseDockNames: {
        left: "right",
        right: "left"
    },
    initComponent: function() {
        var e = this;
        if (e.plain) {
            e.addCls(e.baseCls + "-plain")
        }
        e.addClsWithUI(e.orientation);
        e.addEvents("change");
        e.callParent(arguments);
        Ext.merge(e.layout, e.initialConfig.layout);
        e.layout.align = e.orientation == "vertical" ? "left": "top";
        e.layout.overflowHandler = new Ext.layout.container.boxOverflow.Scroller(e.layout);
        e.remove(e.titleCmp);
        delete e.titleCmp;
        Ext.apply(e.renderData, {
            bodyCls: e.bodyCls,
            dock: e.dock
        })
    },
    onRender: function() {
        var e = this;
        e.callParent();
        if (e.orientation === "vertical" && (Ext.isIE8 || Ext.isIE9) && Ext.isStrict) {
            e.el.on({
                mousemove: e.onMouseMove,
                scope: e
            })
        }
    },
    afterRender: function() {
        var e = this.layout;
        this.callParent();
        if (Ext.isIE9 && Ext.isStrict && this.orientation === "vertical") {
            e.innerCt.on("scroll",
            function() {
                e.innerCt.dom.scrollLeft = 0
            })
        }
    },
    afterLayout: function() {
        this.adjustTabPositions();
        this.callParent(arguments)
    },
    adjustTabPositions: function() {
        var e = this.items.items,
        t = e.length,
        n;
        if (!Ext.isIE9m) {
            if (this.dock === "right") {
                while (t--) {
                    n = e[t];
                    if (n.isVisible()) {
                        n.el.setStyle("left", n.lastBox.width + "px")
                    }
                }
            } else {
                if (this.dock === "left") {
                    while (t--) {
                        n = e[t];
                        if (n.isVisible()) {
                            n.el.setStyle("left", -n.lastBox.height + "px")
                        }
                    }
                }
            }
        }
    },
    getLayout: function() {
        var e = this;
        e.layout.type = e.orientation === "horizontal" ? "hbox": "vbox";
        return e.callParent(arguments)
    },
    onAdd: function(e) {
        e.position = this.dock;
        this.callParent(arguments)
    },
    onRemove: function(e) {
        var t = this;
        if (e === t.previousTab) {
            t.previousTab = null
        }
        t.callParent(arguments)
    },
    afterComponentLayout: function(e) {
        var t = this,
        n = t.needsScroll;
        t.callParent(arguments);
        if (n) {
            t.layout.overflowHandler.scrollToItem(t.activeTab)
        }
        delete t.needsScroll
    },
    onClick: function(e, t) {
        var n = this,
        r = n.tabPanel,
        i, s, o, u;
        if (e.getTarget("." + Ext.baseCSSPrefix + "box-scroller")) {
            return
        }
        if (n.orientation === "vertical" && (Ext.isIE8 || Ext.isIE9) && Ext.isStrict) {
            u = n.getTabInfoFromPoint(e.getXY());
            s = u.tab;
            o = u.close
        } else {
            i = e.getTarget("." + Ext.tab.Tab.prototype.baseCls);
            s = i && Ext.getCmp(i.id);
            o = s && s.closeEl && t === s.closeEl.dom
        }
        if (o) {
            e.preventDefault()
        }
        if (s && s.isDisabled && !s.isDisabled()) {
            if (s.closable && o) {
                s.onCloseClick()
            } else {
                if (r) {
                    r.setActiveTab(s.card)
                } else {
                    n.setActiveTab(s)
                }
            }
            s.afterClick(o)
        }
    },
    onMouseMove: function(e) {
        var t = this,
        n = t._overTab,
        r, i;
        if (e.getTarget("." + Ext.baseCSSPrefix + "box-scroller")) {
            return
        }
        r = t.getTabInfoFromPoint(e.getXY());
        i = r.tab;
        if (i !== n) {
            if (n && n.rendered) {
                n.onMouseLeave(e);
                t._overTab = null
            }
            if (i) {
                i.onMouseEnter(e);
                t._overTab = i;
                if (!i.disabled) {
                    t.el.setStyle("cursor", "pointer")
                }
            } else {
                t.el.setStyle("cursor", "default")
            }
        }
    },
    onMouseLeave: function(e) {
        var t = this._overTab;
        if (t && t.rendered) {
            t.onMouseLeave(e)
        }
    },
    getTabInfoFromPoint: function(e) {
        var t = this,
        n = t.items.items,
        r = n.length,
        i = t.layout.innerCt,
        s = i.getXY(),
        o = new Ext.util.Point(e[0], e[1]),
        u = 0,
        a,
        f,
        l,
        c,
        h,
        p,
        d,
        v,
        m,
        g,
        y,
        b,
        w,
        E,
        S,
        x,
        T;
        for (; u < r; u++) {
            a = n[u].lastBox;
            g = s[0] + a.x;
            y = s[1] - i.dom.scrollTop + a.y;
            b = a.width;
            w = a.height;
            f = new Ext.util.Region(y, g + b, y + w, g);
            if (f.contains(o)) {
                T = n[u];
                l = T.closeEl;
                if (l) {
                    if (t._isTabReversed === undefined) {
                        t._isTabReversed = S = T.btnWrap.dom.currentStyle.filter.indexOf("rotation=2") !== -1
                    }
                    x = S ? this._reverseDockNames[t.dock] : t.dock;
                    v = l.getWidth();
                    m = l.getHeight();
                    h = t.getCloseXY(l, g, y, b, w, v, m, x);
                    p = h[0];
                    d = h[1];
                    E = new Ext.util.Region(d, p + v, d + m, p);
                    c = E.contains(o)
                }
                break
            }
        }
        return {
            tab: T,
            close: c
        }
    },
    getCloseXY: function(e, t, n, r, i, s, o, u) {
        var a = e.getXY(),
        f,
        l;
        if (u === "right") {
            f = t + r - (a[1] - n + o);
            l = n + (a[0] - t)
        } else {
            f = t + (a[1] - n);
            l = n + t + i - a[0] - s
        }
        return [f, l]
    },
    closeTab: function(e) {
        var t = this,
        n = e.card,
        r = t.tabPanel,
        i;
        if (n && n.fireEvent("beforeclose", n) === false) {
            return false
        }
        i = t.findNextActivatable(e);
        Ext.suspendLayouts();
        if (r && n) {
            delete e.ownerCt;
            n.fireEvent("close", n);
            r.remove(n);
            if (!r.getComponent(n)) {
                e.fireClose();
                t.remove(e)
            } else {
                e.ownerCt = t;
                Ext.resumeLayouts(true);
                return false
            }
        }
        if (i) {
            if (r) {
                r.setActiveTab(i.card)
            } else {
                t.setActiveTab(i)
            }
            i.focus()
        }
        Ext.resumeLayouts(true)
    },
    findNextActivatable: function(e) {
        var t = this;
        if (e.active && t.items.getCount() > 1) {
            return t.previousTab && t.previousTab !== e && !t.previousTab.disabled ? t.previousTab: e.next("tab[disabled=false]") || e.prev("tab[disabled=false]")
        }
    },
    setActiveTab: function(e, t) {
        var n = this;
        if (!e.disabled && e !== n.activeTab) {
            if (n.activeTab) {
                if (n.activeTab.isDestroyed) {
                    n.previousTab = null
                } else {
                    n.previousTab = n.activeTab;
                    n.activeTab.deactivate()
                }
            }
            e.activate();
            n.activeTab = e;
            n.needsScroll = true;
            if (!t) {
                n.fireEvent("change", n, e, e.card);
                n.updateLayout()
            }
        }
    }
});Ext.define("Ext.tree.Column", {
    extend: Ext.grid.column.Column,
    alias: "widget.treecolumn",
    tdCls: Ext.baseCSSPrefix + "grid-cell-treecolumn",
    autoLock: true,
    lockable: false,
    draggable: false,
    hideable: false,
    iconCls: Ext.baseCSSPrefix + "tree-icon",
    checkboxCls: Ext.baseCSSPrefix + "tree-checkbox",
    elbowCls: Ext.baseCSSPrefix + "tree-elbow",
    expanderCls: Ext.baseCSSPrefix + "tree-expander",
    textCls: Ext.baseCSSPrefix + "tree-node-text",
    innerCls: Ext.baseCSSPrefix + "grid-cell-inner-treecolumn",
    isTreeColumn: true,
    cellTpl: ['<tpl for="lines">', '<img src="{parent.blankUrl}" class="{parent.childCls} {parent.elbowCls}-img ', '{parent.elbowCls}-<tpl if=".">line<tpl else>empty</tpl>" role="presentation"/>', "</tpl>", '<img src="{blankUrl}" class="{childCls} {elbowCls}-img {elbowCls}', '<tpl if="isLast">-end</tpl><tpl if="expandable">-plus {expanderCls}</tpl>" role="presentation"/>', '<tpl if="checked !== null">', '<input type="button" {ariaCellCheckboxAttr}', ' class="{childCls} {checkboxCls}<tpl if="checked"> {checkboxCls}-checked</tpl>"/>', "</tpl>", '<img src="{blankUrl}" role="presentation" class="{childCls} {baseIconCls} ', '{baseIconCls}-<tpl if="leaf">leaf<tpl else>parent</tpl> {iconCls}"', '<tpl if="icon">style="background-image:url({icon})"</tpl>/>', '<tpl if="href">', '<a href="{href}" role="link" target="{hrefTarget}" class="{textCls} {childCls}">{value}</a>', "<tpl else>", '<span class="{textCls} {childCls}">{value}</span>', "</tpl>"],
    initComponent: function() {
        var e = this,
        t = e.renderer;
        if (typeof t == "string") {
            t = Ext.util.Format[t]
        }
        e.origRenderer = t;
        e.origScope = e.scope || window;
        e.renderer = e.treeRenderer;
        e.scope = e;
        e.callParent()
    },
    treeRenderer: function(e, t, n, r, i, s, o) {
        var u = this,
        a = n.get("cls"),
        f;
        if (a) {
            t.tdCls += " " + a
        }
        f = u.initTemplateRendererData(e, t, n, r, i, s, o);
        return u.getTpl("cellTpl").apply(f)
    },
    initTemplateRendererData: function(e, t, n, r, i, s, o) {
        var u = this,
        a = u.origRenderer,
        f = n.data,
        l = n.parentNode,
        c = o.rootVisible,
        h = [],
        p;
        while (l && (c || l.data.depth > 0)) {
            p = l.data;
            h[c ? p.depth: p.depth - 1] = p.isLast ? 0 : 1;
            l = l.parentNode
        }
        return {
            record: n,
            baseIconCls: u.iconCls,
            iconCls: f.iconCls,
            icon: f.icon,
            checkboxCls: u.checkboxCls,
            checked: f.checked,
            elbowCls: u.elbowCls,
            expanderCls: u.expanderCls,
            textCls: u.textCls,
            leaf: f.leaf,
            expandable: n.isExpandable(),
            isLast: f.isLast,
            blankUrl: Ext.BLANK_IMAGE_URL,
            href: f.href,
            hrefTarget: f.hrefTarget,
            lines: h,
            metaData: t,
            childCls: u.getChildCls ? u.getChildCls() + " ": "",
            value: a ? a.apply(u.origScope, arguments) : e
        }
    }
});Ext.define("Ext.selection.CheckboxModel", {
    alias: "selection.checkboxmodel",
    extend: Ext.selection.RowModel,
    mode: "MULTI",
    injectCheckbox: 0,
    checkOnly: false,
    showHeaderCheckbox: undefined,
    checkSelector: "." + Ext.baseCSSPrefix + "grid-row-checker",
    headerWidth: 24,
    checkerOnCls: Ext.baseCSSPrefix + "grid-hd-checker-on",
    tdCls: Ext.baseCSSPrefix + "grid-cell-special " + Ext.baseCSSPrefix + "grid-cell-row-checker",
    constructor: function() {
        var e = this;
        e.callParent(arguments);
        if (e.mode === "SINGLE" && e.showHeaderCheckbox !== true) {
            e.showHeaderCheckbox = false
        }
    },
    beforeViewRender: function(e) {
        var t = this,
        n;
        t.callParent(arguments);
        if (!t.hasLockedHeader() || e.headerCt.lockedCt) {
            if (t.showHeaderCheckbox !== false) {
                e.headerCt.on("headerclick", t.onHeaderClick, t)
            }
            t.addCheckbox(e, true);
            n = e.ownerCt;
            if (e.headerCt.lockedCt) {
                n = n.ownerCt
            }
            t.mon(n, "reconfigure", t.onReconfigure, t)
        }
    },
    bindComponent: function(e) {
        var t = this;
        t.sortable = false;
        t.callParent(arguments)
    },
    hasLockedHeader: function() {
        var e = this.views,
        t = e.length,
        n;
        for (n = 0; n < t; n++) {
            if (e[n].headerCt.lockedCt) {
                return true
            }
        }
        return false
    },
    addCheckbox: function(e, t) {
        var n = this,
        r = n.injectCheckbox,
        i = e.headerCt;
        if (r !== false) {
            if (r == "first") {
                r = 0
            } else {
                if (r == "last") {
                    r = i.getColumnCount()
                }
            }
            Ext.suspendLayouts();
            if (e.getStore().buffered) {
                n.showHeaderCheckbox = false
            }
            i.add(r, n.getHeaderConfig());
            Ext.resumeLayouts()
        }
        if (t !== true) {
            e.refresh()
        }
    },
    onReconfigure: function(e, t, n) {
        if (n) {
            this.addCheckbox(this.views[0])
        }
    },
    toggleUiHeader: function(e) {
        var t = this.views[0],
        n = t.headerCt,
        r = n.child("gridcolumn[isCheckerHd]"),
        i = this.checkerOnCls;
        if (r) {
            if (e) {
                r.addCls(i)
            } else {
                r.removeCls(i)
            }
        }
    },
    onHeaderClick: function(e, t, n) {
        if (t.isCheckerHd) {
            n.stopEvent();
            var r = this,
            i = t.el.hasCls(Ext.baseCSSPrefix + "grid-hd-checker-on");
            r.preventFocus = true;
            if (i) {
                r.deselectAll()
            } else {
                r.selectAll()
            }
            delete r.preventFocus
        }
    },
    getHeaderConfig: function() {
        var e = this,
        t = e.showHeaderCheckbox !== false;
        return {
            isCheckerHd: t,
            text: "&#160;",
            clickTargetName: "el",
            width: e.headerWidth,
            sortable: false,
            draggable: false,
            resizable: false,
            hideable: false,
            menuDisabled: true,
            dataIndex: "",
            tdCls: e.tdCls,
            cls: t ? Ext.baseCSSPrefix + "column-header-checkbox ": "",
            renderer: Ext.Function.bind(e.renderer, e),
            editRenderer: e.editRenderer || e.renderEmpty,
            locked: e.hasLockedHeader()
        }
    },
    renderEmpty: function() {
        return "&#160;"
    },
    refresh: function() {
        this.callParent(arguments);
        this.updateHeaderState()
    },
    renderer: function(e, t, n, r, i, s, o) {
        return '<div class="' + Ext.baseCSSPrefix + 'grid-row-checker" role="presentation">&#160;</div>'
    },
    processSelection: function(e, t, n, r, i) {
        var s = this,
        o = i.getTarget(s.checkSelector),
        u;
        if (s.checkOnly && !o) {
            return
        }
        if (o) {
            u = s.getSelectionMode();
            if (u !== "SINGLE") {
                s.setSelectionMode("SIMPLE")
            }
            s.selectWithEvent(t, i);
            s.setSelectionMode(u)
        } else {
            s.selectWithEvent(t, i)
        }
    },
    onSelectChange: function() {
        this.callParent(arguments);
        if (!this.suspendChange) {
            this.updateHeaderState()
        }
    },
    onStoreLoad: function() {
        this.callParent(arguments);
        this.updateHeaderState()
    },
    onStoreAdd: function() {
        this.callParent(arguments);
        this.updateHeaderState()
    },
    onStoreRemove: function() {
        this.callParent(arguments);
        this.updateHeaderState()
    },
    onStoreRefresh: function() {
        this.callParent(arguments);
        this.updateHeaderState()
    },
    maybeFireSelectionChange: function(e) {
        if (e && !this.suspendChange) {
            this.updateHeaderState()
        }
        this.callParent(arguments)
    },
    resumeChanges: function() {
        this.callParent();
        if (!this.suspendChange) {
            this.updateHeaderState()
        }
    },
    updateHeaderState: function() {
        var e = this,
        t = e.store,
        n = t.getCount(),
        r = e.views,
        i = false,
        s = 0,
        o,
        u,
        a;
        if (!t.buffered && n > 0) {
            o = e.selected;
            i = true;
            for (a = 0, u = o.getCount(); a < u; ++a) {
                if (!e.getStoreRecord(o.getAt(a))) {
                    break
                }++s
            }
            i = n === s
        }
        if (r && r.length) {
            e.toggleUiHeader(i)
        }
    }
});Ext.define("Ext.slider.Single", {
    extend: Ext.slider.Multi,
    alias: ["widget.slider", "widget.sliderfield"],
    alternateClassName: ["Ext.Slider", "Ext.form.SliderField", "Ext.slider.SingleSlider", "Ext.slider.Slider"],
    getValue: function() {
        return this.callParent([0])
    },
    setValue: function(e, t) {
        var n = arguments,
        r = n.length;
        if (r == 1 || r <= 3 && typeof n[1] != "number") {
            n = Ext.toArray(n);
            n.unshift(0)
        }
        return this.callParent(n)
    },
    getNearest: function() {
        return this.thumbs[0]
    }
});Ext.define("Ext.state.CookieProvider", {
    extend: Ext.state.Provider,
    constructor: function(e) {
        var t = this;
        t.path = "/";
        t.expires = new Date(Ext.Date.now() + 1e3 * 60 * 60 * 24 * 7);
        t.domain = null;
        t.secure = false;
        t.callParent(arguments);
        t.state = t.readCookies()
    },
    set: function(e, t) {
        var n = this;
        if (typeof t == "undefined" || t === null) {
            n.clear(e);
            return
        }
        n.setCookie(e, t);
        n.callParent(arguments)
    },
    clear: function(e) {
        this.clearCookie(e);
        this.callParent(arguments)
    },
    readCookies: function() {
        var e = {},
        t = document.cookie + ";",
        n = /\s?(.*?)=(.*?);/g,
        r = this.prefix,
        i = r.length,
        s, o, u;
        while ((s = n.exec(t)) != null) {
            o = s[1];
            u = s[2];
            if (o && o.substring(0, i) == r) {
                e[o.substr(i)] = this.decodeValue(u)
            }
        }
        return e
    },
    setCookie: function(e, t) {
        var n = this;
        document.cookie = n.prefix + e + "=" + n.encodeValue(t) + (n.expires == null ? "": "; expires=" + n.expires.toUTCString()) + (n.path == null ? "": "; path=" + n.path) + (n.domain == null ? "": "; domain=" + n.domain) + (n.secure == true ? "; secure": "")
    },
    clearCookie: function(e) {
        var t = this;
        document.cookie = t.prefix + e + "=null; expires=Thu, 01-Jan-1970 00:00:01 GMT" + (t.path == null ? "": "; path=" + t.path) + (t.domain == null ? "": "; domain=" + t.domain) + (t.secure == true ? "; secure": "")
    }
});Ext.define("Ext.util.LocalStorage", {
    id: null,
    destroyed: false,
    lazyKeys: true,
    prefix: "",
    session: false,
    _keys: null,
    _store: null,
    _users: 0,
    statics: {
        cache: {},
        get: function(e) {
            var t = this,
            n = t.cache,
            r = {
                _users: 1
            },
            i;
            if (Ext.isString(e)) {
                r.id = e
            } else {
                Ext.apply(r, e)
            }
            if (! (i = n[r.id])) {
                i = new t(r)
            } else {++i._users
            }
            return i
        },
        supported: true
    },
    constructor: function(e) {
        var t = this;
        Ext.apply(t, e);
        if (t._users) {
            Ext.util.LocalStorage.cache[t.id] = t
        }
        t.init()
    },
    init: function() {
        var e = this,
        t = e.id;
        if (!e.prefix && t) {
            e.prefix = t + "-"
        }
        e._store = e.session ? window.sessionStorage: window.localStorage
    },
    destroy: function() {
        var e = this;
        delete Ext.util.LocalStorage.cache[e.id];
        e._store = e._keys = null;
        e.destroyed = true;
        e.destroy = Ext.emptyFn
    },
    getKeys: function() {
        var e = this,
        t = e._store,
        n = e.prefix,
        r = e._keys,
        i = n.length,
        s, o;
        if (!r) {
            e._keys = r = [];
            for (s = t.length; s--;) {
                o = t.key(s);
                if (o.length > i) {
                    if (n === o.substring(0, i)) {
                        r.push(o.substring(i))
                    }
                }
            }
        }
        return r
    },
    release: function() {
        if (!--this._users) {
            this.destroy()
        }
    },
    save: Ext.emptyFn,
    clear: function() {
        var e = this,
        t = e._store,
        n = e.prefix,
        r = e._keys || e.getKeys(),
        i;
        for (i = r.length; i--;) {
            t.removeItem(n + r[i])
        }
        r.length = 0
    },
    key: function(e) {
        var t = this._keys || this.getKeys();
        return 0 <= e && e < t.length ? t[e] : null
    },
    getItem: function(e) {
        var t = this.prefix + e;
        return this._store.getItem(t)
    },
    removeItem: function(e) {
        var t = this,
        n = t.prefix + e,
        r = t._store,
        i = t._keys,
        s = r.length;
        r.removeItem(n);
        if (i && s !== r.length) {
            if (t.lazyKeys) {
                t._keys = null
            } else {
                Ext.Array.remove(i, e)
            }
        }
    },
    setItem: function(e, t) {
        var n = this,
        r = n.prefix + e,
        i = n._store,
        s = i.length,
        o = n._keys;
        i.setItem(r, t);
        if (o && s !== i.length) {
            o.push(e)
        }
    }
},
function() {
    var e = this;
    if ("localStorage" in window) {
        return
    }
    if (!Ext.isIE) {
        e.supported = false;
        return
    }
    e.override({
        data: null,
        flushDelay: 1,
        init: function() {
            var e = this,
            t = e.data,
            n;
            e.el = n = document.createElement("div");
            n.id = e.id || (e.id = "extjs-localstore");
            n.addBehavior("#default#userdata");
            Ext.getHead().dom.appendChild(n);
            n.load(e.id);
            t = n.getAttribute("xdata");
            e.data = t = t ? Ext.decode(t) : {};
            e._flushFn = function() {
                e._timer = null;
                e.save(0)
            }
        },
        destroy: function() {
            var e = this,
            t = e.el;
            if (t) {
                if (e._timer) {
                    e.save()
                }
                t.parentNode.removeChild(t);
                e.data = e.el = null;
                e.callParent()
            }
        },
        getKeys: function() {
            var e = this,
            t = e._keys;
            if (!t) {
                e._keys = t = Ext.Object.getKeys(e.data)
            }
            return t
        },
        save: function(e) {
            var t = this;
            if (!e) {
                if (t._timer) {
                    clearTimeout(t._timer);
                    t._timer = null
                }
                t.el.setAttribute("xdata", Ext.encode(t.data));
                t.el.save(t.id)
            } else {
                if (!t._timer) {
                    t._timer = setTimeout(t._flushFn, e)
                }
            }
        },
        clear: function() {
            var e = this;
            e.data = {};
            e._keys = null;
            e.save(e.flushDelay)
        },
        getItem: function(e) {
            var t = this.data;
            return e in t ? t[e] : null
        },
        removeItem: function(e) {
            var t = this,
            n = t._keys,
            r = t.data;
            if (e in r) {
                delete r[e];
                if (n) {
                    if (t.lazyKeys) {
                        t._keys = null
                    } else {
                        Ext.Array.remove(n, e)
                    }
                }
                t.save(t.flushDelay)
            }
        },
        setItem: function(e, t) {
            var n = this,
            r = n.data,
            i = n._keys;
            if (i && !(e in r)) {
                i.push(e)
            }
            r[e] = t;
            n.save(n.flushDelay)
        }
    })
});Ext.define("Ext.state.LocalStorageProvider", {
    extend: Ext.state.Provider,
    alias: "state.localstorage",
    constructor: function() {
        var e = this;
        e.callParent(arguments);
        e.store = e.getStorageObject();
        if (e.store) {
            e.state = e.readLocalStorage()
        } else {
            e.state = {}
        }
    },
    readLocalStorage: function() {
        var e = this.store,
        t = {},
        n = e.getKeys(),
        r = n.length,
        i;
        while (r--) {
            i = n[r];
            t[i] = this.decodeValue(e.getItem(i))
        }
        return t
    },
    set: function(e, t) {
        var n = this;
        n.clear(e);
        if (t != null) {
            n.store.setItem(e, n.encodeValue(t));
            n.callParent(arguments)
        }
    },
    clear: function(e) {
        this.store.removeItem(e);
        this.callParent(arguments)
    },
    getStorageObject: function() {
        var e = this.prefix,
        t = e,
        n = t.length - 1;
        if (t.charAt(n) === "-") {
            t = t.substring(0, n)
        }
        return new Ext.util.LocalStorage({
            id: t,
            prefix: e
        })
    }
});Ext.define("Ext.tab.Panel", {
    extend: Ext.panel.Panel,
    alias: "widget.tabpanel",
    alternateClassName: ["Ext.TabPanel"],
    tabPosition: "top",
    removePanelHeader: true,
    plain: false,
    itemCls: Ext.baseCSSPrefix + "tabpanel-child",
    minTabWidth: undefined,
    maxTabWidth: undefined,
    deferredRender: true,
    initComponent: function() {
        var e = this,
        t = [].concat(e.dockedItems || []),
        n = e.activeTab || (e.activeTab = 0),
        r = e.tabPosition;
        e.layout = new Ext.layout.container.Card(Ext.apply({
            owner: e,
            deferredRender: e.deferredRender,
            itemCls: e.itemCls,
            activeItem: n
        },
        e.layout));
        e.tabBar = new Ext.tab.Bar(Ext.apply({
            ui: e.ui,
            dock: e.tabPosition,
            orientation: r == "top" || r == "bottom" ? "horizontal": "vertical",
            plain: e.plain,
            cardLayout: e.layout,
            tabPanel: e
        },
        e.tabBar));
        t.push(e.tabBar);
        e.dockedItems = t;
        e.addEvents("beforetabchange", "tabchange");
        e.callParent(arguments);
        n = e.activeTab = e.getComponent(n);
        if (n) {
            e.tabBar.setActiveTab(n.tab, true)
        }
    },
    setActiveTab: function(e) {
        var t = this,
        n;
        e = t.getComponent(e);
        if (e) {
            n = t.getActiveTab();
            if (n === e || t.fireEvent("beforetabchange", t, e, n) === false) {
                return false
            }
            if (!e.isComponent) {
                Ext.suspendLayouts();
                e = t.add(e);
                Ext.resumeLayouts()
            }
            t.activeTab = e;
            Ext.suspendLayouts();
            t.layout.setActiveItem(e);
            e = t.activeTab = t.layout.getActiveItem();
            if (e && e !== n) {
                t.tabBar.setActiveTab(e.tab);
                Ext.resumeLayouts(true);
                if (n !== e) {
                    t.fireEvent("tabchange", t, e, n)
                }
            } else {
                Ext.resumeLayouts(true)
            }
            return e
        }
    },
    getActiveTab: function() {
        var e = this,
        t = e.getComponent(e.activeTab);
        if (t && e.items.indexOf(t) != -1) {
            e.activeTab = t
        } else {
            e.activeTab = null
        }
        return e.activeTab
    },
    getTabBar: function() {
        return this.tabBar
    },
    onAdd: function(e, t) {
        var n = this,
        r = e.tabConfig || {},
        i = {
            xtype: "tab",
            ui: n.tabBar.ui,
            card: e,
            disabled: e.disabled,
            closable: e.closable,
            hidden: e.hidden && !e.hiddenByLayout,
            tooltip: e.tooltip,
            tabBar: n.tabBar,
            position: n.tabPosition
        };
        if (e.closeText !== undefined) {
            i.closeText = e.closeText
        }
        r = Ext.applyIf(r, i);
        e.tab = n.tabBar.insert(t, r);
        e.on({
            scope: n,
            enable: n.onItemEnable,
            disable: n.onItemDisable,
            beforeshow: n.onItemBeforeShow,
            iconchange: n.onItemIconChange,
            iconclschange: n.onItemIconClsChange,
            titlechange: n.onItemTitleChange
        });
        if (e.isPanel) {
            if (n.removePanelHeader) {
                if (e.rendered) {
                    if (e.header) {
                        e.header.hide()
                    }
                } else {
                    e.header = false
                }
            }
            if (e.isPanel && n.border) {
                e.setBorder(false)
            }
        }
    },
    onItemEnable: function(e) {
        e.tab.enable()
    },
    onItemDisable: function(e) {
        e.tab.disable()
    },
    onItemBeforeShow: function(e) {
        if (e !== this.activeTab) {
            this.setActiveTab(e);
            return false
        }
    },
    onItemIconChange: function(e, t) {
        e.tab.setIcon(t)
    },
    onItemIconClsChange: function(e, t) {
        e.tab.setIconCls(t)
    },
    onItemTitleChange: function(e, t) {
        e.tab.setText(t)
    },
    doRemove: function(e, t) {
        var n = this,
        r;
        if (n.destroying || n.items.getCount() == 1) {
            n.activeTab = null
        } else {
            if ((r = n.tabBar.items.indexOf(n.tabBar.findNextActivatable(e.tab))) !== -1) {
                n.setActiveTab(r)
            }
        }
        this.callParent(arguments);
        delete e.tab.card;
        delete e.tab
    },
    onRemove: function(e, t) {
        var n = this;
        e.un({
            scope: n,
            enable: n.onItemEnable,
            disable: n.onItemDisable,
            beforeshow: n.onItemBeforeShow
        });
        if (!n.destroying && e.tab.ownerCt === n.tabBar) {
            n.tabBar.remove(e.tab)
        }
    }
});Ext.define("Ext.toolbar.Spacer", {
    extend: Ext.Component,
    alias: "widget.tbspacer",
    alternateClassName: "Ext.Toolbar.Spacer",
    baseCls: Ext.baseCSSPrefix + "toolbar-spacer",
    focusable: false,
    ariaRole: "presentation"
});Ext.define("Ext.tree.Panel", {
    extend: Ext.panel.Table,
    alias: "widget.treepanel",
    alternateClassName: ["Ext.tree.TreePanel", "Ext.TreePanel"],
    viewType: "treeview",
    selType: "treemodel",
    treeCls: Ext.baseCSSPrefix + "tree-panel",
    deferRowRender: false,
    animate: false,
    rowLines: false,
    lines: true,
    useArrows: true,
    singleExpand: false,
    ddConfig: {
        enableDrag: true,
        enableDrop: true
    },
    rootVisible: true,
    displayField: "text",
    root: null,
    normalCfgCopy: ["displayField", "root", "singleExpand", "useArrows", "lines", "rootVisible", "scroll"],
    lockedCfgCopy: ["displayField", "root", "singleExpand", "useArrows", "lines", "rootVisible"],
    isTree: true,
    arrowCls: Ext.baseCSSPrefix + "tree-arrows",
    linesCls: Ext.baseCSSPrefix + "tree-lines",
    noLinesCls: Ext.baseCSSPrefix + "tree-no-lines",
    autoWidthCls: Ext.baseCSSPrefix + "autowidth-table",
    constructor: function(e) {
        e = e || {};
        if (e.animate === undefined) {
            e.animate = Ext.isBoolean(this.animate) ? this.animate: Ext.enableFx
        }
        this.enableAnimations = e.animate;
        delete e.animate;
        this.callParent([e])
    },
    initComponent: function() {
        var e = this,
        t = [e.treeCls],
        n = e.store,
        r;
        if (e.useArrows) {
            t.push(e.arrowCls);
            e.lines = false
        }
        if (e.lines) {
            t.push(e.linesCls)
        } else {
            if (!e.useArrows) {
                t.push(e.noLinesCls)
            }
        }
        if (Ext.isString(n)) {
            n = e.store = Ext.StoreMgr.lookup(n)
        } else {
            if (!n || !n.isStore) {
                n = Ext.apply({
                    type: "tree",
                    root: e.root,
                    fields: e.fields,
                    model: e.model,
                    folderSort: e.folderSort
                },
                n);
                n = e.store = Ext.StoreMgr.lookup(n)
            } else {
                if (e.root) {
                    n = e.store = Ext.data.StoreManager.lookup(n);
                    n.setRootNode(e.root);
                    if (e.folderSort !== undefined) {
                        n.folderSort = e.folderSort;
                        n.sort()
                    }
                }
            }
        }
        e.store.singleExpand = e.singleExpand;
        e.viewConfig = Ext.apply({
            rootVisible: e.rootVisible,
            animate: e.enableAnimations,
            singleExpand: e.singleExpand,
            node: n.getRootNode(),
            hideHeaders: e.hideHeaders
        },
        e.viewConfig);
        if (!e.columns) {
            if (e.initialConfig.hideHeaders === undefined) {
                e.hideHeaders = true
            }
            e.addCls(e.autoWidthCls);
            e.columns = [{
                xtype: "treecolumn",
                text: "Name",
                width: Ext.isIE6 ? "100%": 1e4,
                dataIndex: e.displayField
            }]
        }
        if (e.cls) {
            t.push(e.cls)
        }
        e.cls = t.join(" ");
        e.callParent();
        e.selModel.treeStore = e.store;
        r = e.getView();
        e.relayEvents(r, ["checkchange", "afteritemexpand", "afteritemcollapse"]);
        if (!r.isLockingView) {
            if (!r.rootVisible && !e.getRootNode()) {
                e.setRootNode({
                    expanded: true
                })
            }
        }
    },
    bindStore: function(e, t) {
        var n = this;
        n.store = e;
        n.storeListeners = n.mon(e, {
            destroyable: true,
            load: n.onStoreLoad,
            rootchange: n.onRootChange,
            clear: n.onClear,
            scope: n
        });
        n.storeRelayers = n.relayEvents(e, ["beforeload", "load"]);
        n.storeRelayers1 = n.mon(e, {
            destroyable: true,
            append: n.createRelayer("itemappend"),
            remove: n.createRelayer("itemremove"),
            move: n.createRelayer("itemmove", [0, 4]),
            insert: n.createRelayer("iteminsert"),
            beforeappend: n.createRelayer("beforeitemappend"),
            beforeremove: n.createRelayer("beforeitemremove"),
            beforemove: n.createRelayer("beforeitemmove"),
            beforeinsert: n.createRelayer("beforeiteminsert"),
            expand: n.createRelayer("itemexpand", [0, 1]),
            collapse: n.createRelayer("itemcollapse", [0, 1]),
            beforeexpand: n.createRelayer("beforeitemexpand", [0, 1]),
            beforecollapse: n.createRelayer("beforeitemcollapse", [0, 1])
        });
        e.ownerTree = n;
        if (!t) {
            n.view.setRootNode(n.getRootNode())
        }
    },
    unbindStore: function() {
        var e = this,
        t = e.store;
        if (t) {
            Ext.destroy(e.storeListeners, e.storeRelayers, e.storeRelayers1);
            delete t.ownerTree
        }
    },
    onClear: function() {
        this.view.onClear()
    },
    setRootNode: function() {
        return this.store.setRootNode.apply(this.store, arguments)
    },
    getRootNode: function() {
        return this.store.getRootNode()
    },
    onRootChange: function(e) {
        this.view.setRootNode(e)
    },
    getChecked: function() {
        return this.getView().getChecked()
    },
    isItemChecked: function(e) {
        return e.get("checked")
    },
    expandNode: function(e, t, n, r) {
        return this.getView().expand(e, t, n, r || this)
    },
    collapseNode: function(e, t, n, r) {
        return this.getView().collapse(e, t, n, r || this)
    },
    expandAll: function(e, t) {
        var n = this,
        r = n.getRootNode(),
        i = n.enableAnimations;
        if (r) {
            if (!i) {
                Ext.suspendLayouts()
            }
            r.expand(true, e, t || n);
            if (!i) {
                Ext.resumeLayouts(true)
            }
        }
    },
    collapseAll: function(e, t) {
        var n = this,
        r = n.getRootNode(),
        i = n.enableAnimations,
        s = n.getView();
        if (r) {
            if (!i) {
                Ext.suspendLayouts()
            }
            t = t || n;
            if (s.rootVisible) {
                r.collapse(true, e, t)
            } else {
                r.collapseChildren(true, e, t)
            }
            if (!i) {
                Ext.resumeLayouts(true)
            }
        }
    },
    expandPath: function(e, t, n, r, i) {
        var s = this,
        o = s.getRootNode(),
        u = 1,
        a = s.getView(),
        f,
        l;
        t = t || s.getRootNode().idProperty;
        n = n || "/";
        if (Ext.isEmpty(e)) {
            Ext.callback(r, i || s, [false, null]);
            return
        }
        f = e.split(n);
        if (o.get(t) != f[1]) {
            Ext.callback(r, i || s, [false, o]);
            return
        }
        l = function() {
            if (++u === f.length) {
                Ext.callback(r, i || s, [true, o]);
                return
            }
            var e = o.findChild(t, f[u]);
            if (!e) {
                Ext.callback(r, i || s, [false, o]);
                return
            }
            o = e;
            o.expand(false, l)
        };
        o.expand(false, l)
    },
    selectPath: function(e, t, n, r, i) {
        var s = this,
        o, u, a;
        t = t || s.getRootNode().idProperty;
        n = n || "/";
        u = e.split(n);
        a = u.pop();
        if (u.length > 1) {
            s.expandPath(u.join(n), t, n,
            function(e, n) {
                var o = n;
                if (e && n) {
                    n = n.findChild(t, a);
                    if (n) {
                        s.getSelectionModel().select(n);
                        Ext.callback(r, i || s, [true, n]);
                        return
                    }
                }
                Ext.callback(r, i || s, [false, o])
            },
            s)
        } else {
            o = s.getRootNode();
            if (o.getId() === a) {
                s.getSelectionModel().select(o);
                Ext.callback(r, i || s, [true, o])
            } else {
                Ext.callback(r, i || s, [false, null])
            }
        }
    }
});Ext.define("Ext.view.DragZone", {
    extend: Ext.dd.DragZone,
    containerScroll: false,
    constructor: function(e) {
        var t = this,
        n, r, i;
        Ext.apply(t, e);
        if (!t.ddGroup) {
            t.ddGroup = "view-dd-zone-" + t.view.id
        }
        n = t.view;
        r = n.ownerCt;
        if (r) {
            i = r.getTargetEl().dom
        } else {
            i = n.el.dom.parentNode
        }
        t.callParent([i]);
        t.ddel = Ext.get(document.createElement("div"));
        t.ddel.addCls(Ext.baseCSSPrefix + "grid-dd-wrap")
    },
    init: function(e, t, n) {
        var r = this;
        r.initTarget(e, t, n);
        r.view.on("itemmousedown", r.onItemMouseDown, r)
    },
    onValidDrop: function(e, t, n) {
        this.callParent();
        e.el.focus()
    },
    onItemMouseDown: function(e, t, n, r, i) {
        if (!this.isPreventDrag(i, t, n, r)) {
            if (e.focusRow) {
                e.focusRow(t)
            }
            this.handleMouseDown(i)
        }
    },
    isPreventDrag: function(e, t, n, r) {
        return false
    },
    getDragData: function(e) {
        var t = this.view,
        n = e.getTarget(t.getItemSelector());
        if (n) {
            return {
                copy: t.copy || t.allowCopy && e.ctrlKey,
                event: new Ext.EventObjectImpl(e),
                view: t,
                ddel: this.ddel,
                item: n,
                records: t.getSelectionModel().getSelection(),
                fromPosition: Ext.fly(n).getXY()
            }
        }
    },
    onInitDrag: function(e, t) {
        var n = this,
        r = n.dragData,
        i = r.view,
        s = i.getSelectionModel(),
        o = i.getRecord(r.item);
        if (!s.isSelected(o)) {
            s.selectWithEvent(o, n.DDMInstance.mousedownEvent)
        }
        r.records = s.getSelection();
        n.ddel.update(n.getDragText());
        n.proxy.update(n.ddel.dom);
        n.onStartDrag(e, t);
        return true
    },
    getDragText: function() {
        var e = this.dragData.records.length;
        return Ext.String.format(this.dragText, e, e === 1 ? "": "s")
    },
    getRepairXY: function(e, t) {
        return t ? t.fromPosition: false
    }
});Ext.define("Ext.tree.ViewDragZone", {
    extend: Ext.view.DragZone,
    isPreventDrag: function(e, t) {
        return t.get("allowDrag") === false || !!e.getTarget(this.view.expanderSelector)
    },
    getDragText: function() {
        var e = this.dragData.records,
        t = e.length,
        n = e[0].get(this.displayField),
        r = "s";
        if (t === 1 && n) {
            return n
        } else {
            if (!n) {
                r = ""
            }
        }
        return Ext.String.format(this.dragText, t, r)
    },
    afterRepair: function() {
        var e = this,
        t = e.view,
        n = t.selectedItemCls,
        r = e.dragData.records,
        i, s = r.length,
        o = Ext.fly,
        u;
        if (Ext.enableFx && e.repairHighlight) {
            for (i = 0; i < s; i++) {
                u = t.getNode(r[i]);
                o(u.firstChild).highlight(e.repairHighlightColor, {
                    listeners: {
                        beforeanimate: function() {
                            if (t.isSelected(u)) {
                                o(u).removeCls(n)
                            }
                        },
                        afteranimate: function() {
                            if (t.isSelected(u)) {
                                o(u).addCls(n)
                            }
                        }
                    }
                })
            }
        }
        e.dragging = false
    }
});Ext.define("Ext.tree.ViewDropZone", {
    extend: Ext.view.DropZone,
    allowParentInserts: false,
    allowContainerDrops: false,
    appendOnly: false,
    expandDelay: 500,
    indicatorCls: Ext.baseCSSPrefix + "tree-ddindicator",
    expandNode: function(e) {
        var t = this.view;
        this.expandProcId = false;
        if (!e.isLeaf() && !e.isExpanded()) {
            t.expand(e);
            this.expandProcId = false
        }
    },
    queueExpand: function(e) {
        this.expandProcId = Ext.Function.defer(this.expandNode, this.expandDelay, this, [e])
    },
    cancelExpand: function() {
        if (this.expandProcId) {
            clearTimeout(this.expandProcId);
            this.expandProcId = false
        }
    },
    getPosition: function(e, t) {
        var n = this.view,
        r = n.getRecord(t),
        i = e.getPageY(),
        s = r.isLeaf(),
        o = false,
        u = Ext.fly(t).getRegion(),
        a;
        if (r.isRoot()) {
            return "append"
        }
        if (this.appendOnly) {
            return s ? false: "append"
        }
        if (!this.allowParentInserts) {
            o = r.hasChildNodes() && r.isExpanded()
        }
        a = (u.bottom - u.top) / (s ? 2 : 3);
        if (i >= u.top && i < u.top + a) {
            return "before"
        } else {
            if (!o && (s || i >= u.bottom - a && i <= u.bottom)) {
                return "after"
            } else {
                return "append"
            }
        }
    },
    isValidDropPoint: function(e, t, n, r, i) {
        if (!e || !i.item) {
            return false
        }
        var s = this.view,
        o = s.getRecord(e),
        u = i.records,
        a = u.length,
        f = u.length,
        l,
        c;
        if (! (o && t && a)) {
            return false
        }
        for (l = 0; l < f; l++) {
            c = u[l];
            if (c.isNode && c.contains(o)) {
                return false
            }
        }
        if (t === "append" && o.get("allowDrop") === false) {
            return false
        } else {
            if (t != "append" && o.parentNode.get("allowDrop") === false) {
                return false
            }
        }
        if (Ext.Array.contains(u, o)) {
            return false
        }
        return s.fireEvent("nodedragover", o, t, i, r) !== false
    },
    onNodeOver: function(e, t, n, r) {
        var i = this.getPosition(n, e),
        s = this.dropNotAllowed,
        o = this.view,
        u = o.getRecord(e),
        a = this.getIndicator(),
        f = 0;
        this.cancelExpand();
        if (i == "append" && !this.expandProcId && !Ext.Array.contains(r.records, u) && !u.isLeaf() && !u.isExpanded()) {
            this.queueExpand(u)
        }
        if (this.isValidDropPoint(e, i, t, n, r)) {
            this.valid = true;
            this.currentPosition = i;
            this.overRecord = u;
            a.setWidth(Ext.fly(e).getWidth());
            f = Ext.fly(e).getY() - Ext.fly(o.el).getY() - 1;
            if (i == "before") {
                s = u.isFirst() ? Ext.baseCSSPrefix + "tree-drop-ok-above": Ext.baseCSSPrefix + "tree-drop-ok-between";
                a.showAt(0, f);
                t.proxy.show()
            } else {
                if (i == "after") {
                    s = u.isLast() ? Ext.baseCSSPrefix + "tree-drop-ok-below": Ext.baseCSSPrefix + "tree-drop-ok-between";
                    f += Ext.fly(e).getHeight();
                    a.showAt(0, f);
                    t.proxy.show()
                } else {
                    s = Ext.baseCSSPrefix + "tree-drop-ok-append";
                    a.hide()
                }
            }
        } else {
            this.valid = false
        }
        this.currentCls = s;
        return s
    },
    onNodeOut: function(e, t, n, r) {
        this.valid = false;
        this.getIndicator().hide()
    },
    onContainerOver: function(e, t, n) {
        return t.getTarget("." + this.indicatorCls) ? this.currentCls: this.dropNotAllowed
    },
    notifyOut: function() {
        this.callParent(arguments);
        this.cancelExpand()
    },
    handleNodeDrop: function(e, t, n) {
        var r = this,
        i = r.view,
        s = t ? t.parentNode: i.panel.getRootNode(),
        o = i.getStore().treeStore.model,
        u,
        a,
        f,
        l,
        c,
        h,
        p,
        d;
        if (e.copy) {
            u = e.records;
            e.records = [];
            for (a = 0, f = u.length; a < f; a++) {
                l = u[a];
                if (l.isNode) {
                    e.records.push(l.copy(undefined, true))
                } else {
                    e.records.push(new o(l.data, l.getId()))
                }
            }
        }
        r.cancelExpand();
        if (n == "before") {
            c = s.insertBefore;
            h = [null, t];
            t = s
        } else {
            if (n == "after") {
                if (t.nextSibling) {
                    c = s.insertBefore;
                    h = [null, t.nextSibling]
                } else {
                    c = s.appendChild;
                    h = [null]
                }
                t = s
            } else {
                if (! (t.isExpanded() || t.isLoading())) {
                    p = true
                }
                c = t.appendChild;
                h = [null]
            }
        }
        d = function() {
            var n, s;
            Ext.suspendLayouts();
            for (a = 0, f = e.records.length; a < f; a++) {
                l = e.records[a];
                if (!l.isNode) {
                    if (l.isModel) {
                        l = new o(l.data, l.getId())
                    } else {
                        l = new o(l)
                    }
                    e.records[a] = l
                }
                h[0] = l;
                c.apply(t, h)
            }
            if (r.sortOnDrop) {
                t.sort(t.getOwnerTree().store.generateComparator())
            }
            Ext.resumeLayouts(true);
            if (Ext.enableFx && r.dropHighlight) {
                n = r.dropHighlightColor;
                for (a = 0; a < f; a++) {
                    s = i.getNode(e.records[a]);
                    if (s) {
                        Ext.fly(s).highlight(n)
                    }
                }
            }
        };
        if (p) {
            t.expand(false, d)
        } else {
            if (t.isLoading()) {
                t.on({
                    expand: d,
                    delay: 1,
                    single: true
                })
            } else {
                d()
            }
        }
    }
});Ext.define("Ext.tree.plugin.TreeViewDragDrop", {
    extend: Ext.AbstractPlugin,
    alias: "plugin.treeviewdragdrop",
    dragText: "{0} selected node{1}",
    allowParentInserts: false,
    allowContainerDrops: false,
    appendOnly: false,
    ddGroup: "TreeDD",
    containerScroll: false,
    expandDelay: 1e3,
    enableDrop: true,
    enableDrag: true,
    nodeHighlightColor: "c3daf9",
    nodeHighlightOnDrop: false,
    nodeHighlightOnRepair: false,
    displayField: "text",
    init: function(e) {
        e.on("render", this.onViewRender, this, {
            single: true
        })
    },
    destroy: function() {
        Ext.destroy(this.dragZone, this.dropZone)
    },
    onViewRender: function(e) {
        var t = this,
        n;
        if (t.enableDrag) {
            if (t.containerScroll) {
                n = e.getEl()
            }
            t.dragZone = new Ext.tree.ViewDragZone(Ext.apply({
                view: e,
                ddGroup: t.dragGroup || t.ddGroup,
                dragText: t.dragText,
                displayField: t.displayField,
                repairHighlightColor: t.nodeHighlightColor,
                repairHighlight: t.nodeHighlightOnRepair,
                scrollEl: n
            },
            t.dragZone))
        }
        if (t.enableDrop) {
            t.dropZone = new Ext.tree.ViewDropZone(Ext.apply({
                view: e,
                ddGroup: t.dropGroup || t.ddGroup,
                allowContainerDrops: t.allowContainerDrops,
                appendOnly: t.appendOnly,
                allowParentInserts: t.allowParentInserts,
                expandDelay: t.expandDelay,
                dropHighlightColor: t.nodeHighlightColor,
                dropHighlight: t.nodeHighlightOnDrop,
                sortOnDrop: t.sortOnDrop,
                containerScroll: t.containerScroll
            },
            t.dropZone))
        }
    }
},
function() {});Ext.define("Ext.util.Cookies", {
    singleton: true,
    set: function(e, t) {
        var n = arguments,
        r = arguments.length,
        i = r > 2 ? n[2] : null,
        s = r > 3 ? n[3] : "/",
        o = r > 4 ? n[4] : null,
        u = r > 5 ? n[5] : false;
        document.cookie = e + "=" + escape(t) + (i === null ? "": "; expires=" + i.toUTCString()) + (s === null ? "": "; path=" + s) + (o === null ? "": "; domain=" + o) + (u === true ? "; secure": "")
    },
    get: function(e) {
        var t = document.cookie.split("; "),
        n = t.length,
        r,
        i,
        s;
        for (i = 0; i < n; ++i) {
            r = t[i].split("=");
            if (r[0] === e) {
                s = r[1];
                return s ? unescape(s) : ""
            }
        }
        return null
    },
    clear: function(e, t) {
        if (this.get(e)) {
            t = t || "/";
            document.cookie = e + "=; expires=Thu, 01-Jan-1970 00:00:01 GMT; path=" + t
        }
    },
    getCookieVal: function(e) {
        var t = document.cookie,
        n = t.indexOf(";", e);
        if (n == -1) {
            n = t.length
        }
        return unescape(t.substring(e, n))
    }
});Ext.define("Ext.util.Grouper", {
    extend: Ext.util.Sorter,
    isGrouper: true,
    getGroupString: function(e) {
        return e.get(this.property)
    }
});Ext.define("Ext.util.History", {
    singleton: true,
    alternateClassName: "Ext.History",
    mixins: {
        observable: Ext.util.Observable
    },
    useTopWindow: true,
    iframeId: Ext.baseCSSPrefix + "history-frame",
    constructor: function() {
        var e = this,
        t, n;
        e.oldIEMode = Ext.isIE7m || Ext.isIEQuirks && (Ext.isIE8 || Ext.isIE9);
        e.iframe = null;
        e.hiddenField = null;
        e.ready = false;
        e.currentToken = null;
        e.mixins.observable.constructor.call(e);
        e.onHashChange = function() {
            n = e.getHash();
            if (n !== t) {
                t = n;
                e.handleStateChange(t)
            }
        }
    },
    getHash: function() {
        return this.win.location.hash.substr(1)
    },
    setHash: function(e) {
        try {
            this.win.location.hash = e
        } catch(t) {}
    },
    handleStateChange: function(e) {
        this.currentToken = e;
        this.fireEvent("change", e)
    },
    updateIFrame: function(e) {
        var t = this.iframe,
        n = t && t.contentWindow && t.contentWindow.document;
        n.open().close();
        n.location.hash = e;
        return true
    },
    checkIFrame: function() {
        var e = this,
        t = e.iframe.contentWindow,
        n, r;
        if (!t || !t.document) {
            Ext.Function.defer(e.checkIFrame, 10, e);
            return
        }
        n = t.location.hash.substr(1);
        r = e.getHash();
        Ext.TaskManager.start({
            run: function() {
                var i = t.location.hash.substr(1),
                s = e.getHash();
                if (i !== n) {
                    n = i;
                    e.handleStateChange(i);
                    e.setHash(i);
                    r = i
                } else {
                    if (s !== r) {
                        r = s;
                        e.updateIFrame(s)
                    }
                }
            },
            interval: 50,
            scope: e
        });
        e.ready = true;
        e.fireEvent("ready", e)
    },
    startUp: function() {
        var e = this;
        e.currentToken = e.getHash();
        if (e.oldIEMode) {
            e.checkIFrame()
        } else {
            if (Ext.supports.Hashchange) {
                Ext.EventManager.on(e.win, "hashchange", e.onHashChange)
            } else {
                Ext.TaskManager.start({
                    run: e.onHashChange,
                    interval: 50
                })
            }
            e.ready = true;
            e.fireEvent("ready", e)
        }
    },
    init: function(e, t) {
        var n = this;
        if (n.ready) {
            Ext.callback(e, t, [n]);
            return
        }
        if (!Ext.isReady) {
            Ext.onReady(function() {
                n.init(e, t)
            });
            return
        }
        n.win = n.useTopWindow ? window.top: window;
        if (n.oldIEMode) {
            n.iframe = Ext.getDom(n.iframeId);
            if (!n.iframe) {
                n.iframe = Ext.DomHelper.append(document.body, {
                    tag: "iframe",
                    role: "presentation",
                    id: n.iframeId,
                    style: "display:none;",
                    src: Ext.SSL_SECURE_URL
                })
            }
        }
        n.addEvents("ready", "change");
        if (e) {
            n.on("ready", e, t, {
                single: true
            })
        }
        n.startUp()
    },
    add: function(e, t) {
        var n = this;
        if (t !== false) {
            if (n.getToken() === e) {
                return true
            }
        }
        if (n.oldIEMode) {
            return n.updateIFrame(e)
        } else {
            n.setHash(e);
            return true
        }
    },
    back: function() {
        var e = this.useTopWindow ? window.top: window;
        e.history.go( - 1)
    },
    forward: function() {
        var e = this.useTopWindow ? window.top: window;
        e.history.go(1)
    },
    getToken: function() {
        return this.ready ? this.currentToken: this.getHash()
    }
});Ext.define("Ext.ux.BoxReorderer", {
    requires: ["Ext.dd.DD"],
    mixins: {
        observable: "Ext.util.Observable"
    },
    itemSelector: ".x-box-item",
    animate: 100,
    constructor: function() {
        this.addEvents("StartDrag", "Drag", "ChangeIndex", "Drop");
        this.mixins.observable.constructor.apply(this, arguments)
    },
    init: function(e) {
        var t = this;
        t.container = e;
        t.animatePolicy = {};
        t.animatePolicy[e.getLayout().names.x] = true;
        t.container.on({
            scope: t,
            boxready: t.onBoxReady,
            beforedestroy: t.onContainerDestroy
        })
    },
    onContainerDestroy: function() {
        var e = this.dd;
        if (e) {
            e.unreg();
            this.dd = null
        }
    },
    onBoxReady: function() {
        var e = this,
        t = e.container.getLayout(),
        n = t.names,
        r;
        r = e.dd = Ext.create("Ext.dd.DD", t.innerCt, e.container.id + "-reorderer");
        Ext.apply(r, {
            animate: e.animate,
            reorderer: e,
            container: e.container,
            getDragCmp: e.getDragCmp,
            clickValidator: Ext.Function.createInterceptor(r.clickValidator, e.clickValidator, e, false),
            onMouseDown: e.onMouseDown,
            startDrag: e.startDrag,
            onDrag: e.onDrag,
            endDrag: e.endDrag,
            getNewIndex: e.getNewIndex,
            doSwap: e.doSwap,
            findReorderable: e.findReorderable
        });
        r.dim = n.width;
        r.startAttr = n.beforeX;
        r.endAttr = n.afterX
    },
    getDragCmp: function(e) {
        return this.container.getChildByElement(e.getTarget(this.itemSelector, 10))
    },
    clickValidator: function(e) {
        var t = this.getDragCmp(e);
        return !! (t && t.reorderable !== false)
    },
    onMouseDown: function(e) {
        var t = this,
        n = t.container,
        r, i, s;
        t.dragCmp = t.getDragCmp(e);
        if (t.dragCmp) {
            i = t.dragCmp.getEl();
            t.startIndex = t.curIndex = n.items.indexOf(t.dragCmp);
            s = i.getBox();
            t.lastPos = s[this.startAttr];
            r = n.el.getBox();
            if (t.dim === "width") {
                t.minX = r.left;
                t.maxX = r.right - s.width;
                t.minY = t.maxY = s.top;
                t.deltaX = e.getPageX() - s.left
            } else {
                t.minY = r.top;
                t.maxY = r.bottom - s.height;
                t.minX = t.maxX = s.left;
                t.deltaY = e.getPageY() - s.top
            }
            t.constrainY = t.constrainX = true
        }
    },
    startDrag: function() {
        var e = this,
        t = e.dragCmp;
        if (t) {
            t.setPosition = Ext.emptyFn;
            t.animate = false;
            if (e.animate) {
                e.container.getLayout().animatePolicy = e.reorderer.animatePolicy
            }
            e.dragElId = t.getEl().id;
            e.reorderer.fireEvent("StartDrag", e, e.container, t, e.curIndex);
            t.suspendEvents();
            t.disabled = true;
            t.el.setStyle("zIndex", 100)
        } else {
            e.dragElId = null
        }
    },
    findReorderable: function(e) {
        var t = this,
        n = t.container.items,
        r;
        if (n.getAt(e).reorderable === false) {
            r = n.getAt(e);
            if (e > t.startIndex) {
                while (r && r.reorderable === false) {
                    e++;
                    r = n.getAt(e)
                }
            } else {
                while (r && r.reorderable === false) {
                    e--;
                    r = n.getAt(e)
                }
            }
        }
        e = Math.min(Math.max(e, 0), n.getCount() - 1);
        if (n.getAt(e).reorderable === false) {
            return - 1
        }
        return e
    },
    doSwap: function(e) {
        var t = this,
        n = t.container.items,
        r = t.container,
        i = t.container._isLayoutRoot,
        s, o, u;
        e = t.findReorderable(e);
        if (e === -1) {
            return
        }
        t.reorderer.fireEvent("ChangeIndex", t, r, t.dragCmp, t.startIndex, e);
        s = n.getAt(t.curIndex);
        o = n.getAt(e);
        n.remove(s);
        u = Math.min(Math.max(e, 0), n.getCount() - 1);
        n.insert(u, s);
        n.remove(o);
        n.insert(t.curIndex, o);
        r._isLayoutRoot = true;
        r.updateLayout();
        r._isLayoutRoot = i;
        t.curIndex = e
    },
    onDrag: function(e) {
        var t = this,
        n;
        n = t.getNewIndex(e.getPoint());
        if (n !== undefined) {
            t.reorderer.fireEvent("Drag", t, t.container, t.dragCmp, t.startIndex, t.curIndex);
            t.doSwap(n)
        }
    },
    endDrag: function(e) {
        if (e) {
            e.stopEvent()
        }
        var t = this,
        n = t.container.getLayout(),
        r;
        if (t.dragCmp) {
            delete t.dragElId;
            delete t.dragCmp.setPosition;
            t.dragCmp.animate = true;
            t.dragCmp.lastBox[n.names.x] = t.dragCmp.getPosition(true)[n.names.widthIndex];
            t.container._isLayoutRoot = true;
            t.container.updateLayout();
            t.container._isLayoutRoot = undefined;
            r = Ext.fx.Manager.getFxQueue(t.dragCmp.el.id)[0];
            if (r) {
                r.on({
                    afteranimate: t.reorderer.afterBoxReflow,
                    scope: t
                })
            } else {
                Ext.Function.defer(t.reorderer.afterBoxReflow, 1, t)
            }
            if (t.animate) {
                delete n.animatePolicy
            }
            t.reorderer.fireEvent("drop", t, t.container, t.dragCmp, t.startIndex, t.curIndex)
        }
    },
    afterBoxReflow: function() {
        var e = this;
        e.dragCmp.el.setStyle("zIndex", "");
        e.dragCmp.disabled = false;
        e.dragCmp.resumeEvents()
    },
    getNewIndex: function(e) {
        var t = this,
        n = t.getDragEl(),
        r = Ext.fly(n).getBox(),
        i,
        s,
        o,
        u = 0,
        a = t.container.items.items,
        f = a.length,
        l = t.lastPos;
        t.lastPos = r[t.startAttr];
        for (; u < f; u++) {
            i = a[u].getEl();
            if (i.is(t.reorderer.itemSelector)) {
                s = i.getBox();
                o = s[t.startAttr] + (s[t.dim] >> 1);
                if (u < t.curIndex) {
                    if (r[t.startAttr] < l && r[t.startAttr] < o - 5) {
                        return u
                    }
                } else {
                    if (u > t.curIndex) {
                        if (r[t.startAttr] > l && r[t.endAttr] > o + 5) {
                            return u
                        }
                    }
                }
            }
        }
    }
});Ext.define("Ext.ux.TabReorderer", {
    alias: "plugin.tabreorderer",
    extend: "Ext.ux.BoxReorderer",
    itemSelector: ".x-tab",
    init: function(e) {
        var t = this;
        t.callParent([e.getTabBar()]);
        e.onAdd = Ext.Function.createSequence(e.onAdd, t.onAdd)
    },
    onBoxReady: function() {
        var e, t, n = 0,
        r;
        this.callParent(arguments);
        for (e = this.container.items.items, t = e.length; n < t; n++) {
            r = e[n];
            if (r.card) {
                r.reorderable = r.card.reorderable
            }
        }
    },
    onAdd: function(e, t) {
        e.tab.reorderable = e.reorderable
    },
    afterBoxReflow: function() {
        var e = this;
        Ext.ux.BoxReorderer.prototype.afterBoxReflow.apply(e, arguments);
        if (e.dragCmp) {
            e.container.tabPanel.setActiveTab(e.dragCmp.card);
            e.container.tabPanel.move(e.startIndex, e.curIndex)
        }
    }
});Ext.define("Ext.form.field.Datetime", {
    extend: "Ext.form.FieldContainer",
    mixins: {
        field: "Ext.form.field.Field"
    },
    alias: "widget.datetimefield",
    layout: "hbox",
    width: 200,
    combineErrors: true,
    initComponent: function() {
        var e = this;
        e.buildField();
        e.callParent();
        e.dateField = e.down("datefield");
        e.timeField = e.down("timefield");
        e.addEvents("focus", "blur", "change", "specialkey");
        e.initField()
    },
    initEvents: function() {
        var e = this,
        t = e.dateField,
        n = e.timeField;
        e.mon(t, {
            scope: e,
            focus: e.onFocus,
            blur: e.onBlur,
            change: e.onChange,
            specialkey: e.onSpecialKey
        });
        e.mon(n, {
            scope: e,
            focus: e.onFocus,
            blur: e.onBlur,
            change: e.onChange,
            specialkey: e.onSpecialKey
        });
        e.callParent()
    },
    focus: function() {
        this.dateField.focus.apply(this.dateField, arguments)
    },
    onFocus: function(e, t, n) {
        var r = this;
        if (r.dateField.hasFocus && r.timeField.hasFocus) {
            return
        }
        r.fireEvent("focus", r, t, n)
    },
    onBlur: function(e, t, n) {
        var r = this;
        if (r.dateField.hasFocus || r.timeField.hasFocus || t && (t.target == r.dateField.triggerEl.elements[0].dom || t.target == r.timeField.triggerEl.elements[0].dom)) {
            return
        }
        r.fireEvent("blur", r, t, n)
    },
    onSpecialKey: function(e, t, n) {
        var r = this,
        i, s;
        if (t.getKey() == t.TAB) {
            i = r.dateField.hasFocus && !t.shiftKey;
            s = r.timeField.hasFocus && t.shiftKey;
            if (i) {
                r.timeField.hasFocus = true
            }
            if (s) {
                r.dateField.hasFocus = true
            }
            if (i || s) {
                return
            }
        }
        r.fireEvent("specialkey", r, t, n)
    },
    onChange: function(e, t, n, r) {
        var i = this,
        s, o;
        if (e instanceof Ext.form.field.Date) {
            s = n;
            o = i.timeField.getValue()
        } else {
            s = i.dateField.getValue();
            o = n
        }
        i.fireEvent("change", i, i.getValue(), i.joinValue(s, o), r)
    },
    doMethod: function(e) {
        var t = this;
        t.dateField[e]();
        t.timeField[e]()
    },
    reset: function() {
        this.doMethod("reset")
    },
    validate: function() {
        var e = this;
        return e.dateField.validate() && e.timeField.validate()
    },
    clearInvalid: function() {
        this.doMethod("clearInvalid")
    },
    isValid: function() {
        var e = this;
        return e.dateField.isValid() && e.timeField.isValid()
    },
    resetOriginalValue: function() {
        this.doMethod("resetOriginalValue")
    },
    buildField: function() {
        var e = this,
        t = e.dateWidth,
        n = e.timeWidth,
        r = ["allowBlank", "blankText", "dateFormat", "disabled", "editable", "emptyText", "readOnly", "selectOnFocus"],
        i = ["disabled", "editable", "readOnly", "selectOnFocus", "timeFormat"],
        s = {
            xtype: "datefield",
            listeners: {}
        },
        o = {
            xtype: "timefield",
            listeners: {}
        };
        if (t) {
            s.width = t
        } else {
            s.flex = n ? 1 : 3
        }
        if (n) {
            o.width = n
        } else {
            o.flex = t ? 1 : 2
        }
        Ext.copyTo(s, e, r);
        if (s.dateFormat) {
            s.format = s.dateFormat
        }
        Ext.apply(s.listeners, e.dateEvents);
        delete e.dateEvents;
        Ext.apply(s, e.dateConfigs);
        Ext.copyTo(o, e, i);
        if (o.timeFormat) {
            o.format = o.timeFormat
        }
        Ext.apply(o.listeners, e.timeEvents);
        delete e.timeEvents;
        Ext.apply(o, e.timeConfigs);
        Ext.each(r,
        function(t) {
            delete e[t]
        });
        Ext.each(i,
        function(t) {
            delete e[t]
        });
        e.items = [s, o]
    },
    getValue: function() {
        var e = this;
        return e.joinValue(e.dateField.getValue(), e.timeField.getValue())
    },
    getRawValue: function() {
        var e = this;
        return e.dateField.getRawValue() + " " + e.timeField.getRawValue()
    },
    setRawValue: function(e) {
        var t = this,
        n = e.split(" ");
        return t.dateField.setRawValue(n[0]) + " " + t.timeField.setRawValue(n[1] || (e ? "": e))
    },
    joinValue: function(e, t) {
        var n = this,
        r = Ext.isDate(e);
        if (r && Ext.isDate(t)) {
            e.setHours(t.getHours(), t.getMinutes(), t.getSeconds(), t.getMilliseconds())
        } else {
            if (r) {
                e.setHours(0, 0, 0, 0)
            }
        }
        return e || null
    },
    setValue: function(e) {
        var t, n = this,
        r = e;
        if (Ext.isString(r)) {
            t = r.indexOf(" ");
            if (t == -1) {
                n.dateField.setValue(r);
                n.timeField.setValue("")
            } else {
                n.dateField.setValue(r.substring(0, t));
                n.timeField.setValue(r.substring(t + 1))
            }
        } else {
            n.dateField.setValue(r);
            n.timeField.setValue(r)
        }
    }
});Ext.onReady(function() {
    var e;
    if (Ext.Date) {
        Ext.Date.monthNames = ["", "", "", "", "", "", "", "", "", "", "", ""];
        Ext.Date.dayNames = ["", "", "", "", "", "", ""];
        Ext.Date.formatCodes.a = "(this.getHours() < 12 ? '' : '')";
        Ext.Date.formatCodes.A = "(this.getHours() < 12 ? '' : '')";
        e = {
            g: 1,
            c: "if (/()/i.test(results[{0}])) {\n" + "if (!h || h == 12) { h = 0; }\n" + "} else { if (!h || h < 12) { h = (h || 0) + 12; }}",
            s: "(|)",
            calcAtEnd: true
        };
        Ext.Date.parseCodes.a = Ext.Date.parseCodes.A = e
    }
    if (Ext.util && Ext.util.Format) {
        Ext.apply(Ext.util.Format, {
            thousandSeparator: ",",
            decimalSeparator: ".",
            currencySign: "",
            dateFormat: "Y-m-d"
        })
    }
});Ext.define("Ext.locale.zh_CN.view.View", {
    override: "Ext.view.View",
    emptyText: ""
});Ext.define("Ext.locale.zh_CN.grid.plugin.DragDrop", {
    override: "Ext.grid.plugin.DragDrop",
    dragText: " {0} "
});Ext.define("Ext.locale.zh_CN.tab.Tab", {
    override: "Ext.tab.Tab",
    closeText: ""
});Ext.define("Ext.locale.zh_CN.form.field.Base", {
    override: "Ext.form.field.Base",
    invalidText: ""
});Ext.define("Ext.locale.zh_CN.view.AbstractView", {
    override: "Ext.view.AbstractView",
    loadingText: "..."
});Ext.define("Ext.locale.zh_CN.picker.Date", {
    override: "Ext.picker.Date",
    todayText: "",
    minText: "",
    maxText: "",
    disabledDaysText: "",
    disabledDatesText: "",
    nextText: " (Ctrl+Right)",
    prevText: " (Ctrl+Left)",
    monthYearText: " (Control+Up/Down )",
    todayTip: "{0} ()",
    format: "Y-m-d",
    ariaTitle: "{0}",
    ariaTitleDateFormat: "Y-m-d",
    longDayFormat: "Y-m-d",
    monthYearFormat: "Y-m",
    getDayInitial: function(e) {
        return e.substr(e.length - 1)
    }
});Ext.define("Ext.locale.zh_CN.form.field.Time", {
    override: "Ext.form.field.Time",
    format: "H:i",
    minText: " {0}",
    maxText: " {0}",
    invalidText: "{0} ",
    altFormats: "H:i:s|His|H:i:s.u|His.u|Hi|g:ia|g:iA|g:i a|g:i A|h:i|g:i|H:i|ga|ha|gA|h a|g a|g A|gi|hi|gia|hia|g|H|gi a|hi a|giA|hiA|gi A|hi A"
});Ext.define("Ext.locale.zh_CN.picker.Month", {
    override: "Ext.picker.Month",
    okText: "",
    cancelText: ""
});Ext.define("Ext.locale.zh_CN.toolbar.Paging", {
    override: "Ext.PagingToolbar",
    beforePageText: "",
    afterPageText: " / {0}",
    firstText: "",
    prevText: "",
    nextText: "",
    lastText: "",
    refreshText: "",
    displayMsg: "{0} - {1} / {2}",
    emptyMsg: ""
});Ext.define("Ext.locale.zh_CN.form.field.Text", {
    override: "Ext.form.field.Text",
    minLengthText: " {0} ",
    maxLengthText: " {0} ",
    blankText: "",
    regexText: "",
    emptyText: null
});Ext.define("Ext.locale.zh_CN.form.field.Number", {
    override: "Ext.form.field.Number",
    minText: " {0}",
    maxText: " {0}",
    negativeText: "",
    nanText: "{0} "
});Ext.define("Ext.locale.zh_CN.form.field.Date", {
    override: "Ext.form.field.Date",
    disabledDaysText: "",
    disabledDatesText: "",
    minText: " {0} ",
    maxText: " {0} ",
    invalidText: "{0} {1}",
    format: "Y-m-d",
    altFormats: "Y-m-d|Ymd|ymd|md|d|j|m/d/Y|n/j/Y|n/j/y|m/j/y|n/d/y|m/j/Y|n/d/Y|m-d-y|m-d-Y|m/d|m-d|mdy|mdY|n-j|n/j"
});Ext.Date.defaultFormat = "Y-m-d";Ext.define("Ext.locale.zh_CN.form.field.ComboBox", {
    override: "Ext.form.field.ComboBox",
    valueNotFoundText: undefined
},
function() {
    Ext.apply(Ext.form.field.ComboBox.prototype.defaultListConfig, {
        loadingText: "..."
    })
});Ext.define("Ext.locale.zh_CN.form.field.VTypes", {
    override: "Ext.form.field.VTypes",
    emailText: ' "user@example.com"',
    urlText: 'URL "http:/' + '/www.example.com"',
    alphaText: "_",
    alphanumText: ",_"
});Ext.define("Ext.locale.zh_CN.form.field.HtmlEditor", {
    override: "Ext.form.field.HtmlEditor",
    createLinkText: ":"
},
function() {
    Ext.apply(Ext.form.field.HtmlEditor.prototype, {
        buttonTips: {
            bold: {
                title: " (Ctrl+B)",
                text: "",
                cls: Ext.baseCSSPrefix + "html-editor-tip"
            },
            italic: {
                title: " (Ctrl+I)",
                text: "",
                cls: Ext.baseCSSPrefix + "html-editor-tip"
            },
            underline: {
                title: " (Ctrl+U)",
                text: "",
                cls: Ext.baseCSSPrefix + "html-editor-tip"
            },
            increasefontsize: {
                title: "",
                text: "",
                cls: Ext.baseCSSPrefix + "html-editor-tip"
            },
            decreasefontsize: {
                title: "",
                text: "",
                cls: Ext.baseCSSPrefix + "html-editor-tip"
            },
            backcolor: {
                title: "",
                text: "",
                cls: Ext.baseCSSPrefix + "html-editor-tip"
            },
            forecolor: {
                title: "",
                text: "",
                cls: Ext.baseCSSPrefix + "html-editor-tip"
            },
            justifyleft: {
                title: "",
                text: "",
                cls: Ext.baseCSSPrefix + "html-editor-tip"
            },
            justifycenter: {
                title: "",
                text: "",
                cls: Ext.baseCSSPrefix + "html-editor-tip"
            },
            justifyright: {
                title: "",
                text: "",
                cls: Ext.baseCSSPrefix + "html-editor-tip"
            },
            insertunorderedlist: {
                title: "",
                text: "",
                cls: Ext.baseCSSPrefix + "html-editor-tip"
            },
            insertorderedlist: {
                title: "",
                text: "",
                cls: Ext.baseCSSPrefix + "html-editor-tip"
            },
            createlink: {
                title: "",
                text: "",
                cls: Ext.baseCSSPrefix + "html-editor-tip"
            },
            sourceedit: {
                title: "",
                text: "",
                cls: Ext.baseCSSPrefix + "html-editor-tip"
            }
        }
    })
});Ext.define("Ext.locale.zh_CN.grid.header.Container", {
    override: "Ext.grid.header.Container",
    sortAscText: "",
    sortDescText: "",
    lockText: "",
    unlockText: "",
    columnsText: ""
});Ext.define("Ext.locale.zh_CN.grid.PropertyColumnModel", {
    override: "Ext.grid.PropertyColumnModel",
    nameText: "",
    valueText: "",
    dateFormat: "Y-m-d"
});Ext.define("Ext.locale.zh_CN.window.MessageBox", {
    override: "Ext.window.MessageBox",
    buttonText: {
        ok: "",
        cancel: "",
        yes: "",
        no: ""
    }
});Ext.define("Ext.locale.zh_CN.Component", {
    override: "Ext.Component"
});Ext.define("Ext.locale.zh_CN.form.field.Base", {
    override: "Ext.form.field.Base",
    labelSeparator: ""
});Ext.define("Ext.locale.zh_CN.form.FieldContainer", {
    override: "Ext.form.FieldContainer",
    labelSeparator: ""
});Ext.define("Ext.locale.zh_CN.form.field.File", {
    override: "Ext.form.field.File",
    buttonText: "..."
});Ext.override(Ext.data.proxy.Server, {
    startParam: "offset",
    limitParam: "max"
});
var Wb = {
    dateFormat: "Y-m-d H:i:s.u",
    nullImage: "wb/images/null.gif",
    maxInt: 2147483647,
    encode: window.Ext ? Ext.encode: null,
    decode: window.Ext ? Ext.decode: null,
    apply: window.Ext ? Ext.apply: null,
    applyIf: window.Ext ? Ext.applyIf: null,
    promptWindows: {},
    toString: function(e) {
        return Object.prototype.toString.call(e)
    },
    each: function(e, t, n) {
        if (Wb.toString(e) === "[object Array]") {
            var r, i = e.length;
            if (n !== true) {
                for (r = 0; r < i; r++) {
                    if (t(e[r], r) === false) {
                        return r
                    }
                }
            } else {
                for (r = i - 1; r > -1; r--) {
                    if (t(e[r], r) === false) {
                        return r
                    }
                }
            }
        } else {
            var s;
            for (s in e) {
                if (e.hasOwnProperty(s)) {
                    if (t(s, e[s]) === false) {
                        return false
                    }
                }
            }
        }
        return true
    },
    indexOf: function(e, t) {
        if (!e) return - 1;
        var n, r;
        r = e.length;
        for (n = 0; n < r; n++) if (e[n] === t) return n;
        return - 1
    },
    propVal: function(e, t, n) {
        if (typeof n == "undefined") n = null;
        t = t.split(".");
        for (var r = 0; r < t.length; r++) {
            if (typeof e[t[r]] == "undefined") return n;
            e = e[t[r]]
        }
        return e
    },
    dom: function(e) {
        return document.getElementById(e)
    },
    emptyFn: function() {},
    isEmpty: function(e) {
        return e === null || e === undefined || e.length === 0
    },
    init: function(e) {
        Wb.defineConsoleMethods();
        Wb.maskTimeout = e.mask === undefined ? 1500 : e.mask;
        if (e.zo == -1) Wb.zoneOffset = -1;
        else Wb.zoneOffset = -e.zo - (new Date).getTimezoneOffset();
        Wb.theme = e.theme || "classic";
        Wb.editTheme = e.editTheme || "default";
        Wb.isNeptune = Wb.theme == "neptune";
        if (window.Ext) {
            Ext.setGlyphFontFamily("FontAwesome");
            Ext.QuickTips.init();
            if (e.timeout !== undefined) {
                Ext.Ajax.timeout = e.timeout;
                Ext.data.Connection.prototype.timeout = e.timeout;
                Ext.data.proxy.Server.prototype.timeout = e.timeout;
                Ext.data.JsonP.timeout = e.timeout;
                Ext.form.Basic.prototype.timeout = Math.round(e.timeout / 1e3)
            }
            Ext.getDoc().on("keydown",
            function(e, t) {
                if (e.getKey() == e.BACKSPACE && (!Wb.isEditor(t) || t.disabled || t.readOnly)) e.stopEvent()
            });
            window.onbeforeunload = function() {
                if (Wb.unloadEvents) {
                    var e, t, n = 0;
                    Wb.each(Wb.unloadEvents,
                    function(r, i) {
                        t = i();
                        if (Wb.isValue(t)) {
                            if (n === 0) e = t;
                            n++
                        }
                    });
                    if (n == 1) return e;
                    else if (n > 1) return Wb.format(Str.itemsInfo, e, n)
                }
            }
        }
    },
    defineConsoleMethods: function() {
        window.Cs = {
            info: function() {
                if (window.console && console.info) console.info.apply(console, arguments)
            },
            warn: function() {
                if (window.console && console.warn) console.warn.apply(console, arguments)
            },
            error: function() {
                if (window.console && console.error) console.error.apply(console, arguments)
            },
            log: function() {
                if (window.console && console.log) console.log.apply(console, arguments)
            }
        }
    },
    request: function(e) {
        var t, n, r = Wb.getBool(e.showMask, true),
        i = e.success,
        s = e.failure;
        n = Ext.apply({},
        e.params, Wb.getValue(e.out));
        if (!Ext.Object.isEmpty(n)) e.params = n;
        t = Ext.applyIf({
            success: function() {
                if (r) Wb.unmask(t.mask, t.message);
                Ext.callback(i, t.scope, arguments)
            },
            failure: function(e) {
                if (r) Wb.unmask(t.mask, t.message);
                if (Wb.getBool(t.showError, true)) Wb.except(e);
                Ext.callback(s, t.scope, arguments)
            }
        },
        e);
        if (r) Wb.mask(t.mask, t.message);
        return Ext.Ajax.request(t)
    },
    toLocal: function(e) {
        if (Wb.zoneOffset != -1 && e) return Ext.Date.add(e, Ext.Date.MINUTE, Wb.zoneOffset);
        else return e
    },
    showIconMessage: function(e, t, n, r, i) {
        if (Ext.isString(t)) {
            t = Ext.String.ellipsis(t, 3e3);
            t = t.replace(/([^<]\/)|(\\)/g, "$&<wbr>")
        }
        return Ext.Msg.show({
            title: e,
            msg: t,
            buttons: Ext.Msg.OK,
            fn: n,
            icon: i,
            animateTarget: r
        })
    },
    info: function(e, t, n) {
        return Wb.showIconMessage(Str.information, e, t, n, Ext.Msg.INFO)
    },
    warn: function(e, t, n) {
        return Wb.showIconMessage(Str.warning, e, t, n, Ext.Msg.WARNING)
    },
    error: function(e, t, n) {
        return Wb.showIconMessage(Str.error, e, t, n, Ext.Msg.ERROR)
    },
    except: function(e, t, n) {
        var r, i;
        if (e instanceof Ext.form.action.Submit) {
            switch (e.failureType) {
            case "client":
                r = Str.clientInvalid;
                break;
            case "connect":
                r = Str.connectFailure;
                break;
            case "load":
                r = Str.loadFailure;
                break;
            default:
                i = e.result ? e.result.value: null;
                if (Ext.String.startsWith(i, "$WBE201")) {
                    Wb.login();
                    return
                } else if (Ext.String.startsWith(i, "$WBE202")) {
                    Wb.login(true);
                    return
                } else {
                    if (i) r = i;
                    else r = e.response.responseText || Str.unknowError
                }
            }
        } else {
            i = e.responseText;
            switch (e.status) {
            case 0:
                r = Str.serverNotResp;
                break;
            case 400:
                r = Str.e400;
                break;
            case 401:
                Wb.login(i && i.indexOf("verify") != -1);
                return;
            case 403:
                r = Str.e403;
                break;
            case 404:
                r = Str.e404;
                break;
            default:
                r = i || Str.unknowError
            }
        }
        return Wb.error(r, t, n)
    },
    confirm: function(e, t, n) {
        return Ext.Msg.show({
            title: Str.confirm,
            msg: e,
            buttons: Ext.Msg.OKCANCEL,
            fn: function(e) {
                var n, r;
                if (Ext.isArray(t)) {
                    n = t[0];
                    if (t.length > 1) r = t[1]
                } else n = t;
                if (e == "ok") n();
                else if (r) r()
            },
            icon: Ext.Msg.QUESTION,
            animateTarget: n
        })
    },
    confirmDo: function(e, t, n, r, i) {
        if (!Ext.isArray(e)) {
            e = e ? [e] : []
        }
        var s, o, u = e.length;
        if (!r) r = Str.del;
        if (u === 0) {
            Wb.warn(Wb.format(Str.selectRecord, r));
            return null
        } else {
            o = e[0];
            if (!n) n = o.fields.items[0].name;
            if (u == 1) {
                s = Wb.format(Str.singleConfirm, r, Wb.propVal(o.data, n))
            } else {
                s = Wb.format(Str.manyConfirm, r, Wb.propVal(o.data, n), u)
            }
            return Wb.confirm(s, t, i)
        }
    },
    choose: function(e, t, n) {
        return Ext.Msg.show({
            title: Str.confirm,
            msg: e,
            buttons: Ext.Msg.YESNOCANCEL,
            fn: t,
            icon: Ext.MessageBox.QUESTION,
            animateTarget: n
        })
    },
    login: function(e) {
        if (window.top != window && window.top.Wb) {
            window.top.Wb.login(e);
            return
        }
        if (Wb.loginWin) Wb.loginWin.show();
        var t, n = {
            changeVC: function() {
                n.verifyImage.setSrc("m?xwl=sys/session/get-verify-image&" + Wb.getId())
            }
        };
        Wb.loginWin = t = new Ext.window.Window({
            title: "",
            height: 240,
            width: 448,
            layout: "absolute",
            modal: true,
            iconCls: "key_icon",
            minButtonWidth: 88,
            buttonAlign: "center",
            resizable: false,
            autoShow: true,
            onEnter: function() {
                if (!Wb.verify(t)) return;
                Wb.request({
                    url: "m?xwl=sys/session/verify",
                    out: t,
                    message: Str.processLogin,
                    showError: false,
                    success: function(e) {
                        if (n.saveNameCheck.getValue()) Wb.setCookie("sys.username", n.username.getValue());
                        t.close()
                    },
                    failure: function(t) {
                        if (e) n.changeVC();
                        Wb.except(t,
                        function() {
                            var e = t.responseText;
                            switch (e) {
                            case Str.vcInvalid:
                            case Str.vcExpired:
                                if (!n.verifyCode.hidden) n.verifyCode.focus(true, true);
                                break;
                            case Str.passwordInvalid:
                                n.password.focus(true, true);
                                break;
                            default:
                                n.username.focus(true, true);
                                break
                            }
                        })
                    }
                })
            },
            buttons: [{
                text: Str.login,
                iconCls: "accept_icon",
                handler: function() {
                    t.onEnter()
                }
            },
            {
                text: Str.reset,
                iconCls: "refresh_icon",
                handler: function() {
                    Wb.reset(t)
                }
            }],
            listeners: {
                destroy: function() {
                    delete Wb.loginWin
                },
                show: function() {
                    var e = Wb.getCookie("sys.username");
                    n.saveNameCheck.setValue( !! e);
                    if (Wb.isEmpty(e)) n.username.focus(false, 20);
                    else {
                        n.username.setValue(e);
                        n.password.focus(false, 20)
                    }
                },
                beforerender: function(t) {
                    Wb.getRefer(t, n);
                    if (e) n.verifyImage.src = "m?xwl=sys/session/get-verify-image";
                    else {
                        n.username.y += 10;
                        n.password.y += 20;
                        n.verifyCode.hidden = true;
                        n.verifyImage.hidden = true
                    }
                }
            },
            items: [{
                xtype: "textfield",
                allowBlank: false,
                fieldStyle: "padding-left:28px;background-image:url(assets/images/app/user.gif);background-repeat:no-repeat;background-position:left center;",
                labelAlign: "right",
                itemId: "username",
                fieldLabel: Str.username,
                x: 16,
                y: 32,
                width: 296
            },
            {
                xtype: "textfield",
                allowBlank: false,
                fieldStyle: "padding-left:28px;background-image:url(assets/images/app/password.gif);background-repeat:no-repeat;background-position:left center;",
                labelAlign: "right",
                itemId: "password",
                inputType: "password",
                fieldLabel: Str.password,
                x: 16,
                y: 64,
                width: 296
            },
            {
                xtype: "textfield",
                allowBlank: false,
                fieldStyle: "padding-left:28px;background-image:url(assets/images/app/check.gif);background-repeat:no-repeat;background-position:left center;",
                labelAlign: "right",
                itemId: "verifyCode",
                fieldLabel: Str.verifyCode,
                x: 16,
                y: 96,
                width: 200
            },
            {
                xtype: "image",
                title: Str.clickChangeVC,
                style: "cursor:pointer;",
                alt: Str.verifyCode,
                itemId: "verifyImage",
                x: 222,
                y: 97,
                width: 90,
                height: 20,
                listeners: {
                    afterrender: {
                        single: true,
                        fn: function(e) {
                            e.mon(e.el, "click",
                            function() {
                                n.changeVC();
                                n.verifyCode.focus(true, true)
                            })
                        }
                    }
                }
            },
            {
                xtype: "image",
                src: "assets/images/app/login.gif",
                x: 328,
                y: 20,
                width: 95,
                height: 122
            },
            {
                xtype: "checkbox",
                itemId: "saveNameCheck",
                boxLabel: Str.saveUserName,
                x: 120,
                y: 128,
                width: 192,
                listeners: {
                    change: function(e, t) {
                        if (!t) Ext.util.Cookies.clear("sys.username")
                    }
                }
            }]
        })
    },
    mask: function(e, t) {
        var n, r = Ext.getBody();
        if (Ext.isFunction(e)) e = e();
        if (!e) e = r;
        if (!Wb.isValue(t)) t = Str.processing;
        if (!e.maskMsgs) e.maskMsgs = [];
        e.maskMsgs.push(t);
        e.mask(Ext.Array.unique(e.maskMsgs).join("<br>"), null, null, Wb.maskTimeout);
        if (e == r) {
            n = (r.$cache || r.getCache()).data;
            if (n.maskShimEl) n.maskShimEl.setStyle("zIndex", 90001);
            if (n.maskEl) n.maskEl.setStyle("zIndex", 90001);
            if (n.maskMsg) n.maskMsg.setStyle("zIndex", 90001)
        }
    },
    unmask: function(e, t) {
        var n, r;
        if (e) {
            if (Ext.isFunction(e)) e = e()
        } else e = Ext.getBody();
        if (!Wb.isValue(t)) t = Str.processing;
        r = e.maskMsgs;
        if (r && r.length > 0) {
            n = r.length;
            Ext.Array.remove(r, t);
            if (r.length === n) throw new Error('The component has no mask with message "' + t + '".');
            if (r.length === 0) e.unmask();
            else e.mask(Ext.Array.unique(r).join("<br>"), null, null, Wb.maskTimeout)
        } else throw new Error("The component has no mask.")
    },
    equals: function(e, t) {
        if (!e) e = "";
        if (!t) t = "";
        return e == t
    },
    uniqueName: function(e, t) {
        var n = t,
        r = 1;
        while (n in e) n = t + r++;
        return n
    },
    getFileSize: function(e) {
        if (e >= 1048576) return Wb.format(e / 1048576, "0,000.#") + " MB";
        else return Wb.format(Math.ceil(e / 1024), "0,000") + " KB"
    },
    getNode: function(e, t) {
        if (t === undefined) t = 0;
        while (e && e.getDepth() > t) {
            e = e.parentNode
        }
        return e
    },
    turnTab: function(e) {
        var t = e,
        n = t,
        r = [];
        Ext.suspendLayouts();
        try {
            while (t = t.ownerCt) {
                if (t instanceof Ext.tab.Panel) r.push(n);
                n = t
            }
            while (t = r.pop()) {
                t.ownerCt.setActiveTab(t)
            }
        } finally {
            Ext.resumeLayouts(true)
        }
    },
    prompt: function(e) {
        function t() {
            if (!Wb.promptPickList) Wb.promptPickList = {};
            if (!Wb.promptSaveList) Wb.promptSaveList = {};
            o.queryBy(function(e) {
                var t = e.pickKeyname,
                n, r, i;
                if (e.saveKeyname) Wb.promptSaveList[e.saveKeyname] = e.getValue();
                if (t && e instanceof Ext.form.field.ComboBox) {
                    n = Wb.promptPickList[t];
                    r = e.getValue();
                    if (Wb.isEmpty(r)) return;
                    if (!n) {
                        Wb.promptPickList[t] = [r];
                        e.store.add({
                            field1: r,
                            field2: r
                        })
                    } else {
                        i = Wb.indexOf(n, r);
                        if (i != -1) {
                            n.splice(i, 1);
                            e.store.removeAt(i)
                        }
                        n.unshift(r);
                        e.store.insert(0, {
                            field1: r,
                            field2: r
                        })
                    }
                }
                return false
            })
        }
        function n(e, t) {
            var n;
            if (e.items.getCount() > 0 && t !== null) {
                if (t) e.down("#" + t).focus(true, true);
                else n = e.query("field")[0];
                if (n && n.focus) n.focus(true, true)
            }
        }
        function r(e) {
            Wb.each(e,
            function(e) {
                if (!e.id) e.id = Wb.getId();
                if (!Wb.getBool(e.allowBlank, true)) {
                    if (e.fieldLabel) e.fieldLabel = "* " + e.fieldLabel
                }
                if (Wb.promptPickList && e.pickKeyname && (Wb.isEmpty(e.store) || Ext.isArray(e.store))) e.store = Ext.Array.merge(Wb.promptPickList[e.pickKeyname] || [], e.store || []);
                if (e.readOnly) {
                    e.selectOnFocus = true
                }
                if (e.items && Ext.isArray(e.items)) r(e.items)
            })
        }
        function i(e) {
            Wb.each(e,
            function(e) {
                if (Wb.promptSaveList && e.saveKeyname && Wb.promptSaveList[e.saveKeyname] !== undefined) Ext.getCmp(e.id).setValue(Wb.promptSaveList[e.saveKeyname]);
                if (e.items && Ext.isArray(e.items)) i(e.items)
            })
        }
        if (e.windowName) {
            var s = Wb.promptWindows[e.windowName];
            if (s) {
                if (e.resetScrollbar) s.body.dom.scrollTop = 0;
                s.setTitle(e.title);
                s.setIconCls(e.iconCls);
                s.handler = e.handler;
                Wb.activePrompt = s;
                s.show();
                n(s, e.defaultFocus);
                return s
            }
        }
        var o, u, a, f;
        f = Ext.apply({},
        e);
        delete f.defaults;
        delete f.listeners;
        f = Ext.apply({
            width: 500,
            minWidth: 100,
            minHeight: 100,
            maximizable: true,
            resizable: true,
            overflowX: "hidden",
            overflowY: "auto",
            bodyPadding: "2 10 10 10",
            modal: true,
            dialog: true,
            layout: "anchor",
            items: u,
            defaults: {
                labelWidth: 100,
                labelAlign: "right",
                xtype: "textfield",
                margin: "8 0 0 0",
                anchor: "-16"
            },
            listeners: {
                close: function() {
                    Wb.activePrompt = null
                },
                ok: function() {
                    t();
                    Ext.callback(o.handler, o, [Wb.getValue(o), o])
                }
            }
        },
        f);
        if (Wb.getBool(f.autoReset, e.windowName)) f.listeners.hide = function(e) {
            Wb.reset(e)
        };
        if (e.windowName) f.closeAction = "hide";
        Ext.apply(f.defaults, e.defaults);
        Ext.apply(f.listeners, e.listeners);
        u = f.items;
        if (!Ext.isArray(u)) u = [u];
        r(u);
        a = f.defaultFocus;
        delete f.defaultFocus;
        if (f.isUpload) {
            f.items = {
                xtype: "form",
                itemId: "form",
                layout: f.layout,
                border: false,
                overflowX: "hidden",
                overflowY: "auto",
                defaults: f.defaults,
                bodyStyle: "background:transparent;",
                items: f.items
            };
            delete f.defaults;
            delete f.overflowX;
            f.layout = "fit";
            delete f.overflowY
        }
        o = new Ext.window.Window(f);
        Wb.activePrompt = o;
        o.show();
        if (!e.win) o.setHeight(Math.min(o.getHeight(), Ext.Element.getViewportHeight() - 8));
        Ext.suspendLayouts();
        try {
            i(u)
        } finally {
            Ext.resumeLayouts(true)
        }
        n(o, a);
        if (f.windowName) {
            Wb.promptWindows[f.windowName] = o;
            if (f.destroyOn) f.destroyOn.mon(f.destroyOn, "destroy",
            function() {
                o.destroy();
                delete Wb.promptWindows[f.windowName]
            })
        }
        return o
    },
    promptText: function(e, t, n) {
        var r = Ext.apply({},
        n),
        i,
        s;
        i = r.allowBlank;
        s = r.value;
        if (r.allowBlank) delete r.allowBlank;
        if (r.value) delete r.value;
        return new Ext.window.Window(Ext.apply({
            title: e,
            autoShow: true,
            modal: true,
            maximizable: true,
            layout: "fit",
            iconCls: "edit_icon",
            dialog: true,
            width: 500,
            height: 300,
            resizable: true,
            defaultFocus: "text",
            listeners: {
                ok: function(e) {
                    if (t) t(e.getComponent("text").getValue(), e)
                }
            },
            items: [{
                allowBlank: r.value === undefined ? true: r.value,
                itemId: "text",
                xtype: "textarea",
                value: s || ""
            }]
        },
        n))
    },
    getValue: function(e, t) {
        var n = {};
        if (!e) return n;
        Ext.suspendLayouts();
        try {
            function r(e) {
                var r = e.itemId;
                if (r && e.getValue && (!t || Wb.indexOf(t, r) != -1) && !n.hasOwnProperty(r)) {
                    if (e instanceof Ext.form.field.File) n["$" + r] = e.removeFile ? 1 : 0;
                    else n[r] = e.getValue()
                }
                return false
            }
            if (!Ext.isArray(e)) e = [e];
            if (t && !Ext.isArray(t)) t = [t];
            Wb.each(e,
            function(e) {
                r(e);
                if (e.queryBy) e.queryBy(r)
            })
        } finally {
            Ext.resumeLayouts(true)
        }
        return n
    },
    getVal: function(e, t) {
        if (!e) return undefined;
        if (!t) {
            if (Ext.isArray(e)) t = e[0].itemId;
            else t = e.itemId
        }
        return Wb.getValue(e, t)[t]
    },
    setValue: function(e, t) {
        if (!e) return;
        Ext.suspendLayouts();
        try {
            function n(e) {
                var n = e.itemId;
                if (n && t.hasOwnProperty(n) && e.setValue) {
                    if (e instanceof Ext.form.field.File) e.inputEl.dom.value = t[n] ? Str.hasFile: "";
                    else {
                        var r = t[n];
                        if (Ext.isObject(r)) {
                            if (e.nestField !== undefined) {
                                r = r[e.nestField]
                            } else if (e.valueField !== undefined) {
                                r = r[e.valueField]
                            }
                        }
                        e.setValue(r)
                    }
                }
                return false
            }
            if (!Ext.isArray(e)) e = [e];
            Wb.each(e,
            function(e) {
                n(e);
                if (e.queryBy) e.queryBy(n)
            })
        } finally {
            Ext.resumeLayouts(true)
        }
    },
    setVal: function(e, t, n) {
        var r = {};
        r[t] = n;
        Wb.setValue(e, r)
    },
    reset: function(e, t) {
        if (!e) return;
        Ext.suspendLayouts();
        try {
            function n(e) {
                var n = e.itemId;
                if (n && e.reset && (!t || Wb.indexOf(t, n) != -1)) {
                    e.reset()
                }
                return false
            }
            if (!Ext.isArray(e)) e = [e];
            if (t && !Ext.isArray(t)) t = [t];
            Wb.each(e,
            function(e) {
                n(e);
                if (e.queryBy) e.queryBy(n)
            })
        } finally {
            Ext.resumeLayouts(true)
        }
    },
    getRefer: function(e, t) {
        function n(e) {
            var n = e.itemId;
            if (n) t[n] = e;
            return false
        }
        if (!t) t = {};
        if (e && !Ext.isArray(e)) e = [e];
        Wb.each(e,
        function(e) {
            n(e);
            if (e.queryBy) e.queryBy(n)
        });
        return t
    },
    highlight: function(e, t) {
        var n;
        if (e.isNode) {
            n = e.getOwnerTree().view.getNode(e);
            if (n) {
                n = Ext.fly(n)
            }
        } else n = e;
        if (n) {
            if (e.isHighlighting) return;
            e.isHighlighting = true;
            if (t) {
                n.highlight("ff0000", {
                    duration: 1500,
                    callback: function() {
                        delete e.isHighlighting
                    }
                })
            } else {
                n.highlight(null, {
                    duration: 1500,
                    callback: function() {
                        delete e.isHighlighting
                    }
                })
            }
        }
    },
    verifyGrid: function(e) {
        var t, n, r, i, s, o = true,
        u = e.bindTable || e,
        a = Wb.findEditing(u);
        if (!a) return true;
        a.completeEdit();
        i = u.columns;
        n = i.length;
        s = u.store;
        s.each(function(e) {
            for (t = 0; t < n; t++) {
                r = i[t];
                if ((r.editor && r.editor.allowBlank === false || r.field && r.field.allowBlank === false) && Wb.isEmpty(e.get(r.dataIndex))) {
                    o = false;
                    a.startEdit(e, r);
                    if (a.activeEditor) a.activeEditor.field.validate();
                    return false
                }
            }
        });
        return o
    },
    verify: function(e) {
        function r(e) {
            if (e.validate && !e.hidden && !e.disabled && !e.validate() && !n) n = e;
            return false
        }
        var t, n;
        if (Ext.isArray(e)) t = e;
        else t = [e];
        Ext.suspendLayouts();
        try {
            Wb.each(t,
            function(e) {
                r(e);
                if (e.queryBy) {
                    e.queryBy(r)
                }
            })
        } finally {
            Ext.resumeLayouts(true)
        }
        if (n) {
            Wb.turnTab(n);
            n.focus(true, true);
            return false
        } else return true
    },
    setRecord: function(e, t) {
        Wb.each(t,
        function(t, n) {
            e.set(t, n)
        });
        e.commit();
        return e
    },
    quoteRegexp: function(e) {
        return e.replace(/[.?*+\^$\[\]\\(){}|\-]/g, "\\$&")
    },
    isValue: function(e) {
        return e !== null && e !== undefined
    },
    findEditing: function(e) {
        var t = e.bindTable || e;
        return t.findPlugin("cellediting") || t.findPlugin("rowediting")
    },
    remove: function(e, t, n) {
        var r = Ext.isArray(e),
        i = r && e[0] instanceof Ext.data.Model;
        if (r && !i) {
            Ext.Array.remove(e, t);
            return
        }
        n = Wb.getBool(n, true);
        if (t && !Ext.isArray(t)) t = [t];
        Ext.suspendLayouts();
        try {
            if (e instanceof Ext.tree.Panel || e instanceof Ext.data.TreeStore) {
                e = e.bindTable || e;
                if (!t) t = Wb.reverse(e.getSelection());
                if (t.length === 0) return;
                var s, o, u;
                if (n) {
                    s = t[t.length - 1];
                    o = s.parentNode;
                    u = s;
                    while (true) {
                        u = u.nextSibling;
                        if (Wb.indexOf(t, u) == -1) break
                    }
                    if (!u) {
                        u = s;
                        while (true) {
                            u = u.previousSibling;
                            if (Wb.indexOf(t, u) == -1) break
                        }
                    }
                    if (!u && o) u = o
                }
                Wb.each(t,
                function(e) {
                    e.remove()
                });
                if (n) {
                    if (u && (u.parentNode || e.rootVisible)) e.setSelection(u)
                }
            } else if (e instanceof Ext.grid.Panel || e instanceof Ext.data.Store) {
                e = e.bindTable || e;
                var a, f, l = Wb.findEditing(e);
                if (l) l.completeEdit();
                if (!t) t = e.getSelection();
                if (t.length === 0) return;
                if (n) a = e.store.indexOf(t[0]);
                if (e instanceof Ext.grid.property.Grid) e.removeProperty(t[0].data.name);
                else {
                    e.store.remove(t);
                    Wb.refreshRowNum(e)
                }
                if (n) {
                    f = e.store.getCount() - 1;
                    if (a > f) a = f;
                    if (a > -1) e.setSelection(a)
                }
            } else if (r) {
                if (e[0] instanceof Ext.data.Model) {
                    Wb.each(e,
                    function(e) {
                        e.remove()
                    })
                }
            } else {
                Wb.each(t,
                function(t) {
                    e.remove(t)
                })
            }
        } finally {
            Ext.resumeLayouts(true)
        }
    },
    setModified: function(e) {
        if (!e.isModified) {
            e.isModified = true;
            if (!Ext.String.startsWith(e.title, "*")) e.setTitle("*" + e.title)
        }
        return e
    },
    unModified: function(e) {
        if (e.isModified) {
            e.isModified = false;
            e.setTitle(e.title.substring(1))
        }
    },
    setTitle: function(e, t) {
        var n = Wb.isEmpty(e.title) ? "": String(e.title),
        r = n.indexOf(" - ");
        if (r != -1) n = n.substring(0, r);
        if (Wb.isEmpty(t)) e.setTitle(n);
        else e.setTitle(n + " - " + t)
    },
    parseBool: function(e, t) {
        if (Wb.isValue(e) || t === undefined) {
            return ! (e === false || e == "false" || e === 0 || e == "0" || e === null || e === undefined)
        } else return t
    },
    getBool: function(e, t) {
        return !! (e === undefined ? t: e)
    },
    reload: function(e, t, n) {
        if (e instanceof Ext.grid.Panel || e instanceof Ext.data.Store) {
            var r = e.store || e,
            i = t || {};
            i.params = Ext.apply({},
            i.params, r.lastOptions.params);
            r.reload(i)
        } else {
            e = e.bindTable || e;
            if (e.isRefreshing) return;
            e.isRefreshing = true;
            if (!n) n = {};
            var s, o, u = e.getSelection()[0],
            a = n.field || e.displayField;
            if (u) s = u.getPath(a, n.separator || "\n");
            e.store.load({
                callback: function(r, i, o) {
                    if (e.isRefreshing) delete e.isRefreshing;
                    if (o && s) e.selectPath(s, a, n.separator || "\n", t)
                }
            })
        }
    },
    verifyName: function(e) {
        var t, n, r = e.length;
        for (n = 0; n < r; n++) {
            t = e.charAt(n);
            if (! (t >= "a" && t <= "z" || t >= "A" && t <= "Z" || t == "_" || n > 0 && t >= "0" && t <= "9")) return Wb.format(Str.invalidChar, t)
        }
        return true
    },
    verifyFile: function(e) {
        var t, n, r = e.length,
        i = '/:*?"<>|';
        for (n = 0; n < r; n++) {
            t = e.charAt(n);
            if (i.indexOf(t) != -1) return Wb.format(Str.invalidChar, t)
        }
        return true
    },
    htmlRender: function(e) {
        return Wb.htmlEncode(e)
    },
    getDoc: function(e) {
        try {
            return e.contentWindow.document || e.contentDocument || window.frames[e.id].document
        } catch(t) {
            return null
        }
    },
    relayEvent: function(e) {
        try {
            var t = this,
            n = Ext.Element.getTrueXY(t),
            r = e.getXY(),
            i = Ext.EventManager.getPageXY(e.browserEvent);
            e.xy = [n[0] + i[0], n[1] + i[1]];
            e.injectEvent(t);
            e.xy = r
        } catch(s) {}
    },
    insertIframe: function(e, t) {
        var n, r = Wb.getId();
        t = Wb.getBool(t, true);
        e.update('<iframe scrolling="auto" id="' + r + '" name="' + r + '" frameborder="0" width="100%" height="100%"></iframe>');
        e.iframe = e.el.down("iframe");
        n = e.iframe.dom;
        e.iframe.submit = function(r, i, s) {
            if (e.isSubmiting) return;
            e.isSubmiting = true;
            if (t) Wb.mask(e, Str.loading);
            Wb.submit(r, i, n.id, s)
        };
        e.iframe.getDoc = function() {
            return Wb.getDoc(n)
        };
        n.onload = function() {
            if (!e.isSubmiting) return;
            delete e.isSubmiting;
            if (t) Wb.unmask(e, Str.loading);
            var r = e.iframe.getDoc();
            if (r) {
                Ext.EventManager.on(r, {
                    mousedown: Wb.relayEvent,
                    mousemove: Wb.relayEvent,
                    mouseup: Wb.relayEvent,
                    click: Wb.relayEvent,
                    dblclick: Wb.relayEvent,
                    scope: n
                })
            }
        };
        e.mon(e, "beforedestroy",
        function(e) {
            var t, r;
            t = e.iframe.getDoc();
            try {
                if (t) {
                    for (r in t) {
                        if (t.hasOwnProperty && t.hasOwnProperty(r)) {
                            delete t[r]
                        }
                    }
                    n.src = "about:blank";
                    t.write("");
                    t.clear();
                    t.close()
                }
                e.iframe.destroy()
            } catch(i) {}
        });
        return e.iframe
    },
    getFilename: function(e) {
        if (Wb.isEmpty(e)) return "";
        var t = Math.max(e.lastIndexOf("/"), e.lastIndexOf("\\"));
        if (t == -1) return e;
        else return e.substring(t + 1)
    },
    extractFileExt: function(e) {
        if (!Wb.isEmpty(e)) {
            var t = e.lastIndexOf(".");
            if (t != -1) return e.substring(t + 1)
        }
        return ""
    },
    getError: function(e, t) {
        if (e) {
            var n = "#WBE" + t + ":",
            r = n.length;
            if (e.substring(0, r) == n) return e.substring(r)
        }
        return null
    },
    select: function(e) {
        var t = e.getOwnerTree(),
        n = [];
        if (!t) return;
        Ext.suspendLayouts();
        e.bubble(function(e) {
            if (t.rootVisible || e.parentNode) n.push(e)
        });
        Wb.each(n,
        function(e) {
            e.expand()
        },
        null, true);
        t.setSelection(e);
        Ext.resumeLayouts(true)
    },
    mimicClick: function(e, t, n, r, i) {
        var s = this;
        if (i.getKey() == i.ENTER) {
            if (s.hasListeners.itemclick) s.fireEventArgs("itemclick", arguments);
            else s.fireEventArgs("itemdblclick", arguments);
            i.stopEvent()
        }
    },
    getLang: function(e) {
        var t = {};
        Wb.each(e,
        function(e, n) {
            t[e] = n[Str.lang]
        });
        return t
    },
    getModifiedTitle: function(e, t) {
        if (!e) return null;
        var n, r = 0,
        i;
        e.items.each(function(e) {
            if (e.isModified) {
                if (!i) i = e;
                if (!n) n = e.title.substring(1);
                r++
            }
        });
        if (t && i) e.setActiveTab(i);
        if (r > 1) return Wb.format(Str.itemsInfo, n, r);
        else if (r == 1) return '"' + n + '" ';
        else return null
    },
    fromPanel: function(e, t) {
        var n = t.target,
        r = e.id;
        if (n.id == r + "-innerCt") return true;
        if (n.id == r + "-body") {
            if (t.getX() > e.getX() + e.body.dom.clientWidth || t.getY() > e.getY() + e.body.dom.clientHeight) return false;
            else return true
        }
        return false
    },
    copy: function(e) {
        function t(e) {
            var n, r = e.data,
            i = {},
            s = ["allowDrag", "allowDrop", "children", "depth", "id", "index", "isFirst", "isLast", "loaded", "loading", "parentId", "root"];
            if (r.id) i.id = Wb.getId();
            Wb.each(r,
            function(e, t) {
                if (Wb.indexOf(s, e) == -1) i[e] = t
            });
            if (!e.isLeaf() && e.isLoaded()) {
                n = e.childNodes;
                i.children = [];
                Wb.each(n,
                function(e) {
                    i.children.push(t(e))
                })
            }
            return i
        }
        return Ext.clone(t(e))
    },
    append: function(e, t, n, r) {
        var i, s = [];
        if (!Ext.isArray(e)) e = [e];
        Ext.suspendLayouts();
        try {
            Wb.each(e,
            function(e) {
                if (n) e = Wb.copy(e);
                i = t.appendChild(e);
                i.commit();
                s.push(i)
            });
            if (Wb.getBool(r, true)) {
                t.expand();
                t.getOwnerTree().setSelection(s)
            }
        } finally {
            Ext.resumeLayouts(true)
        }
        return s
    },
    insertBefore: function(e, t, n, r) {
        var i = t.parentNode,
        s, o = [];
        if (!Ext.isArray(e)) e = [e];
        Ext.suspendLayouts();
        try {
            Wb.each(e,
            function(e) {
                if (n) e = Wb.copy(e);
                s = i.insertBefore(e, t);
                s.commit();
                o.push(s)
            });
            if (Wb.getBool(r, true)) t.getOwnerTree().setSelection(o)
        } finally {
            Ext.resumeLayouts(true)
        }
        return o
    },
    insertAfter: function(e, t, n, r) {
        var i = t.nextSibling,
        s = t.parentNode,
        o, u = [];
        if (!Ext.isArray(e)) e = [e];
        Ext.suspendLayouts();
        try {
            Wb.each(e,
            function(e) {
                if (n) e = Wb.copy(e);
                if (i) o = s.insertBefore(e, i);
                else o = s.appendChild(e);
                o.commit();
                u.push(o)
            });
            if (Wb.getBool(r, true)) t.getOwnerTree().setSelection(u)
        } finally {
            Ext.resumeLayouts(true)
        }
        return u
    },
    expand: function(e, t) {
        var n = e.bindTable || e,
        r = n.getSelection(),
        i;
        if (r.length === 0) {
            i = n.getRootNode();
            if (n.rootVisible) r.push(i);
            else {
                if (t) i.collapseChildren(true);
                else i.expandChildren(true);
                return
            }
        }
        Wb.each(r,
        function(e) {
            if (t) e.collapse(true);
            else e.expand(true)
        })
    },
    collapse: function(e) {
        var t = e.bindTable || e;
        Wb.expand(t, true)
    },
    isModal: function() {
        var e = false;
        Ext.WindowMgr.each(function(t) {
            if (t.modal && t.isVisible()) {
                e = true;
                return false
            }
        });
        return e || Ext.getBody().isMasked()
    },
    getId: function() {
        if (!Wb.id) Wb.id = (new Date).getTime();
        return "wb" + Wb.id++
    },
    getTreeTools: function(e) {
        var t = [];
        if (!e) e = {};
        if (Wb.getBool(e.refresh, true)) t.push({
            type: "refresh",
            tooltip: Str.refresh,
            callback: function(e) {
                Wb.reload(e)
            }
        });
        if (Wb.getBool(e.expand, true)) t.push({
            type: "expand",
            tooltip: Str.expandSelected,
            callback: function(e) {
                Wb.expand(e)
            }
        });
        if (Wb.getBool(e.collapse, true)) t.push({
            type: "collapse",
            tooltip: Str.collapseSelected,
            callback: function(e) {
                Wb.collapse(e)
            }
        });
        if (e.search) t.push({
            type: "search",
            tooltip: Str.toggleSearch,
            callback: function(e) {
                var t = e.getDockedComponent("_searchNodeBar"),
                n = e.displayField;
                if (t) t.setVisible(!t.isVisible());
                else t = e.addDocked({
                    xtype: "toolbar",
                    itemId: "_searchNodeBar",
                    dock: "top",
                    searchHandler: function() {
                        var r = t.getComponent("combo").getValue().toLowerCase(),
                        i = e.getRootNode().findChildBy(function(e) {
                            if (r === (e.data[n] || "").toLowerCase()) return true
                        },
                        e, true);
                        if (i) Wb.select(i);
                        else Wb.warn(Wb.format(Str.notFound, r))
                    },
                    items: [{
                        xtype: "combo",
                        itemId: "combo",
                        flex: 1,
                        displayField: "text",
                        queryMode: "local",
                        store: {
                            fields: ["text"]
                        },
                        doQuery: function(t) {
                            var r, i = this,
                            s = [],
                            o = e.rootVisible;
                            e.getRootNode().cascadeBy(function(e) {
                                if (!o && e.getDepth() === 0) return;
                                r = e.data[n] || "";
                                if (r.toLowerCase().indexOf(t) != -1) s.push({
                                    text: r
                                })
                            });
                            i.store.loadData(s);
                            if (s.length) i.expand();
                            else i.collapse();
                            i.doAutoSelect();
                            return true
                        },
                        listeners: {
                            specialkey: function(e, n) {
                                if (n.getKey() == n.ENTER && !e.isExpanded) {
                                    t.searchHandler();
                                    n.stopEvent()
                                }
                            },
                            select: function() {
                                t.searchHandler()
                            }
                        }
                    },
                    {
                        iconCls: "seek_icon",
                        tooltip: Str.search,
                        handler: function() {
                            t.searchHandler()
                        }
                    }]
                })[0];
                if (t.isVisible()) t.getComponent("combo").focus(false, true)
            }
        });
        return t
    },
    save: function(e) {
        var t = e.store,
        n = e.getValue(),
        r;
        t.clearFilter();
        r = t.findRecord("field1", n);
        if (r) t.remove(r);
        t.insert(0, {
            field1: n
        })
    },
    reverse: function(e) {
        Ext.Array.sort(e,
        function(e, t) {
            return t.getDepth() - e.getDepth()
        });
        return e
    },
    selFirst: function(e) {
        var t, n;
        if (e instanceof Ext.tree.Panel || e instanceof Ext.data.TreeStore) {
            t = e.bindTable || e;
            n = t.getRootNode();
            if (!t.rootVisible) n = n.firstChild;
            if (n && !t.selFirstDone) {
                t.selFirstDone = true;
                t.setSelection(n)
            }
        } else if (e instanceof Ext.grid.Panel || e instanceof Ext.data.Store) {
            t = e.bindTable || e;
            if (t.store && t.store.getCount() > 0) t.setSelection(0)
        }
    },
    getInfo: function(e, t) {
        var n;
        if (Ext.isArray(e)) n = e;
        else n = e.getSelection();
        if (!t) t = "text";
        if (n.length) {
            if (n.length == 1) return n[0].get(t);
            else return Wb.format(Str.itemsInfo, n[0].get(t), n.length)
        } else return ""
    },
    getSection: function(e, t, n) {
        var r = 0,
        i = 0;
        for (r = 0; r < n; r++) {
            i = e.indexOf(t, i);
            if (i == -1) return "";
            i++
        }
        return e.substring(i)
    },
    download: function(e, t, n) {
        var r = Wb.getFrame(),
        i = Wb.getForm(Ext.apply({
            _jsonresp: 1
        },
        t), n);
        i.action = e;
        i.method = "POST";
        i.target = r.id;
        i.submit()
    },
    update: function(e, t, n) {
        var r;
        e.fields.each(function(n) {
            r = n.name;
            if (t.hasOwnProperty(r)) e.set(r, t[r])
        });
        if (Wb.getBool(n, true)) e.commit()
    },
    add: function(e, t, n, r, i) {
        var s, o, u = e.bindTable || e,
        a = Wb.findEditing(u),
        f = u.store;
        if (a) a.completeEdit();
        s = f.indexOf(u.getSelection()[0]);
        if (n) {
            if (s == -1) {
                if (n == "before") n = "first";
                else if (n == "after") n = "last"
            }
        } else n = "last";
        if (!t) t = {};
        switch (n) {
        case "first":
            s = 0;
            o = f.insert(s, t);
            break;
        case "before":
            o = f.insert(s, t);
            break;
        case "after":
            s++;
            o = f.insert(s, t);
            break;
        case "last":
            s = f.getCount();
            o = f.insert(s, t);
            break;
        case "add":
            o = f.add(t);
            s = f.indexOf(o[0]);
            break
        }
        if (s < f.getCount() - 1) {
            Wb.refreshRowNum(u)
        }
        if (Wb.getBool(i, true)) {
            Wb.each(o,
            function(e) {
                e.commit()
            })
        }
        u.setSelection(o);
        if (a && r !== undefined) {
            a.startEdit(o[0], r)
        }
        return o
    },
    addEdit: function(e, t) {
        return Wb.add(e, t, "last", 1, false)
    },
    refreshRowNum: function(e) {
        var t = e.bindTable || e;
        if (!Wb.hasRowNumber(t)) return;
        var n, r = 1,
        i = t.store,
        s = t.view.el.query("div[class~=x-grid-cell-inner-row-numberer]"),
        o = (i.currentPage - 1) * i.pageSize;
        Wb.each(s,
        function(e) {
            n = r + o;
            if (n !== e.innerHTML) e.innerHTML = n;
            r++
        })
    },
    insert: function(e, t) {
        return Wb.edit(e, t, true)
    },
    edit: function(e, t, n) {
        var r, i, s, o, u, a, f = e.bindTable || e;
        if (!n) {
            u = f.getSelection()[0];
            if (!u) {
                Wb.warn(Wb.format(Str.selectRecord, Str.modify));
                return
            }
        }
        if (!t) t = {};
        if (t.title === undefined) t.title = n ? Str.add: Str.modify;
        if (t.iconCls === undefined) t.iconCls = n ? "record_add_icon": "record_edit_icon";
        s = function(e, r) {
            if (t.beforerequest && Ext.callback(t.beforerequest, r.appScope, [e, r]) === false) return;
            var i = Wb.apply(n ? {}: Wb.getData(u, true), t.params, e),
            s;
            s = {
                url: t.url,
                params: i,
                showError: false,
                failure: function(n, i, s) {
                    Wb.except(a ? i: n,
                    function() {
                        if (Wb.getBool(t.autoFocus, true) && n.responseText) {
                            var e, i, s = n.responseText.indexOf(" ");
                            if (s > 0 && s < 100) {
                                e = n.responseText.substring(0, s);
                                try {
                                    i = r.down("field[fieldLabel=* " + e + "]");
                                    if (!i) i = r.down("field[fieldLabel=" + e + "]");
                                    if (i && i.focus) i.focus(true, true)
                                } catch(o) {}
                            }
                        }
                    });
                    if (t.failure) Ext.callback(t.failure, r.appScope, [e, r, a ? s: n.responseText])
                },
                success: function(s, o, l) {
                    var c, h = a ? l: s.responseText;
                    if (Ext.String.startsWith(h, "{") && Ext.String.endsWith(h, "}")) c = Wb.decode(h);
                    else c = {};
                    if ("success" in c) {
                        if (c.success == true) {
                            if (n) Wb.add(f, Wb.applyIf(c, i), t.addPosition);
                            else Wb.update(u, Wb.applyIf(c, i));
                            r.close();
                            Ext.callback(t.success, r.appScope, [e, r, h])
                        } else {
                            Wb.error(c.message)
                        }
                    } else {
                        if (n) Wb.add(f, Wb.applyIf(c, i), t.addPosition);
                        else Wb.update(u, Wb.applyIf(c, i));
                        r.close();
                        Ext.callback(t.success, r.appScope, [e, r, h])
                    }
                }
            };
            if (a) {
                s.form = r.getComponent("form");
                Wb.upload(s)
            } else Wb.request(s)
        };
        if (t.win) {
            i = e.bindEditWin;
            if (!i) {
                i = t.win;
                if (i instanceof Ext.window.Window) {
                    i.closeAction = "hide";
                    e.mon(e, "destroy",
                    function() {
                        i.destroy();
                        delete e.bindEditWin
                    });
                    e.bindEditWin = i
                } else {
                    i = new Ext.window.Window(i)
                }
            }
            a = !!i.down("filefield");
            i.editHandler = function() {
                var e = this;
                s(Wb.getValue(e), e)
            };
            i.isNew = n;
            i.editData = Wb.apply({},
            t.params, n ? null: u.data);
            i.show();
            if (!n) {
                if (t.titleField) Wb.setTitle(i, u.data[t.titleField]);
                Wb.setValue(i, Wb.apply({},
                t.params, u.data))
            }
        } else {
            o = [];
            if (t.firstItems) {
                Wb.each(t.firstItems,
                function(e) {
                    o.push(e)
                })
            }
            Wb.each(f.columns,
            function(e) {
                var t = e.dataIndex;
                if (e.editor) {
                    r = Wb.apply({
                        fieldLabel: e.text,
                        itemId: t
                    },
                    e.editor);
                    o.push(r)
                } else if (e.blobEditor) {
                    a = true;
                    if (n) {
                        r = Wb.apply({
                            fieldLabel: e.text,
                            itemId: t
                        },
                        e.blobEditor)
                    } else {
                        r = {
                            xtype: "fieldcontainer",
                            fieldLabel: e.text,
                            layout: "hbox",
                            items: [Wb.apply({
                                flex: 1,
                                itemId: t
                            },
                            e.blobEditor), {
                                xtype: "button",
                                text: Str.del1,
                                margin: "0 0 0 3",
                                bindFieldName: t,
                                handler: function(e) {
                                    var t = e.ownerCt.getComponent(e.bindFieldName);
                                    t.reset();
                                    t.removeFile = true
                                }
                            }]
                        }
                    }
                    o.push(r)
                }
            });
            if (t.lastItems) {
                Wb.each(t.lastItems,
                function(e) {
                    o.push(e)
                })
            }
            i = Wb.prompt(Wb.apply({
                items: o,
                isUpload: a,
                handler: s
            },
            t));
            if (!n) {
                if (t.titleField) Wb.setTitle(i, u.data[t.titleField]);
                Wb.setValue(i, Wb.apply({},
                t.params, u.data))
            }
        }
        return i
    },
    del: function(e, t) {
        var n = e.bindTable || e,
        r = n.getSelection();
        Wb.confirmDo(r,
        function() {
            Wb.request({
                url: t.url,
                failure: t.failure,
                params: Wb.apply({
                    destroy: Wb.getData(r, true)
                },
                t.params),
                success: function(e) {
                    var i = e.responseText;
                    if (Ext.String.startsWith(i, "{") && Ext.String.endsWith(i, "}")) respObj = Wb.decode(i);
                    else respObj = {};
                    if ("success" in respObj) {
                        if (respObj.success == true) {
                            Wb.remove(n, r);
                            Ext.callback(t.success, n, [n])
                        } else {
                            Wb.error(respObj.message)
                        }
                    } else {
                        Wb.remove(n, r);
                        Ext.callback(t.success, n, [n])
                    }
                }
            })
        },
        t.titleField)
    },
    handle: function(e, t) {
        var n = e.bindTable || e,
        r = n.getSelection();
        Wb.confirmDo(r,
        function() {
            Wb.request({
                url: t.url,
                failure: t.failure,
                params: Wb.apply({
                    data: Wb.getData(r, true)
                },
                t.params),
                success: function(e) {
                    var r = Wb.decode(e.responseText);
                    if (r.success == true) {
                        Ext.callback(t.success, n, [n])
                    } else {
                        Wb.error(r.message)
                    }
                }
            })
        },
        t.titleField, t.verb ? t.verb: "")
    },
    getData: function(e, t) {
        var n, r = [],
        i = Ext.isArray(e);
        if (!i) e = [e];
        Wb.each(e,
        function(e) {
            if (t) {
                n = Ext.apply({},
                e.data);
                Wb.each(e.data,
                function(e, t) {
                    n["#" + e] = t
                });
                Wb.each(e.modified,
                function(e, t) {
                    n["#" + e] = t
                })
            } else {
                n = e.data
            }
            r.push(n)
        });
        return i ? r: r[0]
    },
    sync: function(e) {
        var t, n, r, i, s = e.store || e.grid.store;
        if (s.bindTable) {
            t = Wb.findEditing(s.bindTable);
            if (t) t.completeEdit()
        }
        n = s.getRemovedRecords();
        r = s.getUpdatedRecords();
        i = s.getNewRecords();
        if (!e.params) e.params = {};
        Ext.apply(e.params, {
            destroy: Wb.getData(n, true),
            update: Wb.getData(r, true),
            create: Wb.getData(i)
        });
        if (e.store) delete e.store;
        if (e.grid) delete e.grid;
        Wb.request(e)
    },
    syncCreate: function(e, t, n) {
        var r = 0,
        i = e.store || e;
        if (t) Wb.each(i.getNewRecords(),
        function(e) {
            Wb.update(e, t[r++], false)
        });
        if (Wb.getBool(n, true)) i.commitChanges()
    },
    reject: function(e) {
        var t = e.bindTable || e,
        n = Wb.findEditing(t);
        if (n) n.cancelEdit();
        t.store.rejectChanges();
        Wb.refreshRowNum(t)
    },
    hasRowNumber: function(e) {
        var t = false,
        n = e.bindTable || e,
        r = n.columns;
        if (!r) return false;
        Wb.each(r,
        function(e) {
            if (e.xtype == "rownumberer") {
                t = true;
                return false
            }
        });
        return t
    },
    progress: function(e, t, n) {
        if (e > 1) e = 1;
        else if (e < 0) e = 0;
        if (e === 0) Ext.Msg.show({
            msg: t || Str.processing,
            progressText: "0%",
            width: 300,
            closable: false,
            progress: true,
            animateTarget: n
        });
        else Ext.Msg.updateProgress(e, Math.round(100 * e) + "%")
    },
    upload: function(e) {
        var t, n = (new Date).getTime(),
        r = e.form;
        t = Ext.apply({
            isUpload: true
        },
        {
            showError: Wb.getBool(e.showError, true),
            showMask: Wb.getBool(e.showMask, true),
            params: Ext.apply(Wb.getValue(e.out), e.params, Wb.getValue(r)),
            progressId: n,
            url: e.url + (e.url.indexOf("?") != -1 ? "&": "?") + "_jsonresp=1&uploadId=" + n
        },
        e);
        delete t.form;
        r.form.submit(t)
    },
    getFrame: function() {
        if (!Wb.iframe) {
            var e = document.createElement("iframe"),
            t = "ifm" + Wb.getId();
            Ext.fly(e).set({
                id: t,
                name: t,
                cls: Ext.baseCSSPrefix + "hide-display",
                src: Ext.SSL_SECURE_URL
            });
            document.body.appendChild(e);
            if (document.frames) document.frames[t].name = t;
            e.onload = function() {
                var e, t, n, r;
                try {
                    r = Wb.getDoc(Wb.iframe);
                    if (r) {
                        if (r.body) {
                            if ((n = r.body.firstChild) && /pre/i.test(n.tagName)) {
                                e = n.textContent || n.innerText
                            } else if (n = r.getElementsByTagName("textarea")[0]) {
                                e = n.value
                            } else {
                                e = r.body.textContent || r.body.innerText
                            }
                            if (e) {
                                e = Wb.decode(e);
                                if (!e.success) {
                                    t = e.value;
                                    if (Ext.String.startsWith(t, "$WBE201")) Wb.login();
                                    else if (Ext.String.startsWith(t, "$WBE202")) Wb.login(true);
                                    else Wb.error(t)
                                }
                            }
                        }
                    }
                } catch(i) {
                    if (e) Wb.error(e);
                    else Wb.error(Str.serverNotResp)
                }
            };
            Wb.iframe = e
        }
        return Wb.iframe
    },
    getForm: function(e, t) {
        var n, r = Wb.defaultForm;
        if (r) {
            while (r.childNodes.length !== 0) r.removeChild(r.childNodes[0])
        } else {
            r = document.createElement("FORM");
            Wb.defaultForm = r;
            document.body.appendChild(r)
        }
        if (e) {
            Wb.each(e,
            function(e, t) {
                n = document.createElement("input");
                n.setAttribute("name", e);
                n.setAttribute("type", "hidden");
                if (Ext.isArray(t) || Ext.isObject(t)) t = Wb.encode(t);
                else if (Ext.isDate(t)) t = Wb.dateToStr(t);
                n.setAttribute("value", Wb.isEmpty(t) ? "": t);
                r.appendChild(n)
            })
        }
        if (t) r.encoding = "multipart/form-data";
        else r.encoding = "application/x-www-form-urlencoded";
        return r
    },
    submit: function(e, t, n, r, i) {
        var s = Wb.getForm(t, i);
        s.action = e;
        s.method = r || "POST";
        s.target = n || "_blank";
        s.submit()
    },
    toLine: function(e, t) {
        var n;
        if (e) n = e.replace(/\r?\n/g, " ");
        else return "";
        if (t) return Ext.String.ellipsis(n, t);
        else return n
    },
    numValidator: function(e, t) {
        return function(n) {
            var r = this.getValue();
            if (Wb.isEmpty(r)) return true;
            var i, s = String(r);
            if (Ext.String.startsWith(s, "-")) s = s.substring(1);
            if (s.indexOf(".") != -1) i = s.split(".");
            else if (s.indexOf(",") != -1) i = s.split(",");
            else i = [s, ""];
            if (i[0].length + i[1].length > e || i[1].length > t) return Wb.format(Str.invalidValue, n);
            else return true
        }
    },
    strToDate: function(e) {
        if (!e) return undefined;
        if (e.indexOf(".") == -1) return Ext.Date.parse(e, "Y-m-d H:i:s");
        else return Ext.Date.parse(e, Wb.dateFormat)
    },
    dateToStr: function(e) {
        return Wb.format(e, Wb.dateFormat)
    },
    dateToText: function(e, t) {
        var n, r = Ext.form.field.Date.prototype.format,
        i = Ext.form.field.Time.prototype.format;
        if (!e) return "";
        if (Ext.isString(e)) e = Wb.strToDate(e);
        if (t === true) n = i;
        else if (t === false) n = r;
        else if (t === null) n = r + " " + i;
        else {
            if (Wb.format(e, "Hisu") === "000000000") n = r;
            else n = r + " " + i
        }
        return Wb.format(e, n)
    },
    kv: function(e, t) {
        var n = Wb.find(t, "K", e);
        return n ? n.V: ""
    },
    kvRenderer: function(e, t, n, r, i) {
        var s = this.headerCt.getGridColumns();
        var o = s[i].keyItems;
        if (typeof o == "string") {
            o = Wb.decode(o)
        }
        return Wb.kv(e, o)
    },
    format: function(e) {
        if (Ext.isDate(e)) return Ext.Date.format.apply(this, arguments);
        else if (Ext.isNumber(e)) return Ext.util.Format.number.apply(this, arguments);
        else return Ext.String.format.apply(this, arguments)
    },
    getTag: function(e, t) {
        var n = e.store || e;
        return n.proxy.reader.rawData[t]
    },
    getColumns: function(e) {
        if (!e) return null;
        var t = e.store || e;
        if (t) {
            var n = t.proxy.reader.rawData.columns;
            for (var r = 0; r < n.length; r++) {
                var i = n[r];
                if (typeof i.renderer != "undefined") {
                    i.renderer = Wb[i.renderer]
                }
            }
            return n
        } else return null
    },
    getColumn: function(e, t) {
        var n, r = e.bindTable || e;
        if (Wb.isEmpty(r.columns)) n = Wb.getColumns(r);
        else n = r.columns;
        if (Ext.isString(t)) return Wb.find(n, "dataIndex", t);
        else return n[t] || null
    },
    loadColumns: function(e, t) {
        var n, r = e.bindTable || e;
        if (t || Wb.isEmpty(r.columns)) {
            n = Wb.getColumns(r.store);
            if (n) r.reconfigure(null, n)
        }
    },
    autoLoadColumns: function(e) {
        if (e) {
            var t = e.headerCt.getGridColumns();
            if ((!e.loadColumns || e.loadColumns == "auto") && Wb.isEmpty(t)) {
                Wb.loadColumns(e)
            } else if (e.loadColumns == "reload") Wb.loadColumns(e, true)
        }
    },
    timeRenderer: function(e) {
        return Wb.dateToText(e, true)
    },
    blobRenderer: function(e, t, n, r, i) {
        var s = this,
        o = s.id,
        u = Wb.getColumn(s, i),
        a = Wb.encode(u ? u.dataIndex || "": ""),
        f = [];
        if (s.uploadBlob && (!s.ifUploadBlob || s.ifUploadBlob(a) !== false)) {
            f.push("<a href='javascript:Wb.call(\"" + o + '","uploadBlob",' + a + "," + r + ")'>" + Str.upload + "</a>")
        }
        if (s.downloadBlob && e && (!s.ifDownloadBlob || s.ifDownloadBlob(a) !== false)) {
            f.push("<a href='javascript:Wb.call(\"" + o + '","downloadBlob",' + a + "," + r + ")'>" + Str.download + "</a>")
        }
        if (s.removeBlob && e && (!s.ifRemoveBlob || s.ifRemoveBlob(a) !== false)) {
            f.push("<a href='javascript:Wb.call(\"" + o + '","removeBlob",' + a + "," + r + ")'>" + Str.del1 + "</a>")
        }
        if (f.length) return f.join("&nbsp;&nbsp;");
        else return e
    },
    getIcon: function(e, t) {
        if (Wb.isEmpty(t)) t = "";
        else t = " title=" + Wb.encode(t);
        return '<span class="wb_icon ' + e + '"' + t + "></span>"
    },
    call: function(e, t) {
        var n = Ext.getCmp(e);
        n[t].apply(n, [].slice.call(arguments, 2))
    },
    setBox: function(e, t) {
        var n = false,
        r = e.getLocalX(),
        i = e.getLocalY(),
        s = e.width,
        o = e.height,
        u = t.getLocalX(),
        a = t.getLocalY(),
        f = t.width,
        l = t.height;
        if (r !== u) {
            t.setLocalX(r);
            n = true
        }
        if (i != a) {
            t.setLocalY(i);
            n = true
        }
        if (s != f) {
            t.setWidth(s);
            n = true
        }
        if (o != l) {
            t.setHeight(o);
            n = true
        }
        return n
    },
    find: function(e, t, n) {
        var r = null;
        if (Ext.isArray(e)) {
            if (e[0] instanceof Ext.data.Model) {
                Wb.each(e,
                function(e) {
                    if (e.data[t] === n) {
                        r = e;
                        return false
                    }
                })
            } else {
                Wb.each(e,
                function(e) {
                    if (e[t] === n) {
                        r = e;
                        return false
                    }
                })
            }
        } else if (e) {
            e.each(function(e) {
                if (e.data[t] === n) {
                    r = e;
                    return false
                }
            })
        } else return null;
        return r
    },
    namePart: function(e) {
        if (Wb.isEmpty(e)) return "";
        var t = e.indexOf("=");
        if (t == -1) return e;
        else return e.substring(0, t)
    },
    valuePart: function(e) {
        if (Wb.isEmpty(e)) return "";
        var t = e.indexOf("=");
        if (t == -1) return "";
        else return e.substring(t + 1)
    },
    getSelText: function() {
        if (window.getSelection) return window.getSelection().toString();
        else if (document.selection && document.selection.createRange) return document.selection.createRange().text;
        else return ""
    },
    pluck: function(e, t) {
        var n, r = e.length,
        i = [];
        for (n = 0; n < r; n++) i.push(e[n].data[t]);
        return i
    },
    clearSelText: function() {
        if (document.selection) {
            document.selection.empty()
        } else if (window.getSelection) {
            window.getSelection().removeAllRanges()
        }
    },
    monEnter: function(e, t) {
        var n = e.getKeyMap();
        n.on(13,
        function(n, r) {
            var i = e,
            s = r.target;
            if (i.el.isMasked() || Ext.getBody().isMasked()) return;
            if (s && s.type == "textarea") return;
            r.stopEvent();
            t(e)
        })
    },
    isEditor: function(e) {
        return e.tagName == "INPUT" && (e.type == "text" || e.type == "password") || e.tagName == "TEXTAREA"
    },
    setCookie: function(e, t) {
        Ext.util.Cookies.set(e, t, Ext.Date.add(new Date, Ext.Date.MONTH, 1))
    },
    getCookie: function(e) {
        return Ext.util.Cookies.get(e)
    },
    setChecked: function(e, t) {
        t = !!t;
        e.data.checked = t;
        var n, r = Ext.fly(Ext.fly(e.getOwnerTree().view.id + "-record" + e.id));
        if (!r) return;
        n = r.down("input[type=button]");
        if (t) {
            r.dom.style.removeProperty("text-decoration");
            r.dom.style.setProperty("color", "blue");
            if (n) n.addCls("x-tree-checkbox-checked")
        } else {
            r.dom.style.setProperty("text-decoration", "line-through");
            r.dom.style.setProperty("color", "gray");
            if (n) n.removeCls("x-tree-checkbox-checked")
        }
    },
    show: function(e) {
        var t = new Ext.window.Window(e);
        return t.show()
    },
    sort: function(e, t, n) {
        var r = Wb.getBool(n, true);
        return e.sort(function(e, n) {
            var i, s;
            if (t) {
                i = e ? e[t] : "";
                s = n ? n[t] : ""
            } else {
                i = e || "";
                s = n || ""
            }
            if (Ext.isString(i)) i = i.toUpperCase();
            if (Ext.isString(s)) s = s.toUpperCase();
            if (r) return i.localeCompare(s);
            else {
                if (i > s) return 1;
                else if (i < s) return - 1;
                else return 0
            }
        })
    },
    optMain: function(e) {
        if (!e) return null;
        var t, n, r = [],
        i = ["container", "panel", "form", "tabpanel", "fieldset"];
        Wb.each(e,
        function(e, s) {
            if (s && !s.ownerCt && s instanceof Ext.container.Container && !(s instanceof Ext.window.Window)) {
                if (s.itemId == "main") {
                    n = s;
                    return false
                }
                t = Wb.indexOf(i, s.xtype);
                if (t == -1) t = 9;
                r.push([s, t])
            }
        });
        if (n) return n;
        r.sort(function(e, t) {
            return e[1] - t[1]
        });
        return r.length ? r[0][0] : null
    },
    open: function(PortalConfigs) {
        if (PortalConfigs.reloadCard) {
            PortalConfigs.url = Wb.toUrl(PortalConfigs.reloadCard.bindFile);
            PortalConfigs.reload = true
        }
        if (PortalConfigs.download) {
            Wb.download(PortalConfigs.url, PortalConfigs.params);
            return
        }
        if (window.top != window && window.top.Wb) {
            return window.top.Wb.open(PortalConfigs)
        }
        var PortalVars = {};
        PortalVars.xwlCall = Ext.String.startsWith(PortalConfigs.url, "m?xwl=");
        if (PortalConfigs.isModule === undefined) {
            PortalVars.isModule = true;
            PortalConfigs.url.indexOf(".") == -1
        } else PortalVars.isModule = PortalConfigs.isModule;
        if (PortalVars.xwlCall) PortalVars.path = PortalConfigs.url.substring(6) + ".xwl";
        else PortalVars.path = PortalConfigs.url;
        PortalVars.hasHome = Wb.hasNS("sys.home");
        PortalVars.hasIde = Wb.hasNS("sys.ide");
        if (!PortalConfigs.newWin && (Wb.isValue(PortalConfigs.container) || PortalVars.hasHome || PortalVars.hasIde)) {
            if (PortalConfigs.container === false) PortalVars.tab = null;
            else if (PortalConfigs.container) PortalVars.tab = PortalConfigs.container;
            else if (PortalVars.hasIde) PortalVars.tab = Ide.fileTab;
            else PortalVars.tab = sys.home.tab;
            if (PortalVars.tab) {
                if (PortalConfigs.newTab === false || !PortalConfigs.newTab && !PortalConfigs.params) {
                    if (PortalConfigs.reloadCard) PortalVars.card = PortalConfigs.reloadCard;
                    else {
                        PortalVars.card = null;
                        PortalVars.tab.items.each(function(e) {
                            if (e.bindFile == PortalVars.path && e.lastPortalConfigs && !e.lastPortalConfigs.params) {
                                PortalVars.card = e;
                                return false
                            }
                        })
                    }
                    if (PortalVars.card) {
                        if (PortalConfigs.reload) {
                            if (Wb.unloadEvents) delete Wb.unloadEvents[PortalVars.card.id];
                            Ext.applyIf(PortalConfigs, PortalVars.card.lastPortalConfigs);
                            Ext.Object.clear(PortalVars.card.lastPortalVars);
                            PortalVars.card.lastPortalVars = PortalVars;
                            Ext.Object.clear(PortalVars.card.lastPortalConfigs);
                            PortalVars.card.lastPortalConfigs = PortalConfigs;
                            PortalVars.card.removeAll(true)
                        } else {
                            if (!PortalConfigs.notActiveCard) PortalVars.tab.setActiveTab(PortalVars.card);
                            return PortalVars.card
                        }
                    }
                }
                if (!PortalVars.card) {
                    PortalVars.cardConfig = {
                        iconCls: PortalConfigs.iconCls,
                        title: Ext.String.ellipsis(PortalConfigs.title, 20),
                        closable: true,
                        lastPortalVars: PortalVars,
                        lastPortalConfigs: PortalConfigs,
                        hideMode: Ext.isIE ? "offsets": "display",
                        xtype: "panel",
                        hasParams: !!PortalConfigs.params,
                        bindFile: PortalVars.path,
                        border: false,
                        layout: "fit",
                        listeners: {
                            destroy: function(e) {
                                if (Wb.unloadEvents) delete Wb.unloadEvents[e.id]
                            },
                            beforeclose: function(e) {
                                if (Wb.unloadEvents) {
                                    if (Wb.unloadEvents[e.id] && e.confirmClose !== false) {
                                        var t = Wb.unloadEvents[e.id]();
                                        if (Wb.isValue(t)) {
                                            Wb.confirm(t + "<br><br>" + Str.confirmClose,
                                            function() {
                                                e.confirmClose = false;
                                                e.close()
                                            });
                                            return false
                                        }
                                    } else delete Wb.unloadEvents[e.id]
                                }
                            }
                        }
                    };
                    if (PortalConfigs.tooltip || PortalVars.cardConfig.title !== PortalConfigs.title) {
                        PortalVars.cardConfig.tabConfig = {
                            tooltip: PortalConfigs.tooltip || PortalConfigs.title
                        }
                    }
                    PortalVars.card = PortalVars.tab.add(PortalVars.cardConfig)
                }
                if (!PortalConfigs.notActiveCard) PortalVars.tab.setActiveTab(PortalVars.card)
            }
            if (PortalConfigs.frameOnly) return PortalVars.card;
            if (PortalVars.tab && (PortalConfigs.useIFrame || !PortalVars.isModule || PortalConfigs.useIFrame === undefined && PortalVars.card.iframe)) {
                if (!PortalVars.card.iframe) {
                    Wb.insertIframe(PortalVars.card, PortalConfigs.mask)
                }
                PortalVars.card.iframe.submit(PortalConfigs.url, PortalConfigs.params, PortalConfigs.method)
            } else {
                var doRequest = function() {
                    if (Ext.String.endsWith(PortalVars.path, ".xwl")) PortalVars.requestUrl = "m?xwl=" + PortalVars.path.slice(0, -4);
                    else PortalVars.requestUrl = PortalVars.path;
                    return Wb.request({
                        url: PortalVars.requestUrl + (PortalVars.requestUrl.indexOf("?") == -1 ? "?xwlt=1": "&xwlt=1"),
                        mask: PortalVars.card,
                        timeout: -1,
                        showError: false,
                        showMask: PortalConfigs.mask,
                        params: PortalConfigs.params,
                        callback: function(e, t, n) {
                            if (PortalVars.card) {
                                delete PortalVars.card.request;
                                if (!t) {
                                    if (!PortalVars.card.notShowError && PortalConfigs.showError !== false) Wb.except(n);
                                    if (!PortalVars.card.isClosing) {
                                        PortalVars.card.close()
                                    }
                                }
                            } else if (!t && PortalConfigs.showError !== false) Wb.except(n);
                            if (!t && PortalConfigs.failure) {
                                Ext.callback(PortalConfigs.failure, PortalVars.card, [{},
                                n.responseText])
                            }
                        },
                        success: function(PortalResp) {
                            if (PortalResp.responseText) {
                                if (PortalResp.responseText.substring(0, 10) == "(function(" && PortalResp.responseText.slice( - 3) == "();") {
                                    PortalVars.appScope = eval(PortalResp.responseText.slice(0, -2) + "{}, PortalConfigs.contextOwner||PortalVars.card||null);\n//@ sourceURL=" + window.location.href + "/" + PortalVars.path);
                                    PortalVars.entry = Wb.optMain(PortalVars.appScope);
                                    if (PortalVars.card) PortalVars.card.appScope = PortalVars.appScope;
                                    if (PortalVars.card && PortalVars.entry) PortalVars.card.add(PortalVars.entry);
                                    if (PortalConfigs.success) {
                                        Ext.callback(PortalConfigs.success, PortalVars.card, [PortalVars.appScope, PortalResp.responseText])
                                    }
                                } else {
                                    PortalVars.card.add({
                                        xtype: "container",
                                        autoScroll: true,
                                        style: "font-size:13px;line-height:20px;",
                                        padding: 8,
                                        html: Wb.encodeHtml(PortalResp.responseText)
                                    });
                                    if (PortalConfigs.success) {
                                        Ext.callback(PortalConfigs.success, PortalVars.card, [{},
                                        PortalResp.responseText])
                                    }
                                }
                            } else {
                                if (PortalConfigs.success) {
                                    Ext.callback(PortalConfigs.success, PortalVars.card, [{},
                                    ""])
                                }
                            }
                        }
                    })
                };
                if (PortalVars.tab) {
                    if (PortalVars.card.iframe) {
                        PortalVars.card.fireEvent("beforedestroy", PortalVars.card);
                        PortalVars.card.mun(PortalVars.card, "beforedestroy");
                        delete PortalVars.card.iframe
                    }
                    PortalVars.card.update("");
                    PortalVars.card.request = doRequest(PortalVars.card);
                    PortalVars.card.mon(PortalVars.card, "close",
                    function(e) {
                        e.isClosing = true;
                        if (e.request) {
                            var t = e.request.xhr;
                            if (t) {
                                e.notShowError = true;
                                t.abort()
                            }
                        }
                    })
                } else doRequest()
            }
            if (PortalVars.tab) return PortalVars.card
        } else {
            if (Ext.util.Format.uppercase(PortalConfigs.method) == "GET" && !PortalConfigs.params) {
                window.open(PortalConfigs.url)
            } else {
                Wb.submit(PortalConfigs.url, PortalConfigs.params, null, PortalConfigs.method)
            }
        }
    },
    run: function(e) {
        var t = Ext.apply({
            container: false,
            isModule: true
        },
        e);
        Wb.open(t)
    },
    onUnload: function(e, t) {
        if (!Wb.unloadEvents) Wb.unloadEvents = {};
        Wb.unloadEvents[t ? t.id: Wb.getId()] = e
    },
    toUrl: function(e) {
        if (Ext.String.endsWith(e, ".xwl")) return "m?xwl=" + e.slice(0, -4);
        else return e
    },
    close: function(e) {
        if (window.top != window && window.top.Wb) {
            window.top.Wb.close(e);
            return
        }
        var t = Wb.hasNS("sys.home"),
        n = Wb.hasNS("sys.ide");
        if (t || n) {
            var r = t ? sys.home.tab: Ide.fileTab,
            i = r.getActiveTab();
            if (Ext.isBoolean(e)) {
                Ext.suspendLayouts();
                r.items.each(function(t) {
                    if (e || !e && t != i) {
                        t.close()
                    }
                });
                Ext.resumeLayouts(true)
            } else {
                if (e) i = r.child("[bindFile=" + e + "]");
                if (i) {
                    i.close()
                }
            }
        }
    },
    encodeHtml: function(e) {
        if (!Wb.isValue(e)) return "";
        if (Ext.isString(e)) return Ext.htmlEncode(e).replace(/\r?\n/g, "<br>");
        else return e
    },
    addLink: function(e, t, n) {
        function a() {
            var t = e[i++];
            if (typeof t === "string") {
                return {
                    url: t,
                    type: t.slice( - 3).toLowerCase() == ".js" ? "js": "css"
                }
            } else return t
        }
        function f() {
            s++;
            if (s >= o) t();
            else if (n) c()
        }
        function l() {
            if (this.readyState == "loaded" || this.readyState == "complete") {
                this.onreadystatechange = function() {};
                s++;
                if (s >= o) t();
                else if (n) c()
            }
        }
        function c() {
            var e, r = a();
            if (!Wb.loadedLinks) Wb.loadedLinks = {};
            if (Wb.loadedLinks[r.url]) {
                f();
                return
            } else Wb.loadedLinks[r.url] = true;
            if ((r.type || "js").toLowerCase() == "js") {
                e = document.createElement("script");
                e.type = "text/javascript";
                e.src = r.url
            } else {
                e = document.createElement("link");
                e.rel = "stylesheet";
                e.href = r.url
            }
            u[0].appendChild(e);
            if (!t && !n) return;
            if (e.readyState) e.onreadystatechange = l;
            else e.onload = f
        }
        if (!e || e.length === 0) return;
        var r, i = 0,
        s = 0,
        o = e.length,
        u = document.getElementsByTagName("head");
        if (n) c();
        else {
            for (r = 0; r < o; r++) c()
        }
    },
    ns: function(e) {
        var t, n, r, i, s = e.split(".");
        i = window;
        n = s.length;
        for (t = 0; t < n; t++) {
            r = s[t];
            if (!i[r]) i[r] = {};
            i = i[r]
        }
        return i
    },
    hasNS: function(e) {
        var t, n, r, i, s = e.split(".");
        i = window;
        n = s.length;
        for (t = 0; t < n; t++) {
            r = s[t];
            if (!i[r]) return false;
            i = i[r]
        }
        return true
    },
    recordActivity: function(e) {
        if (e.stopRecNav) return;
        var t;
        if (e instanceof Ext.tab.Panel) {
            t = e.getActiveTab();
            if (t) t = t.id;
            else return
        } else {
            t = e.getSelection()[0];
            if (t) t = t.getPath("text", "\n");
            else return
        }
        if (e.backList.length > 49) e.backList.splice(0, 1);
        e.backList.push(t)
    },
    navigate: function(e, t) {
        if (e instanceof Ext.tree.Panel) {
            e.selectPath(t, "text", "\n")
        } else {
            t = Ext.getCmp(t);
            if (t) e.setActiveTab(t);
            else return false
        }
        return true
    },
    back: function(e) {
        if (e.backList.length < 2) return;
        var t = e.backList.pop();
        if (t) {
            if (e.forwardList.length > 49) e.forwardList.splice(0, 1);
            e.forwardList.push(t)
        } else return;
        e.stopRecNav = true;
        while (e.backList.length > 0 && !Wb.navigate(e, e.backList[e.backList.length - 1])) {
            e.backList.pop()
        }
        e.stopRecNav = false
    },
    forward: function(e) {
        var t;
        e.stopRecNav = true;
        while (t = e.forwardList.pop()) {
            if (Wb.navigate(e, t)) break
        }
        e.stopRecNav = false;
        if (t) {
            if (e.backList.length > 49) e.backList.splice(0, 1);
            e.backList.push(t)
        }
    },
    setNavigate: function(e, t, n) {
        e.backList = [];
        e.forwardList = [];
        if (e instanceof Ext.tree.Panel) {
            e.mon(e, "selectionchange",
            function() {
                var e = this;
                Wb.recordActivity(e)
            })
        } else {
            e.mon(e, "tabchange",
            function() {
                var e = this;
                Wb.recordActivity(e)
            })
        }
        t.navComp = e;
        t.mon(t, "click",
        function(e) {
            Wb.back(e.navComp)
        });
        n.navComp = e;
        n.mon(n, "click",
        function(e) {
            Wb.forward(e.navComp)
        })
    },
    getExcel: function(e, t, n) {
        function c() {
            var e, t, n = s.store.proxy.reader.getFields();
            for (e in n) {
                t = n[e];
                l.add(t.name, t.type ? t.type.type: "")
            }
        }
        function h(e, t) {
            var i, s, o;
            for (i in t) {
                s = t[i];
                if (n && s.hidden) continue;
                if (s.type == "rowNumber") {
                    r.xwl_numText = s.text == "&#160;" ? "": s.text;
                    r.xwl_numWidth = s.width
                } else {
                    o = {
                        align: s.align,
                        dataIndex: s.dataIndex,
                        format: s.excelFormat,
                        ptFormat: s.printFormat,
                        jsFormat: s.format,
                        type: l.get(s.dataIndex),
                        width: s.width,
                        hidden: s.hidden,
                        headerAlign: s.headerAlign,
                        wrap: s.autoWrap,
                        text: s.text == "&#160;" ? "": s.text
                    };
                    if (s.keyName) f[s.dataIndex] = s.keyName;
                    if (s.items && s.items.length > 0) {
                        o.columns = [];
                        h(o.columns, s.items.items)
                    }
                    e.push(o)
                }
            }
            return e
        }
        var r = {},
        i = [],
        s = e,
        o,
        u,
        a = s.store.proxy,
        f = {},
        l = new Ext.util.HashMap;
        o = s.store.proxy.reader.rawData;
        if (!o) return;
        o = o.returnResult;
        if (o !== undefined) {
            Wb.message(Str.result + ": " + o);
            return
        }
        Ext.apply(r, a.allParams);
        r.xwl_url = a.url || a.api.read;
        r.xwl_dateformat = Ext.form.field.Date.prototype.format;
        r.xwl_timeformat = Ext.form.field.Time.prototype.format;
        r.xwl_thousandSeparator = Ext.util.Format.thousandSeparator;
        r.xwl_decimalSeparator = Ext.util.Format.decimalSeparator;
        r.xwl_sheet = s.exportSheetname;
        if (s.exportTitle == "-") r.xwl_title = "";
        else r.xwl_title = s.exportTitle || s.title;
        r.xwl_file = s.exportFilename || r.xwl_title;
        r.xwl_feature = s.featureType;
        u = s.store.groupers.items;
        r.xwl_group = u.length > 0 ? u[0].property: "";
        c();
        r.xwl_meta = Wb.encode(h(i, s.columns));
        r.__keyMap = Wb.encode(f);
        if (t) {
            r.start = 0;
            r.limit = Wb.maxInt
        }
        if (n) Wb.submit("main?xwl=preview", r);
        else Wb.download("downloadUrl", r)
    }
};Ext.apply(Wb, {
    show_mc: function(e, t, n, r, i, s, o) {
        if (e instanceof Object) {
            return e.mc
        } else {
            var u = app.grid1.columns[i].getEditor().store.getById(e);
            if (u) {
                return u.data.mc
            } else {
                return e
            }
        }
    },
    show_bool: function(e, t, n, r, i, s, o) {
        return e ? "": ""
    },
    show_cjdw: function(e, t, n, r, i, s, o) {
        return e ? e.dwmc: ""
    },
    show_files: function(e, t, n, r, i, s, o) {
        var u = "";
        var a;
        for (var f = 0; f < e.length; f++) {
            a = e[f];
            u += '<a href="../new_towerinfo/downloadDrawing/' + a.id + '">' + a.filename + "</a><br>"
        }
        return u
    },
    show_wgbgs: function(e, t, n, r, i, s, o) {
        var u = "";
        var a;
        var f;
        for (var l = 0; l < e.length; l++) {
            a = e[l];
            f = a.lx;
            var c;
            if (f == "yd") {
                c = ""
            }
            if (f == "tt") {
                c = ""
            }
            if (f == "tj") {
                c = ""
            }
            if (f == "pt") {
                c = ""
            }
            u += '<a href="../wgbg/download/' + a.id + '">' + c + "</a>&nbsp;"
        }
        return u
    },
    show_tower: function(e, t, n, r, i, s, o) {
        return e.zm
    },
    show_qyjl: function(e, t, n, r, i, s, o) {
        return e.displayName
    }
});
var Str = {
    add: "",
    back: "",
    cancel: "",
    classic: "",
    clickChangeVC: "",
    clientInvalid: "",
    close: "",
    closeAll: "",
    closeOthers: "",
    collapseSelected: "",
    confirm: "",
    confirmClose: "",
    connectFailure: "",
    currentModuleList: "",
    dataSaved: "",
    del: "",
    del1: "",
    displayName: "",
    download: "",
    e400: "",
    e403: "",
    e404: "",
    email: "",
    emptyHint: "()",
    error: "",
    expandSelected: "",
    falseStr: "",
    file: "",
    fileUpload: "",
    find: "",
    forbidden: " {0}({1})",
    forward: "",
    gray: "",
    gridMethodNotFound: ' "{0}" ',
    hasFile: "()",
    inconsistentPwd: "",
    information: "",
    invalidChar: ' "{0}"',
    invalidName: ' "{0}"',
    invalidPwd: "",
    invalidPwdLen: "6",
    invalidValue: ' "{0}"',
    itemExist: '"{0}" ',
    itemsInfo: '"{0}"  {1} ',
    lang: "zh",
    language: "",
    loadFailure: "",
    loading: "...",
    login: "",
    loginTimes: "",
    logout: "",
    logoutSuccess: "",
    manyConfirm: "{0} {1}  {2} ",
    modify: "",
    myAccount: "",
    myApp: "",
    neptune: "",
    notFound: ' "{0}"',
    ok: "",
    password: "",
    passwordConfirm: "",
    passwordInvalid: "",
    permit: "",
    processLogin: "...",
    processing: "...",
    prohibit: "",
    recordsPerPage: "",
    refresh: "",
    refreshApps: "",
    refreshPage: "",
    refreshWindow: "",
    reset: "",
    saveDesktop: "",
    saveUserName: "",
    search: "",
    selectRecord: "{0}",
    serverNotResp: "",
    singleConfirm: "{0} {1} ",
    theme: "",
    toggleSearch: "/",
    trueStr: "",
    unknowError: "",
    updateNotUnique: "",
    upload: "",
    userNotExist: ' "{0}" ',
    username: "",
    vcExpired: "",
    vcInvalid: "",
    verifyCode: "",
    warning: "",
    expCurToExcel: "Excel",
    expAllToExcel: "Excel"
};window.ctxPath = function() { / () / .exec("");
    /^http:\/\/.*?(\/.*?)\/.*$/.exec(location.href);
    return RegExp.$1
} ();
var TP = {
    show_tjwgbg: function(e, t, n, r, i, s, o) {
        var u = t.column.dataIndex;
        var a = n.data.wgbgs;
        var f = Wb.find(a, "lx", "tj");
        if (f) {
            return f[u]
        }
    },
    show_ttwgbg: function(e, t, n, r, i, s, o) {
        var u = t.column.dataIndex;
        var a = n.data.wgbgs;
        var f = Wb.find(a, "lx", "tt");
        if (f) {
            return f[u]
        }
    },
    show_ydwgbg: function(e, t, n, r, i, s, o) {
        var u = t.column.dataIndex;
        var a = n.data.wgbgs;
        var f = Wb.find(a, "lx", "yd");
        if (f) {
            return f[u]
        }
    },
    show_ptwgbg: function(e, t, n, r, i, s, o) {
        var u = t.column.dataIndex;
        var a = n.data.wgbgs;
        var f = Wb.find(a, "lx", "pt");
        if (f) {
            return f[u]
        }
    }
}